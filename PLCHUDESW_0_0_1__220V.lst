
PLCHUDESW_0_0_1__220V.elf:     file format elf32-littlearm


Disassembly of section .text:

080000c4 <SystemInit-0x14>:
 80000c4:	0800ac7c 	.word	0x0800ac7c
 80000c8:	20000000 	.word	0x20000000
 80000cc:	20000054 	.word	0x20000054
 80000d0:	20000054 	.word	0x20000054
 80000d4:	20001928 	.word	0x20001928

080000d8 <SystemInit>:
  * @retval None
  */
void SystemInit (void)
{    
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80000d8:	2201      	movs	r2, #1
 80000da:	4b39      	ldr	r3, [pc, #228]	; (80001c0 <SystemInit+0xe8>)
  *         SystemCoreClock variable.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{    
 80000dc:	b082      	sub	sp, #8
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80000de:	6819      	ldr	r1, [r3, #0]
 80000e0:	4311      	orrs	r1, r2
 80000e2:	6019      	str	r1, [r3, #0]
#if defined (STM32F031) || defined (STM32F072) || defined (STM32F042) 
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE and MCOSEL[2:0] bits */
  RCC->CFGR &= (uint32_t)0xF8FFB80C;
#else
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, MCOSEL[2:0], MCOPRE[2:0] and PLLNODIV bits */
  RCC->CFGR &= (uint32_t)0x08FFB80C;
 80000e4:	6858      	ldr	r0, [r3, #4]
 80000e6:	4937      	ldr	r1, [pc, #220]	; (80001c4 <SystemInit+0xec>)
 80000e8:	4001      	ands	r1, r0
 80000ea:	6059      	str	r1, [r3, #4]
#endif /* STM32F031*/
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80000ec:	6818      	ldr	r0, [r3, #0]
 80000ee:	4936      	ldr	r1, [pc, #216]	; (80001c8 <SystemInit+0xf0>)
 80000f0:	4001      	ands	r1, r0
 80000f2:	6019      	str	r1, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80000f4:	6818      	ldr	r0, [r3, #0]
 80000f6:	4935      	ldr	r1, [pc, #212]	; (80001cc <SystemInit+0xf4>)
 80000f8:	4001      	ands	r1, r0
 80000fa:	6019      	str	r1, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  RCC->CFGR &= (uint32_t)0xFFC0FFFF;
 80000fc:	6858      	ldr	r0, [r3, #4]
 80000fe:	4934      	ldr	r1, [pc, #208]	; (80001d0 <SystemInit+0xf8>)
 8000100:	4001      	ands	r1, r0

  /* Reset PREDIV1[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
 8000102:	200f      	movs	r0, #15

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;

  /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  RCC->CFGR &= (uint32_t)0xFFC0FFFF;
 8000104:	6059      	str	r1, [r3, #4]

  /* Reset PREDIV1[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
 8000106:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8000108:	4381      	bics	r1, r0
 800010a:	62d9      	str	r1, [r3, #44]	; 0x2c

  /* Reset USARTSW[1:0], I2CSW, CECSW and ADCSW bits */
  RCC->CFGR3 &= (uint32_t)0xFFFFFEAC;
 800010c:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800010e:	4931      	ldr	r1, [pc, #196]	; (80001d4 <SystemInit+0xfc>)
 8000110:	4001      	ands	r1, r0
 8000112:	6319      	str	r1, [r3, #48]	; 0x30

  /* Reset HSI14 bit */
  RCC->CR2 &= (uint32_t)0xFFFFFFFE;
 8000114:	6b59      	ldr	r1, [r3, #52]	; 0x34
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSIStatus = RCC->CR & RCC_CR_HSIRDY;
    StartUpCounter++;  
  } while((HSIStatus == 0) && (StartUpCounter != HSI_STARTUP_TIMEOUT));
 8000116:	20a0      	movs	r0, #160	; 0xa0

  /* Reset USARTSW[1:0], I2CSW, CECSW and ADCSW bits */
  RCC->CFGR3 &= (uint32_t)0xFFFFFEAC;

  /* Reset HSI14 bit */
  RCC->CR2 &= (uint32_t)0xFFFFFFFE;
 8000118:	4391      	bics	r1, r2
 800011a:	6359      	str	r1, [r3, #52]	; 0x34

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800011c:	2100      	movs	r1, #0
 800011e:	6099      	str	r1, [r3, #8]
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
  __IO uint32_t StartUpCounter = 0, HSIStatus = 0;
 8000120:	9100      	str	r1, [sp, #0]
 8000122:	9101      	str	r1, [sp, #4]
  
  /* SYSCLK, HCLK, PCLK configuration ----------------------------------------*/
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSION);
 8000124:	6819      	ldr	r1, [r3, #0]
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSIStatus = RCC->CR & RCC_CR_HSIRDY;
    StartUpCounter++;  
  } while((HSIStatus == 0) && (StartUpCounter != HSI_STARTUP_TIMEOUT));
 8000126:	01c0      	lsls	r0, r0, #7
{
  __IO uint32_t StartUpCounter = 0, HSIStatus = 0;
  
  /* SYSCLK, HCLK, PCLK configuration ----------------------------------------*/
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSION);
 8000128:	430a      	orrs	r2, r1
 800012a:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSIStatus = RCC->CR & RCC_CR_HSIRDY;
 800012c:	2102      	movs	r1, #2
 800012e:	1c1a      	adds	r2, r3, #0
 8000130:	e002      	b.n	8000138 <SystemInit+0x60>
    StartUpCounter++;  
  } while((HSIStatus == 0) && (StartUpCounter != HSI_STARTUP_TIMEOUT));
 8000132:	9b00      	ldr	r3, [sp, #0]
 8000134:	4283      	cmp	r3, r0
 8000136:	d008      	beq.n	800014a <SystemInit+0x72>
  RCC->CR |= ((uint32_t)RCC_CR_HSION);
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSIStatus = RCC->CR & RCC_CR_HSIRDY;
 8000138:	6813      	ldr	r3, [r2, #0]
 800013a:	400b      	ands	r3, r1
 800013c:	9301      	str	r3, [sp, #4]
    StartUpCounter++;  
 800013e:	9b00      	ldr	r3, [sp, #0]
 8000140:	3301      	adds	r3, #1
 8000142:	9300      	str	r3, [sp, #0]
  } while((HSIStatus == 0) && (StartUpCounter != HSI_STARTUP_TIMEOUT));
 8000144:	9b01      	ldr	r3, [sp, #4]
 8000146:	2b00      	cmp	r3, #0
 8000148:	d0f3      	beq.n	8000132 <SystemInit+0x5a>

  if ((RCC->CR & RCC_CR_HSIRDY) != RESET)
 800014a:	2202      	movs	r2, #2
 800014c:	4b1c      	ldr	r3, [pc, #112]	; (80001c0 <SystemInit+0xe8>)
 800014e:	681b      	ldr	r3, [r3, #0]
 8000150:	4013      	ands	r3, r2
 8000152:	d006      	beq.n	8000162 <SystemInit+0x8a>
  {
    HSIStatus = (uint32_t)0x01;
 8000154:	2301      	movs	r3, #1
 8000156:	9301      	str	r3, [sp, #4]
  else
  {
    HSIStatus = (uint32_t)0x00;
  }  

  if (HSIStatus == (uint32_t)0x01)
 8000158:	9b01      	ldr	r3, [sp, #4]
 800015a:	2b01      	cmp	r3, #1
 800015c:	d005      	beq.n	800016a <SystemInit+0x92>
  /* Disable all interrupts */
  RCC->CIR = 0x00000000;

  /* Configure the System clock frequency, AHB/APBx prescalers and Flash settings */
  SetSysClock();
}
 800015e:	b002      	add	sp, #8
 8000160:	4770      	bx	lr
  {
    HSIStatus = (uint32_t)0x01;
  }
  else
  {
    HSIStatus = (uint32_t)0x00;
 8000162:	9301      	str	r3, [sp, #4]
  }  

  if (HSIStatus == (uint32_t)0x01)
 8000164:	9b01      	ldr	r3, [sp, #4]
 8000166:	2b01      	cmp	r3, #1
 8000168:	d1f9      	bne.n	800015e <SystemInit+0x86>
  {
    /* Enable Prefetch Buffer and set Flash Latency */
    FLASH->ACR = FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY;
 800016a:	2211      	movs	r2, #17
 800016c:	4b1a      	ldr	r3, [pc, #104]	; (80001d8 <SystemInit+0x100>)
            
    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 800016e:	2080      	movs	r0, #128	; 0x80
  }  

  if (HSIStatus == (uint32_t)0x01)
  {
    /* Enable Prefetch Buffer and set Flash Latency */
    FLASH->ACR = FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY;
 8000170:	601a      	str	r2, [r3, #0]

    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 8000172:	4a13      	ldr	r2, [pc, #76]	; (80001c0 <SystemInit+0xe8>)
            
    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8000174:	0480      	lsls	r0, r0, #18
  {
    /* Enable Prefetch Buffer and set Flash Latency */
    FLASH->ACR = FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY;

    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 8000176:	6853      	ldr	r3, [r2, #4]
 8000178:	6053      	str	r3, [r2, #4]
      
    /* PCLK = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE_DIV1;
 800017a:	6853      	ldr	r3, [r2, #4]
 800017c:	6053      	str	r3, [r2, #4]

    /* PLL configuration = HSI * 6 = 48 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL));    //Reset
 800017e:	6851      	ldr	r1, [r2, #4]
 8000180:	4b16      	ldr	r3, [pc, #88]	; (80001dc <SystemInit+0x104>)
 8000182:	400b      	ands	r3, r1
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_0 | RCC_CFGR_PLLMULL12);
 8000184:	21a2      	movs	r1, #162	; 0xa2
      
    /* PCLK = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE_DIV1;

    /* PLL configuration = HSI * 6 = 48 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL));    //Reset
 8000186:	6053      	str	r3, [r2, #4]
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_0 | RCC_CFGR_PLLMULL12);
 8000188:	6853      	ldr	r3, [r2, #4]
 800018a:	0389      	lsls	r1, r1, #14
 800018c:	430b      	orrs	r3, r1
            
    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 800018e:	2180      	movs	r1, #128	; 0x80
    /* PCLK = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE_DIV1;

    /* PLL configuration = HSI * 6 = 48 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL));    //Reset
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_0 | RCC_CFGR_PLLMULL12);
 8000190:	6053      	str	r3, [r2, #4]
            
    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 8000192:	6813      	ldr	r3, [r2, #0]
 8000194:	0449      	lsls	r1, r1, #17
 8000196:	430b      	orrs	r3, r1
 8000198:	6013      	str	r3, [r2, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 800019a:	6811      	ldr	r1, [r2, #0]
 800019c:	4b08      	ldr	r3, [pc, #32]	; (80001c0 <SystemInit+0xe8>)
 800019e:	4201      	tst	r1, r0
 80001a0:	d0fb      	beq.n	800019a <SystemInit+0xc2>
    {
    }

    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW)); //Reset
 80001a2:	2103      	movs	r1, #3
 80001a4:	685a      	ldr	r2, [r3, #4]
 80001a6:	438a      	bics	r2, r1
 80001a8:	605a      	str	r2, [r3, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
 80001aa:	2202      	movs	r2, #2
 80001ac:	6859      	ldr	r1, [r3, #4]
 80001ae:	430a      	orrs	r2, r1
 80001b0:	605a      	str	r2, [r3, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)RCC_CFGR_SWS_PLL)
 80001b2:	210c      	movs	r1, #12
 80001b4:	1c1a      	adds	r2, r3, #0
 80001b6:	6853      	ldr	r3, [r2, #4]
 80001b8:	400b      	ands	r3, r1
 80001ba:	2b08      	cmp	r3, #8
 80001bc:	d1fb      	bne.n	80001b6 <SystemInit+0xde>
 80001be:	e7ce      	b.n	800015e <SystemInit+0x86>
 80001c0:	40021000 	.word	0x40021000
 80001c4:	08ffb80c 	.word	0x08ffb80c
 80001c8:	fef6ffff 	.word	0xfef6ffff
 80001cc:	fffbffff 	.word	0xfffbffff
 80001d0:	ffc0ffff 	.word	0xffc0ffff
 80001d4:	fffffeac 	.word	0xfffffeac
 80001d8:	40022000 	.word	0x40022000
 80001dc:	ffc27fff 	.word	0xffc27fff

080001e0 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate (void)
{
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80001e0:	210c      	movs	r1, #12
 80001e2:	4a12      	ldr	r2, [pc, #72]	; (800022c <SystemCoreClockUpdate+0x4c>)
  *           value for HSE crystal.
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate (void)
{
 80001e4:	b510      	push	{r4, lr}
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80001e6:	6853      	ldr	r3, [r2, #4]
 80001e8:	400b      	ands	r3, r1
  
  switch (tmp)
 80001ea:	2b08      	cmp	r3, #8
 80001ec:	d10b      	bne.n	8000206 <SystemCoreClockUpdate+0x26>
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
      pllmull = ( pllmull >> 18) + 2;
      
      if (pllsource == 0x00)
 80001ee:	23c0      	movs	r3, #192	; 0xc0
    case 0x04:  /* HSE used as system clock */
      SystemCoreClock = HSE_VALUE;
      break;
    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 80001f0:	6850      	ldr	r0, [r2, #4]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 80001f2:	6851      	ldr	r1, [r2, #4]
    case 0x04:  /* HSE used as system clock */
      SystemCoreClock = HSE_VALUE;
      break;
    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 80001f4:	0280      	lsls	r0, r0, #10
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
      pllmull = ( pllmull >> 18) + 2;
 80001f6:	0f00      	lsrs	r0, r0, #28
      
      if (pllsource == 0x00)
 80001f8:	025b      	lsls	r3, r3, #9
      break;
    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
      pllmull = ( pllmull >> 18) + 2;
 80001fa:	1c84      	adds	r4, r0, #2
      
      if (pllsource == 0x00)
 80001fc:	4219      	tst	r1, r3
 80001fe:	d10c      	bne.n	800021a <SystemCoreClockUpdate+0x3a>
      {
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
 8000200:	480b      	ldr	r0, [pc, #44]	; (8000230 <SystemCoreClockUpdate+0x50>)
 8000202:	4360      	muls	r0, r4
 8000204:	e000      	b.n	8000208 <SystemCoreClockUpdate+0x28>
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
  
  switch (tmp)
 8000206:	480b      	ldr	r0, [pc, #44]	; (8000234 <SystemCoreClockUpdate+0x54>)
      SystemCoreClock = HSI_VALUE;
      break;
  }
  /* Compute HCLK clock frequency ----------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8000208:	4b08      	ldr	r3, [pc, #32]	; (800022c <SystemCoreClockUpdate+0x4c>)
 800020a:	4a0b      	ldr	r2, [pc, #44]	; (8000238 <SystemCoreClockUpdate+0x58>)
 800020c:	685b      	ldr	r3, [r3, #4]
 800020e:	061b      	lsls	r3, r3, #24
 8000210:	0f1b      	lsrs	r3, r3, #28
 8000212:	5cd3      	ldrb	r3, [r2, r3]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;  
 8000214:	40d8      	lsrs	r0, r3
 8000216:	6110      	str	r0, [r2, #16]
}
 8000218:	bd10      	pop	{r4, pc}
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 800021a:	210f      	movs	r1, #15
 800021c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
 800021e:	4805      	ldr	r0, [pc, #20]	; (8000234 <SystemCoreClockUpdate+0x54>)
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 8000220:	4019      	ands	r1, r3
 8000222:	3101      	adds	r1, #1
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
 8000224:	f003 faa6 	bl	8003774 <__aeabi_uidiv>
 8000228:	4360      	muls	r0, r4
 800022a:	e7ed      	b.n	8000208 <SystemCoreClockUpdate+0x28>
 800022c:	40021000 	.word	0x40021000
 8000230:	003d0900 	.word	0x003d0900
 8000234:	007a1200 	.word	0x007a1200
 8000238:	20000000 	.word	0x20000000

0800023c <vShowerControllerTask>:
//====================================================================================================
//
//====================================================================================================
#ifdef _SHOWERCONTROL_
static void vShowerControllerTask(void *pvParameters)
{
 800023c:	b508      	push	{r3, lr}
	for(;;)
	{
		ShowerController_Task();
 800023e:	f003 fa89 	bl	8003754 <ShowerController_Task>
	}
 8000242:	e7fc      	b.n	800023e <vShowerControllerTask+0x2>

08000244 <vShowerTimeTask>:
//====================================================================================================
//
//====================================================================================================
#ifdef _SHOWERTIME_
static void vShowerTimeTask(void *pvParameters)
{
 8000244:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000246:	4644      	mov	r4, r8
 8000248:	465f      	mov	r7, fp
 800024a:	4656      	mov	r6, sl
 800024c:	464d      	mov	r5, r9
 800024e:	b4f0      	push	{r4, r5, r6, r7}
 8000250:	b083      	sub	sp, #12
	ShowerTime.Date	   = 0;
	ShowerTime.Hours   = 0;
	ShowerTime.Minutes = 0;
	ShowerTime.Seconds = 0;

	ShowerRealTimeDate.WeekDay	= RTC_Weekday_Monday;
 8000252:	466a      	mov	r2, sp
 8000254:	2302      	movs	r3, #2
 8000256:	7013      	strb	r3, [r2, #0]
	ShowerRealTimeDate.Date		= 29;
 8000258:	331b      	adds	r3, #27
 800025a:	7053      	strb	r3, [r2, #1]
	ShowerRealTimeDate.Month	= RTC_Month_October;
 800025c:	3b0d      	subs	r3, #13
 800025e:	7093      	strb	r3, [r2, #2]
	ShowerRealTimeDate.Year		= 15;
 8000260:	3b01      	subs	r3, #1
 8000262:	70d3      	strb	r3, [r2, #3]
	ShowerRealTimeDate.Hours	= 00;
 8000264:	2300      	movs	r3, #0
 8000266:	7113      	strb	r3, [r2, #4]
	ShowerRealTimeDate.Minutes	= 00;
 8000268:	7153      	strb	r3, [r2, #5]
	ShowerRealTimeDate.Seconds	= 00;
 800026a:	7193      	strb	r3, [r2, #6]

	RTCC_SetTimeDate(ShowerRealTimeDate);
 800026c:	9800      	ldr	r0, [sp, #0]
 800026e:	9901      	ldr	r1, [sp, #4]
 8000270:	f001 ff96 	bl	80021a0 <RTCC_SetTimeDate>
	}ShowerTime;

	ShowerTime.Date	   = 0;
	ShowerTime.Hours   = 0;
	ShowerTime.Minutes = 0;
	ShowerTime.Seconds = 0;
 8000274:	2300      	movs	r3, #0
 8000276:	4c27      	ldr	r4, [pc, #156]	; (8000314 <vShowerTimeTask+0xd0>)
 8000278:	4699      	mov	r9, r3
		uint8_t Seconds;
	}ShowerTime;

	ShowerTime.Date	   = 0;
	ShowerTime.Hours   = 0;
	ShowerTime.Minutes = 0;
 800027a:	4698      	mov	r8, r3
		uint8_t Minutes;
		uint8_t Seconds;
	}ShowerTime;

	ShowerTime.Date	   = 0;
	ShowerTime.Hours   = 0;
 800027c:	469b      	mov	fp, r3
		uint8_t Hours;
		uint8_t Minutes;
		uint8_t Seconds;
	}ShowerTime;

	ShowerTime.Date	   = 0;
 800027e:	469a      	mov	sl, r3
 8000280:	e00a      	b.n	8000298 <vShowerTimeTask+0x54>
 8000282:	6865      	ldr	r5, [r4, #4]
				print2 = ShowerRealTimeDate.Seconds;

		print3 = TotalPeriodShowerSeconds;
		//print3 = TotalPeriodShowerMinutes;

				print4 = ShowerTime.Minutes;
 8000284:	4643      	mov	r3, r8
 8000286:	8263      	strh	r3, [r4, #18]
				print5 = ShowerTime.Seconds;
 8000288:	464b      	mov	r3, r9

		vTaskDelay(100);
 800028a:	2064      	movs	r0, #100	; 0x64
										(uint32_t)(ShowerTime.Seconds);

			TotalPeriodShowerMinutes = TotalPeriodShowerSeconds/60;
		}

				print1 = ShowerRealTimeDate.Minutes;
 800028c:	81a6      	strh	r6, [r4, #12]
				print2 = ShowerRealTimeDate.Seconds;
 800028e:	81e7      	strh	r7, [r4, #14]

		print3 = TotalPeriodShowerSeconds;
 8000290:	8225      	strh	r5, [r4, #16]
		//print3 = TotalPeriodShowerMinutes;

				print4 = ShowerTime.Minutes;
				print5 = ShowerTime.Seconds;
 8000292:	82a3      	strh	r3, [r4, #20]

		vTaskDelay(100);
 8000294:	f009 f9b0 	bl	80095f8 <vTaskDelay>

	RTCC_SetTimeDate(ShowerRealTimeDate);

	for (;;)
	{
		RTCC_GetTimeDate(&ShowerRealTimeDate);
 8000298:	4668      	mov	r0, sp
 800029a:	f001 ffa3 	bl	80021e4 <RTCC_GetTimeDate>

		if(ClearShowerTime) /* Initializes shower time count */
 800029e:	7823      	ldrb	r3, [r4, #0]
 80002a0:	2b00      	cmp	r3, #0
 80002a2:	d00b      	beq.n	80002bc <vShowerTimeTask+0x78>
		{
			ShowerTime.Date	   = ShowerRealTimeDate.Date;
 80002a4:	466b      	mov	r3, sp
 80002a6:	785b      	ldrb	r3, [r3, #1]
 80002a8:	469a      	mov	sl, r3
			ShowerTime.Hours   = ShowerRealTimeDate.Hours;
 80002aa:	466b      	mov	r3, sp
 80002ac:	791b      	ldrb	r3, [r3, #4]
 80002ae:	469b      	mov	fp, r3
			ShowerTime.Minutes = ShowerRealTimeDate.Minutes;
 80002b0:	466b      	mov	r3, sp
 80002b2:	795b      	ldrb	r3, [r3, #5]
 80002b4:	4698      	mov	r8, r3
			ShowerTime.Seconds = ShowerRealTimeDate.Seconds;
 80002b6:	466b      	mov	r3, sp
 80002b8:	799b      	ldrb	r3, [r3, #6]
 80002ba:	4699      	mov	r9, r3
		}

		if(ShowerController_GetShowerState() == SHOWER_TIME_FINISHED)
 80002bc:	f003 fa54 	bl	8003768 <ShowerController_GetShowerState>
		{
			TotalPeriodShowerSeconds =	(uint32_t)(ShowerRealTimeDate.Date * 86400) +
										(uint32_t)(ShowerRealTimeDate.Hours * 3600) +
										(uint32_t)(ShowerRealTimeDate.Minutes * 60) +
 80002c0:	466b      	mov	r3, sp
 80002c2:	795e      	ldrb	r6, [r3, #5]
										(uint32_t)(ShowerRealTimeDate.Seconds) -
 80002c4:	799f      	ldrb	r7, [r3, #6]
			ShowerTime.Hours   = ShowerRealTimeDate.Hours;
			ShowerTime.Minutes = ShowerRealTimeDate.Minutes;
			ShowerTime.Seconds = ShowerRealTimeDate.Seconds;
		}

		if(ShowerController_GetShowerState() == SHOWER_TIME_FINISHED)
 80002c6:	2803      	cmp	r0, #3
 80002c8:	d1db      	bne.n	8000282 <vShowerTimeTask+0x3e>
		{
			TotalPeriodShowerSeconds =	(uint32_t)(ShowerRealTimeDate.Date * 86400) +
 80002ca:	785d      	ldrb	r5, [r3, #1]
 80002cc:	4b12      	ldr	r3, [pc, #72]	; (8000318 <vShowerTimeTask+0xd4>)
										(uint32_t)(ShowerRealTimeDate.Hours * 3600) +
 80002ce:	22e1      	movs	r2, #225	; 0xe1
			ShowerTime.Seconds = ShowerRealTimeDate.Seconds;
		}

		if(ShowerController_GetShowerState() == SHOWER_TIME_FINISHED)
		{
			TotalPeriodShowerSeconds =	(uint32_t)(ShowerRealTimeDate.Date * 86400) +
 80002d0:	435d      	muls	r5, r3
										(uint32_t)(ShowerRealTimeDate.Hours * 3600) +
 80002d2:	466b      	mov	r3, sp
 80002d4:	791b      	ldrb	r3, [r3, #4]
 80002d6:	0112      	lsls	r2, r2, #4
 80002d8:	4353      	muls	r3, r2
 80002da:	464a      	mov	r2, r9
			ShowerTime.Seconds = ShowerRealTimeDate.Seconds;
		}

		if(ShowerController_GetShowerState() == SHOWER_TIME_FINISHED)
		{
			TotalPeriodShowerSeconds =	(uint32_t)(ShowerRealTimeDate.Date * 86400) +
 80002dc:	18eb      	adds	r3, r5, r3
 80002de:	19dd      	adds	r5, r3, r7
										(uint32_t)(ShowerRealTimeDate.Hours * 3600) +
										(uint32_t)(ShowerRealTimeDate.Minutes * 60) +
 80002e0:	0133      	lsls	r3, r6, #4
 80002e2:	1b9b      	subs	r3, r3, r6
 80002e4:	009b      	lsls	r3, r3, #2
 80002e6:	18eb      	adds	r3, r5, r3
 80002e8:	1a9b      	subs	r3, r3, r2
										(uint32_t)(ShowerRealTimeDate.Seconds) -
										(uint32_t)(ShowerTime.Date * 86400) -
										(uint32_t)(ShowerTime.Hours * 3600) -
 80002ea:	465a      	mov	r2, fp
 80002ec:	4d0b      	ldr	r5, [pc, #44]	; (800031c <vShowerTimeTask+0xd8>)
										(uint32_t)(ShowerTime.Minutes * 60)	-
										(uint32_t)(ShowerTime.Seconds);

			TotalPeriodShowerMinutes = TotalPeriodShowerSeconds/60;
 80002ee:	213c      	movs	r1, #60	; 0x3c
			TotalPeriodShowerSeconds =	(uint32_t)(ShowerRealTimeDate.Date * 86400) +
										(uint32_t)(ShowerRealTimeDate.Hours * 3600) +
										(uint32_t)(ShowerRealTimeDate.Minutes * 60) +
										(uint32_t)(ShowerRealTimeDate.Seconds) -
										(uint32_t)(ShowerTime.Date * 86400) -
										(uint32_t)(ShowerTime.Hours * 3600) -
 80002f0:	4355      	muls	r5, r2
		{
			TotalPeriodShowerSeconds =	(uint32_t)(ShowerRealTimeDate.Date * 86400) +
										(uint32_t)(ShowerRealTimeDate.Hours * 3600) +
										(uint32_t)(ShowerRealTimeDate.Minutes * 60) +
										(uint32_t)(ShowerRealTimeDate.Seconds) -
										(uint32_t)(ShowerTime.Date * 86400) -
 80002f2:	4652      	mov	r2, sl
 80002f4:	195d      	adds	r5, r3, r5
 80002f6:	4b0a      	ldr	r3, [pc, #40]	; (8000320 <vShowerTimeTask+0xdc>)
 80002f8:	435a      	muls	r2, r3
 80002fa:	18ab      	adds	r3, r5, r2
										(uint32_t)(ShowerTime.Hours * 3600) -
										(uint32_t)(ShowerTime.Minutes * 60)	-
 80002fc:	4642      	mov	r2, r8
 80002fe:	0115      	lsls	r5, r2, #4
 8000300:	1b55      	subs	r5, r2, r5
 8000302:	00ad      	lsls	r5, r5, #2
 8000304:	195d      	adds	r5, r3, r5
			ShowerTime.Seconds = ShowerRealTimeDate.Seconds;
		}

		if(ShowerController_GetShowerState() == SHOWER_TIME_FINISHED)
		{
			TotalPeriodShowerSeconds =	(uint32_t)(ShowerRealTimeDate.Date * 86400) +
 8000306:	6065      	str	r5, [r4, #4]
										(uint32_t)(ShowerTime.Date * 86400) -
										(uint32_t)(ShowerTime.Hours * 3600) -
										(uint32_t)(ShowerTime.Minutes * 60)	-
										(uint32_t)(ShowerTime.Seconds);

			TotalPeriodShowerMinutes = TotalPeriodShowerSeconds/60;
 8000308:	1c28      	adds	r0, r5, #0
 800030a:	f003 fa33 	bl	8003774 <__aeabi_uidiv>
 800030e:	60a0      	str	r0, [r4, #8]
 8000310:	e7b8      	b.n	8000284 <vShowerTimeTask+0x40>
 8000312:	46c0      	nop			; (mov r8, r8)
 8000314:	20000054 	.word	0x20000054
 8000318:	00015180 	.word	0x00015180
 800031c:	fffff1f0 	.word	0xfffff1f0
 8000320:	fffeae80 	.word	0xfffeae80

08000324 <vShowerLogsTask>:
//====================================================================================================
//
//====================================================================================================
#ifdef _LOGS_
static void vShowerLogsTask(void *pvParameters)
{
 8000324:	b570      	push	{r4, r5, r6, lr}
 8000326:	b086      	sub	sp, #24
	uint16_t VarDataTab[12] = {0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0};
 8000328:	2300      	movs	r3, #0
 800032a:	466a      	mov	r2, sp
 800032c:	4e63      	ldr	r6, [pc, #396]	; (80004bc <vShowerLogsTask+0x198>)
 800032e:	8013      	strh	r3, [r2, #0]
 8000330:	8053      	strh	r3, [r2, #2]
 8000332:	8093      	strh	r3, [r2, #4]
 8000334:	80d3      	strh	r3, [r2, #6]
 8000336:	8113      	strh	r3, [r2, #8]
 8000338:	8153      	strh	r3, [r2, #10]
 800033a:	8193      	strh	r3, [r2, #12]
 800033c:	81d3      	strh	r3, [r2, #14]
 800033e:	8213      	strh	r3, [r2, #16]
 8000340:	8253      	strh	r3, [r2, #18]
 8000342:	8293      	strh	r3, [r2, #20]
 8000344:	82d3      	strh	r3, [r2, #22]
 8000346:	e002      	b.n	800034e <vShowerLogsTask+0x2a>
			EE_WriteVariable(EEPROM_ADDRESS_MAX_OUT_TEMP, (VarDataTab[9] > OutletTemperature) ? VarDataTab[9] : OutletTemperature);
			EE_WriteVariable(EEPROM_ADDRESS_MIN_OUT_TEMP, (VarDataTab[10] < OutletTemperature) ? VarDataTab[10] : OutletTemperature);
			EE_WriteVariable(EEPROM_ADDRESS_MID_OUT_TEMP, (VarDataTab[10] + VarDataTab[9])/2);
		}

		vTaskDelay(100);
 8000348:	2064      	movs	r0, #100	; 0x64
 800034a:	f009 f955 	bl	80095f8 <vTaskDelay>
	uint16_t VarDataTab[12] = {0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0};
	uint16_t InletTemperature= 0, OutletTemperature= 0;

	for(;;)
	{
		InletTemperature  = NTC_GetWaterTemperature(TEMPERATURE_INLET);
 800034e:	2001      	movs	r0, #1
 8000350:	f002 fbfa 	bl	8002b48 <NTC_GetWaterTemperature>
 8000354:	1c05      	adds	r5, r0, #0
		OutletTemperature = NTC_GetWaterTemperature(TEMPERATURE_OUTLET);
 8000356:	2002      	movs	r0, #2
 8000358:	f002 fbf6 	bl	8002b48 <NTC_GetWaterTemperature>
 800035c:	1c04      	adds	r4, r0, #0

		if(ShowerController_GetShowerState() == SHOWER_TIME_FINISHED)
 800035e:	f003 fa03 	bl	8003768 <ShowerController_GetShowerState>
 8000362:	2803      	cmp	r0, #3
 8000364:	d1f0      	bne.n	8000348 <vShowerLogsTask+0x24>
		{
			/* Reading first variables values from Flash Virtual Address and storing in VarDataTab[] vector */
			EE_ReadVariable(EEPROM_ADDRESS_LITERS, &VarDataTab[0]);
 8000366:	4669      	mov	r1, sp
 8000368:	4855      	ldr	r0, [pc, #340]	; (80004c0 <vShowerLogsTask+0x19c>)
 800036a:	f001 ffb7 	bl	80022dc <EE_ReadVariable>
			EE_ReadVariable(EEPROM_ADDRESS_HOUERS, &VarDataTab[1]);
 800036e:	466b      	mov	r3, sp
 8000370:	4854      	ldr	r0, [pc, #336]	; (80004c4 <vShowerLogsTask+0x1a0>)
 8000372:	1c99      	adds	r1, r3, #2
 8000374:	f001 ffb2 	bl	80022dc <EE_ReadVariable>
			EE_ReadVariable(EEPROM_ADDRESS_NUMBER, &VarDataTab[2]);
 8000378:	a901      	add	r1, sp, #4
 800037a:	4853      	ldr	r0, [pc, #332]	; (80004c8 <vShowerLogsTask+0x1a4>)
 800037c:	f001 ffae 	bl	80022dc <EE_ReadVariable>

			EE_ReadVariable(EEPROM_ADDRESS_MAX_POT, &VarDataTab[3]);
 8000380:	466b      	mov	r3, sp
 8000382:	4852      	ldr	r0, [pc, #328]	; (80004cc <vShowerLogsTask+0x1a8>)
 8000384:	1d99      	adds	r1, r3, #6
 8000386:	f001 ffa9 	bl	80022dc <EE_ReadVariable>
			EE_ReadVariable(EEPROM_ADDRESS_MIN_POT, &VarDataTab[4]);
 800038a:	a902      	add	r1, sp, #8
 800038c:	4850      	ldr	r0, [pc, #320]	; (80004d0 <vShowerLogsTask+0x1ac>)
 800038e:	f001 ffa5 	bl	80022dc <EE_ReadVariable>
			EE_ReadVariable(EEPROM_ADDRESS_MID_POT, &VarDataTab[5]);
 8000392:	230a      	movs	r3, #10
 8000394:	446b      	add	r3, sp
 8000396:	1c19      	adds	r1, r3, #0
 8000398:	484e      	ldr	r0, [pc, #312]	; (80004d4 <vShowerLogsTask+0x1b0>)
 800039a:	f001 ff9f 	bl	80022dc <EE_ReadVariable>

			EE_ReadVariable(EEPROM_ADDRESS_MAX_IN_TEMP, &VarDataTab[6]);
 800039e:	a903      	add	r1, sp, #12
 80003a0:	484d      	ldr	r0, [pc, #308]	; (80004d8 <vShowerLogsTask+0x1b4>)
 80003a2:	f001 ff9b 	bl	80022dc <EE_ReadVariable>
			EE_ReadVariable(EEPROM_ADDRESS_MIN_IN_TEMP, &VarDataTab[7]);
 80003a6:	230e      	movs	r3, #14
 80003a8:	446b      	add	r3, sp
 80003aa:	1c19      	adds	r1, r3, #0
 80003ac:	484b      	ldr	r0, [pc, #300]	; (80004dc <vShowerLogsTask+0x1b8>)
 80003ae:	f001 ff95 	bl	80022dc <EE_ReadVariable>
			EE_ReadVariable(EEPROM_ADDRESS_MID_IN_TEMP, &VarDataTab[8]);
 80003b2:	a904      	add	r1, sp, #16
 80003b4:	484a      	ldr	r0, [pc, #296]	; (80004e0 <vShowerLogsTask+0x1bc>)
 80003b6:	f001 ff91 	bl	80022dc <EE_ReadVariable>

			EE_ReadVariable(EEPROM_ADDRESS_MAX_OUT_TEMP, &VarDataTab[9]);
 80003ba:	2312      	movs	r3, #18
 80003bc:	446b      	add	r3, sp
 80003be:	1c19      	adds	r1, r3, #0
 80003c0:	4848      	ldr	r0, [pc, #288]	; (80004e4 <vShowerLogsTask+0x1c0>)
 80003c2:	f001 ff8b 	bl	80022dc <EE_ReadVariable>
			EE_ReadVariable(EEPROM_ADDRESS_MIN_OUT_TEMP, &VarDataTab[10]);
 80003c6:	a905      	add	r1, sp, #20
 80003c8:	4847      	ldr	r0, [pc, #284]	; (80004e8 <vShowerLogsTask+0x1c4>)
 80003ca:	f001 ff87 	bl	80022dc <EE_ReadVariable>
			EE_ReadVariable(EEPROM_ADDRESS_MID_OUT_TEMP, &VarDataTab[11]);
 80003ce:	2316      	movs	r3, #22
 80003d0:	446b      	add	r3, sp
 80003d2:	1c19      	adds	r1, r3, #0
 80003d4:	4845      	ldr	r0, [pc, #276]	; (80004ec <vShowerLogsTask+0x1c8>)
 80003d6:	f001 ff81 	bl	80022dc <EE_ReadVariable>

			/* Write variables values on Flash Virtual Address */
			EE_WriteVariable(EEPROM_ADDRESS_LITERS, VarDataTab[0] + VolumeWaterConsumed);
 80003da:	466b      	mov	r3, sp
 80003dc:	8af1      	ldrh	r1, [r6, #22]
 80003de:	881b      	ldrh	r3, [r3, #0]
 80003e0:	4837      	ldr	r0, [pc, #220]	; (80004c0 <vShowerLogsTask+0x19c>)
 80003e2:	18c9      	adds	r1, r1, r3
 80003e4:	b289      	uxth	r1, r1
 80003e6:	f002 f859 	bl	800249c <EE_WriteVariable>
			EE_WriteVariable(EEPROM_ADDRESS_HOUERS, VarDataTab[1] + TotalPeriodShowerMinutes);
 80003ea:	466b      	mov	r3, sp
 80003ec:	8859      	ldrh	r1, [r3, #2]
 80003ee:	68b3      	ldr	r3, [r6, #8]
 80003f0:	4834      	ldr	r0, [pc, #208]	; (80004c4 <vShowerLogsTask+0x1a0>)
 80003f2:	469c      	mov	ip, r3
 80003f4:	4461      	add	r1, ip
 80003f6:	b289      	uxth	r1, r1
 80003f8:	f002 f850 	bl	800249c <EE_WriteVariable>
			EE_WriteVariable(EEPROM_ADDRESS_NUMBER, VarDataTab[2]++);
 80003fc:	466b      	mov	r3, sp
 80003fe:	466a      	mov	r2, sp
 8000400:	8899      	ldrh	r1, [r3, #4]
 8000402:	4831      	ldr	r0, [pc, #196]	; (80004c8 <vShowerLogsTask+0x1a4>)
 8000404:	1c4b      	adds	r3, r1, #1
 8000406:	8093      	strh	r3, [r2, #4]
 8000408:	f002 f848 	bl	800249c <EE_WriteVariable>

			EE_WriteVariable(EEPROM_ADDRESS_MAX_POT, (VarDataTab[3] > PowerStored) ? VarDataTab[3] : PowerStored);
 800040c:	466b      	mov	r3, sp
 800040e:	88da      	ldrh	r2, [r3, #6]
 8000410:	8b33      	ldrh	r3, [r6, #24]
 8000412:	1c19      	adds	r1, r3, #0
 8000414:	4293      	cmp	r3, r2
 8000416:	d200      	bcs.n	800041a <vShowerLogsTask+0xf6>
 8000418:	1c11      	adds	r1, r2, #0
 800041a:	b289      	uxth	r1, r1
 800041c:	482b      	ldr	r0, [pc, #172]	; (80004cc <vShowerLogsTask+0x1a8>)
 800041e:	f002 f83d 	bl	800249c <EE_WriteVariable>
			EE_WriteVariable(EEPROM_ADDRESS_MIN_POT, (VarDataTab[4] < PowerStored) ? VarDataTab[3] : PowerStored);
 8000422:	466b      	mov	r3, sp
 8000424:	8b31      	ldrh	r1, [r6, #24]
 8000426:	891b      	ldrh	r3, [r3, #8]
 8000428:	428b      	cmp	r3, r1
 800042a:	d201      	bcs.n	8000430 <vShowerLogsTask+0x10c>
 800042c:	466b      	mov	r3, sp
 800042e:	88d9      	ldrh	r1, [r3, #6]
 8000430:	4827      	ldr	r0, [pc, #156]	; (80004d0 <vShowerLogsTask+0x1ac>)
 8000432:	f002 f833 	bl	800249c <EE_WriteVariable>
			EE_WriteVariable(EEPROM_ADDRESS_MID_POT, (VarDataTab[4] + VarDataTab[3])/2);
 8000436:	466b      	mov	r3, sp
 8000438:	8919      	ldrh	r1, [r3, #8]
 800043a:	88db      	ldrh	r3, [r3, #6]
 800043c:	4825      	ldr	r0, [pc, #148]	; (80004d4 <vShowerLogsTask+0x1b0>)
 800043e:	18c9      	adds	r1, r1, r3
 8000440:	0849      	lsrs	r1, r1, #1
 8000442:	f002 f82b 	bl	800249c <EE_WriteVariable>

			EE_WriteVariable(EEPROM_ADDRESS_MAX_IN_TEMP, (VarDataTab[6] > InletTemperature) ? VarDataTab[6] : InletTemperature);
 8000446:	466b      	mov	r3, sp
 8000448:	899b      	ldrh	r3, [r3, #12]
	uint16_t VarDataTab[12] = {0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0};
	uint16_t InletTemperature= 0, OutletTemperature= 0;

	for(;;)
	{
		InletTemperature  = NTC_GetWaterTemperature(TEMPERATURE_INLET);
 800044a:	b2ad      	uxth	r5, r5
		OutletTemperature = NTC_GetWaterTemperature(TEMPERATURE_OUTLET);
 800044c:	b2a4      	uxth	r4, r4

			EE_WriteVariable(EEPROM_ADDRESS_MAX_POT, (VarDataTab[3] > PowerStored) ? VarDataTab[3] : PowerStored);
			EE_WriteVariable(EEPROM_ADDRESS_MIN_POT, (VarDataTab[4] < PowerStored) ? VarDataTab[3] : PowerStored);
			EE_WriteVariable(EEPROM_ADDRESS_MID_POT, (VarDataTab[4] + VarDataTab[3])/2);

			EE_WriteVariable(EEPROM_ADDRESS_MAX_IN_TEMP, (VarDataTab[6] > InletTemperature) ? VarDataTab[6] : InletTemperature);
 800044e:	1c29      	adds	r1, r5, #0
 8000450:	429d      	cmp	r5, r3
 8000452:	d200      	bcs.n	8000456 <vShowerLogsTask+0x132>
 8000454:	1c19      	adds	r1, r3, #0
 8000456:	b289      	uxth	r1, r1
 8000458:	481f      	ldr	r0, [pc, #124]	; (80004d8 <vShowerLogsTask+0x1b4>)
 800045a:	f002 f81f 	bl	800249c <EE_WriteVariable>
			EE_WriteVariable(EEPROM_ADDRESS_MIN_IN_TEMP, (VarDataTab[7] < InletTemperature) ? VarDataTab[7] : InletTemperature);
 800045e:	466b      	mov	r3, sp
 8000460:	89db      	ldrh	r3, [r3, #14]
 8000462:	1c29      	adds	r1, r5, #0
 8000464:	429d      	cmp	r5, r3
 8000466:	d900      	bls.n	800046a <vShowerLogsTask+0x146>
 8000468:	1c19      	adds	r1, r3, #0
 800046a:	b289      	uxth	r1, r1
 800046c:	481b      	ldr	r0, [pc, #108]	; (80004dc <vShowerLogsTask+0x1b8>)
 800046e:	f002 f815 	bl	800249c <EE_WriteVariable>
			EE_WriteVariable(EEPROM_ADDRESS_MID_IN_TEMP, (VarDataTab[7] + VarDataTab[6])/2);
 8000472:	466b      	mov	r3, sp
 8000474:	89d9      	ldrh	r1, [r3, #14]
 8000476:	899b      	ldrh	r3, [r3, #12]
 8000478:	4819      	ldr	r0, [pc, #100]	; (80004e0 <vShowerLogsTask+0x1bc>)
 800047a:	18c9      	adds	r1, r1, r3
 800047c:	0849      	lsrs	r1, r1, #1
 800047e:	f002 f80d 	bl	800249c <EE_WriteVariable>

			EE_WriteVariable(EEPROM_ADDRESS_MAX_OUT_TEMP, (VarDataTab[9] > OutletTemperature) ? VarDataTab[9] : OutletTemperature);
 8000482:	466b      	mov	r3, sp
 8000484:	8a5b      	ldrh	r3, [r3, #18]
 8000486:	1c21      	adds	r1, r4, #0
 8000488:	429c      	cmp	r4, r3
 800048a:	d200      	bcs.n	800048e <vShowerLogsTask+0x16a>
 800048c:	1c19      	adds	r1, r3, #0
 800048e:	b289      	uxth	r1, r1
 8000490:	4814      	ldr	r0, [pc, #80]	; (80004e4 <vShowerLogsTask+0x1c0>)
 8000492:	f002 f803 	bl	800249c <EE_WriteVariable>
			EE_WriteVariable(EEPROM_ADDRESS_MIN_OUT_TEMP, (VarDataTab[10] < OutletTemperature) ? VarDataTab[10] : OutletTemperature);
 8000496:	466b      	mov	r3, sp
 8000498:	8a9b      	ldrh	r3, [r3, #20]
 800049a:	1c21      	adds	r1, r4, #0
 800049c:	429c      	cmp	r4, r3
 800049e:	d900      	bls.n	80004a2 <vShowerLogsTask+0x17e>
 80004a0:	1c19      	adds	r1, r3, #0
 80004a2:	b289      	uxth	r1, r1
 80004a4:	4810      	ldr	r0, [pc, #64]	; (80004e8 <vShowerLogsTask+0x1c4>)
 80004a6:	f001 fff9 	bl	800249c <EE_WriteVariable>
			EE_WriteVariable(EEPROM_ADDRESS_MID_OUT_TEMP, (VarDataTab[10] + VarDataTab[9])/2);
 80004aa:	466b      	mov	r3, sp
 80004ac:	8a99      	ldrh	r1, [r3, #20]
 80004ae:	8a5b      	ldrh	r3, [r3, #18]
 80004b0:	480e      	ldr	r0, [pc, #56]	; (80004ec <vShowerLogsTask+0x1c8>)
 80004b2:	18c9      	adds	r1, r1, r3
 80004b4:	0849      	lsrs	r1, r1, #1
 80004b6:	f001 fff1 	bl	800249c <EE_WriteVariable>
 80004ba:	e745      	b.n	8000348 <vShowerLogsTask+0x24>
 80004bc:	20000054 	.word	0x20000054
 80004c0:	00001111 	.word	0x00001111
 80004c4:	00002222 	.word	0x00002222
 80004c8:	00003333 	.word	0x00003333
 80004cc:	00004444 	.word	0x00004444
 80004d0:	00005555 	.word	0x00005555
 80004d4:	00006666 	.word	0x00006666
 80004d8:	00007777 	.word	0x00007777
 80004dc:	00008888 	.word	0x00008888
 80004e0:	00009999 	.word	0x00009999
 80004e4:	0000aaaa 	.word	0x0000aaaa
 80004e8:	0000bbbb 	.word	0x0000bbbb
 80004ec:	0000cccc 	.word	0x0000cccc

080004f0 <vPIDTask>:

//====================================================================================================
//
//====================================================================================================
static void vPIDTask(void *pvParameters)
{
 80004f0:	b508      	push	{r3, lr}
	for (;;)
	{
		PID_Task();
 80004f2:	f002 f92d 	bl	8002750 <PID_Task>

		vTaskDelay(150);
 80004f6:	2096      	movs	r0, #150	; 0x96
 80004f8:	f009 f87e 	bl	80095f8 <vTaskDelay>
	}
 80004fc:	e7f9      	b.n	80004f2 <vPIDTask+0x2>
 80004fe:	46c0      	nop			; (mov r8, r8)

08000500 <vDebugTask>:
//====================================================================================================
// Debug through UART2, RXD/TXD
//====================================================================================================
#ifdef _DEBUG_
static void vDebugTask(void *pvParameters)
{
 8000500:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000502:	4647      	mov	r7, r8
 8000504:	b480      	push	{r7}
 8000506:	b088      	sub	sp, #32
	#ifndef _FAST_DEBUG_
		static uint16_t i = 0;
	#endif

	Debug_Init();
 8000508:	f001 fd46 	bl	8001f98 <Debug_Init>
 800050c:	4c15      	ldr	r4, [pc, #84]	; (8000564 <vDebugTask+0x64>)
 800050e:	4b16      	ldr	r3, [pc, #88]	; (8000568 <vDebugTask+0x68>)

	for(;;)
	{
		#ifdef _FAST_DEBUG_
			sprintf_lib(str_debug, "%02d:%02d Tmp: %d min %02d:%02d; Vol: %d; Engy %d kW - %d %d %d\n",
 8000510:	1c25      	adds	r5, r4, #0
 8000512:	4698      	mov	r8, r3
 8000514:	276c      	movs	r7, #108	; 0x6c
 8000516:	266e      	movs	r6, #110	; 0x6e
 8000518:	351c      	adds	r5, #28
 800051a:	8a21      	ldrh	r1, [r4, #16]
 800051c:	89a2      	ldrh	r2, [r4, #12]
 800051e:	89e3      	ldrh	r3, [r4, #14]
 8000520:	9100      	str	r1, [sp, #0]
 8000522:	8a61      	ldrh	r1, [r4, #18]
 8000524:	1c28      	adds	r0, r5, #0
 8000526:	9101      	str	r1, [sp, #4]
 8000528:	8aa1      	ldrh	r1, [r4, #20]
 800052a:	9102      	str	r1, [sp, #8]
 800052c:	5be1      	ldrh	r1, [r4, r7]
 800052e:	9103      	str	r1, [sp, #12]
 8000530:	5ba1      	ldrh	r1, [r4, r6]
 8000532:	9104      	str	r1, [sp, #16]
 8000534:	2170      	movs	r1, #112	; 0x70
 8000536:	5a61      	ldrh	r1, [r4, r1]
 8000538:	9105      	str	r1, [sp, #20]
 800053a:	2172      	movs	r1, #114	; 0x72
 800053c:	5a61      	ldrh	r1, [r4, r1]
 800053e:	9106      	str	r1, [sp, #24]
 8000540:	2174      	movs	r1, #116	; 0x74
 8000542:	5a61      	ldrh	r1, [r4, r1]
 8000544:	9107      	str	r1, [sp, #28]
 8000546:	4641      	mov	r1, r8
 8000548:	f009 fede 	bl	800a308 <tfp_sprintf>
						print1,print2,print3,print4,print5,print6,print7,print8,print9,print10);
			Debug_Write(str_debug, strlen(str_debug));
 800054c:	1c28      	adds	r0, r5, #0
 800054e:	f009 ffe5 	bl	800a51c <strlen>
 8000552:	1c01      	adds	r1, r0, #0
 8000554:	1c28      	adds	r0, r5, #0
 8000556:	f001 fd5b 	bl	8002010 <Debug_Write>

			sprintf_lib(str_debug, "%d 0\n", User[User_GetIndex()].TemperatureSetPoint);
			Debug_Write(str_debug, strlen(str_debug));
		#endif // _FAST_DEBUG

		vTaskDelay(100);
 800055a:	2064      	movs	r0, #100	; 0x64
 800055c:	f009 f84c 	bl	80095f8 <vTaskDelay>
	}
 8000560:	e7db      	b.n	800051a <vDebugTask+0x1a>
 8000562:	46c0      	nop			; (mov r8, r8)
 8000564:	20000054 	.word	0x20000054
 8000568:	0800aa6c 	.word	0x0800aa6c

0800056c <vScreenTask>:

//====================================================================================================
//
//====================================================================================================
static void vScreenTask(void *pvParameters)
{
 800056c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800056e:	464f      	mov	r7, r9
 8000570:	4646      	mov	r6, r8
 8000572:	b4c0      	push	{r6, r7}
 8000574:	b087      	sub	sp, #28
	uint8_t UserIndex = 0;
	Screen_Init();
 8000576:	f002 ff59 	bl	800342c <Screen_Init>

	for(;;)
	{
		UserIndex = User_GetIndex();

		Screen_Task(User_GetTemperatureSetPoint(UserIndex),
 800057a:	2376      	movs	r3, #118	; 0x76
 800057c:	4699      	mov	r9, r3
 800057e:	3302      	adds	r3, #2
 8000580:	4698      	mov	r8, r3
 8000582:	277a      	movs	r7, #122	; 0x7a
 8000584:	4c0f      	ldr	r4, [pc, #60]	; (80005c4 <vScreenTask+0x58>)
	uint8_t UserIndex = 0;
	Screen_Init();

	for(;;)
	{
		UserIndex = User_GetIndex();
 8000586:	f000 fa2b 	bl	80009e0 <User_GetIndex>
 800058a:	1c05      	adds	r5, r0, #0

		Screen_Task(User_GetTemperatureSetPoint(UserIndex),
 800058c:	f000 f9d8 	bl	8000940 <User_GetTemperatureSetPoint>
 8000590:	1c06      	adds	r6, r0, #0
 8000592:	1c28      	adds	r0, r5, #0
 8000594:	f000 f9e8 	bl	8000968 <User_GetPowerSetPoint>
 8000598:	464b      	mov	r3, r9
 800059a:	5ae3      	ldrh	r3, [r4, r3]
 800059c:	8ae2      	ldrh	r2, [r4, #22]
 800059e:	9301      	str	r3, [sp, #4]
 80005a0:	9302      	str	r3, [sp, #8]
 80005a2:	4643      	mov	r3, r8
 80005a4:	9200      	str	r2, [sp, #0]
 80005a6:	5ae3      	ldrh	r3, [r4, r3]
 80005a8:	1c01      	adds	r1, r0, #0
 80005aa:	9303      	str	r3, [sp, #12]
 80005ac:	5de3      	ldrb	r3, [r4, r7]
 80005ae:	1c30      	adds	r0, r6, #0
 80005b0:	9304      	str	r3, [sp, #16]
 80005b2:	237b      	movs	r3, #123	; 0x7b
 80005b4:	5ce3      	ldrb	r3, [r4, r3]
 80005b6:	1c2a      	adds	r2, r5, #0
 80005b8:	9305      	str	r3, [sp, #20]
 80005ba:	68a3      	ldr	r3, [r4, #8]
 80005bc:	f002 fb50 	bl	8002c60 <Screen_Task>
					EstimatedMonthlyCost,
					EstimatedMonthlyCost,
					TotalPowerConsumption,
					PasswordDigit1,
					PasswordDigit2);
	}
 80005c0:	e7e1      	b.n	8000586 <vScreenTask+0x1a>
 80005c2:	46c0      	nop			; (mov r8, r8)
 80005c4:	20000054 	.word	0x20000054

080005c8 <v10msTask>:

//====================================================================================================
// User Interface Task (Display - LED - Flowmeter)
//====================================================================================================
static void v10msTask (void *pvParameters)
{
 80005c8:	b510      	push	{r4, lr}
	uint8_t count = 0;
	uint8_t UserIndex = 0;

	UserIndex = User_GetIndex();
 80005ca:	f000 fa09 	bl	80009e0 <User_GetIndex>
 80005ce:	1c04      	adds	r4, r0, #0

	LED_Init();
 80005d0:	f000 fc44 	bl	8000e5c <LED_Init>
	LED_SetMode(User_GetLedMode(UserIndex));
 80005d4:	1c20      	adds	r0, r4, #0
 80005d6:	f000 f98b 	bl	80008f0 <User_GetLedMode>
 80005da:	f000 fcf9 	bl	8000fd0 <LED_SetMode>
	LED_SetFixedColor(User_GetLedColor(UserIndex));
 80005de:	1c20      	adds	r0, r4, #0
 80005e0:	f000 f99a 	bl	8000918 <User_GetLedColor>
 80005e4:	f000 fce8 	bl	8000fb8 <LED_SetFixedColor>
//====================================================================================================
// User Interface Task (Display - LED - Flowmeter)
//====================================================================================================
static void v10msTask (void *pvParameters)
{
	uint8_t count = 0;
 80005e8:	2400      	movs	r4, #0
	LED_Init();
	LED_SetMode(User_GetLedMode(UserIndex));
	LED_SetFixedColor(User_GetLedColor(UserIndex));


	Display_Init();
 80005ea:	f000 fcf7 	bl	8000fdc <Display_Init>
	Flowmeter_Init();
 80005ee:	f001 f8d1 	bl	8001794 <Flowmeter_Init>

	for (;;)
	{
		Display_Task();
 80005f2:	f000 fe0d 	bl	8001210 <Display_Task>
		LED_Task();
 80005f6:	f000 fc49 	bl	8000e8c <LED_Task>
		{
			count = 0;
				Flowmeter_Task();
			}

		count++;
 80005fa:	3401      	adds	r4, #1

		vTaskDelay(10);
 80005fc:	200a      	movs	r0, #10
		{
			count = 0;
				Flowmeter_Task();
			}

		count++;
 80005fe:	b2e4      	uxtb	r4, r4

		vTaskDelay(10);
 8000600:	f008 fffa 	bl	80095f8 <vTaskDelay>
	Display_Init();
	Flowmeter_Init();

	for (;;)
	{
		Display_Task();
 8000604:	f000 fe04 	bl	8001210 <Display_Task>
		LED_Task();
 8000608:	f000 fc40 	bl	8000e8c <LED_Task>

		if(count > 10) // One reading every 100ms
 800060c:	2c0a      	cmp	r4, #10
 800060e:	d9f4      	bls.n	80005fa <v10msTask+0x32>
		{
			count = 0;
				Flowmeter_Task();
 8000610:	f001 f9c8 	bl	80019a4 <Flowmeter_Task>
		Display_Task();
		LED_Task();

		if(count > 10) // One reading every 100ms
		{
			count = 0;
 8000614:	2400      	movs	r4, #0
 8000616:	e7f0      	b.n	80005fa <v10msTask+0x32>

08000618 <vBuzzerTask>:

//====================================================================================================
//
//====================================================================================================
static void vBuzzerTask(void *pvParameters)
{
 8000618:	b508      	push	{r3, lr}
	Buzzer_Init();
 800061a:	f001 fd33 	bl	8002084 <Buzzer_Init>
	vTaskDelay(50);
 800061e:	2032      	movs	r0, #50	; 0x32
 8000620:	f008 ffea 	bl	80095f8 <vTaskDelay>
	Buzzer_Beep(50, 2);
 8000624:	2032      	movs	r0, #50	; 0x32
 8000626:	2102      	movs	r1, #2
 8000628:	f001 fd46 	bl	80020b8 <Buzzer_Beep>

	for (;;)
	{
		Buzzer_Task();
 800062c:	f001 fd06 	bl	800203c <Buzzer_Task>
	}
 8000630:	e7fc      	b.n	800062c <vBuzzerTask+0x14>
 8000632:	46c0      	nop			; (mov r8, r8)

08000634 <Calcula_Nota_Banho>:
//====================================================================================================
// Calcula a nota do banho do usuário utilizando a fórmula,
// 80 - { [ (Litros-35) + (Energia-60) + 3*(tempo-10) ] / 4 }
//====================================================================================================
void Calcula_Nota_Banho(void)
{
 8000634:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    static uint16_t uiConsumoKWH;
    static uint16_t uiCustoKWH = 700;

    //..................................................................................
    //ucEnergia = ulAccEnergia/ulAccTempoBanho; // Media do percentual de energia consumida
    ucEnergia = TotalPowerConsumption/TotalPeriodShowerMinutes;
 8000636:	2378      	movs	r3, #120	; 0x78
 8000638:	4e22      	ldr	r6, [pc, #136]	; (80006c4 <Calcula_Nota_Banho+0x90>)
 800063a:	5af0      	ldrh	r0, [r6, r3]
 800063c:	68b1      	ldr	r1, [r6, #8]
 800063e:	f003 f899 	bl	8003774 <__aeabi_uidiv>

    //uiConsumoKWH = uiTempoBanho * ucEnergia * 0.012; // Cálculo em 10*Kwh do consumo do banho atual
    uiConsumoKWH = (TotalPeriodShowerSeconds) * ucEnergia * 0.012;
 8000642:	6877      	ldr	r7, [r6, #4]
    static uint16_t uiConsumoKWH;
    static uint16_t uiCustoKWH = 700;

    //..................................................................................
    //ucEnergia = ulAccEnergia/ulAccTempoBanho; // Media do percentual de energia consumida
    ucEnergia = TotalPowerConsumption/TotalPeriodShowerMinutes;
 8000644:	4c20      	ldr	r4, [pc, #128]	; (80006c8 <Calcula_Nota_Banho+0x94>)
 8000646:	b285      	uxth	r5, r0
 8000648:	8425      	strh	r5, [r4, #32]

    //uiConsumoKWH = uiTempoBanho * ucEnergia * 0.012; // Cálculo em 10*Kwh do consumo do banho atual
    uiConsumoKWH = (TotalPeriodShowerSeconds) * ucEnergia * 0.012;
 800064a:	4378      	muls	r0, r7
 800064c:	f004 fbe0 	bl	8004e10 <__aeabi_ui2d>
 8000650:	4a1e      	ldr	r2, [pc, #120]	; (80006cc <Calcula_Nota_Banho+0x98>)
 8000652:	4b1f      	ldr	r3, [pc, #124]	; (80006d0 <Calcula_Nota_Banho+0x9c>)
 8000654:	f003 fd56 	bl	8004104 <__aeabi_dmul>
 8000658:	f003 fa0e 	bl	8003a78 <__aeabi_d2uiz>

    EstimatedMonthlyCost = uiConsumoKWH * uiCustoKWH; // Aqui tenho o custo do banho em centavos*10
 800065c:	23af      	movs	r3, #175	; 0xaf
    //..................................................................................
    //ucEnergia = ulAccEnergia/ulAccTempoBanho; // Media do percentual de energia consumida
    ucEnergia = TotalPowerConsumption/TotalPeriodShowerMinutes;

    //uiConsumoKWH = uiTempoBanho * ucEnergia * 0.012; // Cálculo em 10*Kwh do consumo do banho atual
    uiConsumoKWH = (TotalPeriodShowerSeconds) * ucEnergia * 0.012;
 800065e:	b280      	uxth	r0, r0

    EstimatedMonthlyCost = uiConsumoKWH * uiCustoKWH; // Aqui tenho o custo do banho em centavos*10
 8000660:	009b      	lsls	r3, r3, #2
    //..................................................................................
    //ucEnergia = ulAccEnergia/ulAccTempoBanho; // Media do percentual de energia consumida
    ucEnergia = TotalPowerConsumption/TotalPeriodShowerMinutes;

    //uiConsumoKWH = uiTempoBanho * ucEnergia * 0.012; // Cálculo em 10*Kwh do consumo do banho atual
    uiConsumoKWH = (TotalPeriodShowerSeconds) * ucEnergia * 0.012;
 8000662:	8460      	strh	r0, [r4, #34]	; 0x22

    EstimatedMonthlyCost = uiConsumoKWH * uiCustoKWH; // Aqui tenho o custo do banho em centavos*10
 8000664:	4358      	muls	r0, r3

    EstimatedMonthlyCost = EstimatedMonthlyCost * 0.0309;  // Multilplicando por '(30dias/1000)*1.03' tenho o custo estimado mensal em R$ para o ultimo banho + 3% de água
 8000666:	b280      	uxth	r0, r0
 8000668:	f004 fb96 	bl	8004d98 <__aeabi_i2d>
 800066c:	4a19      	ldr	r2, [pc, #100]	; (80006d4 <Calcula_Nota_Banho+0xa0>)
 800066e:	4b1a      	ldr	r3, [pc, #104]	; (80006d8 <Calcula_Nota_Banho+0xa4>)
 8000670:	f003 fd48 	bl	8004104 <__aeabi_dmul>
 8000674:	f003 fa00 	bl	8003a78 <__aeabi_d2uiz>
 8000678:	2376      	movs	r3, #118	; 0x76
 800067a:	52f0      	strh	r0, [r6, r3]
    iAcc = iAcc/10;

    iAcc = iAcc + ((int16_t)ucEnergia - 60 );

    //iAcc = iAcc + ( 3*(signed int)(uiTempoBanho - 10) );
    iAcc = iAcc + (3 * (int16_t)((TotalPeriodShowerSeconds) - 10));
 800067c:	0078      	lsls	r0, r7, #1
 800067e:	1838      	adds	r0, r7, r0
 8000680:	385a      	subs	r0, #90	; 0x5a
 8000682:	182d      	adds	r5, r5, r0

    EstimatedMonthlyCost = EstimatedMonthlyCost * 0.0309;  // Multilplicando por '(30dias/1000)*1.03' tenho o custo estimado mensal em R$ para o ultimo banho + 3% de água
    //..................................................................................

    //iAcc = uiLitrosBanho -350;
    iAcc = VolumeWaterConsumed -350;
 8000684:	8af0      	ldrh	r0, [r6, #22]

    iAcc = iAcc/10;
 8000686:	210a      	movs	r1, #10

    EstimatedMonthlyCost = EstimatedMonthlyCost * 0.0309;  // Multilplicando por '(30dias/1000)*1.03' tenho o custo estimado mensal em R$ para o ultimo banho + 3% de água
    //..................................................................................

    //iAcc = uiLitrosBanho -350;
    iAcc = VolumeWaterConsumed -350;
 8000688:	385f      	subs	r0, #95	; 0x5f
 800068a:	38ff      	subs	r0, #255	; 0xff

    iAcc = iAcc/10;
 800068c:	b200      	sxth	r0, r0
 800068e:	f003 f901 	bl	8003894 <__aeabi_idiv>

    iAcc = iAcc + ((int16_t)ucEnergia - 60 );

    //iAcc = iAcc + ( 3*(signed int)(uiTempoBanho - 10) );
    iAcc = iAcc + (3 * (int16_t)((TotalPeriodShowerSeconds) - 10));
 8000692:	1828      	adds	r0, r5, r0

    iAcc = iAcc/2;
 8000694:	b200      	sxth	r0, r0
 8000696:	0fc3      	lsrs	r3, r0, #31
 8000698:	1818      	adds	r0, r3, r0

    iAcc  = 80 - iAcc;
 800069a:	2350      	movs	r3, #80	; 0x50
    iAcc = iAcc + ((int16_t)ucEnergia - 60 );

    //iAcc = iAcc + ( 3*(signed int)(uiTempoBanho - 10) );
    iAcc = iAcc + (3 * (int16_t)((TotalPeriodShowerSeconds) - 10));

    iAcc = iAcc/2;
 800069c:	1040      	asrs	r0, r0, #1

    iAcc  = 80 - iAcc;
 800069e:	1a18      	subs	r0, r3, r0
 80006a0:	b280      	uxth	r0, r0
 80006a2:	b282      	uxth	r2, r0

    if(iAcc > 100)		// nota truncada em 10 para cima
 80006a4:	b213      	sxth	r3, r2
 80006a6:	2b64      	cmp	r3, #100	; 0x64
 80006a8:	dc08      	bgt.n	80006bc <Calcula_Nota_Banho+0x88>
    {
        iAcc = 100;
    }
    else if(iAcc < 0)	// nota truncada em zero para baixo
 80006aa:	2b00      	cmp	r3, #0
 80006ac:	db02      	blt.n	80006b4 <Calcula_Nota_Banho+0x80>
    //iAcc = iAcc + ( 3*(signed int)(uiTempoBanho - 10) );
    iAcc = iAcc + (3 * (int16_t)((TotalPeriodShowerSeconds) - 10));

    iAcc = iAcc/2;

    iAcc  = 80 - iAcc;
 80006ae:	84a2      	strh	r2, [r4, #36]	; 0x24
    else if(iAcc < 0)	// nota truncada em zero para baixo
    {
        iAcc = 0;
    }

    ShowerGrade = iAcc;
 80006b0:	84e0      	strh	r0, [r4, #38]	; 0x26
}
 80006b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    {
        iAcc = 100;
    }
    else if(iAcc < 0)	// nota truncada em zero para baixo
    {
        iAcc = 0;
 80006b4:	2300      	movs	r3, #0
 80006b6:	2000      	movs	r0, #0
 80006b8:	84a3      	strh	r3, [r4, #36]	; 0x24
 80006ba:	e7f9      	b.n	80006b0 <Calcula_Nota_Banho+0x7c>

    iAcc  = 80 - iAcc;

    if(iAcc > 100)		// nota truncada em 10 para cima
    {
        iAcc = 100;
 80006bc:	2364      	movs	r3, #100	; 0x64
 80006be:	2064      	movs	r0, #100	; 0x64
 80006c0:	84a3      	strh	r3, [r4, #36]	; 0x24
 80006c2:	e7f5      	b.n	80006b0 <Calcula_Nota_Banho+0x7c>
 80006c4:	20000054 	.word	0x20000054
 80006c8:	200000d4 	.word	0x200000d4
 80006cc:	bc6a7efa 	.word	0xbc6a7efa
 80006d0:	3f889374 	.word	0x3f889374
 80006d4:	e5c91d15 	.word	0xe5c91d15
 80006d8:	3f9fa43f 	.word	0x3f9fa43f

080006dc <vTriacControllerTask>:

//====================================================================================================
//	Main Shower control
//====================================================================================================
static void vTriacControllerTask(void *pvParameters)
{
 80006dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t Power = 0;
	//static uint8_t StateTimerAdjust  = 0;

	uint8_t UserIndex = 0;

	vTaskDelay(2000); // Wait two seconds to begin to work
 80006de:	20fa      	movs	r0, #250	; 0xfa

//====================================================================================================
//	Main Shower control
//====================================================================================================
static void vTriacControllerTask(void *pvParameters)
{
 80006e0:	4646      	mov	r6, r8
 80006e2:	464f      	mov	r7, r9
	uint8_t Power = 0;
	//static uint8_t StateTimerAdjust  = 0;

	uint8_t UserIndex = 0;

	vTaskDelay(2000); // Wait two seconds to begin to work
 80006e4:	00c0      	lsls	r0, r0, #3

//====================================================================================================
//	Main Shower control
//====================================================================================================
static void vTriacControllerTask(void *pvParameters)
{
 80006e6:	b4c0      	push	{r6, r7}
	uint8_t Power = 0;
	//static uint8_t StateTimerAdjust  = 0;

	uint8_t UserIndex = 0;

	vTaskDelay(2000); // Wait two seconds to begin to work
 80006e8:	f008 ff86 	bl	80095f8 <vTaskDelay>

	LED_Control(LED_DISABLE);
 80006ec:	2002      	movs	r0, #2
 80006ee:	f000 fbc3 	bl	8000e78 <LED_Control>
				Power = User_GetPowerSetPoint(UserIndex) * 11;
			}

			/* Somatório do volme de água consumido */
			VolumeWaterConsumed += Flowmeter_GetFlow()/60; // TODO: verificar contagem do volume
			print6 = VolumeWaterConsumed/100;
 80006f2:	236c      	movs	r3, #108	; 0x6c
//	Main Shower control
//====================================================================================================
static void vTriacControllerTask(void *pvParameters)
{
	enum {CONTROLLER_ON, CONTROLLER_OFF, CONTROLLER_WAIT} State;
	State = CONTROLLER_OFF;
 80006f4:	2601      	movs	r6, #1
				Power = User_GetPowerSetPoint(UserIndex) * 11;
			}

			/* Somatório do volme de água consumido */
			VolumeWaterConsumed += Flowmeter_GetFlow()/60; // TODO: verificar contagem do volume
			print6 = VolumeWaterConsumed/100;
 80006f6:	4698      	mov	r8, r3

			/* Somatório da energia consumida */
			TotalPowerConsumption += Power;
 80006f8:	2778      	movs	r7, #120	; 0x78
 80006fa:	4d71      	ldr	r5, [pc, #452]	; (80008c0 <vTriacControllerTask+0x1e4>)

	LED_Control(LED_DISABLE);

	for(;;)
	{
		TRIAC_LostEdges();
 80006fc:	f001 faa0 	bl	8001c40 <TRIAC_LostEdges>

		//---------------------------------------------
		// State Machine Control (Controlled by Water Flow)
		switch(State)
 8000700:	2e00      	cmp	r6, #0
 8000702:	d02d      	beq.n	8000760 <vTriacControllerTask+0x84>
 8000704:	2e01      	cmp	r6, #1
 8000706:	d16d      	bne.n	80007e4 <vTriacControllerTask+0x108>
				break;
			}
			//----------------------
			case CONTROLLER_OFF:
			{
				ShowerController_SetShowerState(SHOWER_TIME_IDLE); // There isn't shower
 8000708:	2001      	movs	r0, #1
 800070a:	f003 f827 	bl	800375c <ShowerController_SetShowerState>

				if(Flowmeter_GetFlow() > FLOW_ON)	// If there is flow...
 800070e:	f001 f96b 	bl	80019e8 <Flowmeter_GetFlow>
 8000712:	28b4      	cmp	r0, #180	; 0xb4
 8000714:	d900      	bls.n	8000718 <vTriacControllerTask+0x3c>
 8000716:	e0be      	b.n	8000896 <vTriacControllerTask+0x1ba>
		}
#endif //_SHOWER_ADJUST_*/

		//---------------------------------------------
		// Shows flow variation
		if(Flowmeter_GetFlowDerivative() > 0)
 8000718:	f001 f97a 	bl	8001a10 <Flowmeter_GetFlowDerivative>
 800071c:	2800      	cmp	r0, #0
 800071e:	dd02      	ble.n	8000726 <vTriacControllerTask+0x4a>
		{
			Screen_Show(SCREEN_FLOW);
 8000720:	2007      	movs	r0, #7
 8000722:	f002 fdbd 	bl	80032a0 <Screen_Show>
		}

		UserIndex = User_GetIndex();
 8000726:	f000 f95b 	bl	80009e0 <User_GetIndex>
			TotalPowerConsumption += Power;
			print7 = TotalPowerConsumption;
		}
		else
		{
			Screen_SetMainSubScreen(SCREEN_MAIN_IDLE);
 800072a:	2030      	movs	r0, #48	; 0x30
 800072c:	f002 fdb2 	bl	8003294 <Screen_SetMainSubScreen>
		//---------------------------------------------
		// TODO: Protecao para sobre tensao

		//---------------------------------------------
		// Max Temperature Protection
		if((NTC_GetWaterTemperature(TEMPERATURE_OUTLET) > MAX_TEMPERATURE) || (NTC_GetWaterTemperature(TEMPERATURE_RESISTANCE) > MAX_TEMPERATURE))
 8000730:	24f4      	movs	r4, #244	; 0xf4
 8000732:	2002      	movs	r0, #2
 8000734:	f002 fa08 	bl	8002b48 <NTC_GetWaterTemperature>
 8000738:	34ff      	adds	r4, #255	; 0xff
 800073a:	42a0      	cmp	r0, r4
 800073c:	dd6d      	ble.n	800081a <vTriacControllerTask+0x13e>
 800073e:	2300      	movs	r3, #0
		{
			Power = 0;
 8000740:	2400      	movs	r4, #0
 8000742:	4699      	mov	r9, r3
		}

		//---------------------------------------------
		// Set Triac power
		TRIAC_SetPower(Power);
 8000744:	1c20      	adds	r0, r4, #0
 8000746:	f001 fa6b 	bl	8001c20 <TRIAC_SetPower>
		PowerStored = Power;
 800074a:	464b      	mov	r3, r9
 800074c:	832b      	strh	r3, [r5, #24]

		//---------------------------------------------
		// Time delay for hysteresis
		if(State ==  CONTROLLER_WAIT)
 800074e:	2e02      	cmp	r6, #2
 8000750:	d072      	beq.n	8000838 <vTriacControllerTask+0x15c>
		{
			vTaskDelay(1000); // TODO: este delay vai depender da temperatura na resistencia.
		}
		else
		{
			vTaskDelay(100);
 8000752:	2064      	movs	r0, #100	; 0x64
 8000754:	f008 ff50 	bl	80095f8 <vTaskDelay>

	LED_Control(LED_DISABLE);

	for(;;)
	{
		TRIAC_LostEdges();
 8000758:	f001 fa72 	bl	8001c40 <TRIAC_LostEdges>

		//---------------------------------------------
		// State Machine Control (Controlled by Water Flow)
		switch(State)
 800075c:	2e00      	cmp	r6, #0
 800075e:	d1d1      	bne.n	8000704 <vTriacControllerTask+0x28>
		{
			//----------------------
			case CONTROLLER_ON:
			{
				ClearShowerTime = false;			// Keep count from the "00:00:00"
 8000760:	702e      	strb	r6, [r5, #0]

				if(Flowmeter_GetFlow() < FLOW_OFF)	// If there isn't flow...
 8000762:	f001 f941 	bl	80019e8 <Flowmeter_GetFlow>
 8000766:	2895      	cmp	r0, #149	; 0x95
 8000768:	d800      	bhi.n	800076c <vTriacControllerTask+0x90>
 800076a:	e087      	b.n	800087c <vTriacControllerTask+0x1a0>
		}
#endif //_SHOWER_ADJUST_*/

		//---------------------------------------------
		// Shows flow variation
		if(Flowmeter_GetFlowDerivative() > 0)
 800076c:	f001 f950 	bl	8001a10 <Flowmeter_GetFlowDerivative>
 8000770:	2800      	cmp	r0, #0
 8000772:	dd02      	ble.n	800077a <vTriacControllerTask+0x9e>
		{
			Screen_Show(SCREEN_FLOW);
 8000774:	2007      	movs	r0, #7
 8000776:	f002 fd93 	bl	80032a0 <Screen_Show>
		}

		UserIndex = User_GetIndex();
 800077a:	f000 f931 	bl	80009e0 <User_GetIndex>
 800077e:	1c04      	adds	r4, r0, #0

		//---------------------------------------------
		// Apply power according to user configuration SHOWER_MODE_TEMPERATURE or SHOWER_MODE_POWER
		if(State == CONTROLLER_ON)
		{
			if(User_GetShowerMode(UserIndex) == SHOWER_MODE_TEMPERATURE)
 8000780:	1c20      	adds	r0, r4, #0
 8000782:	f000 f8a5 	bl	80008d0 <User_GetShowerMode>
 8000786:	2801      	cmp	r0, #1
 8000788:	d062      	beq.n	8000850 <vTriacControllerTask+0x174>
				Screen_SetMainSubScreen(SCREEN_MAIN_TEMPERATURE);
				Power = Controller_Task(User_GetTemperatureSetPoint(UserIndex));
			}
			else // SHOWER_MODE_POWER
			{
				Screen_SetMainSubScreen(SCREEN_MAIN_POWER);
 800078a:	2032      	movs	r0, #50	; 0x32
 800078c:	f002 fd82 	bl	8003294 <Screen_SetMainSubScreen>
				Power = User_GetPowerSetPoint(UserIndex) * 11;
 8000790:	1c20      	adds	r0, r4, #0
 8000792:	f000 f8e9 	bl	8000968 <User_GetPowerSetPoint>
 8000796:	0084      	lsls	r4, r0, #2
 8000798:	1904      	adds	r4, r0, r4
 800079a:	0064      	lsls	r4, r4, #1
 800079c:	1904      	adds	r4, r0, r4
 800079e:	b2e4      	uxtb	r4, r4
			}

			/* Somatório do volme de água consumido */
			VolumeWaterConsumed += Flowmeter_GetFlow()/60; // TODO: verificar contagem do volume
 80007a0:	f001 f922 	bl	80019e8 <Flowmeter_GetFlow>
 80007a4:	213c      	movs	r1, #60	; 0x3c
 80007a6:	f002 ffe5 	bl	8003774 <__aeabi_uidiv>
 80007aa:	8aeb      	ldrh	r3, [r5, #22]
			print6 = VolumeWaterConsumed/100;
 80007ac:	2164      	movs	r1, #100	; 0x64
				Screen_SetMainSubScreen(SCREEN_MAIN_POWER);
				Power = User_GetPowerSetPoint(UserIndex) * 11;
			}

			/* Somatório do volme de água consumido */
			VolumeWaterConsumed += Flowmeter_GetFlow()/60; // TODO: verificar contagem do volume
 80007ae:	18c0      	adds	r0, r0, r3
 80007b0:	b280      	uxth	r0, r0
 80007b2:	82e8      	strh	r0, [r5, #22]
			print6 = VolumeWaterConsumed/100;
 80007b4:	f002 ffde 	bl	8003774 <__aeabi_uidiv>
 80007b8:	4643      	mov	r3, r8

			/* Somatório da energia consumida */
			TotalPowerConsumption += Power;
			print7 = TotalPowerConsumption;
 80007ba:	226e      	movs	r2, #110	; 0x6e
				Power = User_GetPowerSetPoint(UserIndex) * 11;
			}

			/* Somatório do volme de água consumido */
			VolumeWaterConsumed += Flowmeter_GetFlow()/60; // TODO: verificar contagem do volume
			print6 = VolumeWaterConsumed/100;
 80007bc:	52e8      	strh	r0, [r5, r3]

			/* Somatório da energia consumida */
			TotalPowerConsumption += Power;
 80007be:	5beb      	ldrh	r3, [r5, r7]
		//---------------------------------------------
		// TODO: Protecao para sobre tensao

		//---------------------------------------------
		// Max Temperature Protection
		if((NTC_GetWaterTemperature(TEMPERATURE_OUTLET) > MAX_TEMPERATURE) || (NTC_GetWaterTemperature(TEMPERATURE_RESISTANCE) > MAX_TEMPERATURE))
 80007c0:	2002      	movs	r0, #2
			/* Somatório do volme de água consumido */
			VolumeWaterConsumed += Flowmeter_GetFlow()/60; // TODO: verificar contagem do volume
			print6 = VolumeWaterConsumed/100;

			/* Somatório da energia consumida */
			TotalPowerConsumption += Power;
 80007c2:	18e3      	adds	r3, r4, r3
 80007c4:	b29b      	uxth	r3, r3
		//---------------------------------------------
		// TODO: Protecao para sobre tensao

		//---------------------------------------------
		// Max Temperature Protection
		if((NTC_GetWaterTemperature(TEMPERATURE_OUTLET) > MAX_TEMPERATURE) || (NTC_GetWaterTemperature(TEMPERATURE_RESISTANCE) > MAX_TEMPERATURE))
 80007c6:	26f4      	movs	r6, #244	; 0xf4
			/* Somatório do volme de água consumido */
			VolumeWaterConsumed += Flowmeter_GetFlow()/60; // TODO: verificar contagem do volume
			print6 = VolumeWaterConsumed/100;

			/* Somatório da energia consumida */
			TotalPowerConsumption += Power;
 80007c8:	53eb      	strh	r3, [r5, r7]
			print7 = TotalPowerConsumption;
 80007ca:	52ab      	strh	r3, [r5, r2]
		//---------------------------------------------
		// TODO: Protecao para sobre tensao

		//---------------------------------------------
		// Max Temperature Protection
		if((NTC_GetWaterTemperature(TEMPERATURE_OUTLET) > MAX_TEMPERATURE) || (NTC_GetWaterTemperature(TEMPERATURE_RESISTANCE) > MAX_TEMPERATURE))
 80007cc:	f002 f9bc 	bl	8002b48 <NTC_GetWaterTemperature>
 80007d0:	36ff      	adds	r6, #255	; 0xff
 80007d2:	42b0      	cmp	r0, r6
 80007d4:	dd35      	ble.n	8000842 <vTriacControllerTask+0x166>
			Power = 0;
		}

		//---------------------------------------------
		// Set Triac power
		TRIAC_SetPower(Power);
 80007d6:	2000      	movs	r0, #0
 80007d8:	f001 fa22 	bl	8001c20 <TRIAC_SetPower>
		PowerStored = Power;
 80007dc:	2300      	movs	r3, #0
 80007de:	2600      	movs	r6, #0
 80007e0:	832b      	strh	r3, [r5, #24]
 80007e2:	e7b6      	b.n	8000752 <vTriacControllerTask+0x76>
		}
#endif //_SHOWER_ADJUST_*/

		//---------------------------------------------
		// Shows flow variation
		if(Flowmeter_GetFlowDerivative() > 0)
 80007e4:	f001 f914 	bl	8001a10 <Flowmeter_GetFlowDerivative>
			}
			//----------------------
			case CONTROLLER_WAIT:
			{
				// TODO: implemetar logica para aguardar um tempo ate religar o controle. Isso é devido a energia já acumulada na resistencia
				State = CONTROLLER_OFF;
 80007e8:	2601      	movs	r6, #1
		}
#endif //_SHOWER_ADJUST_*/

		//---------------------------------------------
		// Shows flow variation
		if(Flowmeter_GetFlowDerivative() > 0)
 80007ea:	2800      	cmp	r0, #0
 80007ec:	dd9b      	ble.n	8000726 <vTriacControllerTask+0x4a>
		{
			Screen_Show(SCREEN_FLOW);
 80007ee:	2007      	movs	r0, #7
 80007f0:	f002 fd56 	bl	80032a0 <Screen_Show>
		}

		UserIndex = User_GetIndex();
 80007f4:	f000 f8f4 	bl	80009e0 <User_GetIndex>
			TotalPowerConsumption += Power;
			print7 = TotalPowerConsumption;
		}
		else
		{
			Screen_SetMainSubScreen(SCREEN_MAIN_IDLE);
 80007f8:	2030      	movs	r0, #48	; 0x30
 80007fa:	f002 fd4b 	bl	8003294 <Screen_SetMainSubScreen>
		//---------------------------------------------
		// TODO: Protecao para sobre tensao

		//---------------------------------------------
		// Max Temperature Protection
		if((NTC_GetWaterTemperature(TEMPERATURE_OUTLET) > MAX_TEMPERATURE) || (NTC_GetWaterTemperature(TEMPERATURE_RESISTANCE) > MAX_TEMPERATURE))
 80007fe:	24f4      	movs	r4, #244	; 0xf4
 8000800:	2002      	movs	r0, #2
 8000802:	f002 f9a1 	bl	8002b48 <NTC_GetWaterTemperature>
 8000806:	34ff      	adds	r4, #255	; 0xff
 8000808:	42a0      	cmp	r0, r4
 800080a:	dd2b      	ble.n	8000864 <vTriacControllerTask+0x188>
			Power = 0;
		}

		//---------------------------------------------
		// Set Triac power
		TRIAC_SetPower(Power);
 800080c:	2000      	movs	r0, #0
 800080e:	f001 fa07 	bl	8001c20 <TRIAC_SetPower>
		PowerStored = Power;
 8000812:	2300      	movs	r3, #0
			}
			//----------------------
			case CONTROLLER_WAIT:
			{
				// TODO: implemetar logica para aguardar um tempo ate religar o controle. Isso é devido a energia já acumulada na resistencia
				State = CONTROLLER_OFF;
 8000814:	2601      	movs	r6, #1
		}

		//---------------------------------------------
		// Set Triac power
		TRIAC_SetPower(Power);
		PowerStored = Power;
 8000816:	832b      	strh	r3, [r5, #24]
 8000818:	e79b      	b.n	8000752 <vTriacControllerTask+0x76>
		//---------------------------------------------
		// TODO: Protecao para sobre tensao

		//---------------------------------------------
		// Max Temperature Protection
		if((NTC_GetWaterTemperature(TEMPERATURE_OUTLET) > MAX_TEMPERATURE) || (NTC_GetWaterTemperature(TEMPERATURE_RESISTANCE) > MAX_TEMPERATURE))
 800081a:	2003      	movs	r0, #3
 800081c:	f002 f994 	bl	8002b48 <NTC_GetWaterTemperature>
 8000820:	42a0      	cmp	r0, r4
 8000822:	dc8c      	bgt.n	800073e <vTriacControllerTask+0x62>
 8000824:	2400      	movs	r4, #0
 8000826:	b2a3      	uxth	r3, r4
 8000828:	4699      	mov	r9, r3
			Power = 0;
		}

		//---------------------------------------------
		// Set Triac power
		TRIAC_SetPower(Power);
 800082a:	1c20      	adds	r0, r4, #0
 800082c:	f001 f9f8 	bl	8001c20 <TRIAC_SetPower>
		PowerStored = Power;
 8000830:	464b      	mov	r3, r9
 8000832:	832b      	strh	r3, [r5, #24]

		//---------------------------------------------
		// Time delay for hysteresis
		if(State ==  CONTROLLER_WAIT)
 8000834:	2e02      	cmp	r6, #2
 8000836:	d18c      	bne.n	8000752 <vTriacControllerTask+0x76>
		{
			vTaskDelay(1000); // TODO: este delay vai depender da temperatura na resistencia.
 8000838:	20fa      	movs	r0, #250	; 0xfa
 800083a:	0080      	lsls	r0, r0, #2
 800083c:	f008 fedc 	bl	80095f8 <vTaskDelay>
 8000840:	e75c      	b.n	80006fc <vTriacControllerTask+0x20>
		//---------------------------------------------
		// TODO: Protecao para sobre tensao

		//---------------------------------------------
		// Max Temperature Protection
		if((NTC_GetWaterTemperature(TEMPERATURE_OUTLET) > MAX_TEMPERATURE) || (NTC_GetWaterTemperature(TEMPERATURE_RESISTANCE) > MAX_TEMPERATURE))
 8000842:	2003      	movs	r0, #3
 8000844:	f002 f980 	bl	8002b48 <NTC_GetWaterTemperature>
 8000848:	42b0      	cmp	r0, r6
 800084a:	dcc4      	bgt.n	80007d6 <vTriacControllerTask+0xfa>
 800084c:	2600      	movs	r6, #0
 800084e:	e7ea      	b.n	8000826 <vTriacControllerTask+0x14a>
		// Apply power according to user configuration SHOWER_MODE_TEMPERATURE or SHOWER_MODE_POWER
		if(State == CONTROLLER_ON)
		{
			if(User_GetShowerMode(UserIndex) == SHOWER_MODE_TEMPERATURE)
			{
				Screen_SetMainSubScreen(SCREEN_MAIN_TEMPERATURE);
 8000850:	3030      	adds	r0, #48	; 0x30
 8000852:	f002 fd1f 	bl	8003294 <Screen_SetMainSubScreen>
				Power = Controller_Task(User_GetTemperatureSetPoint(UserIndex));
 8000856:	1c20      	adds	r0, r4, #0
 8000858:	f000 f872 	bl	8000940 <User_GetTemperatureSetPoint>
 800085c:	f002 f824 	bl	80028a8 <Controller_Task>
 8000860:	b2c4      	uxtb	r4, r0
 8000862:	e79d      	b.n	80007a0 <vTriacControllerTask+0xc4>
		//---------------------------------------------
		// TODO: Protecao para sobre tensao

		//---------------------------------------------
		// Max Temperature Protection
		if((NTC_GetWaterTemperature(TEMPERATURE_OUTLET) > MAX_TEMPERATURE) || (NTC_GetWaterTemperature(TEMPERATURE_RESISTANCE) > MAX_TEMPERATURE))
 8000864:	2003      	movs	r0, #3
			}
			//----------------------
			case CONTROLLER_WAIT:
			{
				// TODO: implemetar logica para aguardar um tempo ate religar o controle. Isso é devido a energia já acumulada na resistencia
				State = CONTROLLER_OFF;
 8000866:	2601      	movs	r6, #1
		//---------------------------------------------
		// TODO: Protecao para sobre tensao

		//---------------------------------------------
		// Max Temperature Protection
		if((NTC_GetWaterTemperature(TEMPERATURE_OUTLET) > MAX_TEMPERATURE) || (NTC_GetWaterTemperature(TEMPERATURE_RESISTANCE) > MAX_TEMPERATURE))
 8000868:	f002 f96e 	bl	8002b48 <NTC_GetWaterTemperature>
 800086c:	42a0      	cmp	r0, r4
 800086e:	ddd9      	ble.n	8000824 <vTriacControllerTask+0x148>
			Power = 0;
		}

		//---------------------------------------------
		// Set Triac power
		TRIAC_SetPower(Power);
 8000870:	2000      	movs	r0, #0
 8000872:	f001 f9d5 	bl	8001c20 <TRIAC_SetPower>
		PowerStored = Power;
 8000876:	2300      	movs	r3, #0
 8000878:	832b      	strh	r3, [r5, #24]
 800087a:	e76a      	b.n	8000752 <vTriacControllerTask+0x76>
			{
				ClearShowerTime = false;			// Keep count from the "00:00:00"

				if(Flowmeter_GetFlow() < FLOW_OFF)	// If there isn't flow...
				{
					LED_Control(LED_DISABLE);		// Turn LEDs off
 800087c:	2002      	movs	r0, #2
 800087e:	f000 fafb 	bl	8000e78 <LED_Control>
					State = CONTROLLER_WAIT;		// Go to CONTROLLER_WAIT state

					ShowerController_SetShowerState(SHOWER_TIME_FINISHED); // Shower finished
 8000882:	2003      	movs	r0, #3
 8000884:	f002 ff6a 	bl	800375c <ShowerController_SetShowerState>
					Screen_Show(SCREEN_END_SHOWER);		 // Show in displays the End of Shower message
 8000888:	2029      	movs	r0, #41	; 0x29
 800088a:	f002 fd09 	bl	80032a0 <Screen_Show>
				ClearShowerTime = false;			// Keep count from the "00:00:00"

				if(Flowmeter_GetFlow() < FLOW_OFF)	// If there isn't flow...
				{
					LED_Control(LED_DISABLE);		// Turn LEDs off
					State = CONTROLLER_WAIT;		// Go to CONTROLLER_WAIT state
 800088e:	2602      	movs	r6, #2

					ShowerController_SetShowerState(SHOWER_TIME_FINISHED); // Shower finished
					Screen_Show(SCREEN_END_SHOWER);		 // Show in displays the End of Shower message

					Calcula_Nota_Banho();
 8000890:	f7ff fed0 	bl	8000634 <Calcula_Nota_Banho>
 8000894:	e740      	b.n	8000718 <vTriacControllerTask+0x3c>
			{
				ShowerController_SetShowerState(SHOWER_TIME_IDLE); // There isn't shower

				if(Flowmeter_GetFlow() > FLOW_ON)	// If there is flow...
				{
					ShowerController_SetShowerState(SHOWER_TIME_STARTED); // Shower time started
 8000896:	2002      	movs	r0, #2
 8000898:	f002 ff60 	bl	800375c <ShowerController_SetShowerState>
					ClearShowerTime	  = true;		// Clear shower time count
					VolumeWaterConsumed	  = 0;		// Clear volume of water consumed count
 800089c:	2300      	movs	r3, #0
					TotalPowerConsumption = 0;		// Clear total power consumption count

					Buzzer_Beep(50, 2);				// Give two BIPs
 800089e:	2102      	movs	r1, #2
 80008a0:	2032      	movs	r0, #50	; 0x32

				if(Flowmeter_GetFlow() > FLOW_ON)	// If there is flow...
				{
					ShowerController_SetShowerState(SHOWER_TIME_STARTED); // Shower time started
					ClearShowerTime	  = true;		// Clear shower time count
					VolumeWaterConsumed	  = 0;		// Clear volume of water consumed count
 80008a2:	82eb      	strh	r3, [r5, #22]
					TotalPowerConsumption = 0;		// Clear total power consumption count
 80008a4:	53eb      	strh	r3, [r5, r7]
				ShowerController_SetShowerState(SHOWER_TIME_IDLE); // There isn't shower

				if(Flowmeter_GetFlow() > FLOW_ON)	// If there is flow...
				{
					ShowerController_SetShowerState(SHOWER_TIME_STARTED); // Shower time started
					ClearShowerTime	  = true;		// Clear shower time count
 80008a6:	702e      	strb	r6, [r5, #0]
					VolumeWaterConsumed	  = 0;		// Clear volume of water consumed count
					TotalPowerConsumption = 0;		// Clear total power consumption count

					Buzzer_Beep(50, 2);				// Give two BIPs
 80008a8:	f001 fc06 	bl	80020b8 <Buzzer_Beep>
					Controller_ResetPID(); 			// Reset PID
 80008ac:	f001 feb0 	bl	8002610 <Controller_ResetPID>
					LED_Control(LED_ENABLED); 		// Turn LEDs on
 80008b0:	2001      	movs	r0, #1
 80008b2:	f000 fae1 	bl	8000e78 <LED_Control>
					Screen_Show(SCREEN_FLOW);		// Show flow in displays
 80008b6:	2007      	movs	r0, #7
 80008b8:	f002 fcf2 	bl	80032a0 <Screen_Show>
 80008bc:	e756      	b.n	800076c <vTriacControllerTask+0x90>
 80008be:	46c0      	nop			; (mov r8, r8)
 80008c0:	20000054 	.word	0x20000054

080008c4 <vApplicationIdleHook>:
	specified, or call vTaskDelay()).  If the application makes use of the
	vTaskDelete() API function (as this demo application does) then it is also
	important that vApplicationIdleHook() is permitted to return to its calling
	function, because it is the responsibility of the idle task to clean up
	memory allocated by the kernel to any task that has since been deleted. */
}
 80008c4:	4770      	bx	lr
 80008c6:	46c0      	nop			; (mov r8, r8)

080008c8 <vApplicationStackOverflowHook>:

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2. This hook
	function is called if a stack overflow is detected. */

	taskDISABLE_INTERRUPTS();
 80008c8:	b672      	cpsid	i

	// TODO - Desabilitar as interrupccoes de hardware ou pelo menos a do triac

	for(;;);
 80008ca:	e7fe      	b.n	80008ca <vApplicationStackOverflowHook+0x2>

080008cc <vApplicationTickHook>:
	/* This function will be called by each tick interrupt if
	configUSE_TICK_HOOK is set to 1 in FreeRTOSConfig.h.  User code can be
	added here, but the tick hook is called from an interrupt context, so
	code must not attempt to block, and only the interrupt safe FreeRTOS API
	functions can be used (those that end in FromISR()). */
}
 80008cc:	4770      	bx	lr
 80008ce:	46c0      	nop			; (mov r8, r8)

080008d0 <User_GetShowerMode>:

//------------------------------------
// Get and Set user Shower Mode
uint8_t User_GetShowerMode(uint8_t Index)
{
	return Shower_User[Index].ShowerMode;
 80008d0:	0083      	lsls	r3, r0, #2
 80008d2:	1818      	adds	r0, r3, r0
 80008d4:	4b01      	ldr	r3, [pc, #4]	; (80008dc <User_GetShowerMode+0xc>)
 80008d6:	0040      	lsls	r0, r0, #1
 80008d8:	5c18      	ldrb	r0, [r3, r0]
}
 80008da:	4770      	bx	lr
 80008dc:	200000fc 	.word	0x200000fc

080008e0 <User_SetShowerMode>:
void User_SetShowerMode(uint8_t ShowerMode, uint8_t Index)
{
	Shower_User[Index].ShowerMode = ShowerMode;
 80008e0:	008b      	lsls	r3, r1, #2
 80008e2:	1859      	adds	r1, r3, r1
 80008e4:	4b01      	ldr	r3, [pc, #4]	; (80008ec <User_SetShowerMode+0xc>)
 80008e6:	0049      	lsls	r1, r1, #1
 80008e8:	54c8      	strb	r0, [r1, r3]
}
 80008ea:	4770      	bx	lr
 80008ec:	200000fc 	.word	0x200000fc

080008f0 <User_GetLedMode>:

//------------------------------------
// Get and Set user LED Mode
uint8_t User_GetLedMode(uint8_t Index)
{
	return Shower_User[Index].LedMode;
 80008f0:	0083      	lsls	r3, r0, #2
 80008f2:	1818      	adds	r0, r3, r0
 80008f4:	4b02      	ldr	r3, [pc, #8]	; (8000900 <User_GetLedMode+0x10>)
 80008f6:	0040      	lsls	r0, r0, #1
 80008f8:	1818      	adds	r0, r3, r0
 80008fa:	7840      	ldrb	r0, [r0, #1]
}
 80008fc:	4770      	bx	lr
 80008fe:	46c0      	nop			; (mov r8, r8)
 8000900:	200000fc 	.word	0x200000fc

08000904 <User_SetLedMode>:
void User_SetLedMode(uint8_t LedMode, uint8_t Index)
{
	Shower_User[Index].LedMode = LedMode;
 8000904:	008b      	lsls	r3, r1, #2
 8000906:	1859      	adds	r1, r3, r1
 8000908:	4b02      	ldr	r3, [pc, #8]	; (8000914 <User_SetLedMode+0x10>)
 800090a:	0049      	lsls	r1, r1, #1
 800090c:	1859      	adds	r1, r3, r1
 800090e:	7048      	strb	r0, [r1, #1]
}
 8000910:	4770      	bx	lr
 8000912:	46c0      	nop			; (mov r8, r8)
 8000914:	200000fc 	.word	0x200000fc

08000918 <User_GetLedColor>:

//------------------------------------
// Get and Set user Led Color
uint8_t User_GetLedColor(uint8_t Index)
{
	return Shower_User[Index].LedColor;
 8000918:	0083      	lsls	r3, r0, #2
 800091a:	1818      	adds	r0, r3, r0
 800091c:	4b02      	ldr	r3, [pc, #8]	; (8000928 <User_GetLedColor+0x10>)
 800091e:	0040      	lsls	r0, r0, #1
 8000920:	1818      	adds	r0, r3, r0
 8000922:	7880      	ldrb	r0, [r0, #2]
}
 8000924:	4770      	bx	lr
 8000926:	46c0      	nop			; (mov r8, r8)
 8000928:	200000fc 	.word	0x200000fc

0800092c <User_SetLedColor>:
void User_SetLedColor(uint8_t LedColor, uint8_t Index)
{
	Shower_User[Index].LedColor = LedColor;
 800092c:	008b      	lsls	r3, r1, #2
 800092e:	1859      	adds	r1, r3, r1
 8000930:	4b02      	ldr	r3, [pc, #8]	; (800093c <User_SetLedColor+0x10>)
 8000932:	0049      	lsls	r1, r1, #1
 8000934:	1859      	adds	r1, r3, r1
 8000936:	7088      	strb	r0, [r1, #2]
}
 8000938:	4770      	bx	lr
 800093a:	46c0      	nop			; (mov r8, r8)
 800093c:	200000fc 	.word	0x200000fc

08000940 <User_GetTemperatureSetPoint>:

//------------------------------------
// Get and Set user Temperature Set Point
uint16_t User_GetTemperatureSetPoint(uint8_t Index)
{
	return Shower_User[Index].TemperatureSetPoint;
 8000940:	0083      	lsls	r3, r0, #2
 8000942:	1818      	adds	r0, r3, r0
 8000944:	4b02      	ldr	r3, [pc, #8]	; (8000950 <User_GetTemperatureSetPoint+0x10>)
 8000946:	0040      	lsls	r0, r0, #1
 8000948:	1818      	adds	r0, r3, r0
 800094a:	8880      	ldrh	r0, [r0, #4]
}
 800094c:	4770      	bx	lr
 800094e:	46c0      	nop			; (mov r8, r8)
 8000950:	200000fc 	.word	0x200000fc

08000954 <User_SetTemperatureSetPoint>:
void User_SetTemperatureSetPoint(uint16_t TemperatureSetPoint, uint8_t Index)
{
	Shower_User[Index].TemperatureSetPoint = TemperatureSetPoint;
 8000954:	008b      	lsls	r3, r1, #2
 8000956:	1859      	adds	r1, r3, r1
 8000958:	4b02      	ldr	r3, [pc, #8]	; (8000964 <User_SetTemperatureSetPoint+0x10>)
 800095a:	0049      	lsls	r1, r1, #1
 800095c:	1859      	adds	r1, r3, r1
 800095e:	8088      	strh	r0, [r1, #4]
}
 8000960:	4770      	bx	lr
 8000962:	46c0      	nop			; (mov r8, r8)
 8000964:	200000fc 	.word	0x200000fc

08000968 <User_GetPowerSetPoint>:

//------------------------------------
// Get and Set user Power Set Point
uint8_t User_GetPowerSetPoint(uint8_t Index)
{
	return Shower_User[Index].PowerSetPoint;
 8000968:	0083      	lsls	r3, r0, #2
 800096a:	1818      	adds	r0, r3, r0
 800096c:	4b02      	ldr	r3, [pc, #8]	; (8000978 <User_GetPowerSetPoint+0x10>)
 800096e:	0040      	lsls	r0, r0, #1
 8000970:	1818      	adds	r0, r3, r0
 8000972:	7980      	ldrb	r0, [r0, #6]
}
 8000974:	4770      	bx	lr
 8000976:	46c0      	nop			; (mov r8, r8)
 8000978:	200000fc 	.word	0x200000fc

0800097c <User_SetPowerSetPoint>:
void User_SetPowerSetPoint(uint8_t PowerSetPoint, uint8_t Index)
{
	Shower_User[Index].PowerSetPoint = PowerSetPoint;
 800097c:	008b      	lsls	r3, r1, #2
 800097e:	1859      	adds	r1, r3, r1
 8000980:	4b02      	ldr	r3, [pc, #8]	; (800098c <User_SetPowerSetPoint+0x10>)
 8000982:	0049      	lsls	r1, r1, #1
 8000984:	1859      	adds	r1, r3, r1
 8000986:	7188      	strb	r0, [r1, #6]
}
 8000988:	4770      	bx	lr
 800098a:	46c0      	nop			; (mov r8, r8)
 800098c:	200000fc 	.word	0x200000fc

08000990 <User_GetMaxTemperatureLimit>:

//------------------------------------
// Get and Set user Temperature Limit
uint8_t User_GetMaxTemperatureLimit(uint8_t Index)
{
	return Shower_User[Index].MaxTemperatureLimit;
 8000990:	0083      	lsls	r3, r0, #2
 8000992:	1818      	adds	r0, r3, r0
 8000994:	4b02      	ldr	r3, [pc, #8]	; (80009a0 <User_GetMaxTemperatureLimit+0x10>)
 8000996:	0040      	lsls	r0, r0, #1
 8000998:	1818      	adds	r0, r3, r0
 800099a:	79c0      	ldrb	r0, [r0, #7]
}
 800099c:	4770      	bx	lr
 800099e:	46c0      	nop			; (mov r8, r8)
 80009a0:	200000fc 	.word	0x200000fc

080009a4 <User_SetMaxTemperatureLimit>:
void User_SetMaxTemperatureLimit(uint8_t MaxTemperatureLimit, uint8_t Index)
{
	Shower_User[Index].MaxTemperatureLimit = MaxTemperatureLimit;
 80009a4:	008b      	lsls	r3, r1, #2
 80009a6:	1859      	adds	r1, r3, r1
 80009a8:	4b02      	ldr	r3, [pc, #8]	; (80009b4 <User_SetMaxTemperatureLimit+0x10>)
 80009aa:	0049      	lsls	r1, r1, #1
 80009ac:	1859      	adds	r1, r3, r1
 80009ae:	71c8      	strb	r0, [r1, #7]
}
 80009b0:	4770      	bx	lr
 80009b2:	46c0      	nop			; (mov r8, r8)
 80009b4:	200000fc 	.word	0x200000fc

080009b8 <User_GetBuzzer>:

//------------------------------------
// Get and Set user Buzzer
uint8_t User_GetBuzzer(uint8_t Index)
{
	return Shower_User[Index].Buzzer;
 80009b8:	0083      	lsls	r3, r0, #2
 80009ba:	1818      	adds	r0, r3, r0
 80009bc:	4b02      	ldr	r3, [pc, #8]	; (80009c8 <User_GetBuzzer+0x10>)
 80009be:	0040      	lsls	r0, r0, #1
 80009c0:	1818      	adds	r0, r3, r0
 80009c2:	7a00      	ldrb	r0, [r0, #8]
}
 80009c4:	4770      	bx	lr
 80009c6:	46c0      	nop			; (mov r8, r8)
 80009c8:	200000fc 	.word	0x200000fc

080009cc <User_SetBuzzer>:
void User_SetBuzzer(uint8_t Buzzer, uint8_t Index)
{
	Shower_User[Index].Buzzer = Buzzer;
 80009cc:	008b      	lsls	r3, r1, #2
 80009ce:	1859      	adds	r1, r3, r1
 80009d0:	4b02      	ldr	r3, [pc, #8]	; (80009dc <User_SetBuzzer+0x10>)
 80009d2:	0049      	lsls	r1, r1, #1
 80009d4:	1859      	adds	r1, r3, r1
 80009d6:	7208      	strb	r0, [r1, #8]
}
 80009d8:	4770      	bx	lr
 80009da:	46c0      	nop			; (mov r8, r8)
 80009dc:	200000fc 	.word	0x200000fc

080009e0 <User_GetIndex>:

//------------------------------------
// Get and Set user index
uint8_t User_GetIndex(void)
{
	return UserIndex;
 80009e0:	233c      	movs	r3, #60	; 0x3c
 80009e2:	4a01      	ldr	r2, [pc, #4]	; (80009e8 <User_GetIndex+0x8>)
 80009e4:	5cd0      	ldrb	r0, [r2, r3]
}
 80009e6:	4770      	bx	lr
 80009e8:	200000fc 	.word	0x200000fc

080009ec <User_SetIndex>:
void User_SetIndex(uint8_t Index)
{
	UserIndex = Index;
 80009ec:	233c      	movs	r3, #60	; 0x3c
 80009ee:	4a01      	ldr	r2, [pc, #4]	; (80009f4 <User_SetIndex+0x8>)
 80009f0:	54d0      	strb	r0, [r2, r3]
}
 80009f2:	4770      	bx	lr
 80009f4:	200000fc 	.word	0x200000fc

080009f8 <User_GetParameters>:

//------------------------------------
// Get all user parameters
void User_GetParameters(const User_TypeDef* User_Parameters, uint8_t Index)
{
	User_Copy( (uint8_t*) &Shower_User[Index], (uint8_t*) &User_Parameters );
 80009f8:	008b      	lsls	r3, r1, #2
 80009fa:	1859      	adds	r1, r3, r1
 80009fc:	4b06      	ldr	r3, [pc, #24]	; (8000a18 <User_GetParameters+0x20>)
 80009fe:	0049      	lsls	r1, r1, #1
 8000a00:	1859      	adds	r1, r3, r1
 8000a02:	2300      	movs	r3, #0
}

//------------------------------------
// Get all user parameters
void User_GetParameters(const User_TypeDef* User_Parameters, uint8_t Index)
{
 8000a04:	b082      	sub	sp, #8
 8000a06:	9001      	str	r0, [sp, #4]
 8000a08:	a801      	add	r0, sp, #4
	uint8_t auxSz = sizeof(User_TypeDef);
	uint8_t k;

	for(k = 0; k < auxSz; k++)
	{
		Copy[k] = Original[k];
 8000a0a:	5cc2      	ldrb	r2, [r0, r3]
 8000a0c:	54ca      	strb	r2, [r1, r3]
 8000a0e:	3301      	adds	r3, #1
void User_Copy(uint8_t* Copy, const uint8_t* Original)
{
	uint8_t auxSz = sizeof(User_TypeDef);
	uint8_t k;

	for(k = 0; k < auxSz; k++)
 8000a10:	2b0a      	cmp	r3, #10
 8000a12:	d1fa      	bne.n	8000a0a <User_GetParameters+0x12>
	User_Parameters -> LedColor				= Shower_User[Index].LedColor;
	User_Parameters -> TemperatureSetPoint	= Shower_User[Index].TemperatureSetPoint;
	User_Parameters -> PowerSetPoint		= Shower_User[Index].PowerSetPoint;
	User_Parameters -> MaxTemperatureLimit	= Shower_User[Index].MaxTemperatureLimit;
	User_Parameters -> Buzzer				= Shower_User[Index].Buzzer;*/
}
 8000a14:	b002      	add	sp, #8
 8000a16:	4770      	bx	lr
 8000a18:	200000fc 	.word	0x200000fc

08000a1c <User_Copy>:

void User_Copy(uint8_t* Copy, const uint8_t* Original)
{
 8000a1c:	2300      	movs	r3, #0
	uint8_t auxSz = sizeof(User_TypeDef);
	uint8_t k;

	for(k = 0; k < auxSz; k++)
	{
		Copy[k] = Original[k];
 8000a1e:	5cca      	ldrb	r2, [r1, r3]
 8000a20:	54c2      	strb	r2, [r0, r3]
 8000a22:	3301      	adds	r3, #1
void User_Copy(uint8_t* Copy, const uint8_t* Original)
{
	uint8_t auxSz = sizeof(User_TypeDef);
	uint8_t k;

	for(k = 0; k < auxSz; k++)
 8000a24:	2b0a      	cmp	r3, #10
 8000a26:	d1fa      	bne.n	8000a1e <User_Copy+0x2>
	{
		Copy[k] = Original[k];
	}
}
 8000a28:	4770      	bx	lr
 8000a2a:	46c0      	nop			; (mov r8, r8)

08000a2c <User_SetParameters>:

void User_SetParameters(User_TypeDef User_Parameters, uint8_t Index)
{
 8000a2c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000a2e:	464f      	mov	r7, r9
 8000a30:	4691      	mov	r9, r2
	Shower_User[Index].ShowerMode			= User_Parameters.ShowerMode;
 8000a32:	4a0f      	ldr	r2, [pc, #60]	; (8000a70 <User_SetParameters+0x44>)
		Copy[k] = Original[k];
	}
}

void User_SetParameters(User_TypeDef User_Parameters, uint8_t Index)
{
 8000a34:	4646      	mov	r6, r8
	Shower_User[Index].ShowerMode			= User_Parameters.ShowerMode;
 8000a36:	4694      	mov	ip, r2
 8000a38:	009a      	lsls	r2, r3, #2
 8000a3a:	4690      	mov	r8, r2
 8000a3c:	4662      	mov	r2, ip
 8000a3e:	4443      	add	r3, r8
		Copy[k] = Original[k];
	}
}

void User_SetParameters(User_TypeDef User_Parameters, uint8_t Index)
{
 8000a40:	b4c0      	push	{r6, r7}
 8000a42:	1c05      	adds	r5, r0, #0
 8000a44:	1c07      	adds	r7, r0, #0
 8000a46:	1c0c      	adds	r4, r1, #0
	Shower_User[Index].ShowerMode			= User_Parameters.ShowerMode;
 8000a48:	005b      	lsls	r3, r3, #1
 8000a4a:	54d7      	strb	r7, [r2, r3]
	Shower_User[Index].LedMode				= User_Parameters.LedMode;
	Shower_User[Index].LedColor				= User_Parameters.LedColor;
	Shower_User[Index].TemperatureSetPoint	= User_Parameters.TemperatureSetPoint;
	Shower_User[Index].PowerSetPoint		= User_Parameters.PowerSetPoint;
	Shower_User[Index].MaxTemperatureLimit	= User_Parameters.MaxTemperatureLimit;
	Shower_User[Index].Buzzer				= User_Parameters.Buzzer;
 8000a4c:	464a      	mov	r2, r9
}

void User_SetParameters(User_TypeDef User_Parameters, uint8_t Index)
{
	Shower_User[Index].ShowerMode			= User_Parameters.ShowerMode;
	Shower_User[Index].LedMode				= User_Parameters.LedMode;
 8000a4e:	4463      	add	r3, ip
		Copy[k] = Original[k];
	}
}

void User_SetParameters(User_TypeDef User_Parameters, uint8_t Index)
{
 8000a50:	b085      	sub	sp, #20
 8000a52:	0a2d      	lsrs	r5, r5, #8
 8000a54:	0c00      	lsrs	r0, r0, #16
 8000a56:	0c24      	lsrs	r4, r4, #16
	Shower_User[Index].ShowerMode			= User_Parameters.ShowerMode;
	Shower_User[Index].LedMode				= User_Parameters.LedMode;
	Shower_User[Index].LedColor				= User_Parameters.LedColor;
	Shower_User[Index].TemperatureSetPoint	= User_Parameters.TemperatureSetPoint;
 8000a58:	8099      	strh	r1, [r3, #4]
	Shower_User[Index].PowerSetPoint		= User_Parameters.PowerSetPoint;
	Shower_User[Index].MaxTemperatureLimit	= User_Parameters.MaxTemperatureLimit;
 8000a5a:	0e09      	lsrs	r1, r1, #24
}

void User_SetParameters(User_TypeDef User_Parameters, uint8_t Index)
{
	Shower_User[Index].ShowerMode			= User_Parameters.ShowerMode;
	Shower_User[Index].LedMode				= User_Parameters.LedMode;
 8000a5c:	705d      	strb	r5, [r3, #1]
	Shower_User[Index].LedColor				= User_Parameters.LedColor;
 8000a5e:	7098      	strb	r0, [r3, #2]
	Shower_User[Index].TemperatureSetPoint	= User_Parameters.TemperatureSetPoint;
	Shower_User[Index].PowerSetPoint		= User_Parameters.PowerSetPoint;
 8000a60:	719c      	strb	r4, [r3, #6]
	Shower_User[Index].MaxTemperatureLimit	= User_Parameters.MaxTemperatureLimit;
 8000a62:	71d9      	strb	r1, [r3, #7]
	Shower_User[Index].Buzzer				= User_Parameters.Buzzer;
 8000a64:	721a      	strb	r2, [r3, #8]
}
 8000a66:	b005      	add	sp, #20
 8000a68:	bc0c      	pop	{r2, r3}
 8000a6a:	4690      	mov	r8, r2
 8000a6c:	4699      	mov	r9, r3
 8000a6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000a70:	200000fc 	.word	0x200000fc

08000a74 <User_SetAllShowerVariables>:

void User_SetAllShowerVariables(User_TypeDef User_Parameters)
{
	uint8_t Index;

	UserIndex = 1;  // User 1 is the initial user (Default User)
 8000a74:	4b1c      	ldr	r3, [pc, #112]	; (8000ae8 <User_SetAllShowerVariables+0x74>)
	Shower_User[Index].MaxTemperatureLimit	= User_Parameters.MaxTemperatureLimit;
	Shower_User[Index].Buzzer				= User_Parameters.Buzzer;
}

void User_SetAllShowerVariables(User_TypeDef User_Parameters)
{
 8000a76:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000a78:	464d      	mov	r5, r9
	uint8_t Index;

	UserIndex = 1;  // User 1 is the initial user (Default User)
 8000a7a:	4699      	mov	r9, r3
 8000a7c:	2301      	movs	r3, #1
	Shower_User[Index].MaxTemperatureLimit	= User_Parameters.MaxTemperatureLimit;
	Shower_User[Index].Buzzer				= User_Parameters.Buzzer;
}

void User_SetAllShowerVariables(User_TypeDef User_Parameters)
{
 8000a7e:	465f      	mov	r7, fp
 8000a80:	4656      	mov	r6, sl
 8000a82:	4644      	mov	r4, r8
	uint8_t Index;

	UserIndex = 1;  // User 1 is the initial user (Default User)
 8000a84:	4698      	mov	r8, r3
	Shower_User[Index].MaxTemperatureLimit	= User_Parameters.MaxTemperatureLimit;
	Shower_User[Index].Buzzer				= User_Parameters.Buzzer;
}

void User_SetAllShowerVariables(User_TypeDef User_Parameters)
{
 8000a86:	b4f0      	push	{r4, r5, r6, r7}
 8000a88:	468b      	mov	fp, r1
 8000a8a:	1c0e      	adds	r6, r1, #0
 8000a8c:	1c0c      	adds	r4, r1, #0
 8000a8e:	4692      	mov	sl, r2
	uint8_t Index;

	UserIndex = 1;  // User 1 is the initial user (Default User)
 8000a90:	4649      	mov	r1, r9
 8000a92:	4642      	mov	r2, r8
 8000a94:	333b      	adds	r3, #59	; 0x3b
 8000a96:	54ca      	strb	r2, [r1, r3]
 8000a98:	469c      	mov	ip, r3
 8000a9a:	465b      	mov	r3, fp
	Shower_User[Index].MaxTemperatureLimit	= User_Parameters.MaxTemperatureLimit;
	Shower_User[Index].Buzzer				= User_Parameters.Buzzer;
}

void User_SetAllShowerVariables(User_TypeDef User_Parameters)
{
 8000a9c:	b085      	sub	sp, #20
 8000a9e:	466a      	mov	r2, sp
 8000aa0:	0e19      	lsrs	r1, r3, #24
 8000aa2:	4653      	mov	r3, sl
 8000aa4:	70d3      	strb	r3, [r2, #3]
 8000aa6:	1c05      	adds	r5, r0, #0
 8000aa8:	78d3      	ldrb	r3, [r2, #3]
 8000aaa:	1c07      	adds	r7, r0, #0
 8000aac:	4698      	mov	r8, r3
 8000aae:	464b      	mov	r3, r9
 8000ab0:	0a2d      	lsrs	r5, r5, #8
 8000ab2:	0c00      	lsrs	r0, r0, #16
 8000ab4:	0c24      	lsrs	r4, r4, #16
 8000ab6:	b2ff      	uxtb	r7, r7
 8000ab8:	b2ed      	uxtb	r5, r5
 8000aba:	b2c0      	uxtb	r0, r0
 8000abc:	b2b6      	uxth	r6, r6
 8000abe:	b2e4      	uxtb	r4, r4
 8000ac0:	44cc      	add	ip, r9
		Shower_User[Index].LedMode				= User_Parameters.LedMode;
		Shower_User[Index].LedColor				= User_Parameters.LedColor;
		Shower_User[Index].TemperatureSetPoint	= User_Parameters.TemperatureSetPoint;
		Shower_User[Index].PowerSetPoint		= User_Parameters.PowerSetPoint;
		Shower_User[Index].MaxTemperatureLimit	= User_Parameters.MaxTemperatureLimit;
		Shower_User[Index].Buzzer				= User_Parameters.Buzzer;
 8000ac2:	4642      	mov	r2, r8

	UserIndex = 1;  // User 1 is the initial user (Default User)

	for(Index = 0; Index < 6; Index++)
	{
		Shower_User[Index].ShowerMode			= User_Parameters.ShowerMode;
 8000ac4:	701f      	strb	r7, [r3, #0]
		Shower_User[Index].LedMode				= User_Parameters.LedMode;
 8000ac6:	705d      	strb	r5, [r3, #1]
		Shower_User[Index].LedColor				= User_Parameters.LedColor;
 8000ac8:	7098      	strb	r0, [r3, #2]
		Shower_User[Index].TemperatureSetPoint	= User_Parameters.TemperatureSetPoint;
 8000aca:	809e      	strh	r6, [r3, #4]
		Shower_User[Index].PowerSetPoint		= User_Parameters.PowerSetPoint;
 8000acc:	719c      	strb	r4, [r3, #6]
		Shower_User[Index].MaxTemperatureLimit	= User_Parameters.MaxTemperatureLimit;
 8000ace:	71d9      	strb	r1, [r3, #7]
		Shower_User[Index].Buzzer				= User_Parameters.Buzzer;
 8000ad0:	721a      	strb	r2, [r3, #8]
 8000ad2:	330a      	adds	r3, #10
{
	uint8_t Index;

	UserIndex = 1;  // User 1 is the initial user (Default User)

	for(Index = 0; Index < 6; Index++)
 8000ad4:	4563      	cmp	r3, ip
 8000ad6:	d1f4      	bne.n	8000ac2 <User_SetAllShowerVariables+0x4e>
		Shower_User[Index].TemperatureSetPoint	= User_Parameters.TemperatureSetPoint;
		Shower_User[Index].PowerSetPoint		= User_Parameters.PowerSetPoint;
		Shower_User[Index].MaxTemperatureLimit	= User_Parameters.MaxTemperatureLimit;
		Shower_User[Index].Buzzer				= User_Parameters.Buzzer;
	}
}
 8000ad8:	b005      	add	sp, #20
 8000ada:	bc3c      	pop	{r2, r3, r4, r5}
 8000adc:	4690      	mov	r8, r2
 8000ade:	4699      	mov	r9, r3
 8000ae0:	46a2      	mov	sl, r4
 8000ae2:	46ab      	mov	fp, r5
 8000ae4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000ae6:	46c0      	nop			; (mov r8, r8)
 8000ae8:	200000fc 	.word	0x200000fc

08000aec <User_ResetShowerVariables>:

void User_ResetShowerVariables(void)
{
	uint8_t Index;

	UserIndex = 1;  // User 1 is the initial user (Default User)
 8000aec:	4b0b      	ldr	r3, [pc, #44]	; (8000b1c <User_ResetShowerVariables+0x30>)
		Shower_User[Index].Buzzer				= User_Parameters.Buzzer;
	}
}

void User_ResetShowerVariables(void)
{
 8000aee:	b570      	push	{r4, r5, r6, lr}
	uint8_t Index;

	UserIndex = 1;  // User 1 is the initial user (Default User)
 8000af0:	223c      	movs	r2, #60	; 0x3c
 8000af2:	2101      	movs	r1, #1
 8000af4:	1c1e      	adds	r6, r3, #0
	for(Index = 0; Index < 6; Index++)
	{
		Shower_User[Index].ShowerMode			= 0x01;	// SHOWER_MODE_TEMPERATURE
		Shower_User[Index].LedMode				= 0x04;	// LED_AUTO
		Shower_User[Index].LedColor				= 0x01;	// LED_COLOR_WHITE
		Shower_User[Index].TemperatureSetPoint	= 365;	// DEFAULT_SETPOINT
 8000af6:	246e      	movs	r4, #110	; 0x6e
	UserIndex = 1;  // User 1 is the initial user (Default User)

	for(Index = 0; Index < 6; Index++)
	{
		Shower_User[Index].ShowerMode			= 0x01;	// SHOWER_MODE_TEMPERATURE
		Shower_User[Index].LedMode				= 0x04;	// LED_AUTO
 8000af8:	2504      	movs	r5, #4
		Shower_User[Index].LedColor				= 0x01;	// LED_COLOR_WHITE
		Shower_User[Index].TemperatureSetPoint	= 365;	// DEFAULT_SETPOINT
		Shower_User[Index].PowerSetPoint		= 0;	//
 8000afa:	2000      	movs	r0, #0

void User_ResetShowerVariables(void)
{
	uint8_t Index;

	UserIndex = 1;  // User 1 is the initial user (Default User)
 8000afc:	5499      	strb	r1, [r3, r2]
 8000afe:	363c      	adds	r6, #60	; 0x3c
	for(Index = 0; Index < 6; Index++)
	{
		Shower_User[Index].ShowerMode			= 0x01;	// SHOWER_MODE_TEMPERATURE
		Shower_User[Index].LedMode				= 0x04;	// LED_AUTO
		Shower_User[Index].LedColor				= 0x01;	// LED_COLOR_WHITE
		Shower_User[Index].TemperatureSetPoint	= 365;	// DEFAULT_SETPOINT
 8000b00:	34ff      	adds	r4, #255	; 0xff
		Shower_User[Index].PowerSetPoint		= 0;	//
		Shower_User[Index].Buzzer				= 0x0f;	// BUZZER_ENABLED
 8000b02:	3a2d      	subs	r2, #45	; 0x2d

	UserIndex = 1;  // User 1 is the initial user (Default User)

	for(Index = 0; Index < 6; Index++)
	{
		Shower_User[Index].ShowerMode			= 0x01;	// SHOWER_MODE_TEMPERATURE
 8000b04:	7019      	strb	r1, [r3, #0]
		Shower_User[Index].LedMode				= 0x04;	// LED_AUTO
 8000b06:	705d      	strb	r5, [r3, #1]
		Shower_User[Index].LedColor				= 0x01;	// LED_COLOR_WHITE
 8000b08:	7099      	strb	r1, [r3, #2]
		Shower_User[Index].TemperatureSetPoint	= 365;	// DEFAULT_SETPOINT
 8000b0a:	809c      	strh	r4, [r3, #4]
		Shower_User[Index].PowerSetPoint		= 0;	//
 8000b0c:	7198      	strb	r0, [r3, #6]
		Shower_User[Index].Buzzer				= 0x0f;	// BUZZER_ENABLED
 8000b0e:	721a      	strb	r2, [r3, #8]
		Shower_User[Index].MaxTemperatureLimit	= 0x0f;	// TEMPERATURE_LIMIT_ON
 8000b10:	71da      	strb	r2, [r3, #7]
 8000b12:	330a      	adds	r3, #10
{
	uint8_t Index;

	UserIndex = 1;  // User 1 is the initial user (Default User)

	for(Index = 0; Index < 6; Index++)
 8000b14:	42b3      	cmp	r3, r6
 8000b16:	d1f5      	bne.n	8000b04 <User_ResetShowerVariables+0x18>
		Shower_User[Index].TemperatureSetPoint	= 365;	// DEFAULT_SETPOINT
		Shower_User[Index].PowerSetPoint		= 0;	//
		Shower_User[Index].Buzzer				= 0x0f;	// BUZZER_ENABLED
		Shower_User[Index].MaxTemperatureLimit	= 0x0f;	// TEMPERATURE_LIMIT_ON
	}
}
 8000b18:	bd70      	pop	{r4, r5, r6, pc}
 8000b1a:	46c0      	nop			; (mov r8, r8)
 8000b1c:	200000fc 	.word	0x200000fc

08000b20 <PWM_Init_1>:
	TIM_OCInitTypeDef TIM_OCInitStructure;

	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOB Clocks enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8000b20:	2080      	movs	r0, #128	; 0x80

//==================================================================================================
//
//==================================================================================================
void PWM_Init_1 (void)
{
 8000b22:	b5f0      	push	{r4, r5, r6, r7, lr}
	TIM_OCInitTypeDef TIM_OCInitStructure;

	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOB Clocks enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8000b24:	0280      	lsls	r0, r0, #10

//==================================================================================================
//
//==================================================================================================
void PWM_Init_1 (void)
{
 8000b26:	b08b      	sub	sp, #44	; 0x2c
	TIM_OCInitTypeDef TIM_OCInitStructure;

	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOB Clocks enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8000b28:	2101      	movs	r1, #1
 8000b2a:	f005 fd99 	bl	8006660 <RCC_AHBPeriphClockCmd>

	/* GPIOB Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin   = PWM_PIN_LED_RED | PWM_PIN_LED_GREEN | PWM_PIN_LED_BLUE | PWM_PIN_BUZZER;
 8000b2e:	23f0      	movs	r3, #240	; 0xf0
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP ;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8000b30:	2490      	movs	r4, #144	; 0x90

	/* GPIOB Clocks enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

	/* GPIOB Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin   = PWM_PIN_LED_RED | PWM_PIN_LED_GREEN | PWM_PIN_LED_BLUE | PWM_PIN_BUZZER;
 8000b32:	011b      	lsls	r3, r3, #4
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 8000b34:	466a      	mov	r2, sp

	/* GPIOB Clocks enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

	/* GPIOB Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin   = PWM_PIN_LED_RED | PWM_PIN_LED_GREEN | PWM_PIN_LED_BLUE | PWM_PIN_BUZZER;
 8000b36:	9300      	str	r3, [sp, #0]
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 8000b38:	2302      	movs	r3, #2
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000b3a:	2500      	movs	r5, #0
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP ;
 8000b3c:	2701      	movs	r7, #1
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8000b3e:	05e4      	lsls	r4, r4, #23
	/* GPIOB Clocks enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

	/* GPIOB Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin   = PWM_PIN_LED_RED | PWM_PIN_LED_GREEN | PWM_PIN_LED_BLUE | PWM_PIN_BUZZER;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 8000b40:	7113      	strb	r3, [r2, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP ;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8000b42:	1c20      	adds	r0, r4, #0
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

	/* GPIOB Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin   = PWM_PIN_LED_RED | PWM_PIN_LED_GREEN | PWM_PIN_LED_BLUE | PWM_PIN_BUZZER;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8000b44:	3301      	adds	r3, #1
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP ;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8000b46:	4669      	mov	r1, sp
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

	/* GPIOB Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin   = PWM_PIN_LED_RED | PWM_PIN_LED_GREEN | PWM_PIN_LED_BLUE | PWM_PIN_BUZZER;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8000b48:	7153      	strb	r3, [r2, #5]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000b4a:	7195      	strb	r5, [r2, #6]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP ;
 8000b4c:	71d7      	strb	r7, [r2, #7]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8000b4e:	f005 f96d 	bl	8005e2c <GPIO_Init>

	GPIO_PinAFConfig(PWM_PORT, PWM_PIN_SOURCE_LED_RED,   GPIO_AF_2);
 8000b52:	1c20      	adds	r0, r4, #0
 8000b54:	2108      	movs	r1, #8
 8000b56:	2202      	movs	r2, #2
 8000b58:	f005 fa0a 	bl	8005f70 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(PWM_PORT, PWM_PIN_SOURCE_LED_GREEN, GPIO_AF_2);
 8000b5c:	1c20      	adds	r0, r4, #0
 8000b5e:	210a      	movs	r1, #10
 8000b60:	2202      	movs	r2, #2
 8000b62:	f005 fa05 	bl	8005f70 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(PWM_PORT, PWM_PIN_SOURCE_LED_BLUE,  GPIO_AF_2);
 8000b66:	1c20      	adds	r0, r4, #0
 8000b68:	2109      	movs	r1, #9
 8000b6a:	2202      	movs	r2, #2
 8000b6c:	f005 fa00 	bl	8005f70 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(PWM_PORT, PWM_PIN_SOURCE_BUZZER,    GPIO_AF_2);
 8000b70:	2202      	movs	r2, #2
 8000b72:	1c20      	adds	r0, r4, #0
 8000b74:	210b      	movs	r1, #11
 8000b76:	f005 f9fb 	bl	8005f70 <GPIO_PinAFConfig>

	/* Compute the value to be set in ARR regiter to generate signal frequency at 2.5Khz */
	TimerPeriod = (SystemCoreClock / 2500 ) - 1;// (48000000/2500)-1 = 19199
 8000b7a:	4b21      	ldr	r3, [pc, #132]	; (8000c00 <PWM_Init_1+0xe0>)
 8000b7c:	4921      	ldr	r1, [pc, #132]	; (8000c04 <PWM_Init_1+0xe4>)
 8000b7e:	6818      	ldr	r0, [r3, #0]
 8000b80:	f002 fdf8 	bl	8003774 <__aeabi_uidiv>
 8000b84:	4c20      	ldr	r4, [pc, #128]	; (8000c08 <PWM_Init_1+0xe8>)
 8000b86:	3801      	subs	r0, #1
 8000b88:	8020      	strh	r0, [r4, #0]

	/* TIM1 clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1 , ENABLE);
 8000b8a:	2080      	movs	r0, #128	; 0x80
 8000b8c:	2101      	movs	r1, #1
 8000b8e:	0100      	lsls	r0, r0, #4
 8000b90:	f005 fd72 	bl	8006678 <RCC_APB2PeriphClockCmd>

	/* Time Base configuration */
	TIM_TimeBaseStructure.TIM_Prescaler = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseStructure.TIM_Period = TimerPeriod;
 8000b94:	8823      	ldrh	r3, [r4, #0]

	/* TIM1 clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1 , ENABLE);

	/* Time Base configuration */
	TIM_TimeBaseStructure.TIM_Prescaler = 0;
 8000b96:	a902      	add	r1, sp, #8
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseStructure.TIM_Period = TimerPeriod;
 8000b98:	604b      	str	r3, [r1, #4]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
 8000b9a:	2300      	movs	r3, #0

	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
 8000b9c:	4e1b      	ldr	r6, [pc, #108]	; (8000c0c <PWM_Init_1+0xec>)

	/* TIM1 clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1 , ENABLE);

	/* Time Base configuration */
	TIM_TimeBaseStructure.TIM_Prescaler = 0;
 8000b9e:	800d      	strh	r5, [r1, #0]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseStructure.TIM_Period = TimerPeriod;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;

	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
 8000ba0:	1c30      	adds	r0, r6, #0
	/* TIM1 clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1 , ENABLE);

	/* Time Base configuration */
	TIM_TimeBaseStructure.TIM_Prescaler = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8000ba2:	804d      	strh	r5, [r1, #2]
	TIM_TimeBaseStructure.TIM_Period = TimerPeriod;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 8000ba4:	810d      	strh	r5, [r1, #8]
	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
 8000ba6:	728b      	strb	r3, [r1, #10]

	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
 8000ba8:	f006 fcc8 	bl	800753c <TIM_TimeBaseInit>

	/* Channel 1, 2, 3 and 4 Configuration in PWM mode */
	TIM_OCInitStructure.TIM_OCMode 		 = TIM_OCMode_PWM1;
 8000bac:	2360      	movs	r3, #96	; 0x60
 8000bae:	ac05      	add	r4, sp, #20
 8000bb0:	8023      	strh	r3, [r4, #0]
	TIM_OCInitStructure.TIM_OutputState  = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
 8000bb2:	3b5c      	subs	r3, #92	; 0x5c
 8000bb4:	80a3      	strh	r3, [r4, #4]
	TIM_OCInitStructure.TIM_OCPolarity 	 = TIM_OCPolarity_High;
	TIM_OCInitStructure.TIM_OCNPolarity  = TIM_OCNPolarity_Low;
 8000bb6:	3304      	adds	r3, #4
 8000bb8:	81e3      	strh	r3, [r4, #14]
	TIM_OCInitStructure.TIM_OCIdleState  = TIM_OCIdleState_Set;
	TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;

	TIM_OCInitStructure.TIM_Pulse = 0;
	TIM_OC1Init(TIM1, &TIM_OCInitStructure);
 8000bba:	1c30      	adds	r0, r6, #0
	TIM_OCInitStructure.TIM_OCMode 		 = TIM_OCMode_PWM1;
	TIM_OCInitStructure.TIM_OutputState  = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
	TIM_OCInitStructure.TIM_OCPolarity 	 = TIM_OCPolarity_High;
	TIM_OCInitStructure.TIM_OCNPolarity  = TIM_OCNPolarity_Low;
	TIM_OCInitStructure.TIM_OCIdleState  = TIM_OCIdleState_Set;
 8000bbc:	33f8      	adds	r3, #248	; 0xf8
	TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;

	TIM_OCInitStructure.TIM_Pulse = 0;
	TIM_OC1Init(TIM1, &TIM_OCInitStructure);
 8000bbe:	1c21      	adds	r1, r4, #0
	TIM_OCInitStructure.TIM_OCMode 		 = TIM_OCMode_PWM1;
	TIM_OCInitStructure.TIM_OutputState  = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
	TIM_OCInitStructure.TIM_OCPolarity 	 = TIM_OCPolarity_High;
	TIM_OCInitStructure.TIM_OCNPolarity  = TIM_OCNPolarity_Low;
	TIM_OCInitStructure.TIM_OCIdleState  = TIM_OCIdleState_Set;
 8000bc0:	8223      	strh	r3, [r4, #16]

	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);

	/* Channel 1, 2, 3 and 4 Configuration in PWM mode */
	TIM_OCInitStructure.TIM_OCMode 		 = TIM_OCMode_PWM1;
	TIM_OCInitStructure.TIM_OutputState  = TIM_OutputState_Enable;
 8000bc2:	8067      	strh	r7, [r4, #2]
	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
	TIM_OCInitStructure.TIM_OCPolarity 	 = TIM_OCPolarity_High;
 8000bc4:	81a5      	strh	r5, [r4, #12]
	TIM_OCInitStructure.TIM_OCNPolarity  = TIM_OCNPolarity_Low;
	TIM_OCInitStructure.TIM_OCIdleState  = TIM_OCIdleState_Set;
	TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;
 8000bc6:	8265      	strh	r5, [r4, #18]

	TIM_OCInitStructure.TIM_Pulse = 0;
 8000bc8:	9507      	str	r5, [sp, #28]
	TIM_OC1Init(TIM1, &TIM_OCInitStructure);
 8000bca:	f006 fd8d 	bl	80076e8 <TIM_OC1Init>

	TIM_OCInitStructure.TIM_Pulse = 0;
	TIM_OC2Init(TIM1, &TIM_OCInitStructure);
 8000bce:	1c30      	adds	r0, r6, #0
 8000bd0:	1c21      	adds	r1, r4, #0
	TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;

	TIM_OCInitStructure.TIM_Pulse = 0;
	TIM_OC1Init(TIM1, &TIM_OCInitStructure);

	TIM_OCInitStructure.TIM_Pulse = 0;
 8000bd2:	60a5      	str	r5, [r4, #8]
	TIM_OC2Init(TIM1, &TIM_OCInitStructure);
 8000bd4:	f006 fdc8 	bl	8007768 <TIM_OC2Init>

	TIM_OCInitStructure.TIM_Pulse = 0;
	TIM_OC3Init(TIM1, &TIM_OCInitStructure);
 8000bd8:	1c30      	adds	r0, r6, #0
 8000bda:	1c21      	adds	r1, r4, #0
	TIM_OC1Init(TIM1, &TIM_OCInitStructure);

	TIM_OCInitStructure.TIM_Pulse = 0;
	TIM_OC2Init(TIM1, &TIM_OCInitStructure);

	TIM_OCInitStructure.TIM_Pulse = 0;
 8000bdc:	60a5      	str	r5, [r4, #8]
	TIM_OC3Init(TIM1, &TIM_OCInitStructure);
 8000bde:	f006 fe13 	bl	8007808 <TIM_OC3Init>

	TIM_OCInitStructure.TIM_Pulse = 0;
	TIM_OC4Init(TIM1, &TIM_OCInitStructure);
 8000be2:	1c30      	adds	r0, r6, #0
 8000be4:	1c21      	adds	r1, r4, #0
	TIM_OC2Init(TIM1, &TIM_OCInitStructure);

	TIM_OCInitStructure.TIM_Pulse = 0;
	TIM_OC3Init(TIM1, &TIM_OCInitStructure);

	TIM_OCInitStructure.TIM_Pulse = 0;
 8000be6:	60a5      	str	r5, [r4, #8]
	TIM_OC4Init(TIM1, &TIM_OCInitStructure);
 8000be8:	f006 fe50 	bl	800788c <TIM_OC4Init>

	/* TIM1 counter enable */
	TIM_Cmd(TIM1, ENABLE);
 8000bec:	1c30      	adds	r0, r6, #0
 8000bee:	2101      	movs	r1, #1
 8000bf0:	f006 fd46 	bl	8007680 <TIM_Cmd>

	/* TIM1 Main Output Enable */
	TIM_CtrlPWMOutputs(TIM1, ENABLE);
 8000bf4:	1c30      	adds	r0, r6, #0
 8000bf6:	2101      	movs	r1, #1
 8000bf8:	f006 fd68 	bl	80076cc <TIM_CtrlPWMOutputs>
}
 8000bfc:	b00b      	add	sp, #44	; 0x2c
 8000bfe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000c00:	20000010 	.word	0x20000010
 8000c04:	000009c4 	.word	0x000009c4
 8000c08:	2000013c 	.word	0x2000013c
 8000c0c:	40012c00 	.word	0x40012c00

08000c10 <PWM_Init_2>:

//==================================================================================================
//
//==================================================================================================
void PWM_Init_2 (void)
{
 8000c10:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint16_t TimerPeriod_2 = 0;

	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOA Clocks enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8000c12:	2680      	movs	r6, #128	; 0x80
 8000c14:	02b6      	lsls	r6, r6, #10

//==================================================================================================
//
//==================================================================================================
void PWM_Init_2 (void)
{
 8000c16:	b08b      	sub	sp, #44	; 0x2c
	uint16_t TimerPeriod_2 = 0;

	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOA Clocks enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8000c18:	1c30      	adds	r0, r6, #0
 8000c1a:	2101      	movs	r1, #1
 8000c1c:	f005 fd20 	bl	8006660 <RCC_AHBPeriphClockCmd>
	GPIO_InitStructure.GPIO_Pin   = PWM_PIN_TOUCH; // PIN A6
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP ;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8000c20:	2490      	movs	r4, #144	; 0x90

	/* GPIOA Clocks enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

	/* GPIOA Configuration: */
	GPIO_InitStructure.GPIO_Pin   = PWM_PIN_TOUCH; // PIN A6
 8000c22:	2340      	movs	r3, #64	; 0x40
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 8000c24:	466a      	mov	r2, sp
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000c26:	2500      	movs	r5, #0
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP ;
 8000c28:	2701      	movs	r7, #1

	/* GPIOA Clocks enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

	/* GPIOA Configuration: */
	GPIO_InitStructure.GPIO_Pin   = PWM_PIN_TOUCH; // PIN A6
 8000c2a:	9300      	str	r3, [sp, #0]
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP ;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8000c2c:	05e4      	lsls	r4, r4, #23
	/* GPIOA Clocks enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

	/* GPIOA Configuration: */
	GPIO_InitStructure.GPIO_Pin   = PWM_PIN_TOUCH; // PIN A6
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 8000c2e:	3b3e      	subs	r3, #62	; 0x3e
 8000c30:	7113      	strb	r3, [r2, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP ;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8000c32:	1c20      	adds	r0, r4, #0
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

	/* GPIOA Configuration: */
	GPIO_InitStructure.GPIO_Pin   = PWM_PIN_TOUCH; // PIN A6
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8000c34:	3301      	adds	r3, #1
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP ;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8000c36:	4669      	mov	r1, sp
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

	/* GPIOA Configuration: */
	GPIO_InitStructure.GPIO_Pin   = PWM_PIN_TOUCH; // PIN A6
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8000c38:	7153      	strb	r3, [r2, #5]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000c3a:	7195      	strb	r5, [r2, #6]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP ;
 8000c3c:	71d7      	strb	r7, [r2, #7]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8000c3e:	f005 f8f5 	bl	8005e2c <GPIO_Init>

	GPIO_PinAFConfig(GPIOA, PWM_PIN_SOURCE_TOUCH, GPIO_AF_5);
 8000c42:	2205      	movs	r2, #5
 8000c44:	1c20      	adds	r0, r4, #0
 8000c46:	2106      	movs	r1, #6
 8000c48:	f005 f992 	bl	8005f70 <GPIO_PinAFConfig>

	/* Compute the value to be set in ARR regiter to generate signal frequency at 1Khz */
	TimerPeriod_2 = (SystemCoreClock / 1000) - 1;
 8000c4c:	21fa      	movs	r1, #250	; 0xfa
 8000c4e:	4b1d      	ldr	r3, [pc, #116]	; (8000cc4 <PWM_Init_2+0xb4>)
 8000c50:	0089      	lsls	r1, r1, #2
 8000c52:	6818      	ldr	r0, [r3, #0]
 8000c54:	f002 fd8e 	bl	8003774 <__aeabi_uidiv>

	/* TIM1 clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM16, ENABLE);
 8000c58:	2101      	movs	r1, #1
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_PinAFConfig(GPIOA, PWM_PIN_SOURCE_TOUCH, GPIO_AF_5);

	/* Compute the value to be set in ARR regiter to generate signal frequency at 1Khz */
	TimerPeriod_2 = (SystemCoreClock / 1000) - 1;
 8000c5a:	1e44      	subs	r4, r0, #1

	/* TIM1 clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM16, ENABLE);
 8000c5c:	1c30      	adds	r0, r6, #0
 8000c5e:	f005 fd0b 	bl	8006678 <RCC_APB2PeriphClockCmd>
	/* Time Base configuration */
	TIM_TimeBaseStructure.TIM_Prescaler   = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseStructure.TIM_Period 	  = TimerPeriod_2;
	TIM_TimeBaseStructure.TIM_ClockDivision 	= 0;
	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
 8000c62:	2300      	movs	r3, #0

	TIM_TimeBaseInit(TIM16, &TIM_TimeBaseStructure);
 8000c64:	4e18      	ldr	r6, [pc, #96]	; (8000cc8 <PWM_Init_2+0xb8>)

	/* TIM1 clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM16, ENABLE);

	/* Time Base configuration */
	TIM_TimeBaseStructure.TIM_Prescaler   = 0;
 8000c66:	a902      	add	r1, sp, #8
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseStructure.TIM_Period 	  = TimerPeriod_2;
	TIM_TimeBaseStructure.TIM_ClockDivision 	= 0;
	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;

	TIM_TimeBaseInit(TIM16, &TIM_TimeBaseStructure);
 8000c68:	1c30      	adds	r0, r6, #0
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_PinAFConfig(GPIOA, PWM_PIN_SOURCE_TOUCH, GPIO_AF_5);

	/* Compute the value to be set in ARR regiter to generate signal frequency at 1Khz */
	TimerPeriod_2 = (SystemCoreClock / 1000) - 1;
 8000c6a:	b2a4      	uxth	r4, r4

	/* TIM1 clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM16, ENABLE);

	/* Time Base configuration */
	TIM_TimeBaseStructure.TIM_Prescaler   = 0;
 8000c6c:	800d      	strh	r5, [r1, #0]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8000c6e:	804d      	strh	r5, [r1, #2]
	TIM_TimeBaseStructure.TIM_Period 	  = TimerPeriod_2;
 8000c70:	604c      	str	r4, [r1, #4]
	TIM_TimeBaseStructure.TIM_ClockDivision 	= 0;
 8000c72:	810d      	strh	r5, [r1, #8]
	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
 8000c74:	728b      	strb	r3, [r1, #10]

	TIM_TimeBaseInit(TIM16, &TIM_TimeBaseStructure);
 8000c76:	f006 fc61 	bl	800753c <TIM_TimeBaseInit>

	/* Channel 1, 2, 3 and 4 Configuration in PWM mode */
	TIM_OCInitStructure.TIM_OCMode 		 = TIM_OCMode_PWM1;
 8000c7a:	2360      	movs	r3, #96	; 0x60
 8000c7c:	a905      	add	r1, sp, #20
 8000c7e:	800b      	strh	r3, [r1, #0]
	TIM_OCInitStructure.TIM_OutputState  = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
 8000c80:	3b5c      	subs	r3, #92	; 0x5c
 8000c82:	808b      	strh	r3, [r1, #4]
	TIM_OCInitStructure.TIM_OCPolarity   = TIM_OCPolarity_High;
	TIM_OCInitStructure.TIM_OCNPolarity  = TIM_OCNPolarity_Low;
 8000c84:	3304      	adds	r3, #4
 8000c86:	81cb      	strh	r3, [r1, #14]
	TIM_OCInitStructure.TIM_OCIdleState  = TIM_OCIdleState_Set;
	TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;

	TIM_OCInitStructure.TIM_Pulse = 0;
	TIM_OC1Init(TIM16, &TIM_OCInitStructure);
 8000c88:	1c30      	adds	r0, r6, #0
	TIM_OCInitStructure.TIM_OCMode 		 = TIM_OCMode_PWM1;
	TIM_OCInitStructure.TIM_OutputState  = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
	TIM_OCInitStructure.TIM_OCPolarity   = TIM_OCPolarity_High;
	TIM_OCInitStructure.TIM_OCNPolarity  = TIM_OCNPolarity_Low;
	TIM_OCInitStructure.TIM_OCIdleState  = TIM_OCIdleState_Set;
 8000c8a:	33f8      	adds	r3, #248	; 0xf8
 8000c8c:	820b      	strh	r3, [r1, #16]

	TIM_TimeBaseInit(TIM16, &TIM_TimeBaseStructure);

	/* Channel 1, 2, 3 and 4 Configuration in PWM mode */
	TIM_OCInitStructure.TIM_OCMode 		 = TIM_OCMode_PWM1;
	TIM_OCInitStructure.TIM_OutputState  = TIM_OutputState_Enable;
 8000c8e:	804f      	strh	r7, [r1, #2]
	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
	TIM_OCInitStructure.TIM_OCPolarity   = TIM_OCPolarity_High;
 8000c90:	818d      	strh	r5, [r1, #12]
	TIM_OCInitStructure.TIM_OCNPolarity  = TIM_OCNPolarity_Low;
	TIM_OCInitStructure.TIM_OCIdleState  = TIM_OCIdleState_Set;
	TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;
 8000c92:	824d      	strh	r5, [r1, #18]

	TIM_OCInitStructure.TIM_Pulse = 0;
 8000c94:	608d      	str	r5, [r1, #8]
	TIM_OC1Init(TIM16, &TIM_OCInitStructure);
 8000c96:	f006 fd27 	bl	80076e8 <TIM_OC1Init>

	/* TIM1 counter enable */
	TIM_Cmd(TIM16, ENABLE);
 8000c9a:	1c30      	adds	r0, r6, #0
 8000c9c:	2101      	movs	r1, #1
 8000c9e:	f006 fcef 	bl	8007680 <TIM_Cmd>

	/* TIM1 Main Output Enable */
	TIM_CtrlPWMOutputs(TIM16, ENABLE);
 8000ca2:	1c30      	adds	r0, r6, #0
 8000ca4:	2101      	movs	r1, #1
 8000ca6:	f006 fd11 	bl	80076cc <TIM_CtrlPWMOutputs>

	uint32_t Compare = (uint32_t) (((uint32_t) 50 * (TimerPeriod_2 - 1)) / 100);
 8000caa:	2032      	movs	r0, #50	; 0x32
 8000cac:	3c01      	subs	r4, #1
 8000cae:	4360      	muls	r0, r4
 8000cb0:	2164      	movs	r1, #100	; 0x64
 8000cb2:	f002 fd5f 	bl	8003774 <__aeabi_uidiv>
 8000cb6:	1c01      	adds	r1, r0, #0

	TIM_SetCompare1(TIM16, Compare);
 8000cb8:	1c30      	adds	r0, r6, #0
 8000cba:	f006 fe4b 	bl	8007954 <TIM_SetCompare1>
}
 8000cbe:	b00b      	add	sp, #44	; 0x2c
 8000cc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000cc2:	46c0      	nop			; (mov r8, r8)
 8000cc4:	20000010 	.word	0x20000010
 8000cc8:	40014400 	.word	0x40014400

08000ccc <PWM_Init>:

//==================================================================================================
//
//==================================================================================================
void PWM_Init(void)
{
 8000ccc:	b510      	push	{r4, lr}
	if( PWM_Initialized == 0)
 8000cce:	4c05      	ldr	r4, [pc, #20]	; (8000ce4 <PWM_Init+0x18>)
 8000cd0:	78a3      	ldrb	r3, [r4, #2]
 8000cd2:	2b00      	cmp	r3, #0
 8000cd4:	d105      	bne.n	8000ce2 <PWM_Init+0x16>
	{
		PWM_Init_1();
 8000cd6:	f7ff ff23 	bl	8000b20 <PWM_Init_1>
		PWM_Init_2();
 8000cda:	f7ff ff99 	bl	8000c10 <PWM_Init_2>

		PWM_Initialized = 1;
 8000cde:	2301      	movs	r3, #1
 8000ce0:	70a3      	strb	r3, [r4, #2]
	}
}
 8000ce2:	bd10      	pop	{r4, pc}
 8000ce4:	2000013c 	.word	0x2000013c

08000ce8 <PWM_SetDutyCycle>:

//==================================================================================================
//
//==================================================================================================
void PWM_SetDutyCycle(uint8_t Channel, uint8_t DutyCycle)
{
 8000ce8:	b510      	push	{r4, lr}
	if(PWM_Initialized == 1)
 8000cea:	4b13      	ldr	r3, [pc, #76]	; (8000d38 <PWM_SetDutyCycle+0x50>)
 8000cec:	789a      	ldrb	r2, [r3, #2]
 8000cee:	2a01      	cmp	r2, #1
 8000cf0:	d000      	beq.n	8000cf4 <PWM_SetDutyCycle+0xc>
		if(Channel == PWM_CHANNEL_LED_RED  ) TIM_SetCompare1(TIM1, Compare);
		if(Channel == PWM_CHANNEL_LED_GREEN) TIM_SetCompare3(TIM1, Compare);
		if(Channel == PWM_CHANNEL_LED_BLUE ) TIM_SetCompare2(TIM1, Compare);
		if(Channel == PWM_CHANNEL_BUZZER   ) TIM_SetCompare4(TIM1, Compare);
	}
}
 8000cf2:	bd10      	pop	{r4, pc}
//==================================================================================================
void PWM_SetDutyCycle(uint8_t Channel, uint8_t DutyCycle)
{
	if(PWM_Initialized == 1)
	{
		uint32_t Compare = (uint32_t) (((uint32_t) DutyCycle * (TimerPeriod - 1)) / 100);
 8000cf4:	881b      	ldrh	r3, [r3, #0]
 8000cf6:	1c04      	adds	r4, r0, #0
 8000cf8:	3b01      	subs	r3, #1
 8000cfa:	434b      	muls	r3, r1
 8000cfc:	2164      	movs	r1, #100	; 0x64
 8000cfe:	1c18      	adds	r0, r3, #0
 8000d00:	f002 fd38 	bl	8003774 <__aeabi_uidiv>
 8000d04:	1c01      	adds	r1, r0, #0

		if(Channel == PWM_CHANNEL_LED_RED  ) TIM_SetCompare1(TIM1, Compare);
 8000d06:	2c01      	cmp	r4, #1
 8000d08:	d011      	beq.n	8000d2e <PWM_SetDutyCycle+0x46>
		if(Channel == PWM_CHANNEL_LED_GREEN) TIM_SetCompare3(TIM1, Compare);
 8000d0a:	2c02      	cmp	r4, #2
 8000d0c:	d00b      	beq.n	8000d26 <PWM_SetDutyCycle+0x3e>
		if(Channel == PWM_CHANNEL_LED_BLUE ) TIM_SetCompare2(TIM1, Compare);
 8000d0e:	2c03      	cmp	r4, #3
 8000d10:	d005      	beq.n	8000d1e <PWM_SetDutyCycle+0x36>
		if(Channel == PWM_CHANNEL_BUZZER   ) TIM_SetCompare4(TIM1, Compare);
 8000d12:	2c04      	cmp	r4, #4
 8000d14:	d1ed      	bne.n	8000cf2 <PWM_SetDutyCycle+0xa>
 8000d16:	4809      	ldr	r0, [pc, #36]	; (8000d3c <PWM_SetDutyCycle+0x54>)
 8000d18:	f006 fe22 	bl	8007960 <TIM_SetCompare4>
 8000d1c:	e7e9      	b.n	8000cf2 <PWM_SetDutyCycle+0xa>
	{
		uint32_t Compare = (uint32_t) (((uint32_t) DutyCycle * (TimerPeriod - 1)) / 100);

		if(Channel == PWM_CHANNEL_LED_RED  ) TIM_SetCompare1(TIM1, Compare);
		if(Channel == PWM_CHANNEL_LED_GREEN) TIM_SetCompare3(TIM1, Compare);
		if(Channel == PWM_CHANNEL_LED_BLUE ) TIM_SetCompare2(TIM1, Compare);
 8000d1e:	4807      	ldr	r0, [pc, #28]	; (8000d3c <PWM_SetDutyCycle+0x54>)
 8000d20:	f006 fe1a 	bl	8007958 <TIM_SetCompare2>
 8000d24:	e7e5      	b.n	8000cf2 <PWM_SetDutyCycle+0xa>
	if(PWM_Initialized == 1)
	{
		uint32_t Compare = (uint32_t) (((uint32_t) DutyCycle * (TimerPeriod - 1)) / 100);

		if(Channel == PWM_CHANNEL_LED_RED  ) TIM_SetCompare1(TIM1, Compare);
		if(Channel == PWM_CHANNEL_LED_GREEN) TIM_SetCompare3(TIM1, Compare);
 8000d26:	4805      	ldr	r0, [pc, #20]	; (8000d3c <PWM_SetDutyCycle+0x54>)
 8000d28:	f006 fe18 	bl	800795c <TIM_SetCompare3>
 8000d2c:	e7e1      	b.n	8000cf2 <PWM_SetDutyCycle+0xa>
{
	if(PWM_Initialized == 1)
	{
		uint32_t Compare = (uint32_t) (((uint32_t) DutyCycle * (TimerPeriod - 1)) / 100);

		if(Channel == PWM_CHANNEL_LED_RED  ) TIM_SetCompare1(TIM1, Compare);
 8000d2e:	4803      	ldr	r0, [pc, #12]	; (8000d3c <PWM_SetDutyCycle+0x54>)
 8000d30:	f006 fe10 	bl	8007954 <TIM_SetCompare1>
 8000d34:	e7dd      	b.n	8000cf2 <PWM_SetDutyCycle+0xa>
 8000d36:	46c0      	nop			; (mov r8, r8)
 8000d38:	2000013c 	.word	0x2000013c
 8000d3c:	40012c00 	.word	0x40012c00

08000d40 <LED_SetRGB>:

//==================================================================================================
//
//==================================================================================================
static void LED_SetRGB(uint8_t Red, uint8_t Green, uint8_t Blue)
{
 8000d40:	b538      	push	{r3, r4, r5, lr}
	if(gRed < Red)	        gRed++;
 8000d42:	4c20      	ldr	r4, [pc, #128]	; (8000dc4 <LED_SetRGB+0x84>)
 8000d44:	7823      	ldrb	r3, [r4, #0]
 8000d46:	4283      	cmp	r3, r0
 8000d48:	d235      	bcs.n	8000db6 <LED_SetRGB+0x76>
 8000d4a:	3301      	adds	r3, #1
 8000d4c:	b2db      	uxtb	r3, r3
 8000d4e:	7023      	strb	r3, [r4, #0]
	else if(gRed > Red)	    gRed--;

	if(gGreen < Green)	    gGreen++;
 8000d50:	7860      	ldrb	r0, [r4, #1]
 8000d52:	4288      	cmp	r0, r1
 8000d54:	d225      	bcs.n	8000da2 <LED_SetRGB+0x62>
 8000d56:	3001      	adds	r0, #1
 8000d58:	7060      	strb	r0, [r4, #1]
	else if(gGreen > Green)	gGreen--;

	if(gBlue < Blue)	    gBlue++;
 8000d5a:	78a1      	ldrb	r1, [r4, #2]
 8000d5c:	4291      	cmp	r1, r2
 8000d5e:	d327      	bcc.n	8000db0 <LED_SetRGB+0x70>
	else if(gBlue > Blue)	gBlue--;
 8000d60:	4291      	cmp	r1, r2
 8000d62:	d901      	bls.n	8000d68 <LED_SetRGB+0x28>
 8000d64:	3901      	subs	r1, #1
 8000d66:	70a1      	strb	r1, [r4, #2]

	PWM_SetDutyCycle (PWM_CHANNEL_LED_RED,   (100 * gRed  )/ 255 );
 8000d68:	2564      	movs	r5, #100	; 0x64
 8000d6a:	436b      	muls	r3, r5
 8000d6c:	21ff      	movs	r1, #255	; 0xff
 8000d6e:	1c18      	adds	r0, r3, #0
 8000d70:	f002 fd90 	bl	8003894 <__aeabi_idiv>
 8000d74:	b2c1      	uxtb	r1, r0
 8000d76:	2001      	movs	r0, #1
 8000d78:	f7ff ffb6 	bl	8000ce8 <PWM_SetDutyCycle>
	PWM_SetDutyCycle (PWM_CHANNEL_LED_GREEN, (100 * gGreen)/ 255 );
 8000d7c:	7860      	ldrb	r0, [r4, #1]
 8000d7e:	21ff      	movs	r1, #255	; 0xff
 8000d80:	4368      	muls	r0, r5
 8000d82:	f002 fd87 	bl	8003894 <__aeabi_idiv>
 8000d86:	b2c1      	uxtb	r1, r0
 8000d88:	2002      	movs	r0, #2
 8000d8a:	f7ff ffad 	bl	8000ce8 <PWM_SetDutyCycle>
	PWM_SetDutyCycle (PWM_CHANNEL_LED_BLUE,  (100 * gBlue )/ 255 );
 8000d8e:	78a0      	ldrb	r0, [r4, #2]
 8000d90:	21ff      	movs	r1, #255	; 0xff
 8000d92:	4368      	muls	r0, r5
 8000d94:	f002 fd7e 	bl	8003894 <__aeabi_idiv>
 8000d98:	b2c1      	uxtb	r1, r0
 8000d9a:	2003      	movs	r0, #3
 8000d9c:	f7ff ffa4 	bl	8000ce8 <PWM_SetDutyCycle>
}
 8000da0:	bd38      	pop	{r3, r4, r5, pc}
{
	if(gRed < Red)	        gRed++;
	else if(gRed > Red)	    gRed--;

	if(gGreen < Green)	    gGreen++;
	else if(gGreen > Green)	gGreen--;
 8000da2:	4288      	cmp	r0, r1
 8000da4:	d9d9      	bls.n	8000d5a <LED_SetRGB+0x1a>

	if(gBlue < Blue)	    gBlue++;
 8000da6:	78a1      	ldrb	r1, [r4, #2]
{
	if(gRed < Red)	        gRed++;
	else if(gRed > Red)	    gRed--;

	if(gGreen < Green)	    gGreen++;
	else if(gGreen > Green)	gGreen--;
 8000da8:	3801      	subs	r0, #1
 8000daa:	7060      	strb	r0, [r4, #1]

	if(gBlue < Blue)	    gBlue++;
 8000dac:	4291      	cmp	r1, r2
 8000dae:	d2d7      	bcs.n	8000d60 <LED_SetRGB+0x20>
 8000db0:	3101      	adds	r1, #1
 8000db2:	70a1      	strb	r1, [r4, #2]
 8000db4:	e7d8      	b.n	8000d68 <LED_SetRGB+0x28>
//
//==================================================================================================
static void LED_SetRGB(uint8_t Red, uint8_t Green, uint8_t Blue)
{
	if(gRed < Red)	        gRed++;
	else if(gRed > Red)	    gRed--;
 8000db6:	4283      	cmp	r3, r0
 8000db8:	d9ca      	bls.n	8000d50 <LED_SetRGB+0x10>
 8000dba:	3b01      	subs	r3, #1
 8000dbc:	b2db      	uxtb	r3, r3
 8000dbe:	7023      	strb	r3, [r4, #0]
 8000dc0:	e7c6      	b.n	8000d50 <LED_SetRGB+0x10>
 8000dc2:	46c0      	nop			; (mov r8, r8)
 8000dc4:	20000140 	.word	0x20000140

08000dc8 <LED_SetColor>:

//==================================================================================================
//
//==================================================================================================
static void LED_SetColor(uint8_t Led_Color)
{
 8000dc8:	b510      	push	{r4, lr}
 8000dca:	1e04      	subs	r4, r0, #0
	switch(Led_Color)
 8000dcc:	2c09      	cmp	r4, #9
 8000dce:	d803      	bhi.n	8000dd8 <LED_SetColor+0x10>
 8000dd0:	4a20      	ldr	r2, [pc, #128]	; (8000e54 <LED_SetColor+0x8c>)
 8000dd2:	0083      	lsls	r3, r0, #2
 8000dd4:	58d3      	ldr	r3, [r2, r3]
 8000dd6:	469f      	mov	pc, r3
			LED_SetRGB(255,0,20);
			break;
		}
		default:
		{
			LED_SetRGB(0,0,0);
 8000dd8:	2000      	movs	r0, #0
 8000dda:	2100      	movs	r1, #0
 8000ddc:	2200      	movs	r2, #0
 8000dde:	f7ff ffaf 	bl	8000d40 <LED_SetRGB>
			break;
		}
	}

	CurrentColor = Led_Color;
 8000de2:	4b1d      	ldr	r3, [pc, #116]	; (8000e58 <LED_SetColor+0x90>)
 8000de4:	70dc      	strb	r4, [r3, #3]
}
 8000de6:	bd10      	pop	{r4, pc}
			LED_SetRGB(255,0,0);
			break;
		}
		case LED_COLOR_PINK:
		{
			LED_SetRGB(255,0,20);
 8000de8:	20ff      	movs	r0, #255	; 0xff
 8000dea:	2100      	movs	r1, #0
 8000dec:	2214      	movs	r2, #20
 8000dee:	f7ff ffa7 	bl	8000d40 <LED_SetRGB>
			break;
 8000df2:	e7f6      	b.n	8000de2 <LED_SetColor+0x1a>
			LED_SetRGB(0,0,0);
			break;
		}
		case LED_COLOR_WHITE:
		{
			LED_SetRGB(255,255,255);
 8000df4:	20ff      	movs	r0, #255	; 0xff
 8000df6:	21ff      	movs	r1, #255	; 0xff
 8000df8:	22ff      	movs	r2, #255	; 0xff
 8000dfa:	f7ff ffa1 	bl	8000d40 <LED_SetRGB>
			break;
 8000dfe:	e7f0      	b.n	8000de2 <LED_SetColor+0x1a>
		}
		case LED_COLOR_LIGHT_BLUE:
		{
			LED_SetRGB(50,50,255);
 8000e00:	2032      	movs	r0, #50	; 0x32
 8000e02:	2132      	movs	r1, #50	; 0x32
 8000e04:	22ff      	movs	r2, #255	; 0xff
 8000e06:	f7ff ff9b 	bl	8000d40 <LED_SetRGB>
			break;
 8000e0a:	e7ea      	b.n	8000de2 <LED_SetColor+0x1a>
		}
		case LED_COLOR_BLUE:
		{
			LED_SetRGB(0,0,255);
 8000e0c:	2000      	movs	r0, #0
 8000e0e:	2100      	movs	r1, #0
 8000e10:	22ff      	movs	r2, #255	; 0xff
 8000e12:	f7ff ff95 	bl	8000d40 <LED_SetRGB>
			break;
 8000e16:	e7e4      	b.n	8000de2 <LED_SetColor+0x1a>
		}
		case LED_COLOR_LIGHT_GREEN:
		{
			LED_SetRGB(50,255,50);
 8000e18:	2032      	movs	r0, #50	; 0x32
 8000e1a:	21ff      	movs	r1, #255	; 0xff
 8000e1c:	2232      	movs	r2, #50	; 0x32
 8000e1e:	f7ff ff8f 	bl	8000d40 <LED_SetRGB>
			break;
 8000e22:	e7de      	b.n	8000de2 <LED_SetColor+0x1a>
		}
		case LED_COLOR_GREEN:
		{
			LED_SetRGB(0,255,0);
 8000e24:	2000      	movs	r0, #0
 8000e26:	21ff      	movs	r1, #255	; 0xff
 8000e28:	2200      	movs	r2, #0
 8000e2a:	f7ff ff89 	bl	8000d40 <LED_SetRGB>
			break;
 8000e2e:	e7d8      	b.n	8000de2 <LED_SetColor+0x1a>
		}
		case LED_COLOR_YELLOW:
		{
			LED_SetRGB(255,255,0);
 8000e30:	20ff      	movs	r0, #255	; 0xff
 8000e32:	21ff      	movs	r1, #255	; 0xff
 8000e34:	2200      	movs	r2, #0
 8000e36:	f7ff ff83 	bl	8000d40 <LED_SetRGB>
			break;
 8000e3a:	e7d2      	b.n	8000de2 <LED_SetColor+0x1a>
		}
		case LED_COLOR_ORANGE:
		{
			LED_SetRGB(255,50,0);
 8000e3c:	20ff      	movs	r0, #255	; 0xff
 8000e3e:	2132      	movs	r1, #50	; 0x32
 8000e40:	2200      	movs	r2, #0
 8000e42:	f7ff ff7d 	bl	8000d40 <LED_SetRGB>
			break;
 8000e46:	e7cc      	b.n	8000de2 <LED_SetColor+0x1a>
		}
		case LED_COLOR_RED:
		{
			LED_SetRGB(255,0,0);
 8000e48:	20ff      	movs	r0, #255	; 0xff
 8000e4a:	2100      	movs	r1, #0
 8000e4c:	2200      	movs	r2, #0
 8000e4e:	f7ff ff77 	bl	8000d40 <LED_SetRGB>
			break;
 8000e52:	e7c6      	b.n	8000de2 <LED_SetColor+0x1a>
 8000e54:	0800a6dc 	.word	0x0800a6dc
 8000e58:	20000140 	.word	0x20000140

08000e5c <LED_Init>:

//==================================================================================================
//
//==================================================================================================
void LED_Init(void)
{
 8000e5c:	b508      	push	{r3, lr}
	PWM_Init();
 8000e5e:	f7ff ff35 	bl	8000ccc <PWM_Init>

	gRed   = 0;
 8000e62:	2200      	movs	r2, #0
 8000e64:	4b03      	ldr	r3, [pc, #12]	; (8000e74 <LED_Init+0x18>)
 8000e66:	701a      	strb	r2, [r3, #0]
	gGreen = 0;
 8000e68:	705a      	strb	r2, [r3, #1]
	gBlue  = 0;
 8000e6a:	709a      	strb	r2, [r3, #2]

	Enable = LED_ENABLED;
 8000e6c:	3201      	adds	r2, #1
 8000e6e:	711a      	strb	r2, [r3, #4]
}
 8000e70:	bd08      	pop	{r3, pc}
 8000e72:	46c0      	nop			; (mov r8, r8)
 8000e74:	20000140 	.word	0x20000140

08000e78 <LED_Control>:
//==================================================================================================
//
//==================================================================================================
void LED_Control(uint8_t EnaDis)
{
	Enable = EnaDis;
 8000e78:	4b03      	ldr	r3, [pc, #12]	; (8000e88 <LED_Control+0x10>)
 8000e7a:	7118      	strb	r0, [r3, #4]

	if(Enable == LED_DISABLE)
 8000e7c:	2802      	cmp	r0, #2
 8000e7e:	d102      	bne.n	8000e86 <LED_Control+0xe>
	{
		LedCountDis = LED_TIME_TO_DISABLE;
 8000e80:	22fa      	movs	r2, #250	; 0xfa
 8000e82:	0092      	lsls	r2, r2, #2
 8000e84:	80da      	strh	r2, [r3, #6]
	}
}
 8000e86:	4770      	bx	lr
 8000e88:	20000140 	.word	0x20000140

08000e8c <LED_Task>:

//====================================================================================================
//
//====================================================================================================
void LED_Task ()
{
 8000e8c:	b508      	push	{r3, lr}
	if(Enable == LED_DISABLE)
 8000e8e:	4b47      	ldr	r3, [pc, #284]	; (8000fac <LED_Task+0x120>)
 8000e90:	791a      	ldrb	r2, [r3, #4]
 8000e92:	2a02      	cmp	r2, #2
 8000e94:	d00a      	beq.n	8000eac <LED_Task+0x20>
			LED_SetColor(LED_COLOR_OFF);
		}
	}
	else
	{
		switch(LedMode)
 8000e96:	7a1a      	ldrb	r2, [r3, #8]
 8000e98:	2a05      	cmp	r2, #5
 8000e9a:	d806      	bhi.n	8000eaa <LED_Task+0x1e>
 8000e9c:	4944      	ldr	r1, [pc, #272]	; (8000fb0 <LED_Task+0x124>)
 8000e9e:	0092      	lsls	r2, r2, #2
 8000ea0:	588a      	ldr	r2, [r1, r2]
 8000ea2:	4697      	mov	pc, r2
				break;
			}
			//--------------------------------------------
			case LED_FIXED:
			{
				LED_SetColor(ColorFixed);
 8000ea4:	7b18      	ldrb	r0, [r3, #12]
 8000ea6:	f7ff ff8f 	bl	8000dc8 <LED_SetColor>
			{
				break;
			}
		}
	}
}
 8000eaa:	bd08      	pop	{r3, pc}
//====================================================================================================
void LED_Task ()
{
	if(Enable == LED_DISABLE)
	{
		if(LedCountDis > 0) LedCountDis--;
 8000eac:	88da      	ldrh	r2, [r3, #6]
 8000eae:	2a00      	cmp	r2, #0
 8000eb0:	d103      	bne.n	8000eba <LED_Task+0x2e>
		switch(LedMode)
		{
			//--------------------------------------------
			case LED_OFF:
			{
				LED_SetColor(LED_COLOR_OFF);
 8000eb2:	2000      	movs	r0, #0
 8000eb4:	f7ff ff88 	bl	8000dc8 <LED_SetColor>
				break;
 8000eb8:	e7f7      	b.n	8000eaa <LED_Task+0x1e>
//====================================================================================================
void LED_Task ()
{
	if(Enable == LED_DISABLE)
	{
		if(LedCountDis > 0) LedCountDis--;
 8000eba:	3a01      	subs	r2, #1
 8000ebc:	b292      	uxth	r2, r2
 8000ebe:	80da      	strh	r2, [r3, #6]

		if(LedCountDis <= 0)
 8000ec0:	2a00      	cmp	r2, #0
 8000ec2:	d1f2      	bne.n	8000eaa <LED_Task+0x1e>
 8000ec4:	e7f5      	b.n	8000eb2 <LED_Task+0x26>
				break;
			}
			//--------------------------------------------
			case LED_TEMPERATURE:
			{
				LED_SetColorByTemperature(NTC_GetWaterTemperature(TEMPERATURE_OUTLET));
 8000ec6:	2002      	movs	r0, #2
 8000ec8:	f001 fe3e 	bl	8002b48 <NTC_GetWaterTemperature>
static uint8_t LED_ReturnColorByTemperature(int16_t Temperature)
{
	uint8_t ret = LED_COLOR_OFF;

	// less than 30 degrees -> LIGHT BLUE
	if((Temperature<=300) )
 8000ecc:	2296      	movs	r2, #150	; 0x96
	{
		ret = LED_COLOR_LIGHT_BLUE;
 8000ece:	2302      	movs	r3, #2
static uint8_t LED_ReturnColorByTemperature(int16_t Temperature)
{
	uint8_t ret = LED_COLOR_OFF;

	// less than 30 degrees -> LIGHT BLUE
	if((Temperature<=300) )
 8000ed0:	0052      	lsls	r2, r2, #1
 8000ed2:	4290      	cmp	r0, r2
 8000ed4:	dc49      	bgt.n	8000f6a <LED_Task+0xde>
//==================================================================================================
//
//==================================================================================================
static void LED_SetColorByTemperature(int16_t Temperature)
{
	LED_SetColor(LED_ReturnColorByTemperature(Temperature));
 8000ed6:	1c18      	adds	r0, r3, #0
 8000ed8:	f7ff ff76 	bl	8000dc8 <LED_SetColor>
 8000edc:	e7e5      	b.n	8000eaa <LED_Task+0x1e>
				break;
			}
			//--------------------------------------------
			case LED_POWER:
			{
				LED_SetColorByPower(TRIAC_GetPower());
 8000ede:	f000 feb7 	bl	8001c50 <TRIAC_GetPower>
 8000ee2:	1c03      	adds	r3, r0, #0
	uint8_t ret = LED_COLOR_OFF;

	// 0-12% -> WHITE
	if((Power>=0) && (Power<=12))
	{
		ret = LED_COLOR_WHITE;
 8000ee4:	2001      	movs	r0, #1
static uint8_t LED_ReturnColorByPower(uint8_t Power)
{
	uint8_t ret = LED_COLOR_OFF;

	// 0-12% -> WHITE
	if((Power>=0) && (Power<=12))
 8000ee6:	2b0c      	cmp	r3, #12
 8000ee8:	d9dd      	bls.n	8000ea6 <LED_Task+0x1a>
	{
		ret = LED_COLOR_WHITE;
	}
	// 13-25% -> LIGHT BLUE
	else if((Power>=13) && (Power<=25))
 8000eea:	1c1a      	adds	r2, r3, #0
 8000eec:	3a0d      	subs	r2, #13
 8000eee:	b2d2      	uxtb	r2, r2
	{
		ret = LED_COLOR_LIGHT_BLUE;
 8000ef0:	3001      	adds	r0, #1
	if((Power>=0) && (Power<=12))
	{
		ret = LED_COLOR_WHITE;
	}
	// 13-25% -> LIGHT BLUE
	else if((Power>=13) && (Power<=25))
 8000ef2:	2a0c      	cmp	r2, #12
 8000ef4:	d9d7      	bls.n	8000ea6 <LED_Task+0x1a>
	{
		ret = LED_COLOR_LIGHT_BLUE;
	}
	// 26-38% -> BLUE
	else if((Power>=26) && (Power<=38))
 8000ef6:	1c1a      	adds	r2, r3, #0
 8000ef8:	3a1a      	subs	r2, #26
 8000efa:	b2d2      	uxtb	r2, r2
	{
		ret = LED_COLOR_BLUE;
 8000efc:	3001      	adds	r0, #1
	else if((Power>=13) && (Power<=25))
	{
		ret = LED_COLOR_LIGHT_BLUE;
	}
	// 26-38% -> BLUE
	else if((Power>=26) && (Power<=38))
 8000efe:	2a0c      	cmp	r2, #12
 8000f00:	d9d1      	bls.n	8000ea6 <LED_Task+0x1a>
	{
		ret = LED_COLOR_BLUE;
	}
	// 39-51% -> LIGHT GREEN
	else if((Power>=39) && (Power<=51))
 8000f02:	1c1a      	adds	r2, r3, #0
 8000f04:	3a27      	subs	r2, #39	; 0x27
 8000f06:	b2d2      	uxtb	r2, r2
	{
		ret = LED_COLOR_LIGHT_GREEN;
 8000f08:	3001      	adds	r0, #1
	else if((Power>=26) && (Power<=38))
	{
		ret = LED_COLOR_BLUE;
	}
	// 39-51% -> LIGHT GREEN
	else if((Power>=39) && (Power<=51))
 8000f0a:	2a0c      	cmp	r2, #12
 8000f0c:	d9cb      	bls.n	8000ea6 <LED_Task+0x1a>
	{
		ret = LED_COLOR_LIGHT_GREEN;
	}
	// 52-64% -> GREEN
	else if((Power>=52) && (Power<=64))
 8000f0e:	1c1a      	adds	r2, r3, #0
 8000f10:	3a34      	subs	r2, #52	; 0x34
 8000f12:	b2d2      	uxtb	r2, r2
	{
		ret = LED_COLOR_GREEN;
 8000f14:	3001      	adds	r0, #1
	else if((Power>=39) && (Power<=51))
	{
		ret = LED_COLOR_LIGHT_GREEN;
	}
	// 52-64% -> GREEN
	else if((Power>=52) && (Power<=64))
 8000f16:	2a0c      	cmp	r2, #12
 8000f18:	d9c5      	bls.n	8000ea6 <LED_Task+0x1a>
	{
		ret = LED_COLOR_GREEN;
	}
	// 65-77% -> YELLOW
	else if((Power>=65) && (Power<=77))
 8000f1a:	1c1a      	adds	r2, r3, #0
 8000f1c:	3a41      	subs	r2, #65	; 0x41
 8000f1e:	b2d2      	uxtb	r2, r2
	{
		ret = LED_COLOR_YELLOW;
 8000f20:	3001      	adds	r0, #1
	else if((Power>=52) && (Power<=64))
	{
		ret = LED_COLOR_GREEN;
	}
	// 65-77% -> YELLOW
	else if((Power>=65) && (Power<=77))
 8000f22:	2a0c      	cmp	r2, #12
 8000f24:	d9bf      	bls.n	8000ea6 <LED_Task+0x1a>
		ret = LED_COLOR_ORANGE;
	}
	// 90-100% -> RED
	else if((Power>90))
	{
		ret = LED_COLOR_RED;
 8000f26:	2000      	movs	r0, #0
 8000f28:	220c      	movs	r2, #12
	else if((Power>=65) && (Power<=77))
	{
		ret = LED_COLOR_YELLOW;
	}
	// 78-90% -> ORANGE
	else if((Power>=78) && (Power<=90))
 8000f2a:	3b4e      	subs	r3, #78	; 0x4e
 8000f2c:	b2db      	uxtb	r3, r3
		ret = LED_COLOR_ORANGE;
	}
	// 90-100% -> RED
	else if((Power>90))
	{
		ret = LED_COLOR_RED;
 8000f2e:	429a      	cmp	r2, r3
 8000f30:	4140      	adcs	r0, r0
 8000f32:	2308      	movs	r3, #8
 8000f34:	1a18      	subs	r0, r3, r0
 8000f36:	e7b6      	b.n	8000ea6 <LED_Task+0x1a>
			case LED_AUTO:
			{
				// Change Color each Ex: 250*10ms = 2,5s
				LedCount++;

				if(LedCount > LED_TIME_TO_CHANGE)
 8000f38:	21e1      	movs	r1, #225	; 0xe1
			}
			//--------------------------------------------
			case LED_AUTO:
			{
				// Change Color each Ex: 250*10ms = 2,5s
				LedCount++;
 8000f3a:	895a      	ldrh	r2, [r3, #10]

				if(LedCount > LED_TIME_TO_CHANGE)
 8000f3c:	0049      	lsls	r1, r1, #1
			}
			//--------------------------------------------
			case LED_AUTO:
			{
				// Change Color each Ex: 250*10ms = 2,5s
				LedCount++;
 8000f3e:	3201      	adds	r2, #1
 8000f40:	b292      	uxth	r2, r2
 8000f42:	815a      	strh	r2, [r3, #10]

				if(LedCount > LED_TIME_TO_CHANGE)
 8000f44:	428a      	cmp	r2, r1
 8000f46:	d90d      	bls.n	8000f64 <LED_Task+0xd8>
				{
					col++;
 8000f48:	4a1a      	ldr	r2, [pc, #104]	; (8000fb4 <LED_Task+0x128>)
 8000f4a:	7810      	ldrb	r0, [r2, #0]
 8000f4c:	3001      	adds	r0, #1
 8000f4e:	b2c0      	uxtb	r0, r0
					if(col > LED_COLOR_PINK) col = LED_COLOR_WHITE;
 8000f50:	2809      	cmp	r0, #9
 8000f52:	d803      	bhi.n	8000f5c <LED_Task+0xd0>
				// Change Color each Ex: 250*10ms = 2,5s
				LedCount++;

				if(LedCount > LED_TIME_TO_CHANGE)
				{
					col++;
 8000f54:	7010      	strb	r0, [r2, #0]
					if(col > LED_COLOR_PINK) col = LED_COLOR_WHITE;
					LedCount = 0;
 8000f56:	2200      	movs	r2, #0
 8000f58:	815a      	strh	r2, [r3, #10]
 8000f5a:	e7a4      	b.n	8000ea6 <LED_Task+0x1a>
				LedCount++;

				if(LedCount > LED_TIME_TO_CHANGE)
				{
					col++;
					if(col > LED_COLOR_PINK) col = LED_COLOR_WHITE;
 8000f5c:	2101      	movs	r1, #1
 8000f5e:	2001      	movs	r0, #1
 8000f60:	7011      	strb	r1, [r2, #0]
 8000f62:	e7f8      	b.n	8000f56 <LED_Task+0xca>
 8000f64:	4b13      	ldr	r3, [pc, #76]	; (8000fb4 <LED_Task+0x128>)
 8000f66:	7818      	ldrb	r0, [r3, #0]
 8000f68:	e79d      	b.n	8000ea6 <LED_Task+0x1a>
	if((Temperature<=300) )
	{
		ret = LED_COLOR_LIGHT_BLUE;
	}
	// 31-32 degrees -> BLUE
	else if((Temperature>=310) && (Temperature<=320))
 8000f6a:	b282      	uxth	r2, r0
 8000f6c:	1c11      	adds	r1, r2, #0
 8000f6e:	3937      	subs	r1, #55	; 0x37
 8000f70:	39ff      	subs	r1, #255	; 0xff
	{
		ret = LED_COLOR_BLUE;
 8000f72:	3301      	adds	r3, #1
	if((Temperature<=300) )
	{
		ret = LED_COLOR_LIGHT_BLUE;
	}
	// 31-32 degrees -> BLUE
	else if((Temperature>=310) && (Temperature<=320))
 8000f74:	290a      	cmp	r1, #10
 8000f76:	d9ae      	bls.n	8000ed6 <LED_Task+0x4a>
	{
		ret = LED_COLOR_BLUE;
	}
	// 33-34 degrees -> LIGHT GREEN
	else if((Temperature>=330) && (Temperature<=340))
 8000f78:	3914      	subs	r1, #20
	{
		ret = LED_COLOR_LIGHT_GREEN;
 8000f7a:	3301      	adds	r3, #1
	else if((Temperature>=310) && (Temperature<=320))
	{
		ret = LED_COLOR_BLUE;
	}
	// 33-34 degrees -> LIGHT GREEN
	else if((Temperature>=330) && (Temperature<=340))
 8000f7c:	290a      	cmp	r1, #10
 8000f7e:	d9aa      	bls.n	8000ed6 <LED_Task+0x4a>
	{
		ret = LED_COLOR_LIGHT_GREEN;
	}
	// 35-36 degrees -> GREEN
	else if((Temperature>=350) && (Temperature<=360))
 8000f80:	3914      	subs	r1, #20
	{
		ret = LED_COLOR_GREEN;
 8000f82:	3301      	adds	r3, #1
	else if((Temperature>=330) && (Temperature<=340))
	{
		ret = LED_COLOR_LIGHT_GREEN;
	}
	// 35-36 degrees -> GREEN
	else if((Temperature>=350) && (Temperature<=360))
 8000f84:	290a      	cmp	r1, #10
 8000f86:	d9a6      	bls.n	8000ed6 <LED_Task+0x4a>
	{
		ret = LED_COLOR_GREEN;
	}
	// 37-38 degrees -> YELLOW
	else if((Temperature>=370) && (Temperature<=380))
 8000f88:	3914      	subs	r1, #20
	{
		ret = LED_COLOR_YELLOW;
 8000f8a:	3301      	adds	r3, #1
	else if((Temperature>=350) && (Temperature<=360))
	{
		ret = LED_COLOR_GREEN;
	}
	// 37-38 degrees -> YELLOW
	else if((Temperature>=370) && (Temperature<=380))
 8000f8c:	290a      	cmp	r1, #10
 8000f8e:	d9a2      	bls.n	8000ed6 <LED_Task+0x4a>
	{
		ret = LED_COLOR_YELLOW;
	}
	// 39-40% -> ORANGE
	else if((Temperature>=390) && (Temperature<=400))
 8000f90:	3a87      	subs	r2, #135	; 0x87
 8000f92:	3aff      	subs	r2, #255	; 0xff
	{
		ret = LED_COLOR_ORANGE;
 8000f94:	3301      	adds	r3, #1
	else if((Temperature>=370) && (Temperature<=380))
	{
		ret = LED_COLOR_YELLOW;
	}
	// 39-40% -> ORANGE
	else if((Temperature>=390) && (Temperature<=400))
 8000f96:	2a0a      	cmp	r2, #10
 8000f98:	d99d      	bls.n	8000ed6 <LED_Task+0x4a>
	{
		ret = LED_COLOR_ORANGE;
	}
	// more than 40 degrees -> RED
	else if((Temperature>400))
 8000f9a:	338a      	adds	r3, #138	; 0x8a
 8000f9c:	33ff      	adds	r3, #255	; 0xff
 8000f9e:	4298      	cmp	r0, r3
 8000fa0:	dd02      	ble.n	8000fa8 <LED_Task+0x11c>
	{
		ret = LED_COLOR_RED;
 8000fa2:	3b89      	subs	r3, #137	; 0x89
 8000fa4:	3bff      	subs	r3, #255	; 0xff
 8000fa6:	e796      	b.n	8000ed6 <LED_Task+0x4a>
//==================================================================================================
//
//==================================================================================================
static uint8_t LED_ReturnColorByTemperature(int16_t Temperature)
{
	uint8_t ret = LED_COLOR_OFF;
 8000fa8:	2300      	movs	r3, #0
 8000faa:	e794      	b.n	8000ed6 <LED_Task+0x4a>
 8000fac:	20000140 	.word	0x20000140
 8000fb0:	0800a704 	.word	0x0800a704
 8000fb4:	2000001c 	.word	0x2000001c

08000fb8 <LED_SetFixedColor>:
//==================================================================================================
//
//==================================================================================================
void LED_SetFixedColor(uint8_t Led_Color)
{
	ColorFixed = Led_Color;
 8000fb8:	4b01      	ldr	r3, [pc, #4]	; (8000fc0 <LED_SetFixedColor+0x8>)
 8000fba:	7318      	strb	r0, [r3, #12]
}
 8000fbc:	4770      	bx	lr
 8000fbe:	46c0      	nop			; (mov r8, r8)
 8000fc0:	20000140 	.word	0x20000140

08000fc4 <LED_GetColor>:
//==================================================================================================
//
//==================================================================================================
uint8_t LED_GetColor()
{
	return CurrentColor;
 8000fc4:	4b01      	ldr	r3, [pc, #4]	; (8000fcc <LED_GetColor+0x8>)
 8000fc6:	78d8      	ldrb	r0, [r3, #3]
}
 8000fc8:	4770      	bx	lr
 8000fca:	46c0      	nop			; (mov r8, r8)
 8000fcc:	20000140 	.word	0x20000140

08000fd0 <LED_SetMode>:
//==================================================================================================
//
//==================================================================================================
void LED_SetMode(uint8_t Led_Mode)
{
	LedMode = Led_Mode;
 8000fd0:	4b01      	ldr	r3, [pc, #4]	; (8000fd8 <LED_SetMode+0x8>)
 8000fd2:	7218      	strb	r0, [r3, #8]
}
 8000fd4:	4770      	bx	lr
 8000fd6:	46c0      	nop			; (mov r8, r8)
 8000fd8:	20000140 	.word	0x20000140

08000fdc <Display_Init>:

//==================================================================================================
//
//==================================================================================================
void Display_Init(void)
{
 8000fdc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000fde:	464f      	mov	r7, r9
 8000fe0:	4646      	mov	r6, r8
	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOC Periph clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 8000fe2:	2080      	movs	r0, #128	; 0x80

//==================================================================================================
//
//==================================================================================================
void Display_Init(void)
{
 8000fe4:	b4c0      	push	{r6, r7}
	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOC Periph clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 8000fe6:	02c0      	lsls	r0, r0, #11

//==================================================================================================
//
//==================================================================================================
void Display_Init(void)
{
 8000fe8:	b083      	sub	sp, #12
	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOC Periph clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 8000fea:	2101      	movs	r1, #1
 8000fec:	f005 fb38 	bl	8006660 <RCC_AHBPeriphClockCmd>
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8000ff0:	2080      	movs	r0, #128	; 0x80
 8000ff2:	2101      	movs	r1, #1
 8000ff4:	0280      	lsls	r0, r0, #10
 8000ff6:	f005 fb33 	bl	8006660 <RCC_AHBPeriphClockCmd>
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOF, ENABLE);
 8000ffa:	2080      	movs	r0, #128	; 0x80
 8000ffc:	2101      	movs	r1, #1
 8000ffe:	03c0      	lsls	r0, r0, #15
 8001000:	f005 fb2e 	bl	8006660 <RCC_AHBPeriphClockCmd>

	/* A, B, C, D, E, F segments */
	GPIO_InitStructure.GPIO_Pin   = DISP_A|DISP_B|DISP_C|DISP_D|DISP_E|DISP_F;
 8001004:	4b31      	ldr	r3, [pc, #196]	; (80010cc <Display_Init+0xf0>)
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8001006:	2400      	movs	r4, #0
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOF, ENABLE);

	/* A, B, C, D, E, F segments */
	GPIO_InitStructure.GPIO_Pin   = DISP_A|DISP_B|DISP_C|DISP_D|DISP_E|DISP_F;
 8001008:	9300      	str	r3, [sp, #0]
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
 800100a:	2301      	movs	r3, #1
 800100c:	4698      	mov	r8, r3
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800100e:	2703      	movs	r7, #3
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOF, ENABLE);

	/* A, B, C, D, E, F segments */
	GPIO_InitStructure.GPIO_Pin   = DISP_A|DISP_B|DISP_C|DISP_D|DISP_E|DISP_F;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
 8001010:	466b      	mov	r3, sp
 8001012:	4642      	mov	r2, r8
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001014:	4d2e      	ldr	r5, [pc, #184]	; (80010d0 <Display_Init+0xf4>)
 8001016:	4669      	mov	r1, sp
 8001018:	1c28      	adds	r0, r5, #0
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOF, ENABLE);

	/* A, B, C, D, E, F segments */
	GPIO_InitStructure.GPIO_Pin   = DISP_A|DISP_B|DISP_C|DISP_D|DISP_E|DISP_F;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
 800101a:	711a      	strb	r2, [r3, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800101c:	719c      	strb	r4, [r3, #6]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800101e:	715f      	strb	r7, [r3, #5]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 8001020:	71dc      	strb	r4, [r3, #7]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001022:	f004 ff03 	bl	8005e2c <GPIO_Init>

	/* DOT segment and Display Select */
	GPIO_InitStructure.GPIO_Pin   = DISP_DOT|DISP_UN;
 8001026:	23c0      	movs	r3, #192	; 0xc0
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
 8001028:	4642      	mov	r2, r8
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	/* DOT segment and Display Select */
	GPIO_InitStructure.GPIO_Pin   = DISP_DOT|DISP_UN;
 800102a:	9300      	str	r3, [sp, #0]
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
 800102c:	466b      	mov	r3, sp
 800102e:	711a      	strb	r2, [r3, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8001030:	719c      	strb	r4, [r3, #6]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001032:	715f      	strb	r7, [r3, #5]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 8001034:	71dc      	strb	r4, [r3, #7]
	GPIO_Init(GPIOF, &GPIO_InitStructure);
 8001036:	4b27      	ldr	r3, [pc, #156]	; (80010d4 <Display_Init+0xf8>)
 8001038:	4669      	mov	r1, sp
 800103a:	1c18      	adds	r0, r3, #0
 800103c:	4699      	mov	r9, r3
 800103e:	f004 fef5 	bl	8005e2c <GPIO_Init>

	/* G segment */
	GPIO_InitStructure.GPIO_Pin   = DISP_G;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
 8001042:	466b      	mov	r3, sp
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001044:	715f      	strb	r7, [r3, #5]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8001046:	2790      	movs	r7, #144	; 0x90
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOF, &GPIO_InitStructure);

	/* G segment */
	GPIO_InitStructure.GPIO_Pin   = DISP_G;
 8001048:	2680      	movs	r6, #128	; 0x80
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
 800104a:	4642      	mov	r2, r8
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800104c:	05ff      	lsls	r7, r7, #23
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOF, &GPIO_InitStructure);

	/* G segment */
	GPIO_InitStructure.GPIO_Pin   = DISP_G;
 800104e:	0176      	lsls	r6, r6, #5
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8001050:	1c38      	adds	r0, r7, #0
 8001052:	4669      	mov	r1, sp
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOF, &GPIO_InitStructure);

	/* G segment */
	GPIO_InitStructure.GPIO_Pin   = DISP_G;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
 8001054:	711a      	strb	r2, [r3, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8001056:	719c      	strb	r4, [r3, #6]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 8001058:	71dc      	strb	r4, [r3, #7]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOF, &GPIO_InitStructure);

	/* G segment */
	GPIO_InitStructure.GPIO_Pin   = DISP_G;
 800105a:	9600      	str	r6, [sp, #0]
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800105c:	f004 fee6 	bl	8005e2c <GPIO_Init>

	//Clear all display pins
	GPIO_WriteBit(GPIOB, DISP_A,0);
 8001060:	1c28      	adds	r0, r5, #0
 8001062:	2104      	movs	r1, #4
 8001064:	2200      	movs	r2, #0
 8001066:	f004 ff7b 	bl	8005f60 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOB, DISP_B,0);
 800106a:	2180      	movs	r1, #128	; 0x80
 800106c:	1c28      	adds	r0, r5, #0
 800106e:	0189      	lsls	r1, r1, #6
 8001070:	2200      	movs	r2, #0
 8001072:	f004 ff75 	bl	8005f60 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOB, DISP_C,0);
 8001076:	2180      	movs	r1, #128	; 0x80
 8001078:	1c28      	adds	r0, r5, #0
 800107a:	01c9      	lsls	r1, r1, #7
 800107c:	2200      	movs	r2, #0
 800107e:	f004 ff6f 	bl	8005f60 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOB, DISP_D,0);
 8001082:	1c28      	adds	r0, r5, #0
 8001084:	1c31      	adds	r1, r6, #0
 8001086:	2200      	movs	r2, #0
 8001088:	f004 ff6a 	bl	8005f60 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOB, DISP_E,0);
 800108c:	2180      	movs	r1, #128	; 0x80
 800108e:	1c28      	adds	r0, r5, #0
 8001090:	00c9      	lsls	r1, r1, #3
 8001092:	2200      	movs	r2, #0
 8001094:	f004 ff64 	bl	8005f60 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOB, DISP_F,0);
 8001098:	2180      	movs	r1, #128	; 0x80
 800109a:	1c28      	adds	r0, r5, #0
 800109c:	0109      	lsls	r1, r1, #4
 800109e:	2200      	movs	r2, #0
 80010a0:	f004 ff5e 	bl	8005f60 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOA, DISP_G,0);
 80010a4:	1c38      	adds	r0, r7, #0
 80010a6:	1c31      	adds	r1, r6, #0
 80010a8:	2200      	movs	r2, #0
 80010aa:	f004 ff59 	bl	8005f60 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOF, DISP_DOT,0);
 80010ae:	4648      	mov	r0, r9
 80010b0:	2140      	movs	r1, #64	; 0x40
 80010b2:	2200      	movs	r2, #0
 80010b4:	f004 ff54 	bl	8005f60 <GPIO_WriteBit>

	DigitRight = 0x00;
 80010b8:	4b07      	ldr	r3, [pc, #28]	; (80010d8 <Display_Init+0xfc>)
 80010ba:	701c      	strb	r4, [r3, #0]
	DigitLeft  = 0x00;
 80010bc:	705c      	strb	r4, [r3, #1]

	PointMiddle = 0;
 80010be:	709c      	strb	r4, [r3, #2]
	PointRight  = 0;
 80010c0:	70dc      	strb	r4, [r3, #3]
}
 80010c2:	b003      	add	sp, #12
 80010c4:	bc0c      	pop	{r2, r3}
 80010c6:	4690      	mov	r8, r2
 80010c8:	4699      	mov	r9, r3
 80010ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80010cc:	00007c04 	.word	0x00007c04
 80010d0:	48000400 	.word	0x48000400
 80010d4:	48001400 	.word	0x48001400
 80010d8:	2000014e 	.word	0x2000014e

080010dc <Display_ParallelInterface>:

//==================================================================================================
// Update Display
//==================================================================================================
void Display_ParallelInterface(uint8_t ucByte)
{
 80010dc:	b570      	push	{r4, r5, r6, lr}
			uint8_t _bDP:1;
		}_Bits;
	}Scc;

	Scc._Byte = ucByte;
	GPIO_WriteBit(GPIOB, DISP_A,  (BitAction)Scc._Bits._bA);
 80010de:	07c2      	lsls	r2, r0, #31
 80010e0:	4d1c      	ldr	r5, [pc, #112]	; (8001154 <Display_ParallelInterface+0x78>)
 80010e2:	0fd2      	lsrs	r2, r2, #31

//==================================================================================================
// Update Display
//==================================================================================================
void Display_ParallelInterface(uint8_t ucByte)
{
 80010e4:	1c04      	adds	r4, r0, #0
			uint8_t _bDP:1;
		}_Bits;
	}Scc;

	Scc._Byte = ucByte;
	GPIO_WriteBit(GPIOB, DISP_A,  (BitAction)Scc._Bits._bA);
 80010e6:	b2d2      	uxtb	r2, r2
 80010e8:	1c28      	adds	r0, r5, #0
 80010ea:	2104      	movs	r1, #4
 80010ec:	f004 ff38 	bl	8005f60 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOB, DISP_B,  (BitAction)Scc._Bits._bB);
 80010f0:	2180      	movs	r1, #128	; 0x80
 80010f2:	07a2      	lsls	r2, r4, #30
 80010f4:	1c28      	adds	r0, r5, #0
 80010f6:	0fd2      	lsrs	r2, r2, #31
 80010f8:	0189      	lsls	r1, r1, #6
 80010fa:	f004 ff31 	bl	8005f60 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOB, DISP_C,  (BitAction)Scc._Bits._bC);
 80010fe:	2180      	movs	r1, #128	; 0x80
	GPIO_WriteBit(GPIOB, DISP_D,  (BitAction)Scc._Bits._bD);
 8001100:	2680      	movs	r6, #128	; 0x80
	}Scc;

	Scc._Byte = ucByte;
	GPIO_WriteBit(GPIOB, DISP_A,  (BitAction)Scc._Bits._bA);
	GPIO_WriteBit(GPIOB, DISP_B,  (BitAction)Scc._Bits._bB);
	GPIO_WriteBit(GPIOB, DISP_C,  (BitAction)Scc._Bits._bC);
 8001102:	0762      	lsls	r2, r4, #29
 8001104:	1c28      	adds	r0, r5, #0
 8001106:	0fd2      	lsrs	r2, r2, #31
 8001108:	01c9      	lsls	r1, r1, #7
 800110a:	f004 ff29 	bl	8005f60 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOB, DISP_D,  (BitAction)Scc._Bits._bD);
 800110e:	0176      	lsls	r6, r6, #5
 8001110:	0722      	lsls	r2, r4, #28
 8001112:	1c28      	adds	r0, r5, #0
 8001114:	1c31      	adds	r1, r6, #0
 8001116:	0fd2      	lsrs	r2, r2, #31
 8001118:	f004 ff22 	bl	8005f60 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOB, DISP_E,  (BitAction)Scc._Bits._bE);
 800111c:	2180      	movs	r1, #128	; 0x80
 800111e:	06e2      	lsls	r2, r4, #27
 8001120:	1c28      	adds	r0, r5, #0
 8001122:	0fd2      	lsrs	r2, r2, #31
 8001124:	00c9      	lsls	r1, r1, #3
 8001126:	f004 ff1b 	bl	8005f60 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOB, DISP_F,  (BitAction)Scc._Bits._bF);
 800112a:	2180      	movs	r1, #128	; 0x80
 800112c:	06a2      	lsls	r2, r4, #26
 800112e:	1c28      	adds	r0, r5, #0
 8001130:	0fd2      	lsrs	r2, r2, #31
 8001132:	0109      	lsls	r1, r1, #4
 8001134:	f004 ff14 	bl	8005f60 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOA, DISP_G,  (BitAction)Scc._Bits._bG);
 8001138:	2090      	movs	r0, #144	; 0x90
 800113a:	0662      	lsls	r2, r4, #25
 800113c:	1c31      	adds	r1, r6, #0
 800113e:	0fd2      	lsrs	r2, r2, #31
 8001140:	05c0      	lsls	r0, r0, #23
 8001142:	f004 ff0d 	bl	8005f60 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOF, DISP_DOT,(BitAction)Scc._Bits._bDP);
 8001146:	09e2      	lsrs	r2, r4, #7
 8001148:	4803      	ldr	r0, [pc, #12]	; (8001158 <Display_ParallelInterface+0x7c>)
 800114a:	2140      	movs	r1, #64	; 0x40
 800114c:	f004 ff08 	bl	8005f60 <GPIO_WriteBit>

}
 8001150:	bd70      	pop	{r4, r5, r6, pc}
 8001152:	46c0      	nop			; (mov r8, r8)
 8001154:	48000400 	.word	0x48000400
 8001158:	48001400 	.word	0x48001400

0800115c <Display_ASCIITable>:

//==================================================================================================
// Char table
//==================================================================================================
uint8_t Display_ASCIITable(uint8_t ch)
{
 800115c:	1c03      	adds	r3, r0, #0
 800115e:	3b20      	subs	r3, #32
 8001160:	b2db      	uxtb	r3, r3
 8001162:	2000      	movs	r0, #0
 8001164:	2b90      	cmp	r3, #144	; 0x90
 8001166:	d801      	bhi.n	800116c <Display_ASCIITable+0x10>
 8001168:	4a01      	ldr	r2, [pc, #4]	; (8001170 <Display_ASCIITable+0x14>)
 800116a:	5cd0      	ldrb	r0, [r2, r3]
			Return_Char = 0;
			break;
		}
	}
	return Return_Char;
}
 800116c:	4770      	bx	lr
 800116e:	46c0      	nop			; (mov r8, r8)
 8001170:	0800a71c 	.word	0x0800a71c

08001174 <Display_UpdateChar>:

//==================================================================================================
// Updates Displays Char
//==================================================================================================
void Display_UpdateChar(uint8_t CharLeft, uint8_t CharRight)
{
 8001174:	3920      	subs	r1, #32
 8001176:	b2c9      	uxtb	r1, r1
 8001178:	2200      	movs	r2, #0
 800117a:	2990      	cmp	r1, #144	; 0x90
 800117c:	d801      	bhi.n	8001182 <Display_UpdateChar+0xe>
 800117e:	4b08      	ldr	r3, [pc, #32]	; (80011a0 <Display_UpdateChar+0x2c>)
 8001180:	5c5a      	ldrb	r2, [r3, r1]
	DigitRight  = Display_ASCIITable(CharRight);
 8001182:	4b08      	ldr	r3, [pc, #32]	; (80011a4 <Display_UpdateChar+0x30>)
 8001184:	3820      	subs	r0, #32
 8001186:	b2c0      	uxtb	r0, r0
 8001188:	701a      	strb	r2, [r3, #0]
 800118a:	2200      	movs	r2, #0
 800118c:	2890      	cmp	r0, #144	; 0x90
 800118e:	d801      	bhi.n	8001194 <Display_UpdateChar+0x20>
 8001190:	4a03      	ldr	r2, [pc, #12]	; (80011a0 <Display_UpdateChar+0x2c>)
 8001192:	5c12      	ldrb	r2, [r2, r0]
	DigitLeft   = Display_ASCIITable(CharLeft);
 8001194:	705a      	strb	r2, [r3, #1]
	PointMiddle = 0;
 8001196:	2200      	movs	r2, #0
 8001198:	709a      	strb	r2, [r3, #2]
	PointRight  = 0;
 800119a:	70da      	strb	r2, [r3, #3]
}
 800119c:	4770      	bx	lr
 800119e:	46c0      	nop			; (mov r8, r8)
 80011a0:	0800a71c 	.word	0x0800a71c
 80011a4:	2000014e 	.word	0x2000014e

080011a8 <Display_UpdateChar2>:

//==================================================================================================
//
//==================================================================================================
void Display_UpdateChar2(char *Char)
{
 80011a8:	7843      	ldrb	r3, [r0, #1]
	DigitRight  = Display_ASCIITable(Char[1]);
 80011aa:	2100      	movs	r1, #0
 80011ac:	3b20      	subs	r3, #32
 80011ae:	b2db      	uxtb	r3, r3
 80011b0:	2b90      	cmp	r3, #144	; 0x90
 80011b2:	d801      	bhi.n	80011b8 <Display_UpdateChar2+0x10>
 80011b4:	4a08      	ldr	r2, [pc, #32]	; (80011d8 <Display_UpdateChar2+0x30>)
 80011b6:	5cd1      	ldrb	r1, [r2, r3]
 80011b8:	4a08      	ldr	r2, [pc, #32]	; (80011dc <Display_UpdateChar2+0x34>)
 80011ba:	7011      	strb	r1, [r2, #0]
 80011bc:	7803      	ldrb	r3, [r0, #0]
	DigitLeft   = Display_ASCIITable(Char[0]);
 80011be:	2100      	movs	r1, #0
 80011c0:	3b20      	subs	r3, #32
 80011c2:	b2db      	uxtb	r3, r3
 80011c4:	2b90      	cmp	r3, #144	; 0x90
 80011c6:	d801      	bhi.n	80011cc <Display_UpdateChar2+0x24>
 80011c8:	4903      	ldr	r1, [pc, #12]	; (80011d8 <Display_UpdateChar2+0x30>)
 80011ca:	5cc9      	ldrb	r1, [r1, r3]
	PointMiddle = 0;
 80011cc:	2300      	movs	r3, #0
//
//==================================================================================================
void Display_UpdateChar2(char *Char)
{
	DigitRight  = Display_ASCIITable(Char[1]);
	DigitLeft   = Display_ASCIITable(Char[0]);
 80011ce:	7051      	strb	r1, [r2, #1]
	PointMiddle = 0;
 80011d0:	7093      	strb	r3, [r2, #2]
	PointRight  = 0;
 80011d2:	70d3      	strb	r3, [r2, #3]
}
 80011d4:	4770      	bx	lr
 80011d6:	46c0      	nop			; (mov r8, r8)
 80011d8:	0800a71c 	.word	0x0800a71c
 80011dc:	2000014e 	.word	0x2000014e

080011e0 <Display_UpdatePoints>:
//==================================================================================================
//
//==================================================================================================
void Display_UpdatePoints(uint8_t Value, uint8_t Point)
{
	if(Point & DISPLAY_POINT_MIDDLE) PointMiddle = Value;
 80011e0:	07cb      	lsls	r3, r1, #31
 80011e2:	d501      	bpl.n	80011e8 <Display_UpdatePoints+0x8>
 80011e4:	4b03      	ldr	r3, [pc, #12]	; (80011f4 <Display_UpdatePoints+0x14>)
 80011e6:	7098      	strb	r0, [r3, #2]
	if(Point & DISPLAY_POINT_RIGHT ) PointRight  = Value;
 80011e8:	06cb      	lsls	r3, r1, #27
 80011ea:	d501      	bpl.n	80011f0 <Display_UpdatePoints+0x10>
 80011ec:	4b01      	ldr	r3, [pc, #4]	; (80011f4 <Display_UpdatePoints+0x14>)
 80011ee:	70d8      	strb	r0, [r3, #3]
}
 80011f0:	4770      	bx	lr
 80011f2:	46c0      	nop			; (mov r8, r8)
 80011f4:	2000014e 	.word	0x2000014e

080011f8 <Display_UpdateDecimal>:
//==================================================================================================
//
//==================================================================================================
void Display_UpdateDecimal(uint8_t DecimalDigitLeft, uint8_t DecimalDigitRight)
{
	DigitRight = NUMBER_TABLE[DecimalDigitLeft];
 80011f8:	4a03      	ldr	r2, [pc, #12]	; (8001208 <Display_UpdateDecimal+0x10>)
 80011fa:	4b04      	ldr	r3, [pc, #16]	; (800120c <Display_UpdateDecimal+0x14>)
 80011fc:	5c10      	ldrb	r0, [r2, r0]
	DigitLeft  = NUMBER_TABLE[DecimalDigitRight];
 80011fe:	5c52      	ldrb	r2, [r2, r1]
//==================================================================================================
//
//==================================================================================================
void Display_UpdateDecimal(uint8_t DecimalDigitLeft, uint8_t DecimalDigitRight)
{
	DigitRight = NUMBER_TABLE[DecimalDigitLeft];
 8001200:	7018      	strb	r0, [r3, #0]
	DigitLeft  = NUMBER_TABLE[DecimalDigitRight];
 8001202:	705a      	strb	r2, [r3, #1]
}
 8001204:	4770      	bx	lr
 8001206:	46c0      	nop			; (mov r8, r8)
 8001208:	20000020 	.word	0x20000020
 800120c:	2000014e 	.word	0x2000014e

08001210 <Display_Task>:

//==================================================================================================
//
//==================================================================================================
void Display_Task(void)
{
 8001210:	b510      	push	{r4, lr}
	static uint8_t DigitSelect;

	if(DigitSelect == DISPLAY_DIGIT_RIGHT)
 8001212:	4c17      	ldr	r4, [pc, #92]	; (8001270 <Display_Task+0x60>)
	{
		Display_ParallelInterface(_SP_);
 8001214:	2000      	movs	r0, #0
//==================================================================================================
void Display_Task(void)
{
	static uint8_t DigitSelect;

	if(DigitSelect == DISPLAY_DIGIT_RIGHT)
 8001216:	7923      	ldrb	r3, [r4, #4]
 8001218:	2b00      	cmp	r3, #0
 800121a:	d10f      	bne.n	800123c <Display_Task+0x2c>
	{
		Display_ParallelInterface(_SP_);
 800121c:	f7ff ff5e 	bl	80010dc <Display_ParallelInterface>

		/* Enables Digit Right, DISP_UN = 0 */
		GPIO_WriteBit(GPIOF, DISP_UN, (BitAction)DISPLAY_DIGIT_RIGHT);
 8001220:	4814      	ldr	r0, [pc, #80]	; (8001274 <Display_Task+0x64>)
 8001222:	2180      	movs	r1, #128	; 0x80
 8001224:	2200      	movs	r2, #0
 8001226:	f004 fe9b 	bl	8005f60 <GPIO_WriteBit>

		if(PointRight)
 800122a:	78e3      	ldrb	r3, [r4, #3]
		{
			Display_ParallelInterface(DigitRight | 0x80);
 800122c:	7820      	ldrb	r0, [r4, #0]
		Display_ParallelInterface(_SP_);

		/* Enables Digit Right, DISP_UN = 0 */
		GPIO_WriteBit(GPIOF, DISP_UN, (BitAction)DISPLAY_DIGIT_RIGHT);

		if(PointRight)
 800122e:	2b00      	cmp	r3, #0
 8001230:	d119      	bne.n	8001266 <Display_Task+0x56>
		{
			Display_ParallelInterface(DigitRight | 0x80);
		}
		else
		{
			Display_ParallelInterface(DigitRight);
 8001232:	f7ff ff53 	bl	80010dc <Display_ParallelInterface>
		}

		DigitSelect = DISPLAY_DIGIT_LEFT;
 8001236:	2301      	movs	r3, #1
 8001238:	7123      	strb	r3, [r4, #4]
 800123a:	e00e      	b.n	800125a <Display_Task+0x4a>
	}
	else // DigitSelect != DISPLAY_DIGIT_LEFT)
	{
		Display_ParallelInterface(_SP_);
 800123c:	f7ff ff4e 	bl	80010dc <Display_ParallelInterface>

		/* Enables Digit Left, DISP_UN = 1 */
		GPIO_WriteBit(GPIOF, DISP_UN, (BitAction)DISPLAY_DIGIT_LEFT);
 8001240:	480c      	ldr	r0, [pc, #48]	; (8001274 <Display_Task+0x64>)
 8001242:	2180      	movs	r1, #128	; 0x80
 8001244:	2201      	movs	r2, #1
 8001246:	f004 fe8b 	bl	8005f60 <GPIO_WriteBit>

		if(PointMiddle)
 800124a:	78a3      	ldrb	r3, [r4, #2]
		{
			Display_ParallelInterface(DigitLeft | 0x80);
 800124c:	7860      	ldrb	r0, [r4, #1]
		Display_ParallelInterface(_SP_);

		/* Enables Digit Left, DISP_UN = 1 */
		GPIO_WriteBit(GPIOF, DISP_UN, (BitAction)DISPLAY_DIGIT_LEFT);

		if(PointMiddle)
 800124e:	2b00      	cmp	r3, #0
 8001250:	d104      	bne.n	800125c <Display_Task+0x4c>
		{
			Display_ParallelInterface(DigitLeft | 0x80);
		}
		else
		{
			Display_ParallelInterface(DigitLeft);
 8001252:	f7ff ff43 	bl	80010dc <Display_ParallelInterface>
		}

		DigitSelect = DISPLAY_DIGIT_RIGHT;
 8001256:	2300      	movs	r3, #0
 8001258:	7123      	strb	r3, [r4, #4]
	}
}
 800125a:	bd10      	pop	{r4, pc}
		/* Enables Digit Left, DISP_UN = 1 */
		GPIO_WriteBit(GPIOF, DISP_UN, (BitAction)DISPLAY_DIGIT_LEFT);

		if(PointMiddle)
		{
			Display_ParallelInterface(DigitLeft | 0x80);
 800125c:	2380      	movs	r3, #128	; 0x80
 800125e:	4318      	orrs	r0, r3
 8001260:	f7ff ff3c 	bl	80010dc <Display_ParallelInterface>
 8001264:	e7f7      	b.n	8001256 <Display_Task+0x46>
		/* Enables Digit Right, DISP_UN = 0 */
		GPIO_WriteBit(GPIOF, DISP_UN, (BitAction)DISPLAY_DIGIT_RIGHT);

		if(PointRight)
		{
			Display_ParallelInterface(DigitRight | 0x80);
 8001266:	2380      	movs	r3, #128	; 0x80
 8001268:	4318      	orrs	r0, r3
 800126a:	f7ff ff37 	bl	80010dc <Display_ParallelInterface>
 800126e:	e7e2      	b.n	8001236 <Display_Task+0x26>
 8001270:	2000014e 	.word	0x2000014e
 8001274:	48001400 	.word	0x48001400

08001278 <Display_UpdateValue>:
//==================================================================================================
//
//==================================================================================================
void Display_UpdateValue(int32_t Value)
{
	if((Value > -19) && (Value < 0)) // -X to -1.0
 8001278:	1c03      	adds	r3, r0, #0
 800127a:	3312      	adds	r3, #18

//==================================================================================================
//
//==================================================================================================
void Display_UpdateValue(int32_t Value)
{
 800127c:	b570      	push	{r4, r5, r6, lr}
 800127e:	1c04      	adds	r4, r0, #0
	if((Value > -19) && (Value < 0)) // -X to -1.0
 8001280:	2b11      	cmp	r3, #17
 8001282:	d923      	bls.n	80012cc <Display_UpdateValue+0x54>
		DigitLeft  = _SEG_G_;

		PointMiddle = 1;
		PointRight  = 0;
	}
	else if((Value >= 0) && (Value < 10))  // 0 to 0.9
 8001284:	2809      	cmp	r0, #9
 8001286:	d916      	bls.n	80012b6 <Display_UpdateValue+0x3e>
		DigitLeft  = NUMBER_TABLE[0];

		PointMiddle = 1;
		PointRight  = 0;
	}
	else if(Value < 100) // 1.0 to 9.9
 8001288:	2863      	cmp	r0, #99	; 0x63
 800128a:	dd2e      	ble.n	80012ea <Display_UpdateValue+0x72>
		PointMiddle = 1;
		PointRight  = 0;
	}
	else if(Value >= 100)  // 10.0 to X
	{
		int32_t val = Value/10;
 800128c:	210a      	movs	r1, #10
 800128e:	f002 fb01 	bl	8003894 <__aeabi_idiv>

		DigitRight = NUMBER_TABLE[val%10];
 8001292:	210a      	movs	r1, #10
		PointMiddle = 1;
		PointRight  = 0;
	}
	else if(Value >= 100)  // 10.0 to X
	{
		int32_t val = Value/10;
 8001294:	1c06      	adds	r6, r0, #0

		DigitRight = NUMBER_TABLE[val%10];
 8001296:	f002 fbe3 	bl	8003a60 <__aeabi_idivmod>
 800129a:	4d1a      	ldr	r5, [pc, #104]	; (8001304 <Display_UpdateValue+0x8c>)
 800129c:	4c1a      	ldr	r4, [pc, #104]	; (8001308 <Display_UpdateValue+0x90>)
 800129e:	5c6b      	ldrb	r3, [r5, r1]
		DigitLeft  = NUMBER_TABLE[val/10];
 80012a0:	1c30      	adds	r0, r6, #0
	}
	else if(Value >= 100)  // 10.0 to X
	{
		int32_t val = Value/10;

		DigitRight = NUMBER_TABLE[val%10];
 80012a2:	7023      	strb	r3, [r4, #0]
		DigitLeft  = NUMBER_TABLE[val/10];
 80012a4:	210a      	movs	r1, #10
 80012a6:	f002 faf5 	bl	8003894 <__aeabi_idiv>
 80012aa:	5c2b      	ldrb	r3, [r5, r0]
 80012ac:	7063      	strb	r3, [r4, #1]

		PointMiddle = 0;
 80012ae:	2300      	movs	r3, #0
 80012b0:	70a3      	strb	r3, [r4, #2]
		PointRight  = 0;
 80012b2:	70e3      	strb	r3, [r4, #3]
 80012b4:	e009      	b.n	80012ca <Display_UpdateValue+0x52>
		PointMiddle = 1;
		PointRight  = 0;
	}
	else if((Value >= 0) && (Value < 10))  // 0 to 0.9
	{
		DigitRight = NUMBER_TABLE[Value];
 80012b6:	4a13      	ldr	r2, [pc, #76]	; (8001304 <Display_UpdateValue+0x8c>)
 80012b8:	4b13      	ldr	r3, [pc, #76]	; (8001308 <Display_UpdateValue+0x90>)
 80012ba:	5c11      	ldrb	r1, [r2, r0]
		DigitLeft  = NUMBER_TABLE[0];
 80012bc:	7812      	ldrb	r2, [r2, #0]
		PointMiddle = 1;
		PointRight  = 0;
	}
	else if((Value >= 0) && (Value < 10))  // 0 to 0.9
	{
		DigitRight = NUMBER_TABLE[Value];
 80012be:	7019      	strb	r1, [r3, #0]
		DigitLeft  = NUMBER_TABLE[0];
 80012c0:	705a      	strb	r2, [r3, #1]

		PointMiddle = 1;
 80012c2:	2201      	movs	r2, #1
 80012c4:	709a      	strb	r2, [r3, #2]
		PointRight  = 0;
 80012c6:	2200      	movs	r2, #0
 80012c8:	70da      	strb	r2, [r3, #3]
	else
	{
		DigitLeft  = _E_;
		DigitRight = _r_;
	}
}
 80012ca:	bd70      	pop	{r4, r5, r6, pc}
//==================================================================================================
void Display_UpdateValue(int32_t Value)
{
	if((Value > -19) && (Value < 0)) // -X to -1.0
	{
		DigitRight = NUMBER_TABLE[(~Value+1)/10];
 80012cc:	210a      	movs	r1, #10
 80012ce:	4249      	negs	r1, r1
 80012d0:	f002 fae0 	bl	8003894 <__aeabi_idiv>
 80012d4:	4b0b      	ldr	r3, [pc, #44]	; (8001304 <Display_UpdateValue+0x8c>)
 80012d6:	4d0c      	ldr	r5, [pc, #48]	; (8001308 <Display_UpdateValue+0x90>)
 80012d8:	5c1b      	ldrb	r3, [r3, r0]
 80012da:	702b      	strb	r3, [r5, #0]
		DigitLeft  = _SEG_G_;
 80012dc:	2340      	movs	r3, #64	; 0x40
		PointRight  = 0;
	}
	else if(Value < 100) // 1.0 to 9.9
	{
		DigitRight = NUMBER_TABLE[Value%10];
		DigitLeft  = NUMBER_TABLE[Value/10];
 80012de:	706b      	strb	r3, [r5, #1]

		PointMiddle = 1;
 80012e0:	2301      	movs	r3, #1
 80012e2:	70ab      	strb	r3, [r5, #2]
		PointRight  = 0;
 80012e4:	2300      	movs	r3, #0
 80012e6:	70eb      	strb	r3, [r5, #3]
 80012e8:	e7ef      	b.n	80012ca <Display_UpdateValue+0x52>
		PointMiddle = 1;
		PointRight  = 0;
	}
	else if(Value < 100) // 1.0 to 9.9
	{
		DigitRight = NUMBER_TABLE[Value%10];
 80012ea:	210a      	movs	r1, #10
 80012ec:	f002 fbb8 	bl	8003a60 <__aeabi_idivmod>
 80012f0:	4e04      	ldr	r6, [pc, #16]	; (8001304 <Display_UpdateValue+0x8c>)
 80012f2:	4d05      	ldr	r5, [pc, #20]	; (8001308 <Display_UpdateValue+0x90>)
 80012f4:	5c73      	ldrb	r3, [r6, r1]
		DigitLeft  = NUMBER_TABLE[Value/10];
 80012f6:	1c20      	adds	r0, r4, #0
		PointMiddle = 1;
		PointRight  = 0;
	}
	else if(Value < 100) // 1.0 to 9.9
	{
		DigitRight = NUMBER_TABLE[Value%10];
 80012f8:	702b      	strb	r3, [r5, #0]
		DigitLeft  = NUMBER_TABLE[Value/10];
 80012fa:	210a      	movs	r1, #10
 80012fc:	f002 faca 	bl	8003894 <__aeabi_idiv>
 8001300:	5c33      	ldrb	r3, [r6, r0]
 8001302:	e7ec      	b.n	80012de <Display_UpdateValue+0x66>
 8001304:	20000020 	.word	0x20000020
 8001308:	2000014e 	.word	0x2000014e

0800130c <Display_UpdateTimeValue>:
	}
}

void Display_UpdateTimeValue(uint32_t Value)
{
	PointMiddle = 0;
 800130c:	2300      	movs	r3, #0
		DigitRight = _r_;
	}
}

void Display_UpdateTimeValue(uint32_t Value)
{
 800130e:	b570      	push	{r4, r5, r6, lr}
	PointMiddle = 0;
 8001310:	4d31      	ldr	r5, [pc, #196]	; (80013d8 <Display_UpdateTimeValue+0xcc>)
 8001312:	70ab      	strb	r3, [r5, #2]
	PointRight  = 0;
 8001314:	70eb      	strb	r3, [r5, #3]

	if((Value >= 0) && (Value <= 9))  // 0 to 9
 8001316:	2809      	cmp	r0, #9
 8001318:	d925      	bls.n	8001366 <Display_UpdateTimeValue+0x5a>
	{
		DigitRight = NUMBER_TABLE[Value];
		DigitLeft  = NUMBER_TABLE[0];
	}
	else if((Value >= 10) && (Value <= 99)) // 10 to 99
 800131a:	1c03      	adds	r3, r0, #0
 800131c:	3b0a      	subs	r3, #10
 800131e:	1c04      	adds	r4, r0, #0
 8001320:	2b59      	cmp	r3, #89	; 0x59
 8001322:	d913      	bls.n	800134c <Display_UpdateTimeValue+0x40>
	{
		DigitRight = NUMBER_TABLE[Value%10];
		DigitLeft  = NUMBER_TABLE[Value/10];
	}
	else if((Value >= 100) && (Value <= 999)) // 100 to 999
 8001324:	1c02      	adds	r2, r0, #0
 8001326:	4b2d      	ldr	r3, [pc, #180]	; (80013dc <Display_UpdateTimeValue+0xd0>)
 8001328:	3a64      	subs	r2, #100	; 0x64
 800132a:	429a      	cmp	r2, r3
 800132c:	d932      	bls.n	8001394 <Display_UpdateTimeValue+0x88>
	{
		DigitRight = NUMBER_TABLE[(Value/10)%10];
		DigitLeft  = NUMBER_TABLE[(Value/10)/10];
	}
	else if((Value >= 1000) && (Value <= 9999)) // 1000 to 9999
 800132e:	4b2c      	ldr	r3, [pc, #176]	; (80013e0 <Display_UpdateTimeValue+0xd4>)
 8001330:	18c2      	adds	r2, r0, r3
 8001332:	4b2c      	ldr	r3, [pc, #176]	; (80013e4 <Display_UpdateTimeValue+0xd8>)
 8001334:	429a      	cmp	r2, r3
 8001336:	d91c      	bls.n	8001372 <Display_UpdateTimeValue+0x66>
	{
		DigitRight = NUMBER_TABLE[(Value/100)%10];
		DigitLeft  = NUMBER_TABLE[(Value/100)/10];
	}
	else if((Value >= 10000) && (Value <= 99999)) // 10000 to 99999
 8001338:	4b2b      	ldr	r3, [pc, #172]	; (80013e8 <Display_UpdateTimeValue+0xdc>)
 800133a:	18c2      	adds	r2, r0, r3
 800133c:	4b2b      	ldr	r3, [pc, #172]	; (80013ec <Display_UpdateTimeValue+0xe0>)
 800133e:	429a      	cmp	r2, r3
 8001340:	d938      	bls.n	80013b4 <Display_UpdateTimeValue+0xa8>
		DigitRight = NUMBER_TABLE[(Value/1000)%10];
		DigitLeft  = NUMBER_TABLE[(Value/1000)/10];
	}
	else
	{
		DigitLeft  = _E_;
 8001342:	2379      	movs	r3, #121	; 0x79
 8001344:	706b      	strb	r3, [r5, #1]
		DigitRight = _r_;
 8001346:	3b29      	subs	r3, #41	; 0x29
 8001348:	702b      	strb	r3, [r5, #0]
 800134a:	e00b      	b.n	8001364 <Display_UpdateTimeValue+0x58>
		DigitRight = NUMBER_TABLE[Value];
		DigitLeft  = NUMBER_TABLE[0];
	}
	else if((Value >= 10) && (Value <= 99)) // 10 to 99
	{
		DigitRight = NUMBER_TABLE[Value%10];
 800134c:	210a      	movs	r1, #10
 800134e:	f002 fa97 	bl	8003880 <__aeabi_uidivmod>
 8001352:	4e27      	ldr	r6, [pc, #156]	; (80013f0 <Display_UpdateTimeValue+0xe4>)
		DigitLeft  = NUMBER_TABLE[Value/10];
 8001354:	1c20      	adds	r0, r4, #0
		DigitRight = NUMBER_TABLE[Value];
		DigitLeft  = NUMBER_TABLE[0];
	}
	else if((Value >= 10) && (Value <= 99)) // 10 to 99
	{
		DigitRight = NUMBER_TABLE[Value%10];
 8001356:	5c73      	ldrb	r3, [r6, r1]
		DigitLeft  = NUMBER_TABLE[Value/10];
 8001358:	210a      	movs	r1, #10
		DigitRight = NUMBER_TABLE[Value];
		DigitLeft  = NUMBER_TABLE[0];
	}
	else if((Value >= 10) && (Value <= 99)) // 10 to 99
	{
		DigitRight = NUMBER_TABLE[Value%10];
 800135a:	702b      	strb	r3, [r5, #0]
		DigitLeft  = NUMBER_TABLE[Value/10];
 800135c:	f002 fa0a 	bl	8003774 <__aeabi_uidiv>
 8001360:	5c33      	ldrb	r3, [r6, r0]
 8001362:	706b      	strb	r3, [r5, #1]
	else
	{
		DigitLeft  = _E_;
		DigitRight = _r_;
	}
}
 8001364:	bd70      	pop	{r4, r5, r6, pc}
	PointMiddle = 0;
	PointRight  = 0;

	if((Value >= 0) && (Value <= 9))  // 0 to 9
	{
		DigitRight = NUMBER_TABLE[Value];
 8001366:	4b22      	ldr	r3, [pc, #136]	; (80013f0 <Display_UpdateTimeValue+0xe4>)
 8001368:	5c1a      	ldrb	r2, [r3, r0]
		DigitLeft  = NUMBER_TABLE[0];
 800136a:	781b      	ldrb	r3, [r3, #0]
	PointMiddle = 0;
	PointRight  = 0;

	if((Value >= 0) && (Value <= 9))  // 0 to 9
	{
		DigitRight = NUMBER_TABLE[Value];
 800136c:	702a      	strb	r2, [r5, #0]
		DigitLeft  = NUMBER_TABLE[0];
 800136e:	706b      	strb	r3, [r5, #1]
 8001370:	e7f8      	b.n	8001364 <Display_UpdateTimeValue+0x58>
		DigitRight = NUMBER_TABLE[(Value/10)%10];
		DigitLeft  = NUMBER_TABLE[(Value/10)/10];
	}
	else if((Value >= 1000) && (Value <= 9999)) // 1000 to 9999
	{
		DigitRight = NUMBER_TABLE[(Value/100)%10];
 8001372:	2164      	movs	r1, #100	; 0x64
 8001374:	f002 f9fe 	bl	8003774 <__aeabi_uidiv>
 8001378:	210a      	movs	r1, #10
 800137a:	f002 fa81 	bl	8003880 <__aeabi_uidivmod>
 800137e:	4e1c      	ldr	r6, [pc, #112]	; (80013f0 <Display_UpdateTimeValue+0xe4>)
		DigitLeft  = NUMBER_TABLE[(Value/100)/10];
 8001380:	1c20      	adds	r0, r4, #0
		DigitRight = NUMBER_TABLE[(Value/10)%10];
		DigitLeft  = NUMBER_TABLE[(Value/10)/10];
	}
	else if((Value >= 1000) && (Value <= 9999)) // 1000 to 9999
	{
		DigitRight = NUMBER_TABLE[(Value/100)%10];
 8001382:	5c73      	ldrb	r3, [r6, r1]
		DigitLeft  = NUMBER_TABLE[(Value/100)/10];
 8001384:	21fa      	movs	r1, #250	; 0xfa
		DigitRight = NUMBER_TABLE[(Value/10)%10];
		DigitLeft  = NUMBER_TABLE[(Value/10)/10];
	}
	else if((Value >= 1000) && (Value <= 9999)) // 1000 to 9999
	{
		DigitRight = NUMBER_TABLE[(Value/100)%10];
 8001386:	702b      	strb	r3, [r5, #0]
		DigitLeft  = NUMBER_TABLE[(Value/100)/10];
 8001388:	0089      	lsls	r1, r1, #2
 800138a:	f002 f9f3 	bl	8003774 <__aeabi_uidiv>
 800138e:	5c33      	ldrb	r3, [r6, r0]
 8001390:	706b      	strb	r3, [r5, #1]
 8001392:	e7e7      	b.n	8001364 <Display_UpdateTimeValue+0x58>
		DigitRight = NUMBER_TABLE[Value%10];
		DigitLeft  = NUMBER_TABLE[Value/10];
	}
	else if((Value >= 100) && (Value <= 999)) // 100 to 999
	{
		DigitRight = NUMBER_TABLE[(Value/10)%10];
 8001394:	210a      	movs	r1, #10
 8001396:	f002 f9ed 	bl	8003774 <__aeabi_uidiv>
 800139a:	210a      	movs	r1, #10
 800139c:	f002 fa70 	bl	8003880 <__aeabi_uidivmod>
 80013a0:	4e13      	ldr	r6, [pc, #76]	; (80013f0 <Display_UpdateTimeValue+0xe4>)
		DigitLeft  = NUMBER_TABLE[(Value/10)/10];
 80013a2:	1c20      	adds	r0, r4, #0
		DigitRight = NUMBER_TABLE[Value%10];
		DigitLeft  = NUMBER_TABLE[Value/10];
	}
	else if((Value >= 100) && (Value <= 999)) // 100 to 999
	{
		DigitRight = NUMBER_TABLE[(Value/10)%10];
 80013a4:	5c73      	ldrb	r3, [r6, r1]
		DigitLeft  = NUMBER_TABLE[(Value/10)/10];
 80013a6:	2164      	movs	r1, #100	; 0x64
		DigitRight = NUMBER_TABLE[Value%10];
		DigitLeft  = NUMBER_TABLE[Value/10];
	}
	else if((Value >= 100) && (Value <= 999)) // 100 to 999
	{
		DigitRight = NUMBER_TABLE[(Value/10)%10];
 80013a8:	702b      	strb	r3, [r5, #0]
		DigitLeft  = NUMBER_TABLE[(Value/10)/10];
 80013aa:	f002 f9e3 	bl	8003774 <__aeabi_uidiv>
 80013ae:	5c33      	ldrb	r3, [r6, r0]
 80013b0:	706b      	strb	r3, [r5, #1]
 80013b2:	e7d7      	b.n	8001364 <Display_UpdateTimeValue+0x58>
		DigitRight = NUMBER_TABLE[(Value/100)%10];
		DigitLeft  = NUMBER_TABLE[(Value/100)/10];
	}
	else if((Value >= 10000) && (Value <= 99999)) // 10000 to 99999
	{
		DigitRight = NUMBER_TABLE[(Value/1000)%10];
 80013b4:	21fa      	movs	r1, #250	; 0xfa
 80013b6:	0089      	lsls	r1, r1, #2
 80013b8:	f002 f9dc 	bl	8003774 <__aeabi_uidiv>
 80013bc:	210a      	movs	r1, #10
 80013be:	f002 fa5f 	bl	8003880 <__aeabi_uidivmod>
 80013c2:	4e0b      	ldr	r6, [pc, #44]	; (80013f0 <Display_UpdateTimeValue+0xe4>)
		DigitLeft  = NUMBER_TABLE[(Value/1000)/10];
 80013c4:	1c20      	adds	r0, r4, #0
		DigitRight = NUMBER_TABLE[(Value/100)%10];
		DigitLeft  = NUMBER_TABLE[(Value/100)/10];
	}
	else if((Value >= 10000) && (Value <= 99999)) // 10000 to 99999
	{
		DigitRight = NUMBER_TABLE[(Value/1000)%10];
 80013c6:	5c73      	ldrb	r3, [r6, r1]
		DigitLeft  = NUMBER_TABLE[(Value/1000)/10];
 80013c8:	490a      	ldr	r1, [pc, #40]	; (80013f4 <Display_UpdateTimeValue+0xe8>)
		DigitRight = NUMBER_TABLE[(Value/100)%10];
		DigitLeft  = NUMBER_TABLE[(Value/100)/10];
	}
	else if((Value >= 10000) && (Value <= 99999)) // 10000 to 99999
	{
		DigitRight = NUMBER_TABLE[(Value/1000)%10];
 80013ca:	702b      	strb	r3, [r5, #0]
		DigitLeft  = NUMBER_TABLE[(Value/1000)/10];
 80013cc:	f002 f9d2 	bl	8003774 <__aeabi_uidiv>
 80013d0:	5c33      	ldrb	r3, [r6, r0]
 80013d2:	706b      	strb	r3, [r5, #1]
 80013d4:	e7c6      	b.n	8001364 <Display_UpdateTimeValue+0x58>
 80013d6:	46c0      	nop			; (mov r8, r8)
 80013d8:	2000014e 	.word	0x2000014e
 80013dc:	00000383 	.word	0x00000383
 80013e0:	fffffc18 	.word	0xfffffc18
 80013e4:	00002327 	.word	0x00002327
 80013e8:	ffffd8f0 	.word	0xffffd8f0
 80013ec:	00015f8f 	.word	0x00015f8f
 80013f0:	20000020 	.word	0x20000020
 80013f4:	00002710 	.word	0x00002710

080013f8 <Display_Version>:
//==================================================================================================
// Print firmware version
//==================================================================================================
void Display_Version(uint8_t Major, uint8_t Minor)
{
	PointMiddle = 1;
 80013f8:	2201      	movs	r2, #1
 80013fa:	4b05      	ldr	r3, [pc, #20]	; (8001410 <Display_Version+0x18>)
 80013fc:	709a      	strb	r2, [r3, #2]
	PointRight  = 0;
 80013fe:	2200      	movs	r2, #0
 8001400:	70da      	strb	r2, [r3, #3]

	DigitRight = NUMBER_TABLE[Minor];
 8001402:	4a04      	ldr	r2, [pc, #16]	; (8001414 <Display_Version+0x1c>)
 8001404:	5c51      	ldrb	r1, [r2, r1]
	DigitLeft  = NUMBER_TABLE[Major];
 8001406:	5c12      	ldrb	r2, [r2, r0]
void Display_Version(uint8_t Major, uint8_t Minor)
{
	PointMiddle = 1;
	PointRight  = 0;

	DigitRight = NUMBER_TABLE[Minor];
 8001408:	7019      	strb	r1, [r3, #0]
	DigitLeft  = NUMBER_TABLE[Major];
 800140a:	705a      	strb	r2, [r3, #1]
}
 800140c:	4770      	bx	lr
 800140e:	46c0      	nop			; (mov r8, r8)
 8001410:	2000014e 	.word	0x2000014e
 8001414:	20000020 	.word	0x20000020

08001418 <IrDA_Init>:

//==================================================================================================
//
//==================================================================================================
void IrDA_Init(xQueueHandle *QueueHandler)
{
 8001418:	b5f0      	push	{r4, r5, r6, r7, lr}
 800141a:	1c06      	adds	r6, r0, #0
	EXTI_InitTypeDef EXTI_InitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	/* Enable GPIOB clock - AHB: advanced high-performance bus*/
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 800141c:	2080      	movs	r0, #128	; 0x80

	/* Configure PA0 pin as input floating */
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_1;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 800141e:	2400      	movs	r4, #0
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8001420:	2501      	movs	r5, #1

	/* Enable GPIOB clock - AHB: advanced high-performance bus*/
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);

	/* Configure PA0 pin as input floating */
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_1;
 8001422:	2702      	movs	r7, #2

//==================================================================================================
//
//==================================================================================================
void IrDA_Init(xQueueHandle *QueueHandler)
{
 8001424:	b089      	sub	sp, #36	; 0x24
	EXTI_InitTypeDef EXTI_InitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	/* Enable GPIOB clock - AHB: advanced high-performance bus*/
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 8001426:	02c0      	lsls	r0, r0, #11
 8001428:	2101      	movs	r1, #1
 800142a:	f005 f919 	bl	8006660 <RCC_AHBPeriphClockCmd>

	/* Configure PA0 pin as input floating */
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_1;
 800142e:	a903      	add	r1, sp, #12
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001430:	481e      	ldr	r0, [pc, #120]	; (80014ac <IrDA_Init+0x94>)
	/* Enable GPIOB clock - AHB: advanced high-performance bus*/
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);

	/* Configure PA0 pin as input floating */
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_1;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8001432:	710c      	strb	r4, [r1, #4]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8001434:	71cd      	strb	r5, [r1, #7]

	/* Enable GPIOB clock - AHB: advanced high-performance bus*/
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);

	/* Configure PA0 pin as input floating */
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_1;
 8001436:	9703      	str	r7, [sp, #12]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001438:	f004 fcf8 	bl	8005e2c <GPIO_Init>

	/* Enable SYSCFG clock - APB: advanced peripheral bus*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 800143c:	2001      	movs	r0, #1
 800143e:	2101      	movs	r1, #1
 8001440:	f005 f91a 	bl	8006678 <RCC_APB2PeriphClockCmd>

	/* Connect EXTI0 Line to PA0 pin */
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource1);
 8001444:	2101      	movs	r1, #1
 8001446:	2001      	movs	r0, #1
 8001448:	f005 ffb4 	bl	80073b4 <SYSCFG_EXTILineConfig>

	/* Configure EXTI0 line */
	EXTI_InitStructure.EXTI_Line 	= EXTI_Line1;
	EXTI_InitStructure.EXTI_Mode 	= EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
 800144c:	2308      	movs	r3, #8

	/* Connect EXTI0 Line to PA0 pin */
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource1);

	/* Configure EXTI0 line */
	EXTI_InitStructure.EXTI_Line 	= EXTI_Line1;
 800144e:	a801      	add	r0, sp, #4
	EXTI_InitStructure.EXTI_Mode 	= EXTI_Mode_Interrupt;
 8001450:	7104      	strb	r4, [r0, #4]
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
 8001452:	7143      	strb	r3, [r0, #5]
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 8001454:	7185      	strb	r5, [r0, #6]

	/* Connect EXTI0 Line to PA0 pin */
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource1);

	/* Configure EXTI0 line */
	EXTI_InitStructure.EXTI_Line 	= EXTI_Line1;
 8001456:	9701      	str	r7, [sp, #4]
	EXTI_InitStructure.EXTI_Mode 	= EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	EXTI_Init(&EXTI_InitStructure);
 8001458:	f004 f918 	bl	800568c <EXTI_Init>

	/* Enable and set EXTI0 Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_1_IRQn;
 800145c:	466a      	mov	r2, sp
 800145e:	2305      	movs	r3, #5
	NVIC_InitStructure.NVIC_IRQChannelPriority = 0x01;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 8001460:	4668      	mov	r0, sp
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	EXTI_Init(&EXTI_InitStructure);

	/* Enable and set EXTI0 Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_1_IRQn;
 8001462:	7013      	strb	r3, [r2, #0]
	NVIC_InitStructure.NVIC_IRQChannelPriority = 0x01;
 8001464:	7055      	strb	r5, [r2, #1]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8001466:	7095      	strb	r5, [r2, #2]
	NVIC_Init(&NVIC_InitStructure);
 8001468:	f004 fd94 	bl	8005f94 <NVIC_Init>

	EXTI_ClearITPendingBit(EXTI_Line1);
 800146c:	2002      	movs	r0, #2
 800146e:	f004 f96f 	bl	8005750 <EXTI_ClearITPendingBit>

	/* Timer Configuration */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE);
 8001472:	2101      	movs	r1, #1
 8001474:	2010      	movs	r0, #16
 8001476:	f005 f90b 	bl	8006690 <RCC_APB1PeriphClockCmd>

	TIM_TimeBaseInitTypeDef timerInitStructure;
	timerInitStructure.TIM_Prescaler 	 = 48;    // 48000000 / 48 = 1000000 -->> 1us resolution
 800147a:	2330      	movs	r3, #48	; 0x30
 800147c:	a905      	add	r1, sp, #20
 800147e:	800b      	strh	r3, [r1, #0]
	timerInitStructure.TIM_CounterMode 	 = TIM_CounterMode_Up;
	timerInitStructure.TIM_Period 		 = 10000; // Counter max number
 8001480:	4b0b      	ldr	r3, [pc, #44]	; (80014b0 <IrDA_Init+0x98>)
	timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	timerInitStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM6, &timerInitStructure);
 8001482:	4d0c      	ldr	r5, [pc, #48]	; (80014b4 <IrDA_Init+0x9c>)
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE);

	TIM_TimeBaseInitTypeDef timerInitStructure;
	timerInitStructure.TIM_Prescaler 	 = 48;    // 48000000 / 48 = 1000000 -->> 1us resolution
	timerInitStructure.TIM_CounterMode 	 = TIM_CounterMode_Up;
	timerInitStructure.TIM_Period 		 = 10000; // Counter max number
 8001484:	604b      	str	r3, [r1, #4]
	timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	timerInitStructure.TIM_RepetitionCounter = 0;
 8001486:	2300      	movs	r3, #0
	TIM_TimeBaseInit(TIM6, &timerInitStructure);
 8001488:	1c28      	adds	r0, r5, #0
	TIM_TimeBaseInitTypeDef timerInitStructure;
	timerInitStructure.TIM_Prescaler 	 = 48;    // 48000000 / 48 = 1000000 -->> 1us resolution
	timerInitStructure.TIM_CounterMode 	 = TIM_CounterMode_Up;
	timerInitStructure.TIM_Period 		 = 10000; // Counter max number
	timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	timerInitStructure.TIM_RepetitionCounter = 0;
 800148a:	728b      	strb	r3, [r1, #10]
	/* Timer Configuration */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE);

	TIM_TimeBaseInitTypeDef timerInitStructure;
	timerInitStructure.TIM_Prescaler 	 = 48;    // 48000000 / 48 = 1000000 -->> 1us resolution
	timerInitStructure.TIM_CounterMode 	 = TIM_CounterMode_Up;
 800148c:	804c      	strh	r4, [r1, #2]
	timerInitStructure.TIM_Period 		 = 10000; // Counter max number
	timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
 800148e:	810c      	strh	r4, [r1, #8]
	timerInitStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM6, &timerInitStructure);
 8001490:	f006 f854 	bl	800753c <TIM_TimeBaseInit>
	TIM_Cmd(TIM6, ENABLE);
 8001494:	1c28      	adds	r0, r5, #0
 8001496:	2101      	movs	r1, #1
 8001498:	f006 f8f2 	bl	8007680 <TIM_Cmd>

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 800149c:	2120      	movs	r1, #32

	DataReceived = 0;
 800149e:	4b06      	ldr	r3, [pc, #24]	; (80014b8 <IrDA_Init+0xa0>)
 80014a0:	4a06      	ldr	r2, [pc, #24]	; (80014bc <IrDA_Init+0xa4>)
 80014a2:	601c      	str	r4, [r3, #0]
 80014a4:	6011      	str	r1, [r2, #0]

	IrDA_EnableIRQ();

	IrDAQueueHandler = QueueHandler;
 80014a6:	605e      	str	r6, [r3, #4]
}
 80014a8:	b009      	add	sp, #36	; 0x24
 80014aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80014ac:	48000400 	.word	0x48000400
 80014b0:	00002710 	.word	0x00002710
 80014b4:	40001000 	.word	0x40001000
 80014b8:	20000154 	.word	0x20000154
 80014bc:	e000e100 	.word	0xe000e100

080014c0 <IrDA_IRQHandler>:

//==================================================================================================
//
//==================================================================================================
uint32_t IrDA_IRQHandler()
{
 80014c0:	b570      	push	{r4, r5, r6, lr}

	static uint32_t RisingEdgeTime;
	static uint32_t FallingEdgeTime;
	static uint32_t ReceivedBitsCount;

	EXTI->PR |= 0x00000002;	// Clear the IRQ pending flag
 80014c2:	2502      	movs	r5, #2
 80014c4:	4e23      	ldr	r6, [pc, #140]	; (8001554 <IrDA_IRQHandler+0x94>)

	if(((EXTI->FTSR & 0x00000002) == 0) && ((EXTI->RTSR & 0x00000002) > 0)) //if RisingEdge
	{
		TIM_SetCounter(TIM6, 0);
 80014c6:	4824      	ldr	r0, [pc, #144]	; (8001558 <IrDA_IRQHandler+0x98>)

	static uint32_t RisingEdgeTime;
	static uint32_t FallingEdgeTime;
	static uint32_t ReceivedBitsCount;

	EXTI->PR |= 0x00000002;	// Clear the IRQ pending flag
 80014c8:	6973      	ldr	r3, [r6, #20]
 80014ca:	432b      	orrs	r3, r5
 80014cc:	6173      	str	r3, [r6, #20]

	if(((EXTI->FTSR & 0x00000002) == 0) && ((EXTI->RTSR & 0x00000002) > 0)) //if RisingEdge
 80014ce:	68f4      	ldr	r4, [r6, #12]
 80014d0:	402c      	ands	r4, r5
 80014d2:	d102      	bne.n	80014da <IrDA_IRQHandler+0x1a>
 80014d4:	68b3      	ldr	r3, [r6, #8]
 80014d6:	421d      	tst	r5, r3
 80014d8:	d128      	bne.n	800152c <IrDA_IRQHandler+0x6c>
		EXTI->FTSR |= 0x00000002;  // Falling trigger selection register
		EXTI->RTSR &= 0xFFFFBFFF;  // Rising trigger selection register
	}
	else //if FallingEdge
	{
		FallingEdgeTime = TIM_GetCounter(TIM6);
 80014da:	f006 f895 	bl	8007608 <TIM_GetCounter>

		// Configuration for the Next Edge (RisingEdge)
		EXTI->FTSR &= 0xFFFFFFFD;  // Falling trigger selection register
 80014de:	2102      	movs	r1, #2
		EXTI->FTSR |= 0x00000002;  // Falling trigger selection register
		EXTI->RTSR &= 0xFFFFBFFF;  // Rising trigger selection register
	}
	else //if FallingEdge
	{
		FallingEdgeTime = TIM_GetCounter(TIM6);
 80014e0:	4b1e      	ldr	r3, [pc, #120]	; (800155c <IrDA_IRQHandler+0x9c>)

		// Configuration for the Next Edge (RisingEdge)
		EXTI->FTSR &= 0xFFFFFFFD;  // Falling trigger selection register
 80014e2:	4a1c      	ldr	r2, [pc, #112]	; (8001554 <IrDA_IRQHandler+0x94>)
		EXTI->FTSR |= 0x00000002;  // Falling trigger selection register
		EXTI->RTSR &= 0xFFFFBFFF;  // Rising trigger selection register
	}
	else //if FallingEdge
	{
		FallingEdgeTime = TIM_GetCounter(TIM6);
 80014e4:	60d8      	str	r0, [r3, #12]

		// Configuration for the Next Edge (RisingEdge)
		EXTI->FTSR &= 0xFFFFFFFD;  // Falling trigger selection register
 80014e6:	68d4      	ldr	r4, [r2, #12]
 80014e8:	438c      	bics	r4, r1
 80014ea:	60d4      	str	r4, [r2, #12]
		EXTI->RTSR |= 0x00000002;  // Rising trigger selection register
 80014ec:	6894      	ldr	r4, [r2, #8]
 80014ee:	4321      	orrs	r1, r4
 80014f0:	6091      	str	r1, [r2, #8]

		// Shifts the received bit to the left (it opens space for the next bit)
		DataReceived = DataReceived << 1;

		// Start Bit
		if((FallingEdgeTime - RisingEdgeTime) >= 4000) // Start Bit (4.440ms)
 80014f2:	6899      	ldr	r1, [r3, #8]
		// Configuration for the Next Edge (RisingEdge)
		EXTI->FTSR &= 0xFFFFFFFD;  // Falling trigger selection register
		EXTI->RTSR |= 0x00000002;  // Rising trigger selection register

		// Shifts the received bit to the left (it opens space for the next bit)
		DataReceived = DataReceived << 1;
 80014f4:	681a      	ldr	r2, [r3, #0]

		// Start Bit
		if((FallingEdgeTime - RisingEdgeTime) >= 4000) // Start Bit (4.440ms)
 80014f6:	1a40      	subs	r0, r0, r1
 80014f8:	4919      	ldr	r1, [pc, #100]	; (8001560 <IrDA_IRQHandler+0xa0>)
		// Configuration for the Next Edge (RisingEdge)
		EXTI->FTSR &= 0xFFFFFFFD;  // Falling trigger selection register
		EXTI->RTSR |= 0x00000002;  // Rising trigger selection register

		// Shifts the received bit to the left (it opens space for the next bit)
		DataReceived = DataReceived << 1;
 80014fa:	0052      	lsls	r2, r2, #1
 80014fc:	601a      	str	r2, [r3, #0]

		// Start Bit
		if((FallingEdgeTime - RisingEdgeTime) >= 4000) // Start Bit (4.440ms)
 80014fe:	4288      	cmp	r0, r1
 8001500:	d80e      	bhi.n	8001520 <IrDA_IRQHandler+0x60>
		{
			DataReceived = 0;
			ReceivedBitsCount = 0;
		}
		else if((FallingEdgeTime - RisingEdgeTime) >= 1000) // Bit 1 (1.600ms)
 8001502:	4918      	ldr	r1, [pc, #96]	; (8001564 <IrDA_IRQHandler+0xa4>)
 8001504:	4288      	cmp	r0, r1
 8001506:	d902      	bls.n	800150e <IrDA_IRQHandler+0x4e>
		{
			DataReceived |= 0b1;
 8001508:	2101      	movs	r1, #1
 800150a:	430a      	orrs	r2, r1
 800150c:	601a      	str	r2, [r3, #0]
		}
		//else Bit 0 (520us) (DataReceived is 0 by default, we dont need the else condition)

		// Command ready
		if(++ReceivedBitsCount >= 33) // 32 data bits plus start bit
 800150e:	691a      	ldr	r2, [r3, #16]
 8001510:	3201      	adds	r2, #1
 8001512:	2a20      	cmp	r2, #32
 8001514:	d91a      	bls.n	800154c <IrDA_IRQHandler+0x8c>
		{
			ReceivedBitsCount = 0;
 8001516:	2200      	movs	r2, #0
			return DataReceived;
 8001518:	681c      	ldr	r4, [r3, #0]
		//else Bit 0 (520us) (DataReceived is 0 by default, we dont need the else condition)

		// Command ready
		if(++ReceivedBitsCount >= 33) // 32 data bits plus start bit
		{
			ReceivedBitsCount = 0;
 800151a:	611a      	str	r2, [r3, #16]
			return DataReceived;
		}
	}

	return 0;
}
 800151c:	1c20      	adds	r0, r4, #0
 800151e:	bd70      	pop	{r4, r5, r6, pc}
		DataReceived = DataReceived << 1;

		// Start Bit
		if((FallingEdgeTime - RisingEdgeTime) >= 4000) // Start Bit (4.440ms)
		{
			DataReceived = 0;
 8001520:	2200      	movs	r2, #0
 8001522:	601a      	str	r2, [r3, #0]
			DataReceived |= 0b1;
		}
		//else Bit 0 (520us) (DataReceived is 0 by default, we dont need the else condition)

		// Command ready
		if(++ReceivedBitsCount >= 33) // 32 data bits plus start bit
 8001524:	3201      	adds	r2, #1
 8001526:	611a      	str	r2, [r3, #16]
			ReceivedBitsCount = 0;
			return DataReceived;
		}
	}

	return 0;
 8001528:	2400      	movs	r4, #0
 800152a:	e7f7      	b.n	800151c <IrDA_IRQHandler+0x5c>

	EXTI->PR |= 0x00000002;	// Clear the IRQ pending flag

	if(((EXTI->FTSR & 0x00000002) == 0) && ((EXTI->RTSR & 0x00000002) > 0)) //if RisingEdge
	{
		TIM_SetCounter(TIM6, 0);
 800152c:	2100      	movs	r1, #0
 800152e:	f006 f867 	bl	8007600 <TIM_SetCounter>
		RisingEdgeTime = TIM_GetCounter(TIM6);
 8001532:	4809      	ldr	r0, [pc, #36]	; (8001558 <IrDA_IRQHandler+0x98>)
 8001534:	f006 f868 	bl	8007608 <TIM_GetCounter>
 8001538:	4b08      	ldr	r3, [pc, #32]	; (800155c <IrDA_IRQHandler+0x9c>)
 800153a:	6098      	str	r0, [r3, #8]

		// Configuration for the Next Edge (FallingEdge)
		EXTI->FTSR |= 0x00000002;  // Falling trigger selection register
 800153c:	68f3      	ldr	r3, [r6, #12]
 800153e:	431d      	orrs	r5, r3
 8001540:	60f5      	str	r5, [r6, #12]
		EXTI->RTSR &= 0xFFFFBFFF;  // Rising trigger selection register
 8001542:	68b2      	ldr	r2, [r6, #8]
 8001544:	4b08      	ldr	r3, [pc, #32]	; (8001568 <IrDA_IRQHandler+0xa8>)
 8001546:	4013      	ands	r3, r2
 8001548:	60b3      	str	r3, [r6, #8]
 800154a:	e7e7      	b.n	800151c <IrDA_IRQHandler+0x5c>
			DataReceived |= 0b1;
		}
		//else Bit 0 (520us) (DataReceived is 0 by default, we dont need the else condition)

		// Command ready
		if(++ReceivedBitsCount >= 33) // 32 data bits plus start bit
 800154c:	611a      	str	r2, [r3, #16]
			ReceivedBitsCount = 0;
			return DataReceived;
		}
	}

	return 0;
 800154e:	2400      	movs	r4, #0
 8001550:	e7e4      	b.n	800151c <IrDA_IRQHandler+0x5c>
 8001552:	46c0      	nop			; (mov r8, r8)
 8001554:	40010400 	.word	0x40010400
 8001558:	40001000 	.word	0x40001000
 800155c:	20000154 	.word	0x20000154
 8001560:	00000f9f 	.word	0x00000f9f
 8001564:	000003e7 	.word	0x000003e7
 8001568:	ffffbfff 	.word	0xffffbfff

0800156c <EXTI0_1_IRQHandler>:

//==================================================================================================
//
//==================================================================================================
void EXTI0_1_IRQHandler(void)
{
 800156c:	b530      	push	{r4, r5, lr}

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 800156e:	2380      	movs	r3, #128	; 0x80
 8001570:	2520      	movs	r5, #32
 8001572:	4c09      	ldr	r4, [pc, #36]	; (8001598 <EXTI0_1_IRQHandler+0x2c>)
 8001574:	b083      	sub	sp, #12
 8001576:	50e5      	str	r5, [r4, r3]
	uint32_t Data;

    static portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;

	IrDA_DisableIRQ(); // Disable the IRQ
	Data = IrDA_IRQHandler();
 8001578:	f7ff ffa2 	bl	80014c0 <IrDA_IRQHandler>
 800157c:	9001      	str	r0, [sp, #4]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 800157e:	6025      	str	r5, [r4, #0]
	IrDA_EnableIRQ();

	if(Data > 0)
 8001580:	2800      	cmp	r0, #0
 8001582:	d007      	beq.n	8001594 <EXTI0_1_IRQHandler+0x28>
	{
		xQueueSendFromISR(*IrDAQueueHandler, &Data, &xHigherPriorityTaskWoken);
 8001584:	4a05      	ldr	r2, [pc, #20]	; (800159c <EXTI0_1_IRQHandler+0x30>)
 8001586:	a901      	add	r1, sp, #4
 8001588:	6853      	ldr	r3, [r2, #4]
 800158a:	3214      	adds	r2, #20
 800158c:	6818      	ldr	r0, [r3, #0]
 800158e:	2300      	movs	r3, #0
 8001590:	f007 fa20 	bl	80089d4 <xQueueGenericSendFromISR>
	}
}
 8001594:	b003      	add	sp, #12
 8001596:	bd30      	pop	{r4, r5, pc}
 8001598:	e000e100 	.word	0xe000e100
 800159c:	20000154 	.word	0x20000154

080015a0 <IrDA_EnableIRQ>:
 80015a0:	2220      	movs	r2, #32
 80015a2:	4b01      	ldr	r3, [pc, #4]	; (80015a8 <IrDA_EnableIRQ+0x8>)
 80015a4:	601a      	str	r2, [r3, #0]
//
//==================================================================================================
void IrDA_EnableIRQ(void)
{
	NVIC_EnableIRQ(EXTI0_1_IRQn);
}
 80015a6:	4770      	bx	lr
 80015a8:	e000e100 	.word	0xe000e100

080015ac <IrDA_DisableIRQ>:

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 80015ac:	2120      	movs	r1, #32
 80015ae:	2380      	movs	r3, #128	; 0x80
 80015b0:	4a01      	ldr	r2, [pc, #4]	; (80015b8 <IrDA_DisableIRQ+0xc>)
 80015b2:	50d1      	str	r1, [r2, r3]
//
//==================================================================================================
void IrDA_DisableIRQ(void)
{
	NVIC_DisableIRQ(EXTI0_1_IRQn);
}
 80015b4:	4770      	bx	lr
 80015b6:	46c0      	nop			; (mov r8, r8)
 80015b8:	e000e100 	.word	0xe000e100

080015bc <AD_Init>:

//==================================================================================================
//
//==================================================================================================
void AD_Init(void)
{
 80015bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80015be:	4647      	mov	r7, r8
 80015c0:	b480      	push	{r7}
	if(AD_Initialized == 0)
 80015c2:	4e5b      	ldr	r6, [pc, #364]	; (8001730 <AD_Init+0x174>)

//==================================================================================================
//
//==================================================================================================
void AD_Init(void)
{
 80015c4:	b08e      	sub	sp, #56	; 0x38
	if(AD_Initialized == 0)
 80015c6:	7835      	ldrb	r5, [r6, #0]
 80015c8:	2d00      	cmp	r5, #0
 80015ca:	d003      	beq.n	80015d4 <AD_Init+0x18>
		ADC_Config();
		DMA_Config();

		AD_Initialized = 1;
	}
}
 80015cc:	b00e      	add	sp, #56	; 0x38
 80015ce:	bc04      	pop	{r2}
 80015d0:	4690      	mov	r8, r2
 80015d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
{
	ADC_InitTypeDef	 ADC_InitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;

	/* ADC1 DeInit */
	ADC_DeInit(ADC1);
 80015d4:	4857      	ldr	r0, [pc, #348]	; (8001734 <AD_Init+0x178>)
 80015d6:	f003 fdc3 	bl	8005160 <ADC_DeInit>

	/* GPIOA and GPIOB Periph clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 80015da:	2080      	movs	r0, #128	; 0x80
 80015dc:	2101      	movs	r1, #1
 80015de:	0280      	lsls	r0, r0, #10
 80015e0:	f005 f83e 	bl	8006660 <RCC_AHBPeriphClockCmd>
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 80015e4:	2080      	movs	r0, #128	; 0x80
 80015e6:	2101      	movs	r1, #1
 80015e8:	02c0      	lsls	r0, r0, #11
 80015ea:	f005 f839 	bl	8006660 <RCC_AHBPeriphClockCmd>

	/* ADC1 Periph clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
 80015ee:	2080      	movs	r0, #128	; 0x80
 80015f0:	2101      	movs	r1, #1
 80015f2:	0080      	lsls	r0, r0, #2
 80015f4:	f005 f840 	bl	8006678 <RCC_APB2PeriphClockCmd>

	/* Configure ADC Channels as analog input */
	GPIO_InitStructure.GPIO_Pin  = AD_PIN_VOLTMETER | AD_PIN_NTC1 | AD_PIN_NTC2 | AD_PIN_NTC3;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80015f8:	2090      	movs	r0, #144	; 0x90

	/* ADC1 Periph clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);

	/* Configure ADC Channels as analog input */
	GPIO_InitStructure.GPIO_Pin  = AD_PIN_VOLTMETER | AD_PIN_NTC1 | AD_PIN_NTC2 | AD_PIN_NTC3;
 80015fa:	2333      	movs	r3, #51	; 0x33
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 80015fc:	2703      	movs	r7, #3

	/* ADC1 Periph clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);

	/* Configure ADC Channels as analog input */
	GPIO_InitStructure.GPIO_Pin  = AD_PIN_VOLTMETER | AD_PIN_NTC1 | AD_PIN_NTC2 | AD_PIN_NTC3;
 80015fe:	ac01      	add	r4, sp, #4
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8001600:	1c21      	adds	r1, r4, #0
 8001602:	05c0      	lsls	r0, r0, #23
	/* ADC1 Periph clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);

	/* Configure ADC Channels as analog input */
	GPIO_InitStructure.GPIO_Pin  = AD_PIN_VOLTMETER | AD_PIN_NTC1 | AD_PIN_NTC2 | AD_PIN_NTC3;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 8001604:	7127      	strb	r7, [r4, #4]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8001606:	71e5      	strb	r5, [r4, #7]

	/* ADC1 Periph clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);

	/* Configure ADC Channels as analog input */
	GPIO_InitStructure.GPIO_Pin  = AD_PIN_VOLTMETER | AD_PIN_NTC1 | AD_PIN_NTC2 | AD_PIN_NTC3;
 8001608:	9301      	str	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800160a:	f004 fc0f 	bl	8005e2c <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin  = AD_PIN_TOUCH_UP;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800160e:	2090      	movs	r0, #144	; 0x90
	GPIO_InitStructure.GPIO_Pin  = AD_PIN_VOLTMETER | AD_PIN_NTC1 | AD_PIN_NTC2 | AD_PIN_NTC3;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin  = AD_PIN_TOUCH_UP;
 8001610:	2380      	movs	r3, #128	; 0x80
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8001612:	1c21      	adds	r1, r4, #0
 8001614:	05c0      	lsls	r0, r0, #23
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin  = AD_PIN_TOUCH_UP;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 8001616:	7127      	strb	r7, [r4, #4]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8001618:	71e5      	strb	r5, [r4, #7]
	GPIO_InitStructure.GPIO_Pin  = AD_PIN_VOLTMETER | AD_PIN_NTC1 | AD_PIN_NTC2 | AD_PIN_NTC3;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin  = AD_PIN_TOUCH_UP;
 800161a:	9301      	str	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800161c:	f004 fc06 	bl	8005e2c <GPIO_Init>

	/* Configure ADC Channels as analog input */
	GPIO_InitStructure.GPIO_Pin  = AD_PIN_TOUCH_DOWN;
 8001620:	2301      	movs	r3, #1
 8001622:	4698      	mov	r8, r3
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001624:	1c21      	adds	r1, r4, #0
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* Configure ADC Channels as analog input */
	GPIO_InitStructure.GPIO_Pin  = AD_PIN_TOUCH_DOWN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 8001626:	7127      	strb	r7, [r4, #4]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8001628:	71e5      	strb	r5, [r4, #7]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 800162a:	4843      	ldr	r0, [pc, #268]	; (8001738 <AD_Init+0x17c>)

	/* Initialize ADC structure */
	ADC_StructInit(&ADC_InitStructure);
 800162c:	ac03      	add	r4, sp, #12
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* Configure ADC Channels as analog input */
	GPIO_InitStructure.GPIO_Pin  = AD_PIN_TOUCH_DOWN;
 800162e:	9301      	str	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001630:	f004 fbfc 	bl	8005e2c <GPIO_Init>

	/* Initialize ADC structure */
	ADC_StructInit(&ADC_InitStructure);
 8001634:	1c20      	adds	r0, r4, #0
 8001636:	f003 fdbb 	bl	80051b0 <ADC_StructInit>

	/* Configure the ADC1 in continuous mode withe a resolution equal to 12 bits  */
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
	ADC_InitStructure.ADC_ContinuousConvMode   = ENABLE;
 800163a:	4643      	mov	r3, r8
	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
	ADC_InitStructure.ADC_DataAlign 	= ADC_DataAlign_Right;
	ADC_InitStructure.ADC_ScanDirection = ADC_ScanDirection_Upward;
	ADC_Init(ADC1, &ADC_InitStructure);
 800163c:	483d      	ldr	r0, [pc, #244]	; (8001734 <AD_Init+0x178>)
 800163e:	1c21      	adds	r1, r4, #0
	/* Initialize ADC structure */
	ADC_StructInit(&ADC_InitStructure);

	/* Configure the ADC1 in continuous mode withe a resolution equal to 12 bits  */
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
	ADC_InitStructure.ADC_ContinuousConvMode   = ENABLE;
 8001640:	7123      	strb	r3, [r4, #4]

	/* Initialize ADC structure */
	ADC_StructInit(&ADC_InitStructure);

	/* Configure the ADC1 in continuous mode withe a resolution equal to 12 bits  */
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
 8001642:	9503      	str	r5, [sp, #12]
	ADC_InitStructure.ADC_ContinuousConvMode   = ENABLE;
	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 8001644:	60a5      	str	r5, [r4, #8]
	ADC_InitStructure.ADC_DataAlign 	= ADC_DataAlign_Right;
 8001646:	6125      	str	r5, [r4, #16]
	ADC_InitStructure.ADC_ScanDirection = ADC_ScanDirection_Upward;
 8001648:	6165      	str	r5, [r4, #20]
	ADC_Init(ADC1, &ADC_InitStructure);
 800164a:	f003 fd9b 	bl	8005184 <ADC_Init>

	//ADC_ChannelConfig(ADC1, ADC_Channel_0, ADC_SampleTime_28_5Cycles); // PA0 - ADC_IN0 - VOLTMETER
	ADC_ChannelConfig(ADC1, ADC_Channel_0, ADC_SampleTime_239_5Cycles);// PA0 - ADC_IN0 - VOLTMETER
 800164e:	4839      	ldr	r0, [pc, #228]	; (8001734 <AD_Init+0x178>)
 8001650:	2101      	movs	r1, #1
 8001652:	2207      	movs	r2, #7
 8001654:	f003 fe4e 	bl	80052f4 <ADC_ChannelConfig>
	ADC_ChannelConfig(ADC1, ADC_Channel_1, ADC_SampleTime_28_5Cycles); // PA1 - ADC_IN1 - NTC1
 8001658:	4836      	ldr	r0, [pc, #216]	; (8001734 <AD_Init+0x178>)
 800165a:	2102      	movs	r1, #2
 800165c:	2203      	movs	r2, #3
 800165e:	f003 fe49 	bl	80052f4 <ADC_ChannelConfig>
	ADC_ChannelConfig(ADC1, ADC_Channel_4, ADC_SampleTime_28_5Cycles); // PA4 - ADC_IN4 - NTC2
 8001662:	4834      	ldr	r0, [pc, #208]	; (8001734 <AD_Init+0x178>)
 8001664:	2110      	movs	r1, #16
 8001666:	2203      	movs	r2, #3
 8001668:	f003 fe44 	bl	80052f4 <ADC_ChannelConfig>
	ADC_ChannelConfig(ADC1, ADC_Channel_5, ADC_SampleTime_28_5Cycles); // PA5 - ADC_IN5 - NTC3
 800166c:	4831      	ldr	r0, [pc, #196]	; (8001734 <AD_Init+0x178>)
 800166e:	2120      	movs	r1, #32
 8001670:	2203      	movs	r2, #3
 8001672:	f003 fe3f 	bl	80052f4 <ADC_ChannelConfig>
	ADC_ChannelConfig(ADC1, ADC_Channel_7, ADC_SampleTime_28_5Cycles); // PB7 - ADC_IN7 - TOUCH_UP
 8001676:	482f      	ldr	r0, [pc, #188]	; (8001734 <AD_Init+0x178>)
 8001678:	2180      	movs	r1, #128	; 0x80
 800167a:	2203      	movs	r2, #3
 800167c:	f003 fe3a 	bl	80052f4 <ADC_ChannelConfig>
	ADC_ChannelConfig(ADC1, ADC_Channel_8, ADC_SampleTime_28_5Cycles); // PB0 - ADC_IN8 - TOUCH_DOWN
 8001680:	2180      	movs	r1, #128	; 0x80
 8001682:	482c      	ldr	r0, [pc, #176]	; (8001734 <AD_Init+0x178>)
 8001684:	0049      	lsls	r1, r1, #1
 8001686:	2203      	movs	r2, #3
 8001688:	f003 fe34 	bl	80052f4 <ADC_ChannelConfig>


	/* Convert the ADC1 temperature sensor  with 55.5 Cycles as sampling time */
	ADC_ChannelConfig(ADC1, ADC_Channel_TempSensor, ADC_SampleTime_28_5Cycles);
 800168c:	2180      	movs	r1, #128	; 0x80
 800168e:	2203      	movs	r2, #3
 8001690:	0249      	lsls	r1, r1, #9
 8001692:	4828      	ldr	r0, [pc, #160]	; (8001734 <AD_Init+0x178>)
 8001694:	f003 fe2e 	bl	80052f4 <ADC_ChannelConfig>

	ADC_TempSensorCmd(ENABLE);
 8001698:	2001      	movs	r0, #1
 800169a:	f003 fdf5 	bl	8005288 <ADC_TempSensorCmd>

	/* Convert the ADC1 Vref  with 55.5 Cycles as sampling time */
	//ADC_ChannelConfig(ADC1, ADC_Channel_Vrefint, ADC_SampleTime_28_5Cycles);
	ADC_ChannelConfig(ADC1, ADC_Channel_Vrefint, ADC_SampleTime_239_5Cycles);
 800169e:	2180      	movs	r1, #128	; 0x80
 80016a0:	2207      	movs	r2, #7
 80016a2:	0289      	lsls	r1, r1, #10
 80016a4:	4823      	ldr	r0, [pc, #140]	; (8001734 <AD_Init+0x178>)
 80016a6:	f003 fe25 	bl	80052f4 <ADC_ChannelConfig>
	ADC_VrefintCmd(ENABLE);
 80016aa:	2001      	movs	r0, #1
 80016ac:	f003 fdfe 	bl	80052ac <ADC_VrefintCmd>

	/* ADC Calibration */
	ADC_GetCalibrationFactor(ADC1);
 80016b0:	4820      	ldr	r0, [pc, #128]	; (8001734 <AD_Init+0x178>)
 80016b2:	f003 fe55 	bl	8005360 <ADC_GetCalibrationFactor>

	/* ADC DMA request in circular mode */
	ADC_DMARequestModeConfig(ADC1, ADC_DMAMode_Circular);
 80016b6:	481f      	ldr	r0, [pc, #124]	; (8001734 <AD_Init+0x178>)
 80016b8:	2102      	movs	r1, #2
 80016ba:	f003 fe89 	bl	80053d0 <ADC_DMARequestModeConfig>

	/* Enable ADC_DMA */
	ADC_DMACmd(ADC1, ENABLE);
 80016be:	481d      	ldr	r0, [pc, #116]	; (8001734 <AD_Init+0x178>)
 80016c0:	2101      	movs	r1, #1
 80016c2:	f003 fe79 	bl	80053b8 <ADC_DMACmd>

	/* Enable the ADC peripheral */
	ADC_Cmd(ADC1, ENABLE);
 80016c6:	481b      	ldr	r0, [pc, #108]	; (8001734 <AD_Init+0x178>)
 80016c8:	2101      	movs	r1, #1
 80016ca:	f003 fd79 	bl	80051c0 <ADC_Cmd>

	/* Wait the ADRDY flag */
	while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_ADRDY));
 80016ce:	4819      	ldr	r0, [pc, #100]	; (8001734 <AD_Init+0x178>)
 80016d0:	2101      	movs	r1, #1
 80016d2:	f003 fe8f 	bl	80053f4 <ADC_GetFlagStatus>
 80016d6:	2800      	cmp	r0, #0
 80016d8:	d0f9      	beq.n	80016ce <AD_Init+0x112>

	/* ADC1 regular Software Start Conv */
	ADC_StartOfConversion(ADC1);
 80016da:	4816      	ldr	r0, [pc, #88]	; (8001734 <AD_Init+0x178>)
 80016dc:	f003 fe62 	bl	80053a4 <ADC_StartOfConversion>
static void DMA_Config(void)
{
	DMA_InitTypeDef   DMA_InitStructure;

	/* DMA1 clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
 80016e0:	2101      	movs	r1, #1
 80016e2:	2001      	movs	r0, #1
 80016e4:	f004 ffbc 	bl	8006660 <RCC_AHBPeriphClockCmd>

	/* DMA1 Channel1 Config */
	DMA_DeInit(DMA1_Channel1);
 80016e8:	4814      	ldr	r0, [pc, #80]	; (800173c <AD_Init+0x180>)
 80016ea:	f003 fe9f 	bl	800542c <DMA_DeInit>
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC1_DR_Address;
	DMA_InitStructure.DMA_MemoryBaseAddr 	 = (uint32_t)RegularConvData_Tab;
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
	DMA_InitStructure.DMA_BufferSize 	= SAMPLES;
 80016ee:	2208      	movs	r2, #8
 80016f0:	60e2      	str	r2, [r4, #12]
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
	DMA_InitStructure.DMA_MemoryInc 	= DMA_MemoryInc_Enable;
 80016f2:	3278      	adds	r2, #120	; 0x78
 80016f4:	6162      	str	r2, [r4, #20]
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
 80016f6:	3280      	adds	r2, #128	; 0x80
 80016f8:	61a2      	str	r2, [r4, #24]
	DMA_InitStructure.DMA_MemoryDataSize 	 = DMA_MemoryDataSize_HalfWord;
 80016fa:	2280      	movs	r2, #128	; 0x80
 80016fc:	00d2      	lsls	r2, r2, #3
 80016fe:	61e2      	str	r2, [r4, #28]
	DMA_InitStructure.DMA_Mode 		= DMA_Mode_Circular;
 8001700:	2220      	movs	r2, #32
	/* DMA1 clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

	/* DMA1 Channel1 Config */
	DMA_DeInit(DMA1_Channel1);
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC1_DR_Address;
 8001702:	4b0f      	ldr	r3, [pc, #60]	; (8001740 <AD_Init+0x184>)
	DMA_InitStructure.DMA_BufferSize 	= SAMPLES;
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
	DMA_InitStructure.DMA_MemoryInc 	= DMA_MemoryInc_Enable;
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
	DMA_InitStructure.DMA_MemoryDataSize 	 = DMA_MemoryDataSize_HalfWord;
	DMA_InitStructure.DMA_Mode 		= DMA_Mode_Circular;
 8001704:	6222      	str	r2, [r4, #32]
	/* DMA1 clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

	/* DMA1 Channel1 Config */
	DMA_DeInit(DMA1_Channel1);
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC1_DR_Address;
 8001706:	9303      	str	r3, [sp, #12]
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
	DMA_InitStructure.DMA_MemoryInc 	= DMA_MemoryInc_Enable;
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
	DMA_InitStructure.DMA_MemoryDataSize 	 = DMA_MemoryDataSize_HalfWord;
	DMA_InitStructure.DMA_Mode 		= DMA_Mode_Circular;
	DMA_InitStructure.DMA_Priority 	= DMA_Priority_High;
 8001708:	2280      	movs	r2, #128	; 0x80
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

	/* DMA1 Channel1 Config */
	DMA_DeInit(DMA1_Channel1);
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC1_DR_Address;
	DMA_InitStructure.DMA_MemoryBaseAddr 	 = (uint32_t)RegularConvData_Tab;
 800170a:	1d33      	adds	r3, r6, #4
 800170c:	6063      	str	r3, [r4, #4]
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 800170e:	2300      	movs	r3, #0
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
	DMA_InitStructure.DMA_MemoryInc 	= DMA_MemoryInc_Enable;
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
	DMA_InitStructure.DMA_MemoryDataSize 	 = DMA_MemoryDataSize_HalfWord;
	DMA_InitStructure.DMA_Mode 		= DMA_Mode_Circular;
	DMA_InitStructure.DMA_Priority 	= DMA_Priority_High;
 8001710:	0192      	lsls	r2, r2, #6
	DMA_InitStructure.DMA_M2M 		= DMA_M2M_Disable;
	DMA_Init(DMA1_Channel1, &DMA_InitStructure);
 8001712:	480a      	ldr	r0, [pc, #40]	; (800173c <AD_Init+0x180>)
 8001714:	1c21      	adds	r1, r4, #0

	/* DMA1 Channel1 Config */
	DMA_DeInit(DMA1_Channel1);
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC1_DR_Address;
	DMA_InitStructure.DMA_MemoryBaseAddr 	 = (uint32_t)RegularConvData_Tab;
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 8001716:	60a3      	str	r3, [r4, #8]
	DMA_InitStructure.DMA_BufferSize 	= SAMPLES;
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8001718:	6123      	str	r3, [r4, #16]
	DMA_InitStructure.DMA_MemoryInc 	= DMA_MemoryInc_Enable;
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
	DMA_InitStructure.DMA_MemoryDataSize 	 = DMA_MemoryDataSize_HalfWord;
	DMA_InitStructure.DMA_Mode 		= DMA_Mode_Circular;
	DMA_InitStructure.DMA_Priority 	= DMA_Priority_High;
	DMA_InitStructure.DMA_M2M 		= DMA_M2M_Disable;
 800171a:	62a3      	str	r3, [r4, #40]	; 0x28
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
	DMA_InitStructure.DMA_MemoryInc 	= DMA_MemoryInc_Enable;
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
	DMA_InitStructure.DMA_MemoryDataSize 	 = DMA_MemoryDataSize_HalfWord;
	DMA_InitStructure.DMA_Mode 		= DMA_Mode_Circular;
	DMA_InitStructure.DMA_Priority 	= DMA_Priority_High;
 800171c:	6262      	str	r2, [r4, #36]	; 0x24
	DMA_InitStructure.DMA_M2M 		= DMA_M2M_Disable;
	DMA_Init(DMA1_Channel1, &DMA_InitStructure);
 800171e:	f003 ff13 	bl	8005548 <DMA_Init>

	/* DMA1 Channel1 enable */
	DMA_Cmd(DMA1_Channel1, ENABLE);
 8001722:	4806      	ldr	r0, [pc, #24]	; (800173c <AD_Init+0x180>)
 8001724:	2101      	movs	r1, #1
 8001726:	f003 ff3b 	bl	80055a0 <DMA_Cmd>
	if(AD_Initialized == 0)
	{
		ADC_Config();
		DMA_Config();

		AD_Initialized = 1;
 800172a:	2301      	movs	r3, #1
 800172c:	7033      	strb	r3, [r6, #0]
 800172e:	e74d      	b.n	80015cc <AD_Init+0x10>
 8001730:	2000016c 	.word	0x2000016c
 8001734:	40012400 	.word	0x40012400
 8001738:	48000400 	.word	0x48000400
 800173c:	40020008 	.word	0x40020008
 8001740:	40012440 	.word	0x40012440

08001744 <AD_GetValue>:

//==================================================================================================
//
//==================================================================================================
uint16_t AD_GetValue(uint8_t index)
{
 8001744:	b538      	push	{r3, r4, r5, lr}
	if(AD_Initialized == 1)
 8001746:	4d0a      	ldr	r5, [pc, #40]	; (8001770 <AD_GetValue+0x2c>)

//==================================================================================================
//
//==================================================================================================
uint16_t AD_GetValue(uint8_t index)
{
 8001748:	1c04      	adds	r4, r0, #0
	if(AD_Initialized == 1)
 800174a:	782b      	ldrb	r3, [r5, #0]

		return RegularConvData_Tab[index];
	}
	else
	{
		return 0;
 800174c:	2000      	movs	r0, #0
//==================================================================================================
//
//==================================================================================================
uint16_t AD_GetValue(uint8_t index)
{
	if(AD_Initialized == 1)
 800174e:	2b01      	cmp	r3, #1
 8001750:	d000      	beq.n	8001754 <AD_GetValue+0x10>
	}
	else
	{
		return 0;
	}
}
 8001752:	bd38      	pop	{r3, r4, r5, pc}
		// RegularConvData_Tab[7] - Vref               - ADC_IN17
		//--------------------------------------------------------

		/* Test DMA1 TC flag */

		while((DMA_GetFlagStatus(DMA1_FLAG_TC1)) == RESET);
 8001754:	2002      	movs	r0, #2
 8001756:	f003 ff51 	bl	80055fc <DMA_GetFlagStatus>
 800175a:	2800      	cmp	r0, #0
 800175c:	d0fa      	beq.n	8001754 <AD_GetValue+0x10>

		/* Clear DMA TC flag */
		DMA_ClearFlag(DMA1_FLAG_TC1);

		return RegularConvData_Tab[index];
 800175e:	0064      	lsls	r4, r4, #1
		/* Test DMA1 TC flag */

		while((DMA_GetFlagStatus(DMA1_FLAG_TC1)) == RESET);

		/* Clear DMA TC flag */
		DMA_ClearFlag(DMA1_FLAG_TC1);
 8001760:	2002      	movs	r0, #2

		return RegularConvData_Tab[index];
 8001762:	192c      	adds	r4, r5, r4
		/* Test DMA1 TC flag */

		while((DMA_GetFlagStatus(DMA1_FLAG_TC1)) == RESET);

		/* Clear DMA TC flag */
		DMA_ClearFlag(DMA1_FLAG_TC1);
 8001764:	f003 ff5a 	bl	800561c <DMA_ClearFlag>

		return RegularConvData_Tab[index];
 8001768:	88a0      	ldrh	r0, [r4, #4]
 800176a:	b280      	uxth	r0, r0
 800176c:	e7f1      	b.n	8001752 <AD_GetValue+0xe>
 800176e:	46c0      	nop			; (mov r8, r8)
 8001770:	2000016c 	.word	0x2000016c

08001774 <vFlowTimerCallback>:
//==================================================================================================
//
//==================================================================================================
void vFlowTimerCallback(TimerHandle_t pxTimer)
{
	Frequency = 0;
 8001774:	2300      	movs	r3, #0

//==================================================================================================
//
//==================================================================================================
void vFlowTimerCallback(TimerHandle_t pxTimer)
{
 8001776:	b500      	push	{lr}
	Frequency = 0;
 8001778:	4a05      	ldr	r2, [pc, #20]	; (8001790 <vFlowTimerCallback+0x1c>)

//==================================================================================================
//
//==================================================================================================
void vFlowTimerCallback(TimerHandle_t pxTimer)
{
 800177a:	b083      	sub	sp, #12
	Frequency = 0;
 800177c:	6013      	str	r3, [r2, #0]
	Flow = 0;
 800177e:	8093      	strh	r3, [r2, #4]
	FlowDerivative = 0;
 8001780:	80d3      	strh	r3, [r2, #6]

	xTimerStop(pxTimer, 0);
 8001782:	2103      	movs	r1, #3
 8001784:	9300      	str	r3, [sp, #0]
 8001786:	2200      	movs	r2, #0
 8001788:	f008 fa12 	bl	8009bb0 <xTimerGenericCommand>
}
 800178c:	b003      	add	sp, #12
 800178e:	bd00      	pop	{pc}
 8001790:	20000180 	.word	0x20000180

08001794 <Flowmeter_Init>:
	NVIC_InitTypeDef NVIC_InitStructure;
	TIM_ICInitTypeDef TIM_ICInitStructure;
	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;

	/* TIM15 clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM15, ENABLE);
 8001794:	2080      	movs	r0, #128	; 0x80

//==================================================================================================
//
//==================================================================================================
void Flowmeter_Init(void)
{
 8001796:	b5f0      	push	{r4, r5, r6, r7, lr}
	NVIC_InitTypeDef NVIC_InitStructure;
	TIM_ICInitTypeDef TIM_ICInitStructure;
	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;

	/* TIM15 clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM15, ENABLE);
 8001798:	0240      	lsls	r0, r0, #9

//==================================================================================================
//
//==================================================================================================
void Flowmeter_Init(void)
{
 800179a:	b08d      	sub	sp, #52	; 0x34
	NVIC_InitTypeDef NVIC_InitStructure;
	TIM_ICInitTypeDef TIM_ICInitStructure;
	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;

	/* TIM15 clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM15, ENABLE);
 800179c:	2101      	movs	r1, #1
 800179e:	f004 ff6b 	bl	8006678 <RCC_APB2PeriphClockCmd>

	/* GPIOB clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 80017a2:	2080      	movs	r0, #128	; 0x80
 80017a4:	2101      	movs	r1, #1
 80017a6:	02c0      	lsls	r0, r0, #11
 80017a8:	f004 ff5a 	bl	8006660 <RCC_AHBPeriphClockCmd>

	/* TIM15 chennel2 configuration : PA.01 */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_15; // Flowmeter PIN
 80017ac:	2380      	movs	r3, #128	; 0x80
 80017ae:	021b      	lsls	r3, r3, #8
 80017b0:	9304      	str	r3, [sp, #16]
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 80017b2:	2302      	movs	r3, #2
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80017b4:	2400      	movs	r4, #0
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP ;
 80017b6:	2701      	movs	r7, #1
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 80017b8:	4d2e      	ldr	r5, [pc, #184]	; (8001874 <Flowmeter_Init+0xe0>)

	/* GPIOB clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);

	/* TIM15 chennel2 configuration : PA.01 */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_15; // Flowmeter PIN
 80017ba:	a904      	add	r1, sp, #16
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 80017bc:	710b      	strb	r3, [r1, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP ;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 80017be:	1c28      	adds	r0, r5, #0
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);

	/* TIM15 chennel2 configuration : PA.01 */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_15; // Flowmeter PIN
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80017c0:	3301      	adds	r3, #1
 80017c2:	714b      	strb	r3, [r1, #5]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80017c4:	718c      	strb	r4, [r1, #6]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP ;
 80017c6:	71cf      	strb	r7, [r1, #7]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 80017c8:	f004 fb30 	bl	8005e2c <GPIO_Init>

	/* Connect TIM pin to AF2 */
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource15, GPIO_AF_1);
 80017cc:	2201      	movs	r2, #1
 80017ce:	1c28      	adds	r0, r5, #0
 80017d0:	210f      	movs	r1, #15
 80017d2:	f004 fbcd 	bl	8005f70 <GPIO_PinAFConfig>

	/* Enable the TIM15 global Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = TIM15_IRQn;
 80017d6:	2314      	movs	r3, #20
 80017d8:	a803      	add	r0, sp, #12
 80017da:	7003      	strb	r3, [r0, #0]
	NVIC_InitStructure.NVIC_IRQChannelPriority = 0;
 80017dc:	7044      	strb	r4, [r0, #1]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80017de:	7087      	strb	r7, [r0, #2]
	NVIC_Init(&NVIC_InitStructure);
 80017e0:	f004 fbd8 	bl	8005f94 <NVIC_Init>

	/* Time base configuration */

	TIM_TimeBaseStructure.TIM_Prescaler 	= (SystemCoreClock / 1000) - 1; // (48000000/1000)-1 = 47999
 80017e4:	21fa      	movs	r1, #250	; 0xfa
 80017e6:	4b24      	ldr	r3, [pc, #144]	; (8001878 <Flowmeter_Init+0xe4>)
 80017e8:	0089      	lsls	r1, r1, #2
 80017ea:	6818      	ldr	r0, [r3, #0]
 80017ec:	f001 ffc2 	bl	8003774 <__aeabi_uidiv>
	TIM_TimeBaseStructure.TIM_Period 		= 0xFFFF; // Maximal
	TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;
	TIM_TimeBaseStructure.TIM_CounterMode 	= TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM15, &TIM_TimeBaseStructure);
 80017f0:	4d22      	ldr	r5, [pc, #136]	; (800187c <Flowmeter_Init+0xe8>)
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	/* Time base configuration */

	TIM_TimeBaseStructure.TIM_Prescaler 	= (SystemCoreClock / 1000) - 1; // (48000000/1000)-1 = 47999
 80017f2:	ae09      	add	r6, sp, #36	; 0x24
	TIM_TimeBaseStructure.TIM_Period 		= 0xFFFF; // Maximal
 80017f4:	4b22      	ldr	r3, [pc, #136]	; (8001880 <Flowmeter_Init+0xec>)
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	/* Time base configuration */

	TIM_TimeBaseStructure.TIM_Prescaler 	= (SystemCoreClock / 1000) - 1; // (48000000/1000)-1 = 47999
 80017f6:	3801      	subs	r0, #1
 80017f8:	8030      	strh	r0, [r6, #0]
	TIM_TimeBaseStructure.TIM_Period 		= 0xFFFF; // Maximal
	TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;
	TIM_TimeBaseStructure.TIM_CounterMode 	= TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM15, &TIM_TimeBaseStructure);
 80017fa:	1c31      	adds	r1, r6, #0
 80017fc:	1c28      	adds	r0, r5, #0
	NVIC_Init(&NVIC_InitStructure);

	/* Time base configuration */

	TIM_TimeBaseStructure.TIM_Prescaler 	= (SystemCoreClock / 1000) - 1; // (48000000/1000)-1 = 47999
	TIM_TimeBaseStructure.TIM_Period 		= 0xFFFF; // Maximal
 80017fe:	6073      	str	r3, [r6, #4]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;
 8001800:	8134      	strh	r4, [r6, #8]
	TIM_TimeBaseStructure.TIM_CounterMode 	= TIM_CounterMode_Up;
 8001802:	8074      	strh	r4, [r6, #2]
	TIM_TimeBaseInit(TIM15, &TIM_TimeBaseStructure);
 8001804:	f005 fe9a 	bl	800753c <TIM_TimeBaseInit>

	TIM_ICInitStructure.TIM_Channel 	= TIM_Channel_2;
 8001808:	2304      	movs	r3, #4
 800180a:	a906      	add	r1, sp, #24
 800180c:	800b      	strh	r3, [r1, #0]
	TIM_ICInitStructure.TIM_ICPolarity 	= TIM_ICPolarity_BothEdge;
	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
	TIM_ICInitStructure.TIM_ICFilter 	= 0x0;

	TIM_PWMIConfig(TIM15, &TIM_ICInitStructure);
 800180e:	1c28      	adds	r0, r5, #0
	TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;
	TIM_TimeBaseStructure.TIM_CounterMode 	= TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM15, &TIM_TimeBaseStructure);

	TIM_ICInitStructure.TIM_Channel 	= TIM_Channel_2;
	TIM_ICInitStructure.TIM_ICPolarity 	= TIM_ICPolarity_BothEdge;
 8001810:	3306      	adds	r3, #6
 8001812:	804b      	strh	r3, [r1, #2]
	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
 8001814:	808f      	strh	r7, [r1, #4]
	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
 8001816:	80cc      	strh	r4, [r1, #6]
	TIM_ICInitStructure.TIM_ICFilter 	= 0x0;
 8001818:	810c      	strh	r4, [r1, #8]

	TIM_PWMIConfig(TIM15, &TIM_ICInitStructure);
 800181a:	f006 fa3f 	bl	8007c9c <TIM_PWMIConfig>

	/* Select the TIM15 Input Trigger: TI2FP2 */
	TIM_SelectInputTrigger(TIM15, TIM_TS_TI2FP2);
 800181e:	1c28      	adds	r0, r5, #0
 8001820:	2160      	movs	r1, #96	; 0x60
 8001822:	f006 fbc3 	bl	8007fac <TIM_SelectInputTrigger>

	/* Select the slave Mode: Reset Mode */
	TIM_SelectSlaveMode(TIM15, TIM_SlaveMode_Reset);
 8001826:	1c28      	adds	r0, r5, #0
 8001828:	2104      	movs	r1, #4
 800182a:	f006 fbcd 	bl	8007fc8 <TIM_SelectSlaveMode>
	TIM_SelectMasterSlaveMode(TIM15,TIM_MasterSlaveMode_Enable);
 800182e:	1c28      	adds	r0, r5, #0
 8001830:	2180      	movs	r1, #128	; 0x80
 8001832:	f006 fbd1 	bl	8007fd8 <TIM_SelectMasterSlaveMode>

	/* TIM enable counter */
	TIM_Cmd(TIM15, ENABLE);
 8001836:	1c28      	adds	r0, r5, #0
 8001838:	2101      	movs	r1, #1
 800183a:	f005 ff21 	bl	8007680 <TIM_Cmd>

	/* Enable the CC2 Interrupt Request */
	TIM_ITConfig(TIM15, TIM_IT_CC2, ENABLE);
 800183e:	1c28      	adds	r0, r5, #0
 8001840:	2104      	movs	r1, #4
 8001842:	2201      	movs	r2, #1
 8001844:	f006 fb06 	bl	8007e54 <TIM_ITConfig>

	Frequency = 0;
 8001848:	4d0e      	ldr	r5, [pc, #56]	; (8001884 <Flowmeter_Init+0xf0>)
	Flow = 0;
	FlowDerivative = 0;

	xFlowTimer = xTimerCreate("FlowTimer",
 800184a:	4b0f      	ldr	r3, [pc, #60]	; (8001888 <Flowmeter_Init+0xf4>)
	TIM_Cmd(TIM15, ENABLE);

	/* Enable the CC2 Interrupt Request */
	TIM_ITConfig(TIM15, TIM_IT_CC2, ENABLE);

	Frequency = 0;
 800184c:	602c      	str	r4, [r5, #0]
	Flow = 0;
 800184e:	80ac      	strh	r4, [r5, #4]
	FlowDerivative = 0;
 8001850:	80ec      	strh	r4, [r5, #6]

	xFlowTimer = xTimerCreate("FlowTimer",
 8001852:	9300      	str	r3, [sp, #0]
 8001854:	68ab      	ldr	r3, [r5, #8]
 8001856:	2164      	movs	r1, #100	; 0x64
 8001858:	2200      	movs	r2, #0
 800185a:	480c      	ldr	r0, [pc, #48]	; (800188c <Flowmeter_Init+0xf8>)
 800185c:	f008 f988 	bl	8009b70 <xTimerCreate>
							  100 / portTICK_PERIOD_MS,
							  pdFALSE,
							  pvTimerID,
							  vFlowTimerCallback);

	xTimerStopFromISR(xFlowTimer, 0);
 8001860:	2108      	movs	r1, #8

	Frequency = 0;
	Flow = 0;
	FlowDerivative = 0;

	xFlowTimer = xTimerCreate("FlowTimer",
 8001862:	60e8      	str	r0, [r5, #12]
							  100 / portTICK_PERIOD_MS,
							  pdFALSE,
							  pvTimerID,
							  vFlowTimerCallback);

	xTimerStopFromISR(xFlowTimer, 0);
 8001864:	2200      	movs	r2, #0
 8001866:	9400      	str	r4, [sp, #0]
 8001868:	2300      	movs	r3, #0
 800186a:	f008 f9a1 	bl	8009bb0 <xTimerGenericCommand>

}
 800186e:	b00d      	add	sp, #52	; 0x34
 8001870:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001872:	46c0      	nop			; (mov r8, r8)
 8001874:	48000400 	.word	0x48000400
 8001878:	20000010 	.word	0x20000010
 800187c:	40014000 	.word	0x40014000
 8001880:	0000ffff 	.word	0x0000ffff
 8001884:	20000180 	.word	0x20000180
 8001888:	08001775 	.word	0x08001775
 800188c:	0800ab34 	.word	0x0800ab34

08001890 <Flowmeter_FlowConversion>:

//==================================================================================================
//
//==================================================================================================
void Flowmeter_FlowConversion()
{
 8001890:	b510      	push	{r4, lr}
	if(Frequency > 0)
 8001892:	4c0a      	ldr	r4, [pc, #40]	; (80018bc <Flowmeter_FlowConversion+0x2c>)
 8001894:	6820      	ldr	r0, [r4, #0]
 8001896:	2800      	cmp	r0, #0
 8001898:	d101      	bne.n	800189e <Flowmeter_FlowConversion+0xe>
		/******************************/

		// TODO: Fazer rotinas para calibracao - por hora esta fixo
		Flow = (14.3368 * Frequency) - 1.3948;
	}
	else Flow = 0;
 800189a:	80a0      	strh	r0, [r4, #4]
}
 800189c:	bd10      	pop	{r4, pc}
		/*   +--------+-----------+   */
		/*                            */
		/******************************/

		// TODO: Fazer rotinas para calibracao - por hora esta fixo
		Flow = (14.3368 * Frequency) - 1.3948;
 800189e:	f003 fab7 	bl	8004e10 <__aeabi_ui2d>
 80018a2:	4a07      	ldr	r2, [pc, #28]	; (80018c0 <Flowmeter_FlowConversion+0x30>)
 80018a4:	4b07      	ldr	r3, [pc, #28]	; (80018c4 <Flowmeter_FlowConversion+0x34>)
 80018a6:	f002 fc2d 	bl	8004104 <__aeabi_dmul>
 80018aa:	4a07      	ldr	r2, [pc, #28]	; (80018c8 <Flowmeter_FlowConversion+0x38>)
 80018ac:	4b07      	ldr	r3, [pc, #28]	; (80018cc <Flowmeter_FlowConversion+0x3c>)
 80018ae:	f002 fec3 	bl	8004638 <__aeabi_dsub>
 80018b2:	f002 f8e1 	bl	8003a78 <__aeabi_d2uiz>
 80018b6:	80a0      	strh	r0, [r4, #4]
 80018b8:	e7f0      	b.n	800189c <Flowmeter_FlowConversion+0xc>
 80018ba:	46c0      	nop			; (mov r8, r8)
 80018bc:	20000180 	.word	0x20000180
 80018c0:	0cb295ea 	.word	0x0cb295ea
 80018c4:	402cac71 	.word	0x402cac71
 80018c8:	ce075f70 	.word	0xce075f70
 80018cc:	3ff65119 	.word	0x3ff65119

080018d0 <Flowmeter_FlowDerivative>:

//==================================================================================================
//
//==================================================================================================
void Flowmeter_FlowDerivative()
{
 80018d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80018d2:	4647      	mov	r7, r8
	uint8_t i;
	static int16_t Derivative_Vector[N_FLOW+1];

	if(Flow <  FLOW_ON)
 80018d4:	4b18      	ldr	r3, [pc, #96]	; (8001938 <Flowmeter_FlowDerivative+0x68>)

//==================================================================================================
//
//==================================================================================================
void Flowmeter_FlowDerivative()
{
 80018d6:	b480      	push	{r7}
	uint8_t i;
	static int16_t Derivative_Vector[N_FLOW+1];

	if(Flow <  FLOW_ON)
 80018d8:	8899      	ldrh	r1, [r3, #4]
 80018da:	4698      	mov	r8, r3
 80018dc:	29b3      	cmp	r1, #179	; 0xb3
 80018de:	d926      	bls.n	800192e <Flowmeter_FlowDerivative+0x5e>
 80018e0:	1c1c      	adds	r4, r3, #0
 80018e2:	1c1d      	adds	r5, r3, #0
 80018e4:	3420      	adds	r4, #32
 80018e6:	1c23      	adds	r3, r4, #0
 80018e8:	350e      	adds	r5, #14
	}
	else
	{
		for(i=N_FLOW; i>=1; i--)
		{
			Derivative_Vector[i] = Derivative_Vector[i-1];
 80018ea:	881a      	ldrh	r2, [r3, #0]
 80018ec:	3b02      	subs	r3, #2
 80018ee:	809a      	strh	r2, [r3, #4]
	{
		FlowDerivative = 0;
	}
	else
	{
		for(i=N_FLOW; i>=1; i--)
 80018f0:	42ab      	cmp	r3, r5
 80018f2:	d1fa      	bne.n	80018ea <Flowmeter_FlowDerivative+0x1a>
		{
			Derivative_Vector[i] = Derivative_Vector[i-1];
		}

		Derivative_Vector[0] = Flow * N_FLOW;
 80018f4:	00cb      	lsls	r3, r1, #3
 80018f6:	18c9      	adds	r1, r1, r3
 80018f8:	4643      	mov	r3, r8
 80018fa:	2709      	movs	r7, #9
 80018fc:	2600      	movs	r6, #0
 80018fe:	8219      	strh	r1, [r3, #16]

		FlowDerivative = 0;

		for(i=N_FLOW; i>=1; i--)
		{
			FlowDerivative += (Derivative_Vector[i-1] - Derivative_Vector[i])/i;
 8001900:	2200      	movs	r2, #0
 8001902:	5ea3      	ldrsh	r3, [r4, r2]
 8001904:	2202      	movs	r2, #2
 8001906:	5ea0      	ldrsh	r0, [r4, r2]
 8001908:	1c39      	adds	r1, r7, #0
 800190a:	1a18      	subs	r0, r3, r0
 800190c:	f001 ffc2 	bl	8003894 <__aeabi_idiv>
 8001910:	3c02      	subs	r4, #2
 8001912:	1980      	adds	r0, r0, r6
 8001914:	b286      	uxth	r6, r0
 8001916:	3f01      	subs	r7, #1

		Derivative_Vector[0] = Flow * N_FLOW;

		FlowDerivative = 0;

		for(i=N_FLOW; i>=1; i--)
 8001918:	42a5      	cmp	r5, r4
 800191a:	d1f1      	bne.n	8001900 <Flowmeter_FlowDerivative+0x30>
		{
			FlowDerivative += (Derivative_Vector[i-1] - Derivative_Vector[i])/i;
		}

		FlowDerivative /= N_FLOW;
 800191c:	b230      	sxth	r0, r6
 800191e:	2109      	movs	r1, #9
 8001920:	f001 ffb8 	bl	8003894 <__aeabi_idiv>
 8001924:	4643      	mov	r3, r8
 8001926:	80d8      	strh	r0, [r3, #6]
	}
}
 8001928:	bc04      	pop	{r2}
 800192a:	4690      	mov	r8, r2
 800192c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint8_t i;
	static int16_t Derivative_Vector[N_FLOW+1];

	if(Flow <  FLOW_ON)
	{
		FlowDerivative = 0;
 800192e:	2300      	movs	r3, #0
 8001930:	4642      	mov	r2, r8
 8001932:	80d3      	strh	r3, [r2, #6]
 8001934:	e7f8      	b.n	8001928 <Flowmeter_FlowDerivative+0x58>
 8001936:	46c0      	nop			; (mov r8, r8)
 8001938:	20000180 	.word	0x20000180

0800193c <TIM15_IRQHandler>:
//==================================================================================================
// Flowmeter
//==================================================================================================
void TIM15_IRQHandler(void)
{
	xTimerStopFromISR(xFlowTimer, 0);
 800193c:	2300      	movs	r3, #0

//==================================================================================================
// Flowmeter
//==================================================================================================
void TIM15_IRQHandler(void)
{
 800193e:	b530      	push	{r4, r5, lr}
	xTimerStopFromISR(xFlowTimer, 0);
 8001940:	4c16      	ldr	r4, [pc, #88]	; (800199c <TIM15_IRQHandler+0x60>)

//==================================================================================================
// Flowmeter
//==================================================================================================
void TIM15_IRQHandler(void)
{
 8001942:	b083      	sub	sp, #12
	xTimerStopFromISR(xFlowTimer, 0);
 8001944:	9300      	str	r3, [sp, #0]

    if(TIM_GetITStatus(TIM15, TIM_IT_CC2) != RESET)
 8001946:	4d16      	ldr	r5, [pc, #88]	; (80019a0 <TIM15_IRQHandler+0x64>)
//==================================================================================================
// Flowmeter
//==================================================================================================
void TIM15_IRQHandler(void)
{
	xTimerStopFromISR(xFlowTimer, 0);
 8001948:	2108      	movs	r1, #8
 800194a:	68e0      	ldr	r0, [r4, #12]
 800194c:	2200      	movs	r2, #0
 800194e:	f008 f92f 	bl	8009bb0 <xTimerGenericCommand>

    if(TIM_GetITStatus(TIM15, TIM_IT_CC2) != RESET)
 8001952:	1c28      	adds	r0, r5, #0
 8001954:	2104      	movs	r1, #4
 8001956:	f006 fa93 	bl	8007e80 <TIM_GetITStatus>
 800195a:	2800      	cmp	r0, #0
 800195c:	d110      	bne.n	8001980 <TIM15_IRQHandler+0x44>
 800195e:	6820      	ldr	r0, [r4, #0]
		{
			Frequency = 0;
		}
    }

    if(Frequency < 3)
 8001960:	2802      	cmp	r0, #2
 8001962:	d801      	bhi.n	8001968 <TIM15_IRQHandler+0x2c>
    {
    	Frequency = 0;
 8001964:	2300      	movs	r3, #0
 8001966:	6023      	str	r3, [r4, #0]
    }

    xTimerStartFromISR(xFlowTimer, 0);
 8001968:	68e4      	ldr	r4, [r4, #12]
 800196a:	f007 fd23 	bl	80093b4 <xTaskGetTickCountFromISR>
 800196e:	2300      	movs	r3, #0
 8001970:	1c02      	adds	r2, r0, #0
 8001972:	9300      	str	r3, [sp, #0]
 8001974:	1c20      	adds	r0, r4, #0
 8001976:	2106      	movs	r1, #6
 8001978:	f008 f91a 	bl	8009bb0 <xTimerGenericCommand>
}
 800197c:	b003      	add	sp, #12
 800197e:	bd30      	pop	{r4, r5, pc}
	xTimerStopFromISR(xFlowTimer, 0);

    if(TIM_GetITStatus(TIM15, TIM_IT_CC2) != RESET)
    {
		/* Clear TIM15 Capture compare interrupt pending bit */
		TIM_ClearITPendingBit(TIM15, TIM_IT_CC2);
 8001980:	1c28      	adds	r0, r5, #0
 8001982:	2104      	movs	r1, #4
 8001984:	f006 fa88 	bl	8007e98 <TIM_ClearITPendingBit>

		if(TIM15->CCR2 != 0)
 8001988:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800198a:	2b00      	cmp	r3, #0
 800198c:	d0ea      	beq.n	8001964 <TIM15_IRQHandler+0x28>
		{
			Frequency = 1000 / TIM15->CCR2;
 800198e:	20fa      	movs	r0, #250	; 0xfa
 8001990:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 8001992:	0080      	lsls	r0, r0, #2
 8001994:	f001 feee 	bl	8003774 <__aeabi_uidiv>
 8001998:	6020      	str	r0, [r4, #0]
 800199a:	e7e1      	b.n	8001960 <TIM15_IRQHandler+0x24>
 800199c:	20000180 	.word	0x20000180
 80019a0:	40014000 	.word	0x40014000

080019a4 <Flowmeter_Task>:

//==================================================================================================
// Flowmeter Task
//==================================================================================================
void Flowmeter_Task(void)
{
 80019a4:	b510      	push	{r4, lr}
//==================================================================================================
//
//==================================================================================================
void Flowmeter_FlowConversion()
{
	if(Frequency > 0)
 80019a6:	4c0b      	ldr	r4, [pc, #44]	; (80019d4 <Flowmeter_Task+0x30>)
 80019a8:	6820      	ldr	r0, [r4, #0]
 80019aa:	2800      	cmp	r0, #0
 80019ac:	d103      	bne.n	80019b6 <Flowmeter_Task+0x12>
		/******************************/

		// TODO: Fazer rotinas para calibracao - por hora esta fixo
		Flow = (14.3368 * Frequency) - 1.3948;
	}
	else Flow = 0;
 80019ae:	80a0      	strh	r0, [r4, #4]
// Flowmeter Task
//==================================================================================================
void Flowmeter_Task(void)
{
	Flowmeter_FlowConversion();
	Flowmeter_FlowDerivative();
 80019b0:	f7ff ff8e 	bl	80018d0 <Flowmeter_FlowDerivative>
}
 80019b4:	bd10      	pop	{r4, pc}
		/*   +--------+-----------+   */
		/*                            */
		/******************************/

		// TODO: Fazer rotinas para calibracao - por hora esta fixo
		Flow = (14.3368 * Frequency) - 1.3948;
 80019b6:	f003 fa2b 	bl	8004e10 <__aeabi_ui2d>
 80019ba:	4a07      	ldr	r2, [pc, #28]	; (80019d8 <Flowmeter_Task+0x34>)
 80019bc:	4b07      	ldr	r3, [pc, #28]	; (80019dc <Flowmeter_Task+0x38>)
 80019be:	f002 fba1 	bl	8004104 <__aeabi_dmul>
 80019c2:	4a07      	ldr	r2, [pc, #28]	; (80019e0 <Flowmeter_Task+0x3c>)
 80019c4:	4b07      	ldr	r3, [pc, #28]	; (80019e4 <Flowmeter_Task+0x40>)
 80019c6:	f002 fe37 	bl	8004638 <__aeabi_dsub>
 80019ca:	f002 f855 	bl	8003a78 <__aeabi_d2uiz>
 80019ce:	80a0      	strh	r0, [r4, #4]
 80019d0:	e7ee      	b.n	80019b0 <Flowmeter_Task+0xc>
 80019d2:	46c0      	nop			; (mov r8, r8)
 80019d4:	20000180 	.word	0x20000180
 80019d8:	0cb295ea 	.word	0x0cb295ea
 80019dc:	402cac71 	.word	0x402cac71
 80019e0:	ce075f70 	.word	0xce075f70
 80019e4:	3ff65119 	.word	0x3ff65119

080019e8 <Flowmeter_GetFlow>:
//==================================================================================================
//
//==================================================================================================
uint16_t Flowmeter_GetFlow()
{
	if(!ForcedFlow)
 80019e8:	4b02      	ldr	r3, [pc, #8]	; (80019f4 <Flowmeter_GetFlow+0xc>)
 80019ea:	8c98      	ldrh	r0, [r3, #36]	; 0x24
 80019ec:	2800      	cmp	r0, #0
 80019ee:	d100      	bne.n	80019f2 <Flowmeter_GetFlow+0xa>
	{
	return Flow;
 80019f0:	8898      	ldrh	r0, [r3, #4]
}
	else
	{
		return ForcedFlow;
	}
}
 80019f2:	4770      	bx	lr
 80019f4:	20000180 	.word	0x20000180

080019f8 <Flowmeter_ForceGetFlow>:
//==================================================================================================
// -->> JUST TO DEBUG <<-- FUNCTION THAT FORCES THE FLOW VALUE
//==================================================================================================
void Flowmeter_ForceGetFlow(uint16_t Forced)
{
	ForcedFlow = Forced;
 80019f8:	4b01      	ldr	r3, [pc, #4]	; (8001a00 <Flowmeter_ForceGetFlow+0x8>)
 80019fa:	8498      	strh	r0, [r3, #36]	; 0x24
}
 80019fc:	4770      	bx	lr
 80019fe:	46c0      	nop			; (mov r8, r8)
 8001a00:	20000180 	.word	0x20000180

08001a04 <Flowmeter_GetFrequency>:
//==================================================================================================
//
//==================================================================================================
uint32_t Flowmeter_GetFrequency()
{
	return Frequency;
 8001a04:	4b01      	ldr	r3, [pc, #4]	; (8001a0c <Flowmeter_GetFrequency+0x8>)
 8001a06:	6818      	ldr	r0, [r3, #0]
}
 8001a08:	4770      	bx	lr
 8001a0a:	46c0      	nop			; (mov r8, r8)
 8001a0c:	20000180 	.word	0x20000180

08001a10 <Flowmeter_GetFlowDerivative>:
//==================================================================================================
//
//==================================================================================================
int16_t Flowmeter_GetFlowDerivative()
{
	return FlowDerivative;
 8001a10:	4b01      	ldr	r3, [pc, #4]	; (8001a18 <Flowmeter_GetFlowDerivative+0x8>)
 8001a12:	2006      	movs	r0, #6
 8001a14:	5e18      	ldrsh	r0, [r3, r0]
}
 8001a16:	4770      	bx	lr
 8001a18:	20000180 	.word	0x20000180

08001a1c <Flowmeter_EnableIRQ>:

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 8001a1c:	2280      	movs	r2, #128	; 0x80
 8001a1e:	4b02      	ldr	r3, [pc, #8]	; (8001a28 <Flowmeter_EnableIRQ+0xc>)
 8001a20:	0352      	lsls	r2, r2, #13
 8001a22:	601a      	str	r2, [r3, #0]
//
//==================================================================================================
void Flowmeter_EnableIRQ (void)
{
	NVIC_EnableIRQ (TIM15_IRQn);
}
 8001a24:	4770      	bx	lr
 8001a26:	46c0      	nop			; (mov r8, r8)
 8001a28:	e000e100 	.word	0xe000e100

08001a2c <Flowmeter_DisableIRQ>:

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 8001a2c:	2180      	movs	r1, #128	; 0x80
 8001a2e:	2380      	movs	r3, #128	; 0x80
 8001a30:	4a01      	ldr	r2, [pc, #4]	; (8001a38 <Flowmeter_DisableIRQ+0xc>)
 8001a32:	0349      	lsls	r1, r1, #13
 8001a34:	50d1      	str	r1, [r2, r3]
//
//==================================================================================================
void Flowmeter_DisableIRQ (void)
{
	NVIC_DisableIRQ (TIM15_IRQn);
}
 8001a36:	4770      	bx	lr
 8001a38:	e000e100 	.word	0xe000e100

08001a3c <TRIAC_Init>:

//==================================================================================================
//
//==================================================================================================
void TRIAC_Init(void)
{
 8001a3c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001a3e:	4644      	mov	r4, r8
 8001a40:	465f      	mov	r7, fp
 8001a42:	4656      	mov	r6, sl
 8001a44:	464d      	mov	r5, r9
static void TRIAC_PinProtection (void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOC Periph clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOF, ENABLE);
 8001a46:	2080      	movs	r0, #128	; 0x80

//==================================================================================================
//
//==================================================================================================
void TRIAC_Init(void)
{
 8001a48:	b4f0      	push	{r4, r5, r6, r7}
static void TRIAC_PinProtection (void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOC Periph clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOF, ENABLE);
 8001a4a:	03c0      	lsls	r0, r0, #15

//==================================================================================================
//
//==================================================================================================
void TRIAC_Init(void)
{
 8001a4c:	b087      	sub	sp, #28
static void TRIAC_PinProtection (void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOC Periph clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOF, ENABLE);
 8001a4e:	2101      	movs	r1, #1

	/* Configure PA15 in output pushpull mode */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_0; // Protection PIN
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;
 8001a50:	2500      	movs	r5, #0
static void TRIAC_PinProtection (void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOC Periph clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOF, ENABLE);
 8001a52:	f004 fe05 	bl	8006660 <RCC_AHBPeriphClockCmd>

	/* Configure PA15 in output pushpull mode */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_0; // Protection PIN
 8001a56:	2601      	movs	r6, #1
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001a58:	2303      	movs	r3, #3

	/* GPIOC Periph clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOF, ENABLE);

	/* Configure PA15 in output pushpull mode */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_0; // Protection PIN
 8001a5a:	ac03      	add	r4, sp, #12
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOF, &GPIO_InitStructure);
 8001a5c:	1c21      	adds	r1, r4, #0
 8001a5e:	4867      	ldr	r0, [pc, #412]	; (8001bfc <TRIAC_Init+0x1c0>)
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOF, ENABLE);

	/* Configure PA15 in output pushpull mode */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_0; // Protection PIN
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001a60:	469a      	mov	sl, r3

	/* GPIOC Periph clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOF, ENABLE);

	/* Configure PA15 in output pushpull mode */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_0; // Protection PIN
 8001a62:	9603      	str	r6, [sp, #12]
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;
 8001a64:	7125      	strb	r5, [r4, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001a66:	7163      	strb	r3, [r4, #5]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 8001a68:	71e5      	strb	r5, [r4, #7]
	GPIO_Init(GPIOF, &GPIO_InitStructure);
 8001a6a:	f004 f9df 	bl	8005e2c <GPIO_Init>
static void TRIAC_PinOut(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOF Periph clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 8001a6e:	2380      	movs	r3, #128	; 0x80
 8001a70:	02db      	lsls	r3, r3, #11
 8001a72:	1c18      	adds	r0, r3, #0
 8001a74:	2101      	movs	r1, #1
 8001a76:	4698      	mov	r8, r3
 8001a78:	f004 fdf2 	bl	8006660 <RCC_AHBPeriphClockCmd>
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOC, ENABLE);
 8001a7c:	2080      	movs	r0, #128	; 0x80
 8001a7e:	2101      	movs	r1, #1
 8001a80:	0300      	lsls	r0, r0, #12
 8001a82:	f004 fded 	bl	8006660 <RCC_AHBPeriphClockCmd>

	/* Configure PF7 and PF6 in output pushpull mode */
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001a86:	4653      	mov	r3, sl
 8001a88:	7163      	strb	r3, [r4, #5]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;

	/* TRIAC 1 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001a8a:	4b5d      	ldr	r3, [pc, #372]	; (8001c00 <TRIAC_Init+0x1c4>)
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;

	/* TRIAC 1 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 8001a8c:	2780      	movs	r7, #128	; 0x80
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001a8e:	4699      	mov	r9, r3
 8001a90:	1c18      	adds	r0, r3, #0
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;

	/* TRIAC 1 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 8001a92:	00bf      	lsls	r7, r7, #2
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001a94:	1c21      	adds	r1, r4, #0
	/* GPIOF Periph clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOC, ENABLE);

	/* Configure PF7 and PF6 in output pushpull mode */
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
 8001a96:	7126      	strb	r6, [r4, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8001a98:	71a5      	strb	r5, [r4, #6]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 8001a9a:	71e5      	strb	r5, [r4, #7]

	/* TRIAC 1 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 8001a9c:	9703      	str	r7, [sp, #12]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001a9e:	f004 f9c5 	bl	8005e2c <GPIO_Init>
	GPIO_ResetBits(GPIOB, GPIO_Pin_9);
 8001aa2:	4648      	mov	r0, r9
 8001aa4:	1c39      	adds	r1, r7, #0
 8001aa6:	f004 fa59 	bl	8005f5c <GPIO_ResetBits>

	/* TRIAC 2 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8001aaa:	4b56      	ldr	r3, [pc, #344]	; (8001c04 <TRIAC_Init+0x1c8>)
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	GPIO_ResetBits(GPIOB, GPIO_Pin_9);

	/* TRIAC 2 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
 8001aac:	2780      	movs	r7, #128	; 0x80
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8001aae:	469b      	mov	fp, r3
 8001ab0:	1c18      	adds	r0, r3, #0
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	GPIO_ResetBits(GPIOB, GPIO_Pin_9);

	/* TRIAC 2 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
 8001ab2:	01bf      	lsls	r7, r7, #6
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8001ab4:	1c21      	adds	r1, r4, #0
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	GPIO_ResetBits(GPIOB, GPIO_Pin_9);

	/* TRIAC 2 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
 8001ab6:	9703      	str	r7, [sp, #12]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8001ab8:	f004 f9b8 	bl	8005e2c <GPIO_Init>
	GPIO_ResetBits(GPIOC, GPIO_Pin_13);
 8001abc:	4658      	mov	r0, fp
 8001abe:	1c39      	adds	r1, r7, #0
 8001ac0:	f004 fa4c 	bl	8005f5c <GPIO_ResetBits>
	GPIO_InitTypeDef GPIO_InitStructure;
	EXTI_InitTypeDef EXTI_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	/* Enable GPIOC clock - AHB: advanced high-performance bus*/
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 8001ac4:	4640      	mov	r0, r8
 8001ac6:	2101      	movs	r1, #1
 8001ac8:	f004 fdca 	bl	8006660 <RCC_AHBPeriphClockCmd>

	/* Configure PF1 pin as input floating */
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_8; // Zero Crossing PIN
 8001acc:	2380      	movs	r3, #128	; 0x80
 8001ace:	005b      	lsls	r3, r3, #1
 8001ad0:	469b      	mov	fp, r3
 8001ad2:	af01      	add	r7, sp, #4
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001ad4:	4648      	mov	r0, r9
 8001ad6:	1c39      	adds	r1, r7, #0

	/* Enable GPIOC clock - AHB: advanced high-performance bus*/
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);

	/* Configure PF1 pin as input floating */
	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_8; // Zero Crossing PIN
 8001ad8:	9301      	str	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8001ada:	713d      	strb	r5, [r7, #4]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8001adc:	71fe      	strb	r6, [r7, #7]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001ade:	f004 f9a5 	bl	8005e2c <GPIO_Init>

	/* Enable SYSCFG clock - APB: advanced peripheral bus*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 8001ae2:	2001      	movs	r0, #1
 8001ae4:	2101      	movs	r1, #1
 8001ae6:	f004 fdc7 	bl	8006678 <RCC_APB2PeriphClockCmd>

	/* Connect EXTI13 Line to PB8 pin */
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource8);
 8001aea:	2108      	movs	r1, #8
 8001aec:	2001      	movs	r0, #1
 8001aee:	f005 fc61 	bl	80073b4 <SYSCFG_EXTILineConfig>

	/* Configure EXTI13 line */
	EXTI_InitStructure.EXTI_Line = EXTI_Line8;
 8001af2:	465b      	mov	r3, fp
	//EXTI_InitStructure.EXTI_Line = EXTI_Line2;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	EXTI_Init(&EXTI_InitStructure);
 8001af4:	1c20      	adds	r0, r4, #0

	/* Connect EXTI13 Line to PB8 pin */
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource8);

	/* Configure EXTI13 line */
	EXTI_InitStructure.EXTI_Line = EXTI_Line8;
 8001af6:	9303      	str	r3, [sp, #12]
	//EXTI_InitStructure.EXTI_Line = EXTI_Line2;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
 8001af8:	3bf8      	subs	r3, #248	; 0xf8
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource8);

	/* Configure EXTI13 line */
	EXTI_InitStructure.EXTI_Line = EXTI_Line8;
	//EXTI_InitStructure.EXTI_Line = EXTI_Line2;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 8001afa:	7125      	strb	r5, [r4, #4]
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
 8001afc:	7163      	strb	r3, [r4, #5]
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 8001afe:	71a6      	strb	r6, [r4, #6]
	EXTI_Init(&EXTI_InitStructure);
 8001b00:	f003 fdc4 	bl	800568c <EXTI_Init>

	/* Enable and set EXTI13 Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = EXTI4_15_IRQn;
 8001b04:	466a      	mov	r2, sp
 8001b06:	2307      	movs	r3, #7
	//NVIC_InitStructure.NVIC_IRQChannel = EXTI2_3_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPriority = 0x00;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 8001b08:	4668      	mov	r0, sp
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	EXTI_Init(&EXTI_InitStructure);

	/* Enable and set EXTI13 Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = EXTI4_15_IRQn;
 8001b0a:	7013      	strb	r3, [r2, #0]
	//NVIC_InitStructure.NVIC_IRQChannel = EXTI2_3_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPriority = 0x00;
 8001b0c:	7055      	strb	r5, [r2, #1]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8001b0e:	7096      	strb	r6, [r2, #2]
	NVIC_Init(&NVIC_InitStructure);
 8001b10:	f004 fa40 	bl	8005f94 <NVIC_Init>
{
	TIM_TimeBaseInitTypeDef timerInitStructure;
	NVIC_InitTypeDef nvicStructure;

	/* Timer Configuration */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM17, ENABLE);
 8001b14:	4640      	mov	r0, r8
 8001b16:	2101      	movs	r1, #1
 8001b18:	f004 fdae 	bl	8006678 <RCC_APB2PeriphClockCmd>

	timerInitStructure.TIM_Prescaler = 48;		// 48000000 / 48 = 1000000  -> 1us
 8001b1c:	2330      	movs	r3, #48	; 0x30
 8001b1e:	8023      	strh	r3, [r4, #0]
	timerInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8001b20:	2300      	movs	r3, #0
 8001b22:	4698      	mov	r8, r3
	timerInitStructure.TIM_Period = HALF_CYCLE; // Counter max number
 8001b24:	4b38      	ldr	r3, [pc, #224]	; (8001c08 <TRIAC_Init+0x1cc>)
	timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	timerInitStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM17, &timerInitStructure);
 8001b26:	1c21      	adds	r1, r4, #0
	/* Timer Configuration */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM17, ENABLE);

	timerInitStructure.TIM_Prescaler = 48;		// 48000000 / 48 = 1000000  -> 1us
	timerInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	timerInitStructure.TIM_Period = HALF_CYCLE; // Counter max number
 8001b28:	6063      	str	r3, [r4, #4]
	timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	timerInitStructure.TIM_RepetitionCounter = 0;
 8001b2a:	4643      	mov	r3, r8
 8001b2c:	72a3      	strb	r3, [r4, #10]
	TIM_TimeBaseInit(TIM17, &timerInitStructure);
 8001b2e:	4b37      	ldr	r3, [pc, #220]	; (8001c0c <TRIAC_Init+0x1d0>)

	/* Timer Configuration */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM17, ENABLE);

	timerInitStructure.TIM_Prescaler = 48;		// 48000000 / 48 = 1000000  -> 1us
	timerInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8001b30:	8065      	strh	r5, [r4, #2]
	timerInitStructure.TIM_Period = HALF_CYCLE; // Counter max number
	timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	timerInitStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM17, &timerInitStructure);
 8001b32:	4699      	mov	r9, r3
 8001b34:	1c18      	adds	r0, r3, #0
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM17, ENABLE);

	timerInitStructure.TIM_Prescaler = 48;		// 48000000 / 48 = 1000000  -> 1us
	timerInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	timerInitStructure.TIM_Period = HALF_CYCLE; // Counter max number
	timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
 8001b36:	8125      	strh	r5, [r4, #8]
	timerInitStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM17, &timerInitStructure);
 8001b38:	f005 fd00 	bl	800753c <TIM_TimeBaseInit>
	TIM_Cmd(TIM17, ENABLE);
 8001b3c:	4648      	mov	r0, r9
 8001b3e:	2101      	movs	r1, #1
 8001b40:	f005 fd9e 	bl	8007680 <TIM_Cmd>

	TIM_SetCounter(TIM17, 0);
 8001b44:	4648      	mov	r0, r9
 8001b46:	2100      	movs	r1, #0
 8001b48:	f005 fd5a 	bl	8007600 <TIM_SetCounter>

	TIM_ITConfig(TIM17, TIM_IT_CC1, ENABLE);
 8001b4c:	4648      	mov	r0, r9
 8001b4e:	2102      	movs	r1, #2
 8001b50:	2201      	movs	r2, #1
 8001b52:	f006 f97f 	bl	8007e54 <TIM_ITConfig>

	nvicStructure.NVIC_IRQChannel = TIM17_IRQn;
 8001b56:	2316      	movs	r3, #22
 8001b58:	703b      	strb	r3, [r7, #0]
	nvicStructure.NVIC_IRQChannelPriority = 0;
 8001b5a:	4643      	mov	r3, r8
	nvicStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&nvicStructure);
 8001b5c:	1c38      	adds	r0, r7, #0
	TIM_SetCounter(TIM17, 0);

	TIM_ITConfig(TIM17, TIM_IT_CC1, ENABLE);

	nvicStructure.NVIC_IRQChannel = TIM17_IRQn;
	nvicStructure.NVIC_IRQChannelPriority = 0;
 8001b5e:	707b      	strb	r3, [r7, #1]
	nvicStructure.NVIC_IRQChannelCmd = ENABLE;
 8001b60:	70be      	strb	r6, [r7, #2]
	NVIC_Init(&nvicStructure);
 8001b62:	f004 fa17 	bl	8005f94 <NVIC_Init>

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 8001b66:	2280      	movs	r2, #128	; 0x80
 8001b68:	2380      	movs	r3, #128	; 0x80
 8001b6a:	4f29      	ldr	r7, [pc, #164]	; (8001c10 <TRIAC_Init+0x1d4>)
 8001b6c:	03d2      	lsls	r2, r2, #15
 8001b6e:	50fa      	str	r2, [r7, r3]
static void TRIAC_TIM14(void)
{
	TIM_TimeBaseInitTypeDef timerInitStructure;

	/* Timer Configuration */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM14, ENABLE);
 8001b70:	4658      	mov	r0, fp
 8001b72:	2101      	movs	r1, #1
 8001b74:	f004 fd8c 	bl	8006690 <RCC_APB1PeriphClockCmd>

	timerInitStructure.TIM_Prescaler = 48;    // 48000000 / 48  = 10000  -> 1us
 8001b78:	2330      	movs	r3, #48	; 0x30
 8001b7a:	8023      	strh	r3, [r4, #0]
	timerInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	timerInitStructure.TIM_Period = 0xFFFF;   // Counter max number
 8001b7c:	4b25      	ldr	r3, [pc, #148]	; (8001c14 <TRIAC_Init+0x1d8>)
	timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	timerInitStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM14, &timerInitStructure);
 8001b7e:	1c21      	adds	r1, r4, #0
	/* Timer Configuration */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM14, ENABLE);

	timerInitStructure.TIM_Prescaler = 48;    // 48000000 / 48  = 10000  -> 1us
	timerInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	timerInitStructure.TIM_Period = 0xFFFF;   // Counter max number
 8001b80:	6063      	str	r3, [r4, #4]
	timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	timerInitStructure.TIM_RepetitionCounter = 0;
 8001b82:	4643      	mov	r3, r8
 8001b84:	72a3      	strb	r3, [r4, #10]
	TIM_TimeBaseInit(TIM14, &timerInitStructure);
 8001b86:	4b24      	ldr	r3, [pc, #144]	; (8001c18 <TRIAC_Init+0x1dc>)

	/* Timer Configuration */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM14, ENABLE);

	timerInitStructure.TIM_Prescaler = 48;    // 48000000 / 48  = 10000  -> 1us
	timerInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8001b88:	8065      	strh	r5, [r4, #2]
	timerInitStructure.TIM_Period = 0xFFFF;   // Counter max number
	timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	timerInitStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM14, &timerInitStructure);
 8001b8a:	4699      	mov	r9, r3
 8001b8c:	1c18      	adds	r0, r3, #0
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM14, ENABLE);

	timerInitStructure.TIM_Prescaler = 48;    // 48000000 / 48  = 10000  -> 1us
	timerInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	timerInitStructure.TIM_Period = 0xFFFF;   // Counter max number
	timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
 8001b8e:	8125      	strh	r5, [r4, #8]
	timerInitStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM14, &timerInitStructure);
 8001b90:	f005 fcd4 	bl	800753c <TIM_TimeBaseInit>
	TIM_Cmd(TIM14, ENABLE);
 8001b94:	4648      	mov	r0, r9
 8001b96:	2101      	movs	r1, #1
 8001b98:	f005 fd72 	bl	8007680 <TIM_Cmd>

	TIM_SetCounter(TIM14, 0);
 8001b9c:	4648      	mov	r0, r9
 8001b9e:	2100      	movs	r1, #0
 8001ba0:	f005 fd2e 	bl	8007600 <TIM_SetCounter>
static void TRIAC_PinDebug(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOC Periph clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8001ba4:	2080      	movs	r0, #128	; 0x80
	TIM_TimeBaseInit(TIM14, &timerInitStructure);
	TIM_Cmd(TIM14, ENABLE);

	TIM_SetCounter(TIM14, 0);

	LastEdgeTime = 0;
 8001ba6:	4b1d      	ldr	r3, [pc, #116]	; (8001c1c <TRIAC_Init+0x1e0>)
static void TRIAC_PinDebug(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOC Periph clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8001ba8:	0280      	lsls	r0, r0, #10
 8001baa:	2101      	movs	r1, #1
	TIM_TimeBaseInit(TIM14, &timerInitStructure);
	TIM_Cmd(TIM14, ENABLE);

	TIM_SetCounter(TIM14, 0);

	LastEdgeTime = 0;
 8001bac:	4699      	mov	r9, r3
 8001bae:	601d      	str	r5, [r3, #0]
	EdgeTime = 0;
 8001bb0:	605d      	str	r5, [r3, #4]
static void TRIAC_PinDebug(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOC Periph clock enable */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8001bb2:	f004 fd55 	bl	8006660 <RCC_AHBPeriphClockCmd>
	/* Configure PA15 in output pushpull mode
	 * In the board the reference is P8
	 */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_15; //P8 in the board
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8001bb6:	4643      	mov	r3, r8
 8001bb8:	71a3      	strb	r3, [r4, #6]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001bba:	4653      	mov	r3, sl

	/* Configure PA15 in output pushpull mode
	 * In the board the reference is P8
	 */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_15; //P8 in the board
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
 8001bbc:	7126      	strb	r6, [r4, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8001bbe:	2690      	movs	r6, #144	; 0x90
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

	/* Configure PA15 in output pushpull mode
	 * In the board the reference is P8
	 */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_15; //P8 in the board
 8001bc0:	2580      	movs	r5, #128	; 0x80
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001bc2:	7163      	strb	r3, [r4, #5]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
 8001bc4:	2302      	movs	r3, #2
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8001bc6:	05f6      	lsls	r6, r6, #23
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

	/* Configure PA15 in output pushpull mode
	 * In the board the reference is P8
	 */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_15; //P8 in the board
 8001bc8:	022d      	lsls	r5, r5, #8
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8001bca:	1c30      	adds	r0, r6, #0
 8001bcc:	1c21      	adds	r1, r4, #0
	 */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_15; //P8 in the board
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
 8001bce:	71e3      	strb	r3, [r4, #7]
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

	/* Configure PA15 in output pushpull mode
	 * In the board the reference is P8
	 */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_15; //P8 in the board
 8001bd0:	9503      	str	r5, [sp, #12]
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8001bd2:	f004 f92b 	bl	8005e2c <GPIO_Init>

	GPIO_ResetBits(GPIOA, GPIO_Pin_15);
 8001bd6:	1c30      	adds	r0, r6, #0
 8001bd8:	1c29      	adds	r1, r5, #0
 8001bda:	f004 f9bf 	bl	8005f5c <GPIO_ResetBits>

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 8001bde:	2320      	movs	r3, #32
 8001be0:	603b      	str	r3, [r7, #0]
 8001be2:	2380      	movs	r3, #128	; 0x80
 8001be4:	03db      	lsls	r3, r3, #15
 8001be6:	603b      	str	r3, [r7, #0]

	TRIAC_PinDebug();		// Debug PIN configuration

	TRIAC_EnableIRQ();

	ShowerPower = 0;
 8001be8:	4642      	mov	r2, r8
 8001bea:	464b      	mov	r3, r9
 8001bec:	721a      	strb	r2, [r3, #8]
}
 8001bee:	b007      	add	sp, #28
 8001bf0:	bc3c      	pop	{r2, r3, r4, r5}
 8001bf2:	4690      	mov	r8, r2
 8001bf4:	4699      	mov	r9, r3
 8001bf6:	46a2      	mov	sl, r4
 8001bf8:	46ab      	mov	fp, r5
 8001bfa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001bfc:	48001400 	.word	0x48001400
 8001c00:	48000400 	.word	0x48000400
 8001c04:	48000800 	.word	0x48000800
 8001c08:	0000208d 	.word	0x0000208d
 8001c0c:	40014800 	.word	0x40014800
 8001c10:	e000e100 	.word	0xe000e100
 8001c14:	0000ffff 	.word	0x0000ffff
 8001c18:	40002000 	.word	0x40002000
 8001c1c:	200001a8 	.word	0x200001a8

08001c20 <TRIAC_SetPower>:
//==================================================================================================
// Set TRIAC Power
//==================================================================================================
void TRIAC_SetPower(uint8_t Power)
{
	ShowerPower = Power;
 8001c20:	4b01      	ldr	r3, [pc, #4]	; (8001c28 <TRIAC_SetPower+0x8>)
 8001c22:	7218      	strb	r0, [r3, #8]
}
 8001c24:	4770      	bx	lr
 8001c26:	46c0      	nop			; (mov r8, r8)
 8001c28:	200001a8 	.word	0x200001a8

08001c2c <TRIAC_GetError>:
//==================================================================================================
// Get TRIAC Error
//==================================================================================================
uint8_t TRIAC_GetError()
{
	if(LostEdgeCounter > MAX_LOST_EDGE)
 8001c2c:	4b03      	ldr	r3, [pc, #12]	; (8001c3c <TRIAC_GetError+0x10>)
	{
		return TRIAC_ERROR_LOST_EDGES;
 8001c2e:	2004      	movs	r0, #4
//==================================================================================================
// Get TRIAC Error
//==================================================================================================
uint8_t TRIAC_GetError()
{
	if(LostEdgeCounter > MAX_LOST_EDGE)
 8001c30:	68da      	ldr	r2, [r3, #12]
 8001c32:	2a64      	cmp	r2, #100	; 0x64
 8001c34:	d900      	bls.n	8001c38 <TRIAC_GetError+0xc>
	}
	else
	{
		return TriacError;
	}
}
 8001c36:	4770      	bx	lr
	{
		return TRIAC_ERROR_LOST_EDGES;
	}
	else
	{
		return TriacError;
 8001c38:	7c18      	ldrb	r0, [r3, #16]
 8001c3a:	e7fc      	b.n	8001c36 <TRIAC_GetError+0xa>
 8001c3c:	200001a8 	.word	0x200001a8

08001c40 <TRIAC_LostEdges>:
//==================================================================================================
//
//==================================================================================================
void TRIAC_LostEdges()
{
	LostEdgeCounter++;
 8001c40:	4a02      	ldr	r2, [pc, #8]	; (8001c4c <TRIAC_LostEdges+0xc>)
 8001c42:	68d3      	ldr	r3, [r2, #12]
 8001c44:	3301      	adds	r3, #1
 8001c46:	60d3      	str	r3, [r2, #12]
}
 8001c48:	4770      	bx	lr
 8001c4a:	46c0      	nop			; (mov r8, r8)
 8001c4c:	200001a8 	.word	0x200001a8

08001c50 <TRIAC_GetPower>:
//==================================================================================================
// Get current TRIAC Power
//==================================================================================================
uint8_t TRIAC_GetPower(void)
{
	return ShowerPower;
 8001c50:	4b01      	ldr	r3, [pc, #4]	; (8001c58 <TRIAC_GetPower+0x8>)
 8001c52:	7a18      	ldrb	r0, [r3, #8]
}
 8001c54:	4770      	bx	lr
 8001c56:	46c0      	nop			; (mov r8, r8)
 8001c58:	200001a8 	.word	0x200001a8

08001c5c <EXTI4_15_IRQHandler>:

//==================================================================================================
// Called every time Zero Crossing pin gets a rising edge
//==================================================================================================
void EXTI4_15_IRQHandler(void)
{
 8001c5c:	b538      	push	{r3, r4, r5, lr}
static bool TRIAC_Check60Hz(void)
{
	bool Ret = false;
	uint32_t Delta;

	EdgeTime = TIM_GetCounter(TIM14);
 8001c5e:	4827      	ldr	r0, [pc, #156]	; (8001cfc <EXTI4_15_IRQHandler+0xa0>)
 8001c60:	f005 fcd2 	bl	8007608 <TIM_GetCounter>
 8001c64:	4c26      	ldr	r4, [pc, #152]	; (8001d00 <EXTI4_15_IRQHandler+0xa4>)
	Delta = EdgeTime - LastEdgeTime;
 8001c66:	6823      	ldr	r3, [r4, #0]
static bool TRIAC_Check60Hz(void)
{
	bool Ret = false;
	uint32_t Delta;

	EdgeTime = TIM_GetCounter(TIM14);
 8001c68:	6060      	str	r0, [r4, #4]
	Delta = EdgeTime - LastEdgeTime;
 8001c6a:	1ac5      	subs	r5, r0, r3

	if(Delta > EDGE_TIME_MIN)
 8001c6c:	23fa      	movs	r3, #250	; 0xfa
 8001c6e:	019b      	lsls	r3, r3, #6
 8001c70:	429d      	cmp	r5, r3
 8001c72:	d808      	bhi.n	8001c86 <EXTI4_15_IRQHandler+0x2a>

		TRIAC_Control();
	}
	else
	{
		LostEdgeCounter++;
 8001c74:	68e3      	ldr	r3, [r4, #12]
 8001c76:	3301      	adds	r3, #1
 8001c78:	60e3      	str	r3, [r4, #12]
	}

	EXTI->PR |= 0x00000002;		// Clear the IRQ pending flag
 8001c7a:	2302      	movs	r3, #2
 8001c7c:	4a21      	ldr	r2, [pc, #132]	; (8001d04 <EXTI4_15_IRQHandler+0xa8>)
 8001c7e:	6951      	ldr	r1, [r2, #20]
 8001c80:	430b      	orrs	r3, r1
 8001c82:	6153      	str	r3, [r2, #20]
}
 8001c84:	bd38      	pop	{r3, r4, r5, pc}
	EdgeTime = TIM_GetCounter(TIM14);
	Delta = EdgeTime - LastEdgeTime;

	if(Delta > EDGE_TIME_MIN)
	{
		TIM_SetCounter(TIM14, 0);
 8001c86:	481d      	ldr	r0, [pc, #116]	; (8001cfc <EXTI4_15_IRQHandler+0xa0>)
 8001c88:	2100      	movs	r1, #0
 8001c8a:	f005 fcb9 	bl	8007600 <TIM_SetCounter>
		LastEdgeTime = TIM_GetCounter(TIM14);
 8001c8e:	481b      	ldr	r0, [pc, #108]	; (8001cfc <EXTI4_15_IRQHandler+0xa0>)
 8001c90:	f005 fcba 	bl	8007608 <TIM_GetCounter>

		// Check if interruption time is right. This is done to avoid a false edge
		if((Delta > EDGE_TIME_MIN) && (Delta < EDGE_TIME_MAX)) Ret = true;
 8001c94:	4b1c      	ldr	r3, [pc, #112]	; (8001d08 <EXTI4_15_IRQHandler+0xac>)
	Delta = EdgeTime - LastEdgeTime;

	if(Delta > EDGE_TIME_MIN)
	{
		TIM_SetCounter(TIM14, 0);
		LastEdgeTime = TIM_GetCounter(TIM14);
 8001c96:	6020      	str	r0, [r4, #0]

		// Check if interruption time is right. This is done to avoid a false edge
		if((Delta > EDGE_TIME_MIN) && (Delta < EDGE_TIME_MAX)) Ret = true;
 8001c98:	18e8      	adds	r0, r5, r3
 8001c9a:	4b1c      	ldr	r3, [pc, #112]	; (8001d0c <EXTI4_15_IRQHandler+0xb0>)
 8001c9c:	4298      	cmp	r0, r3
 8001c9e:	d8e9      	bhi.n	8001c74 <EXTI4_15_IRQHandler+0x18>

	if(TRIAC_Check60Hz() == true)
	{
		// For debug purposes
		debug = ~debug;
		GPIO_WriteBit(GPIOA, GPIO_Pin_15, debug);
 8001ca0:	2090      	movs	r0, #144	; 0x90
 8001ca2:	2180      	movs	r1, #128	; 0x80
	static bool debug = 0;	// Used to check if "Zero Crossing" interruption is working ( alternates 0/1 on pin every time a interruption occur)

	if(TRIAC_Check60Hz() == true)
	{
		// For debug purposes
		debug = ~debug;
 8001ca4:	2301      	movs	r3, #1
		GPIO_WriteBit(GPIOA, GPIO_Pin_15, debug);
 8001ca6:	05c0      	lsls	r0, r0, #23
 8001ca8:	0209      	lsls	r1, r1, #8
 8001caa:	2201      	movs	r2, #1
	static bool debug = 0;	// Used to check if "Zero Crossing" interruption is working ( alternates 0/1 on pin every time a interruption occur)

	if(TRIAC_Check60Hz() == true)
	{
		// For debug purposes
		debug = ~debug;
 8001cac:	7663      	strb	r3, [r4, #25]
		GPIO_WriteBit(GPIOA, GPIO_Pin_15, debug);
 8001cae:	f004 f957 	bl	8005f60 <GPIO_WriteBit>

		if(LostEdgeCounter > 0) LostEdgeCounter--;
 8001cb2:	68e3      	ldr	r3, [r4, #12]
 8001cb4:	2b00      	cmp	r3, #0
 8001cb6:	d001      	beq.n	8001cbc <EXTI4_15_IRQHandler+0x60>
 8001cb8:	3b01      	subs	r3, #1
 8001cba:	60e3      	str	r3, [r4, #12]
//==================================================================================================
//
//==================================================================================================
static void TRIAC_Control(void)
{
	if(TestTriacCount < TRIAC_TEST_COUNT_MAX) // TRIAC_TEST_COUNT_MAX = 240
 8001cbc:	6963      	ldr	r3, [r4, #20]
 8001cbe:	2bef      	cmp	r3, #239	; 0xef
 8001cc0:	d910      	bls.n	8001ce4 <EXTI4_15_IRQHandler+0x88>
		//TIM_ClearITPendingBit(TIM17, TIM_IT_CC1);
		//NVIC_EnableIRQ (TIM17_IRQn);
	}
	else
	{
		TestTriacCount = 0;
 8001cc2:	2300      	movs	r3, #0
		TestTriac = true;
		TIM_SetCounter(TIM17, HALF_CYCLE/2);
 8001cc4:	4812      	ldr	r0, [pc, #72]	; (8001d10 <EXTI4_15_IRQHandler+0xb4>)
		//TIM_ClearITPendingBit(TIM17, TIM_IT_CC1);
		//NVIC_EnableIRQ (TIM17_IRQn);
	}
	else
	{
		TestTriacCount = 0;
 8001cc6:	6163      	str	r3, [r4, #20]
		TestTriac = true;
		TIM_SetCounter(TIM17, HALF_CYCLE/2);
 8001cc8:	4912      	ldr	r1, [pc, #72]	; (8001d14 <EXTI4_15_IRQHandler+0xb8>)
		//NVIC_EnableIRQ (TIM17_IRQn);
	}
	else
	{
		TestTriacCount = 0;
		TestTriac = true;
 8001cca:	3301      	adds	r3, #1
 8001ccc:	7623      	strb	r3, [r4, #24]
		TIM_SetCounter(TIM17, HALF_CYCLE/2);
 8001cce:	f005 fc97 	bl	8007600 <TIM_SetCounter>
		//TIM_ClearITPendingBit(TIM17, TIM_IT_CC1);
		//NVIC_EnableIRQ (TIM17_IRQn);
	}

	TIM_ClearITPendingBit(TIM17, TIM_IT_CC1);
 8001cd2:	480f      	ldr	r0, [pc, #60]	; (8001d10 <EXTI4_15_IRQHandler+0xb4>)
 8001cd4:	2102      	movs	r1, #2
 8001cd6:	f006 f8df 	bl	8007e98 <TIM_ClearITPendingBit>
 8001cda:	2280      	movs	r2, #128	; 0x80
 8001cdc:	4b0e      	ldr	r3, [pc, #56]	; (8001d18 <EXTI4_15_IRQHandler+0xbc>)
 8001cde:	03d2      	lsls	r2, r2, #15
 8001ce0:	601a      	str	r2, [r3, #0]
 8001ce2:	e7ca      	b.n	8001c7a <EXTI4_15_IRQHandler+0x1e>
//==================================================================================================
static void TRIAC_Control(void)
{
	if(TestTriacCount < TRIAC_TEST_COUNT_MAX) // TRIAC_TEST_COUNT_MAX = 240
	{
		TestTriacCount++;
 8001ce4:	3301      	adds	r3, #1
 8001ce6:	6163      	str	r3, [r4, #20]
		TestTriac = false;
 8001ce8:	2300      	movs	r3, #0
 8001cea:	7623      	strb	r3, [r4, #24]
		TIM_SetCounter(TIM17, TRIAC_POWER_TABLE[ShowerPower]);
 8001cec:	7a23      	ldrb	r3, [r4, #8]
 8001cee:	4a0b      	ldr	r2, [pc, #44]	; (8001d1c <EXTI4_15_IRQHandler+0xc0>)
 8001cf0:	009b      	lsls	r3, r3, #2
 8001cf2:	5899      	ldr	r1, [r3, r2]
 8001cf4:	4806      	ldr	r0, [pc, #24]	; (8001d10 <EXTI4_15_IRQHandler+0xb4>)
 8001cf6:	f005 fc83 	bl	8007600 <TIM_SetCounter>
 8001cfa:	e7ea      	b.n	8001cd2 <EXTI4_15_IRQHandler+0x76>
 8001cfc:	40002000 	.word	0x40002000
 8001d00:	200001a8 	.word	0x200001a8
 8001d04:	40010400 	.word	0x40010400
 8001d08:	ffffc17f 	.word	0xffffc17f
 8001d0c:	000007ce 	.word	0x000007ce
 8001d10:	40014800 	.word	0x40014800
 8001d14:	00001046 	.word	0x00001046
 8001d18:	e000e100 	.word	0xe000e100
 8001d1c:	0800a7b0 	.word	0x0800a7b0

08001d20 <TIM17_IRQHandler>:

//==================================================================================================
//
//==================================================================================================
void TIM17_IRQHandler()
{
 8001d20:	b538      	push	{r3, r4, r5, lr}
	if(TIM_GetITStatus(TIM17, TIM_IT_CC1) != RESET)
 8001d22:	4861      	ldr	r0, [pc, #388]	; (8001ea8 <TIM17_IRQHandler+0x188>)
 8001d24:	2102      	movs	r1, #2
 8001d26:	f006 f8ab 	bl	8007e80 <TIM_GetITStatus>
 8001d2a:	2800      	cmp	r0, #0
 8001d2c:	d100      	bne.n	8001d30 <TIM17_IRQHandler+0x10>
		{
			TestTriac = false;
			TRIAC_Test();
		}
	}
}
 8001d2e:	bd38      	pop	{r3, r4, r5, pc}
//==================================================================================================
void TIM17_IRQHandler()
{
	if(TIM_GetITStatus(TIM17, TIM_IT_CC1) != RESET)
	{
		TIM_ClearITPendingBit(TIM17, TIM_IT_CC1);
 8001d30:	485d      	ldr	r0, [pc, #372]	; (8001ea8 <TIM17_IRQHandler+0x188>)
 8001d32:	2102      	movs	r1, #2
 8001d34:	f006 f8b0 	bl	8007e98 <TIM_ClearITPendingBit>

		if(TestTriac == false)
 8001d38:	4c5c      	ldr	r4, [pc, #368]	; (8001eac <TIM17_IRQHandler+0x18c>)
 8001d3a:	7e23      	ldrb	r3, [r4, #24]
 8001d3c:	2b00      	cmp	r3, #0
 8001d3e:	d038      	beq.n	8001db2 <TIM17_IRQHandler+0x92>
{
	//----------------------------------
	// Test T1 and T2
	// Desliga T1 e T2 e verifica o estado do pino Proteção (PF0)

	GPIO_WriteBit(GPIOB,GPIO_Pin_9,  0); // TRIAC 1
 8001d40:	2180      	movs	r1, #128	; 0x80
		{
			TRIAC_Pulse();
		}
		else // TestTriac = true
		{
			TestTriac = false;
 8001d42:	2500      	movs	r5, #0
{
	//----------------------------------
	// Test T1 and T2
	// Desliga T1 e T2 e verifica o estado do pino Proteção (PF0)

	GPIO_WriteBit(GPIOB,GPIO_Pin_9,  0); // TRIAC 1
 8001d44:	485a      	ldr	r0, [pc, #360]	; (8001eb0 <TIM17_IRQHandler+0x190>)
 8001d46:	0089      	lsls	r1, r1, #2
 8001d48:	2200      	movs	r2, #0
		{
			TRIAC_Pulse();
		}
		else // TestTriac = true
		{
			TestTriac = false;
 8001d4a:	7625      	strb	r5, [r4, #24]
{
	//----------------------------------
	// Test T1 and T2
	// Desliga T1 e T2 e verifica o estado do pino Proteção (PF0)

	GPIO_WriteBit(GPIOB,GPIO_Pin_9,  0); // TRIAC 1
 8001d4c:	f004 f908 	bl	8005f60 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOC,GPIO_Pin_13, 0); // TRIAC 2
 8001d50:	2180      	movs	r1, #128	; 0x80
 8001d52:	4858      	ldr	r0, [pc, #352]	; (8001eb4 <TIM17_IRQHandler+0x194>)
 8001d54:	0189      	lsls	r1, r1, #6
 8001d56:	2200      	movs	r2, #0
 8001d58:	f004 f902 	bl	8005f60 <GPIO_WriteBit>

	if(GPIO_ReadInputDataBit(GPIOF, GPIO_Pin_0) == 0) // Pin Protection Triac
 8001d5c:	4856      	ldr	r0, [pc, #344]	; (8001eb8 <TIM17_IRQHandler+0x198>)
 8001d5e:	2101      	movs	r1, #1
 8001d60:	f004 f8e6 	bl	8005f30 <GPIO_ReadInputDataBit>
 8001d64:	2800      	cmp	r0, #0
 8001d66:	d10e      	bne.n	8001d86 <TIM17_IRQHandler+0x66>
	//Reading 0v, short circuit in T1 e T2
	{
		TriacError = TRIAC_ERROR_T3;
 8001d68:	2303      	movs	r3, #3
 8001d6a:	7423      	strb	r3, [r4, #16]
		}
	}

	//----------------------------------
	// Turn off TRIACs
	GPIO_WriteBit(GPIOB,GPIO_Pin_9,  0);
 8001d6c:	2180      	movs	r1, #128	; 0x80
 8001d6e:	4850      	ldr	r0, [pc, #320]	; (8001eb0 <TIM17_IRQHandler+0x190>)
 8001d70:	0089      	lsls	r1, r1, #2
 8001d72:	2200      	movs	r2, #0
 8001d74:	f004 f8f4 	bl	8005f60 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOC,GPIO_Pin_13, 0);
 8001d78:	2180      	movs	r1, #128	; 0x80
 8001d7a:	484e      	ldr	r0, [pc, #312]	; (8001eb4 <TIM17_IRQHandler+0x194>)
 8001d7c:	0189      	lsls	r1, r1, #6
 8001d7e:	2200      	movs	r2, #0
 8001d80:	f004 f8ee 	bl	8005f60 <GPIO_WriteBit>
 8001d84:	e7d3      	b.n	8001d2e <TIM17_IRQHandler+0xe>
	//----------------------------------
	// Test T1
	if(TriacError == TRIAC_OK)
	{
		//Desliga T1 e liga T2 e verifica o estado do pino Proteção (PF0)
		GPIO_WriteBit(GPIOB,GPIO_Pin_9,  0); // TRIAC 1
 8001d86:	2180      	movs	r1, #128	; 0x80
 8001d88:	4849      	ldr	r0, [pc, #292]	; (8001eb0 <TIM17_IRQHandler+0x190>)
 8001d8a:	0089      	lsls	r1, r1, #2
 8001d8c:	2200      	movs	r2, #0
		TriacError = TRIAC_ERROR_T3;
	}
	else
	//Reading "220v"
	{
		TriacError = TRIAC_OK;
 8001d8e:	7425      	strb	r5, [r4, #16]
	//----------------------------------
	// Test T1
	if(TriacError == TRIAC_OK)
	{
		//Desliga T1 e liga T2 e verifica o estado do pino Proteção (PF0)
		GPIO_WriteBit(GPIOB,GPIO_Pin_9,  0); // TRIAC 1
 8001d90:	f004 f8e6 	bl	8005f60 <GPIO_WriteBit>
		GPIO_WriteBit(GPIOC,GPIO_Pin_13, 1); // TRIAC 2
 8001d94:	2180      	movs	r1, #128	; 0x80
 8001d96:	4847      	ldr	r0, [pc, #284]	; (8001eb4 <TIM17_IRQHandler+0x194>)
 8001d98:	0189      	lsls	r1, r1, #6
 8001d9a:	2201      	movs	r2, #1
 8001d9c:	f004 f8e0 	bl	8005f60 <GPIO_WriteBit>

		if(GPIO_ReadInputDataBit(GPIOF, GPIO_Pin_0) == 0) // Pin Protection Triac
 8001da0:	4845      	ldr	r0, [pc, #276]	; (8001eb8 <TIM17_IRQHandler+0x198>)
 8001da2:	2101      	movs	r1, #1
 8001da4:	f004 f8c4 	bl	8005f30 <GPIO_ReadInputDataBit>
 8001da8:	2800      	cmp	r0, #0
 8001daa:	d123      	bne.n	8001df4 <TIM17_IRQHandler+0xd4>
		//Reading 0v, short circuit in T1
		{
			TriacError = TRIAC_ERROR_T1;
 8001dac:	2301      	movs	r3, #1
 8001dae:	7423      	strb	r3, [r4, #16]
 8001db0:	e7dc      	b.n	8001d6c <TIM17_IRQHandler+0x4c>
//==================================================================================================
// Shooting of TRIACs
//==================================================================================================
static void TRIAC_Pulse()
{
	switch (PulseState)
 8001db2:	4a42      	ldr	r2, [pc, #264]	; (8001ebc <TIM17_IRQHandler+0x19c>)
 8001db4:	7813      	ldrb	r3, [r2, #0]
 8001db6:	2b02      	cmp	r3, #2
 8001db8:	d055      	beq.n	8001e66 <TIM17_IRQHandler+0x146>
 8001dba:	d94c      	bls.n	8001e56 <TIM17_IRQHandler+0x136>
 8001dbc:	2b03      	cmp	r3, #3
 8001dbe:	d031      	beq.n	8001e24 <TIM17_IRQHandler+0x104>
 8001dc0:	2b04      	cmp	r3, #4
 8001dc2:	d111      	bne.n	8001de8 <TIM17_IRQHandler+0xc8>
		//	  +--+         +--+
		//    |  |         |  |
		// ___|  |_________|  |_____
		case 4:
		{
			PulseState = 1;
 8001dc4:	2301      	movs	r3, #1
			GPIO_WriteBit(GPIOB,GPIO_Pin_9,  0); // TRIAC 1
 8001dc6:	2180      	movs	r1, #128	; 0x80
		//	  +--+         +--+
		//    |  |         |  |
		// ___|  |_________|  |_____
		case 4:
		{
			PulseState = 1;
 8001dc8:	7013      	strb	r3, [r2, #0]
			GPIO_WriteBit(GPIOB,GPIO_Pin_9,  0); // TRIAC 1
 8001dca:	4839      	ldr	r0, [pc, #228]	; (8001eb0 <TIM17_IRQHandler+0x190>)
 8001dcc:	0089      	lsls	r1, r1, #2
 8001dce:	2200      	movs	r2, #0
 8001dd0:	f004 f8c6 	bl	8005f60 <GPIO_WriteBit>
			GPIO_WriteBit(GPIOC,GPIO_Pin_13, 0); // TRIAC 2
 8001dd4:	2180      	movs	r1, #128	; 0x80
 8001dd6:	4837      	ldr	r0, [pc, #220]	; (8001eb4 <TIM17_IRQHandler+0x194>)
 8001dd8:	0189      	lsls	r1, r1, #6
 8001dda:	2200      	movs	r2, #0
 8001ddc:	f004 f8c0 	bl	8005f60 <GPIO_WriteBit>
			TIM_SetCounter(TIM17, PULSE_LENGHT); // 0.1ms
 8001de0:	4831      	ldr	r0, [pc, #196]	; (8001ea8 <TIM17_IRQHandler+0x188>)
 8001de2:	2164      	movs	r1, #100	; 0x64
 8001de4:	f005 fc0c 	bl	8007600 <TIM_SetCounter>

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 8001de8:	2180      	movs	r1, #128	; 0x80
 8001dea:	2380      	movs	r3, #128	; 0x80
 8001dec:	4a34      	ldr	r2, [pc, #208]	; (8001ec0 <TIM17_IRQHandler+0x1a0>)
 8001dee:	03c9      	lsls	r1, r1, #15
 8001df0:	50d1      	str	r1, [r2, r3]
 8001df2:	e79c      	b.n	8001d2e <TIM17_IRQHandler+0xe>
		}
	}

	//----------------------------------
	// Test T2
	if( TriacError == TRIAC_OK )
 8001df4:	7c23      	ldrb	r3, [r4, #16]
 8001df6:	2b00      	cmp	r3, #0
 8001df8:	d1b8      	bne.n	8001d6c <TIM17_IRQHandler+0x4c>
	{
		//Desliga T2 e liga T1 e verifica o estado do pino Proteção (PF0)
		GPIO_WriteBit(GPIOB,GPIO_Pin_9,  1); // TRIAC 1
 8001dfa:	2180      	movs	r1, #128	; 0x80
 8001dfc:	482c      	ldr	r0, [pc, #176]	; (8001eb0 <TIM17_IRQHandler+0x190>)
 8001dfe:	0089      	lsls	r1, r1, #2
 8001e00:	2201      	movs	r2, #1
 8001e02:	f004 f8ad 	bl	8005f60 <GPIO_WriteBit>
		GPIO_WriteBit(GPIOC,GPIO_Pin_13, 0); // TRIAC 2
 8001e06:	2180      	movs	r1, #128	; 0x80
 8001e08:	482a      	ldr	r0, [pc, #168]	; (8001eb4 <TIM17_IRQHandler+0x194>)
 8001e0a:	0189      	lsls	r1, r1, #6
 8001e0c:	2200      	movs	r2, #0
 8001e0e:	f004 f8a7 	bl	8005f60 <GPIO_WriteBit>

		if(GPIO_ReadInputDataBit(GPIOF, GPIO_Pin_0) == 0) // Pin Protection Triac
 8001e12:	4829      	ldr	r0, [pc, #164]	; (8001eb8 <TIM17_IRQHandler+0x198>)
 8001e14:	2101      	movs	r1, #1
 8001e16:	f004 f88b 	bl	8005f30 <GPIO_ReadInputDataBit>
 8001e1a:	2800      	cmp	r0, #0
 8001e1c:	d1a6      	bne.n	8001d6c <TIM17_IRQHandler+0x4c>
		//Reading 0v, short circuit in T2
		{
			TriacError = TRIAC_ERROR_T2;
 8001e1e:	2302      	movs	r3, #2
 8001e20:	7423      	strb	r3, [r4, #16]
 8001e22:	e7a3      	b.n	8001d6c <TIM17_IRQHandler+0x4c>
		//	  +--+         +--
		//    |  |         |
		// ___|  |_________|
		case 3:
		{
			PulseState = 4;
 8001e24:	2304      	movs	r3, #4
 8001e26:	7013      	strb	r3, [r2, #0]
			// Se potência acima de 0 e TRIACs não estão em curto, turn on T1 and T2.
			// Otherwise, turn then off
			if((ShowerPower > 0) && (TriacError == TRIAC_OK))
 8001e28:	7a23      	ldrb	r3, [r4, #8]
 8001e2a:	2b00      	cmp	r3, #0
 8001e2c:	d002      	beq.n	8001e34 <TIM17_IRQHandler+0x114>
		case 1:
		{
			PulseState = 2;
			// Se potência acima de 0 e TRIACs não estão em curto, liga T1 e T2.
			// Otherwise, turn then off
			if((ShowerPower > 0) && (TriacError == TRIAC_OK))
 8001e2e:	7c23      	ldrb	r3, [r4, #16]
 8001e30:	2b00      	cmp	r3, #0
 8001e32:	d02b      	beq.n	8001e8c <TIM17_IRQHandler+0x16c>
				GPIO_WriteBit(GPIOB,GPIO_Pin_9,  1); // TRIAC 1
				GPIO_WriteBit(GPIOC,GPIO_Pin_13, 1); // TRIAC 2
			}
			else
			{
				GPIO_WriteBit(GPIOB,GPIO_Pin_9,  0); // TRIAC 1
 8001e34:	2180      	movs	r1, #128	; 0x80
 8001e36:	481e      	ldr	r0, [pc, #120]	; (8001eb0 <TIM17_IRQHandler+0x190>)
 8001e38:	0089      	lsls	r1, r1, #2
 8001e3a:	2200      	movs	r2, #0
 8001e3c:	f004 f890 	bl	8005f60 <GPIO_WriteBit>
				GPIO_WriteBit(GPIOC,GPIO_Pin_13, 0); // TRIAC 2
 8001e40:	2180      	movs	r1, #128	; 0x80
 8001e42:	481c      	ldr	r0, [pc, #112]	; (8001eb4 <TIM17_IRQHandler+0x194>)
 8001e44:	0189      	lsls	r1, r1, #6
 8001e46:	2200      	movs	r2, #0
 8001e48:	f004 f88a 	bl	8005f60 <GPIO_WriteBit>
			}
			TIM_SetCounter(TIM17, HALF_CYCLE - PULSE_LENGHT);//(8.3-0.1)ms
 8001e4c:	4816      	ldr	r0, [pc, #88]	; (8001ea8 <TIM17_IRQHandler+0x188>)
 8001e4e:	491d      	ldr	r1, [pc, #116]	; (8001ec4 <TIM17_IRQHandler+0x1a4>)
 8001e50:	f005 fbd6 	bl	8007600 <TIM_SetCounter>
 8001e54:	e76b      	b.n	8001d2e <TIM17_IRQHandler+0xe>
//==================================================================================================
// Shooting of TRIACs
//==================================================================================================
static void TRIAC_Pulse()
{
	switch (PulseState)
 8001e56:	2b01      	cmp	r3, #1
 8001e58:	d1c6      	bne.n	8001de8 <TIM17_IRQHandler+0xc8>
		//	  +--
		//    |
		// ___|
		case 1:
		{
			PulseState = 2;
 8001e5a:	2302      	movs	r3, #2
 8001e5c:	7013      	strb	r3, [r2, #0]
			// Se potência acima de 0 e TRIACs não estão em curto, liga T1 e T2.
			// Otherwise, turn then off
			if((ShowerPower > 0) && (TriacError == TRIAC_OK))
 8001e5e:	7a23      	ldrb	r3, [r4, #8]
 8001e60:	2b00      	cmp	r3, #0
 8001e62:	d1e4      	bne.n	8001e2e <TIM17_IRQHandler+0x10e>
 8001e64:	e7e6      	b.n	8001e34 <TIM17_IRQHandler+0x114>
		//	  +--+
		//    |  |
		// ___|  |______
		case 2:
		{
			PulseState = 3;
 8001e66:	2303      	movs	r3, #3
			// Turn TRIACs off
			GPIO_WriteBit(GPIOB,GPIO_Pin_9,  0); // TRIAC 1
 8001e68:	2180      	movs	r1, #128	; 0x80
		//	  +--+
		//    |  |
		// ___|  |______
		case 2:
		{
			PulseState = 3;
 8001e6a:	7013      	strb	r3, [r2, #0]
			// Turn TRIACs off
			GPIO_WriteBit(GPIOB,GPIO_Pin_9,  0); // TRIAC 1
 8001e6c:	4810      	ldr	r0, [pc, #64]	; (8001eb0 <TIM17_IRQHandler+0x190>)
 8001e6e:	0089      	lsls	r1, r1, #2
 8001e70:	2200      	movs	r2, #0
 8001e72:	f004 f875 	bl	8005f60 <GPIO_WriteBit>
			GPIO_WriteBit(GPIOC,GPIO_Pin_13, 0); // TRIAC 2
 8001e76:	2180      	movs	r1, #128	; 0x80
 8001e78:	480e      	ldr	r0, [pc, #56]	; (8001eb4 <TIM17_IRQHandler+0x194>)
 8001e7a:	0189      	lsls	r1, r1, #6
 8001e7c:	2200      	movs	r2, #0
 8001e7e:	f004 f86f 	bl	8005f60 <GPIO_WriteBit>
			TIM_SetCounter(TIM17, PULSE_LENGHT); // 0.1ms
 8001e82:	4809      	ldr	r0, [pc, #36]	; (8001ea8 <TIM17_IRQHandler+0x188>)
 8001e84:	2164      	movs	r1, #100	; 0x64
 8001e86:	f005 fbbb 	bl	8007600 <TIM_SetCounter>
 8001e8a:	e750      	b.n	8001d2e <TIM17_IRQHandler+0xe>
			PulseState = 2;
			// Se potência acima de 0 e TRIACs não estão em curto, liga T1 e T2.
			// Otherwise, turn then off
			if((ShowerPower > 0) && (TriacError == TRIAC_OK))
			{
				GPIO_WriteBit(GPIOB,GPIO_Pin_9,  1); // TRIAC 1
 8001e8c:	2180      	movs	r1, #128	; 0x80
 8001e8e:	4808      	ldr	r0, [pc, #32]	; (8001eb0 <TIM17_IRQHandler+0x190>)
 8001e90:	0089      	lsls	r1, r1, #2
 8001e92:	2201      	movs	r2, #1
 8001e94:	f004 f864 	bl	8005f60 <GPIO_WriteBit>
				GPIO_WriteBit(GPIOC,GPIO_Pin_13, 1); // TRIAC 2
 8001e98:	2180      	movs	r1, #128	; 0x80
 8001e9a:	4806      	ldr	r0, [pc, #24]	; (8001eb4 <TIM17_IRQHandler+0x194>)
 8001e9c:	0189      	lsls	r1, r1, #6
 8001e9e:	2201      	movs	r2, #1
 8001ea0:	f004 f85e 	bl	8005f60 <GPIO_WriteBit>
 8001ea4:	e7d2      	b.n	8001e4c <TIM17_IRQHandler+0x12c>
 8001ea6:	46c0      	nop			; (mov r8, r8)
 8001ea8:	40014800 	.word	0x40014800
 8001eac:	200001a8 	.word	0x200001a8
 8001eb0:	48000400 	.word	0x48000400
 8001eb4:	48000800 	.word	0x48000800
 8001eb8:	48001400 	.word	0x48001400
 8001ebc:	20000034 	.word	0x20000034
 8001ec0:	e000e100 	.word	0xe000e100
 8001ec4:	00002029 	.word	0x00002029

08001ec8 <TRIAC_EnableIRQ>:

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 8001ec8:	2220      	movs	r2, #32
 8001eca:	4b03      	ldr	r3, [pc, #12]	; (8001ed8 <TRIAC_EnableIRQ+0x10>)
 8001ecc:	601a      	str	r2, [r3, #0]
 8001ece:	2280      	movs	r2, #128	; 0x80
 8001ed0:	03d2      	lsls	r2, r2, #15
 8001ed2:	601a      	str	r2, [r3, #0]
//==================================================================================================
void TRIAC_EnableIRQ (void)
{
	NVIC_EnableIRQ(EXTI0_1_IRQn); // ZC
	NVIC_EnableIRQ(TIM17_IRQn);   // Pulse Timer
}
 8001ed4:	4770      	bx	lr
 8001ed6:	46c0      	nop			; (mov r8, r8)
 8001ed8:	e000e100 	.word	0xe000e100

08001edc <TRIAC_DisableIRQ>:

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 8001edc:	2380      	movs	r3, #128	; 0x80
 8001ede:	2120      	movs	r1, #32
 8001ee0:	4a02      	ldr	r2, [pc, #8]	; (8001eec <TRIAC_DisableIRQ+0x10>)
 8001ee2:	50d1      	str	r1, [r2, r3]
 8001ee4:	2180      	movs	r1, #128	; 0x80
 8001ee6:	03c9      	lsls	r1, r1, #15
 8001ee8:	50d1      	str	r1, [r2, r3]
//==================================================================================================
void TRIAC_DisableIRQ(void)
{
	NVIC_DisableIRQ(EXTI0_1_IRQn); // ZC
	NVIC_DisableIRQ(TIM17_IRQn);   // Pulse Timer
}
 8001eea:	4770      	bx	lr
 8001eec:	e000e100 	.word	0xe000e100

08001ef0 <Bluetooth_Init>:
	USART_InitTypeDef USART_InitStructure;   // USART configuration struct
	GPIO_InitTypeDef  GPIO_InitStructure;    // GPIO configuration struct
	//NVIC_InitTypeDef  NVIC_InitStructure;  // NVIC configuration struct

	/* Enable GPIO clock */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 8001ef0:	2080      	movs	r0, #128	; 0x80

//==================================================================================================
//
//==================================================================================================
void Bluetooth_Init(void)
{
 8001ef2:	b530      	push	{r4, r5, lr}
	USART_InitTypeDef USART_InitStructure;   // USART configuration struct
	GPIO_InitTypeDef  GPIO_InitStructure;    // GPIO configuration struct
	//NVIC_InitTypeDef  NVIC_InitStructure;  // NVIC configuration struct

	/* Enable GPIO clock */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 8001ef4:	02c0      	lsls	r0, r0, #11

//==================================================================================================
//
//==================================================================================================
void Bluetooth_Init(void)
{
 8001ef6:	b089      	sub	sp, #36	; 0x24
	USART_InitTypeDef USART_InitStructure;   // USART configuration struct
	GPIO_InitTypeDef  GPIO_InitStructure;    // GPIO configuration struct
	//NVIC_InitTypeDef  NVIC_InitStructure;  // NVIC configuration struct

	/* Enable GPIO clock */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 8001ef8:	2101      	movs	r1, #1
 8001efa:	f004 fbb1 	bl	8006660 <RCC_AHBPeriphClockCmd>

	/* Enables High Speed APB (APB2) peripheral clock*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);
 8001efe:	2080      	movs	r0, #128	; 0x80

	/* Connect PB6 to USART1_Tx */
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_0);
 8001f00:	4d18      	ldr	r5, [pc, #96]	; (8001f64 <Bluetooth_Init+0x74>)

	/* Enable GPIO clock */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);

	/* Enables High Speed APB (APB2) peripheral clock*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);
 8001f02:	01c0      	lsls	r0, r0, #7
 8001f04:	2101      	movs	r1, #1
 8001f06:	f004 fbb7 	bl	8006678 <RCC_APB2PeriphClockCmd>

	/* Connect PB6 to USART1_Tx */
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_0);
 8001f0a:	1c28      	adds	r0, r5, #0
 8001f0c:	2106      	movs	r1, #6
 8001f0e:	2200      	movs	r2, #0
 8001f10:	f004 f82e 	bl	8005f70 <GPIO_PinAFConfig>
	/* Connect PB7 to USART1_Rx */
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_0);
 8001f14:	1c28      	adds	r0, r5, #0
 8001f16:	2107      	movs	r1, #7
 8001f18:	2200      	movs	r2, #0
 8001f1a:	f004 f829 	bl	8005f70 <GPIO_PinAFConfig>

	/* Configure USART1 pins:  Rx and Tx ----------------------------*/
	GPIO_InitStructure.GPIO_Pin	  = GPIO_Pin_6 | GPIO_Pin_7;
 8001f1e:	23c0      	movs	r3, #192	; 0xc0
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001f20:	466a      	mov	r2, sp
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_0);
	/* Connect PB7 to USART1_Rx */
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_0);

	/* Configure USART1 pins:  Rx and Tx ----------------------------*/
	GPIO_InitStructure.GPIO_Pin	  = GPIO_Pin_6 | GPIO_Pin_7;
 8001f22:	9300      	str	r3, [sp, #0]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001f24:	3bbd      	subs	r3, #189	; 0xbd
 8001f26:	7153      	strb	r3, [r2, #5]
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 8001f28:	3b01      	subs	r3, #1
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8001f2a:	2400      	movs	r4, #0
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_0);

	/* Configure USART1 pins:  Rx and Tx ----------------------------*/
	GPIO_InitStructure.GPIO_Pin	  = GPIO_Pin_6 | GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 8001f2c:	7113      	strb	r3, [r2, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
 8001f2e:	2301      	movs	r3, #1
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001f30:	1c28      	adds	r0, r5, #0
 8001f32:	4669      	mov	r1, sp

	/* Configure USART1 pins:  Rx and Tx ----------------------------*/
	GPIO_InitStructure.GPIO_Pin	  = GPIO_Pin_6 | GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8001f34:	7194      	strb	r4, [r2, #6]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
 8001f36:	71d3      	strb	r3, [r2, #7]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001f38:	f003 ff78 	bl	8005e2c <GPIO_Init>
	- One Stop Bit
	- No parity
	- Hardware flow control disabled (RTS and CTS signals)
	- Receive and transmit enabled
	*/
	USART_InitStructure.USART_BaudRate 	 = 9600;
 8001f3c:	2396      	movs	r3, #150	; 0x96
 8001f3e:	019b      	lsls	r3, r3, #6
 8001f40:	9302      	str	r3, [sp, #8]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits 	 = USART_StopBits_1;
	USART_InitStructure.USART_Parity 	 = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode 		 = USART_Mode_Rx | USART_Mode_Tx;
 8001f42:	230c      	movs	r3, #12
	- No parity
	- Hardware flow control disabled (RTS and CTS signals)
	- Receive and transmit enabled
	*/
	USART_InitStructure.USART_BaudRate 	 = 9600;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8001f44:	9403      	str	r4, [sp, #12]
	USART_InitStructure.USART_StopBits 	 = USART_StopBits_1;
 8001f46:	9404      	str	r4, [sp, #16]
	USART_InitStructure.USART_Parity 	 = USART_Parity_No;
 8001f48:	9405      	str	r4, [sp, #20]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8001f4a:	9407      	str	r4, [sp, #28]
	USART_InitStructure.USART_Mode 		 = USART_Mode_Rx | USART_Mode_Tx;
	USART_Init(USART1, &USART_InitStructure);
 8001f4c:	4c06      	ldr	r4, [pc, #24]	; (8001f68 <Bluetooth_Init+0x78>)
 8001f4e:	a902      	add	r1, sp, #8
 8001f50:	1c20      	adds	r0, r4, #0
	USART_InitStructure.USART_BaudRate 	 = 9600;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits 	 = USART_StopBits_1;
	USART_InitStructure.USART_Parity 	 = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode 		 = USART_Mode_Rx | USART_Mode_Tx;
 8001f52:	9306      	str	r3, [sp, #24]
	USART_Init(USART1, &USART_InitStructure);
 8001f54:	f006 f8f8 	bl	8008148 <USART_Init>
	NVIC_InitStructure.NVIC_IRQChannelPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);	*/

	/* Enable USART */
	USART_Cmd(USART1,ENABLE);
 8001f58:	1c20      	adds	r0, r4, #0
 8001f5a:	2101      	movs	r1, #1
 8001f5c:	f006 f974 	bl	8008248 <USART_Cmd>
}
 8001f60:	b009      	add	sp, #36	; 0x24
 8001f62:	bd30      	pop	{r4, r5, pc}
 8001f64:	48000400 	.word	0x48000400
 8001f68:	40013800 	.word	0x40013800

08001f6c <Bluetooth_Write>:

//==================================================================================================
//
//==================================================================================================
void Bluetooth_Write(char *Data, uint32_t Tam)
{
 8001f6c:	b538      	push	{r3, r4, r5, lr}
 8001f6e:	1c04      	adds	r4, r0, #0
 8001f70:	1845      	adds	r5, r0, r1
	uint32_t i;
	
	for(i=0; i<Tam; i++)
 8001f72:	2900      	cmp	r1, #0
 8001f74:	d00c      	beq.n	8001f90 <Bluetooth_Write+0x24>
	{	 
		while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
 8001f76:	4807      	ldr	r0, [pc, #28]	; (8001f94 <Bluetooth_Write+0x28>)
 8001f78:	2180      	movs	r1, #128	; 0x80
 8001f7a:	f006 fb3d 	bl	80085f8 <USART_GetFlagStatus>
 8001f7e:	2800      	cmp	r0, #0
 8001f80:	d0f9      	beq.n	8001f76 <Bluetooth_Write+0xa>
		
		USART_SendData(USART1, Data[i]);
 8001f82:	7821      	ldrb	r1, [r4, #0]
 8001f84:	4803      	ldr	r0, [pc, #12]	; (8001f94 <Bluetooth_Write+0x28>)
 8001f86:	3401      	adds	r4, #1
 8001f88:	f006 fa1e 	bl	80083c8 <USART_SendData>
//==================================================================================================
void Bluetooth_Write(char *Data, uint32_t Tam)
{
	uint32_t i;
	
	for(i=0; i<Tam; i++)
 8001f8c:	42ac      	cmp	r4, r5
 8001f8e:	d1f2      	bne.n	8001f76 <Bluetooth_Write+0xa>
	{	 
		while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
		
		USART_SendData(USART1, Data[i]);
	}
}
 8001f90:	bd38      	pop	{r3, r4, r5, pc}
 8001f92:	46c0      	nop			; (mov r8, r8)
 8001f94:	40013800 	.word	0x40013800

08001f98 <Debug_Init>:

//==================================================================================================
//
//==================================================================================================
void Debug_Init(void)
{
 8001f98:	b570      	push	{r4, r5, r6, lr}
	USART_InitTypeDef USART_InitStructure;
	GPIO_InitTypeDef  GPIO_InitStructure;

	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8001f9a:	2480      	movs	r4, #128	; 0x80

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);

	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_1);
 8001f9c:	2590      	movs	r5, #144	; 0x90
void Debug_Init(void)
{
	USART_InitTypeDef USART_InitStructure;
	GPIO_InitTypeDef  GPIO_InitStructure;

	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8001f9e:	02a4      	lsls	r4, r4, #10

//==================================================================================================
//
//==================================================================================================
void Debug_Init(void)
{
 8001fa0:	b088      	sub	sp, #32
	USART_InitTypeDef USART_InitStructure;
	GPIO_InitTypeDef  GPIO_InitStructure;

	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8001fa2:	1c20      	adds	r0, r4, #0
 8001fa4:	2101      	movs	r1, #1
 8001fa6:	f004 fb5b 	bl	8006660 <RCC_AHBPeriphClockCmd>

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);

	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_1);
 8001faa:	05ed      	lsls	r5, r5, #23
	USART_InitTypeDef USART_InitStructure;
	GPIO_InitTypeDef  GPIO_InitStructure;

	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);
 8001fac:	1c20      	adds	r0, r4, #0
 8001fae:	2101      	movs	r1, #1
 8001fb0:	f004 fb6e 	bl	8006690 <RCC_APB1PeriphClockCmd>

	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_1);
 8001fb4:	1c28      	adds	r0, r5, #0
 8001fb6:	2102      	movs	r1, #2
 8001fb8:	2201      	movs	r2, #1
 8001fba:	f003 ffd9 	bl	8005f70 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_1);
 8001fbe:	1c28      	adds	r0, r5, #0
 8001fc0:	2103      	movs	r1, #3
 8001fc2:	2201      	movs	r2, #1
 8001fc4:	f003 ffd4 	bl	8005f70 <GPIO_PinAFConfig>

	/* Configure USART1 pins:  Rx and Tx ----------------------------*/
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_2 | GPIO_Pin_3;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8001fc8:	466a      	mov	r2, sp
 8001fca:	2303      	movs	r3, #3
 8001fcc:	7153      	strb	r3, [r2, #5]
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 8001fce:	3b01      	subs	r3, #1
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8001fd0:	2400      	movs	r4, #0
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_1);

	/* Configure USART1 pins:  Rx and Tx ----------------------------*/
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_2 | GPIO_Pin_3;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 8001fd2:	7113      	strb	r3, [r2, #4]

	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_1);
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_1);

	/* Configure USART1 pins:  Rx and Tx ----------------------------*/
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_2 | GPIO_Pin_3;
 8001fd4:	260c      	movs	r6, #12
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
 8001fd6:	2301      	movs	r3, #1
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8001fd8:	1c28      	adds	r0, r5, #0
 8001fda:	4669      	mov	r1, sp

	/* Configure USART1 pins:  Rx and Tx ----------------------------*/
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_2 | GPIO_Pin_3;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8001fdc:	7194      	strb	r4, [r2, #6]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
 8001fde:	71d3      	strb	r3, [r2, #7]

	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_1);
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_1);

	/* Configure USART1 pins:  Rx and Tx ----------------------------*/
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_2 | GPIO_Pin_3;
 8001fe0:	9600      	str	r6, [sp, #0]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8001fe2:	f003 ff23 	bl	8005e2c <GPIO_Init>

	USART_InitStructure.USART_BaudRate   = 38400;
 8001fe6:	2396      	movs	r3, #150	; 0x96
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8001fe8:	9403      	str	r4, [sp, #12]
	USART_InitStructure.USART_StopBits   = USART_StopBits_1;
 8001fea:	9404      	str	r4, [sp, #16]
	USART_InitStructure.USART_Parity 	 = USART_Parity_No;
 8001fec:	9405      	str	r4, [sp, #20]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8001fee:	9407      	str	r4, [sp, #28]
	USART_InitStructure.USART_Mode 	     = USART_Mode_Rx | USART_Mode_Tx;
	USART_Init(USART2, &USART_InitStructure);
 8001ff0:	4c06      	ldr	r4, [pc, #24]	; (800200c <Debug_Init+0x74>)
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	USART_InitStructure.USART_BaudRate   = 38400;
 8001ff2:	021b      	lsls	r3, r3, #8
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits   = USART_StopBits_1;
	USART_InitStructure.USART_Parity 	 = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode 	     = USART_Mode_Rx | USART_Mode_Tx;
	USART_Init(USART2, &USART_InitStructure);
 8001ff4:	1c20      	adds	r0, r4, #0
 8001ff6:	a902      	add	r1, sp, #8
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	USART_InitStructure.USART_BaudRate   = 38400;
 8001ff8:	9302      	str	r3, [sp, #8]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits   = USART_StopBits_1;
	USART_InitStructure.USART_Parity 	 = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode 	     = USART_Mode_Rx | USART_Mode_Tx;
 8001ffa:	9606      	str	r6, [sp, #24]
	USART_Init(USART2, &USART_InitStructure);
 8001ffc:	f006 f8a4 	bl	8008148 <USART_Init>

	USART_Cmd(USART2,ENABLE);
 8002000:	1c20      	adds	r0, r4, #0
 8002002:	2101      	movs	r1, #1
 8002004:	f006 f920 	bl	8008248 <USART_Cmd>
}
 8002008:	b008      	add	sp, #32
 800200a:	bd70      	pop	{r4, r5, r6, pc}
 800200c:	40004400 	.word	0x40004400

08002010 <Debug_Write>:

//==================================================================================================
//
//==================================================================================================
void Debug_Write(char *Data, uint32_t Tam)
{
 8002010:	b538      	push	{r3, r4, r5, lr}
 8002012:	1c04      	adds	r4, r0, #0
 8002014:	1845      	adds	r5, r0, r1
	uint32_t i;

	for(i=0; i<Tam; i++)
 8002016:	2900      	cmp	r1, #0
 8002018:	d00c      	beq.n	8002034 <Debug_Write+0x24>
	{
		while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET);
 800201a:	4807      	ldr	r0, [pc, #28]	; (8002038 <Debug_Write+0x28>)
 800201c:	2180      	movs	r1, #128	; 0x80
 800201e:	f006 faeb 	bl	80085f8 <USART_GetFlagStatus>
 8002022:	2800      	cmp	r0, #0
 8002024:	d0f9      	beq.n	800201a <Debug_Write+0xa>

		USART_SendData(USART2, Data[i]);
 8002026:	7821      	ldrb	r1, [r4, #0]
 8002028:	4803      	ldr	r0, [pc, #12]	; (8002038 <Debug_Write+0x28>)
 800202a:	3401      	adds	r4, #1
 800202c:	f006 f9cc 	bl	80083c8 <USART_SendData>
//==================================================================================================
void Debug_Write(char *Data, uint32_t Tam)
{
	uint32_t i;

	for(i=0; i<Tam; i++)
 8002030:	42ac      	cmp	r4, r5
 8002032:	d1f2      	bne.n	800201a <Debug_Write+0xa>
	{
		while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET);

		USART_SendData(USART2, Data[i]);
	}
}
 8002034:	bd38      	pop	{r3, r4, r5, pc}
 8002036:	46c0      	nop			; (mov r8, r8)
 8002038:	40004400 	.word	0x40004400

0800203c <Buzzer_Task>:
//==================================================================================================
//
//==================================================================================================
void Buzzer_Task()
{
	xSemaphoreTake(xBuzzerSemaphore, portMAX_DELAY);
 800203c:	2201      	movs	r2, #1

//==================================================================================================
//
//==================================================================================================
void Buzzer_Task()
{
 800203e:	b538      	push	{r3, r4, r5, lr}
	xSemaphoreTake(xBuzzerSemaphore, portMAX_DELAY);
 8002040:	4d0f      	ldr	r5, [pc, #60]	; (8002080 <Buzzer_Task+0x44>)
 8002042:	2100      	movs	r1, #0
 8002044:	6828      	ldr	r0, [r5, #0]
 8002046:	4252      	negs	r2, r2
 8002048:	2300      	movs	r3, #0
 800204a:	f006 fd03 	bl	8008a54 <xQueueGenericReceive>
 800204e:	792c      	ldrb	r4, [r5, #4]
 8002050:	3c01      	subs	r4, #1
 8002052:	b2e4      	uxtb	r4, r4
 8002054:	e001      	b.n	800205a <Buzzer_Task+0x1e>
 8002056:	3c01      	subs	r4, #1
 8002058:	b2e4      	uxtb	r4, r4

	uint8_t Repeat = BuzzerRepeat;

	do
	{
		PWM_SetDutyCycle(PWM_CHANNEL_BUZZER, BUZZER_DUTYCYCLE);
 800205a:	2119      	movs	r1, #25
 800205c:	2004      	movs	r0, #4
 800205e:	f7fe fe43 	bl	8000ce8 <PWM_SetDutyCycle>
		vTaskDelay(BuzzerTime);
 8002062:	7968      	ldrb	r0, [r5, #5]
 8002064:	f007 fac8 	bl	80095f8 <vTaskDelay>
		PWM_SetDutyCycle(PWM_CHANNEL_BUZZER, 0);
 8002068:	2004      	movs	r0, #4
 800206a:	2100      	movs	r1, #0
 800206c:	f7fe fe3c 	bl	8000ce8 <PWM_SetDutyCycle>

		if(Repeat > 0) vTaskDelay(30);
 8002070:	2cff      	cmp	r4, #255	; 0xff
 8002072:	d0f0      	beq.n	8002056 <Buzzer_Task+0x1a>
 8002074:	201e      	movs	r0, #30
 8002076:	f007 fabf 	bl	80095f8 <vTaskDelay>

	}
	while((--Repeat) > 0);
 800207a:	2c00      	cmp	r4, #0
 800207c:	d1eb      	bne.n	8002056 <Buzzer_Task+0x1a>
}
 800207e:	bd38      	pop	{r3, r4, r5, pc}
 8002080:	200001c4 	.word	0x200001c4

08002084 <Buzzer_Init>:

//==================================================================================================
//
//==================================================================================================
void Buzzer_Init (void)
{
 8002084:	b510      	push	{r4, lr}
	PWM_Init();
 8002086:	f7fe fe21 	bl	8000ccc <PWM_Init>

	vSemaphoreCreateBinary(xBuzzerSemaphore ); // Create the semaphore
 800208a:	2001      	movs	r0, #1
 800208c:	2100      	movs	r1, #0
 800208e:	2203      	movs	r2, #3
 8002090:	f006 fbb0 	bl	80087f4 <xQueueGenericCreate>
 8002094:	4c07      	ldr	r4, [pc, #28]	; (80020b4 <Buzzer_Init+0x30>)
 8002096:	6020      	str	r0, [r4, #0]
 8002098:	2800      	cmp	r0, #0
 800209a:	d005      	beq.n	80020a8 <Buzzer_Init+0x24>
 800209c:	2100      	movs	r1, #0
 800209e:	2200      	movs	r2, #0
 80020a0:	2300      	movs	r3, #0
 80020a2:	f006 fbd3 	bl	800884c <xQueueGenericSend>
 80020a6:	6820      	ldr	r0, [r4, #0]
	xSemaphoreTake(xBuzzerSemaphore, 0);       // Take semaphore after creating it.
 80020a8:	2100      	movs	r1, #0
 80020aa:	2200      	movs	r2, #0
 80020ac:	2300      	movs	r3, #0
 80020ae:	f006 fcd1 	bl	8008a54 <xQueueGenericReceive>
}
 80020b2:	bd10      	pop	{r4, pc}
 80020b4:	200001c4 	.word	0x200001c4

080020b8 <Buzzer_Beep>:

//==================================================================================================
//
//==================================================================================================
void Buzzer_Beep(uint16_t Time, uint8_t Repeat)
{
 80020b8:	b508      	push	{r3, lr}
	BuzzerTime 	 = Time;
	BuzzerRepeat = Repeat;

	if(BuzzerControl == BUZZER_ENABLED)
 80020ba:	4a07      	ldr	r2, [pc, #28]	; (80020d8 <Buzzer_Beep+0x20>)
//==================================================================================================
//
//==================================================================================================
void Buzzer_Beep(uint16_t Time, uint8_t Repeat)
{
	BuzzerTime 	 = Time;
 80020bc:	4b07      	ldr	r3, [pc, #28]	; (80020dc <Buzzer_Beep+0x24>)
	BuzzerRepeat = Repeat;

	if(BuzzerControl == BUZZER_ENABLED)
 80020be:	7812      	ldrb	r2, [r2, #0]
//==================================================================================================
//
//==================================================================================================
void Buzzer_Beep(uint16_t Time, uint8_t Repeat)
{
	BuzzerTime 	 = Time;
 80020c0:	7158      	strb	r0, [r3, #5]
	BuzzerRepeat = Repeat;
 80020c2:	7119      	strb	r1, [r3, #4]

	if(BuzzerControl == BUZZER_ENABLED)
 80020c4:	2a0f      	cmp	r2, #15
 80020c6:	d000      	beq.n	80020ca <Buzzer_Beep+0x12>
	{
		xSemaphoreGive(xBuzzerSemaphore);
	}
}
 80020c8:	bd08      	pop	{r3, pc}
	BuzzerTime 	 = Time;
	BuzzerRepeat = Repeat;

	if(BuzzerControl == BUZZER_ENABLED)
	{
		xSemaphoreGive(xBuzzerSemaphore);
 80020ca:	6818      	ldr	r0, [r3, #0]
 80020cc:	2100      	movs	r1, #0
 80020ce:	2200      	movs	r2, #0
 80020d0:	2300      	movs	r3, #0
 80020d2:	f006 fbbb 	bl	800884c <xQueueGenericSend>
 80020d6:	e7f7      	b.n	80020c8 <Buzzer_Beep+0x10>
 80020d8:	20000035 	.word	0x20000035
 80020dc:	200001c4 	.word	0x200001c4

080020e0 <Buzzer_Control>:
//==================================================================================================
//
//==================================================================================================
void Buzzer_Control(uint8_t EnDis)
{
	BuzzerControl = EnDis;
 80020e0:	4b01      	ldr	r3, [pc, #4]	; (80020e8 <Buzzer_Control+0x8>)
 80020e2:	7018      	strb	r0, [r3, #0]
}
 80020e4:	4770      	bx	lr
 80020e6:	46c0      	nop			; (mov r8, r8)
 80020e8:	20000035 	.word	0x20000035

080020ec <RTCC_Config>:
//
//==================================================================================================
void RTCC_Config(void)
{
	/* Enable the PWR clock */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
 80020ec:	2080      	movs	r0, #128	; 0x80

//==================================================================================================
//
//==================================================================================================
void RTCC_Config(void)
{
 80020ee:	b508      	push	{r3, lr}
	/* Enable the PWR clock */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
 80020f0:	2101      	movs	r1, #1
 80020f2:	0540      	lsls	r0, r0, #21
 80020f4:	f004 facc 	bl	8006690 <RCC_APB1PeriphClockCmd>

	/* Allow access to RTC */
	PWR_BackupAccessCmd(ENABLE);
 80020f8:	2001      	movs	r0, #1
 80020fa:	f003 ffa3 	bl	8006044 <PWR_BackupAccessCmd>

#if defined (RTC_CLOCK_SOURCE_LSI)  /* LSI used as RTC source clock*/
	/* The RTC Clock may varies due to LSI frequency dispersion. */
	/* Enable the LSI OSC */
	RCC_LSICmd(ENABLE);
 80020fe:	2001      	movs	r0, #1
 8002100:	f004 f8c6 	bl	8006290 <RCC_LSICmd>

	RCC_LSEConfig(RCC_LSE_ON);
 8002104:	2001      	movs	r0, #1
 8002106:	f004 f8a7 	bl	8006258 <RCC_LSEConfig>

	/* Wait till LSI is ready */
	while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET){}
 800210a:	2041      	movs	r0, #65	; 0x41
 800210c:	f004 fafc 	bl	8006708 <RCC_GetFlagStatus>
 8002110:	2800      	cmp	r0, #0
 8002112:	d0fa      	beq.n	800210a <RTCC_Config+0x1e>

	/* Select the RTC Clock Source */
	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
 8002114:	2080      	movs	r0, #128	; 0x80
 8002116:	0080      	lsls	r0, r0, #2
 8002118:	f004 fa76 	bl	8006608 <RCC_RTCCLKConfig>

	SynchPrediv  = 0x18F;
 800211c:	2290      	movs	r2, #144	; 0x90
 800211e:	4b06      	ldr	r3, [pc, #24]	; (8002138 <RTCC_Config+0x4c>)
 8002120:	32ff      	adds	r2, #255	; 0xff
 8002122:	601a      	str	r2, [r3, #0]
	AsynchPrediv = 0x63;
 8002124:	3a2d      	subs	r2, #45	; 0x2d
 8002126:	3aff      	subs	r2, #255	; 0xff
#else
	#error Please select the RTC Clock source inside the main.c file
#endif /* RTC_CLOCK_SOURCE_LSI */

	/* Enable the RTC Clock */
	RCC_RTCCLKCmd(ENABLE);
 8002128:	2001      	movs	r0, #1

	/* Select the RTC Clock Source */
	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);

	SynchPrediv  = 0x18F;
	AsynchPrediv = 0x63;
 800212a:	605a      	str	r2, [r3, #4]
#else
	#error Please select the RTC Clock source inside the main.c file
#endif /* RTC_CLOCK_SOURCE_LSI */

	/* Enable the RTC Clock */
	RCC_RTCCLKCmd(ENABLE);
 800212c:	f004 fa74 	bl	8006618 <RCC_RTCCLKCmd>

	/* Wait for RTC APB registers synchronization */
	RTC_WaitForSynchro();
 8002130:	f004 fba2 	bl	8006878 <RTC_WaitForSynchro>
}
 8002134:	bd08      	pop	{r3, pc}
 8002136:	46c0      	nop			; (mov r8, r8)
 8002138:	200001cc 	.word	0x200001cc

0800213c <RTCC_TimeRegulate>:

//==================================================================================================
//
//==================================================================================================
void RTCC_TimeRegulate(void)
{
 800213c:	b510      	push	{r4, lr}
 800213e:	b082      	sub	sp, #8
	RTC_TimeTypeDef RTC_TimeStructure;
	RTC_DateTypeDef RTC_DateStruct;

	RTC_TimeStructure.RTC_H12  = RTC_H12_AM;
 8002140:	2400      	movs	r4, #0
 8002142:	466b      	mov	r3, sp
 8002144:	70dc      	strb	r4, [r3, #3]
	RTC_DateStruct.RTC_WeekDay = RTC_Weekday_Monday;
 8002146:	2302      	movs	r3, #2
 8002148:	a901      	add	r1, sp, #4
 800214a:	700b      	strb	r3, [r1, #0]
	RTC_DateStruct.RTC_Month   = RTC_Month_January;
 800214c:	3b01      	subs	r3, #1
 800214e:	704b      	strb	r3, [r1, #1]
	RTC_DateStruct.RTC_Date    = 1;
 8002150:	708b      	strb	r3, [r1, #2]
	RTC_DateStruct.RTC_Year    = 15;

	/* Configure the RTC time register */
	if(RTC_SetDate(RTC_Format_BIN, &RTC_DateStruct) == ERROR)
 8002152:	2000      	movs	r0, #0

	RTC_TimeStructure.RTC_H12  = RTC_H12_AM;
	RTC_DateStruct.RTC_WeekDay = RTC_Weekday_Monday;
	RTC_DateStruct.RTC_Month   = RTC_Month_January;
	RTC_DateStruct.RTC_Date    = 1;
	RTC_DateStruct.RTC_Year    = 15;
 8002154:	330e      	adds	r3, #14
 8002156:	70cb      	strb	r3, [r1, #3]

	/* Configure the RTC time register */
	if(RTC_SetDate(RTC_Format_BIN, &RTC_DateStruct) == ERROR)
 8002158:	f004 fcc6 	bl	8006ae8 <RTC_SetDate>
	{
		// TODO - Tratar o retorno
		//printf("\n\r>> !! RTC Set Date failed. !! <<\n\r");
	}

	RTC_TimeStructure.RTC_H12     = RTC_H12_AM;
 800215c:	466b      	mov	r3, sp
	RTC_TimeStructure.RTC_Hours   = 8;
 800215e:	466a      	mov	r2, sp
	{
		// TODO - Tratar o retorno
		//printf("\n\r>> !! RTC Set Date failed. !! <<\n\r");
	}

	RTC_TimeStructure.RTC_H12     = RTC_H12_AM;
 8002160:	70dc      	strb	r4, [r3, #3]
	RTC_TimeStructure.RTC_Hours   = 8;
 8002162:	2308      	movs	r3, #8
	RTC_TimeStructure.RTC_Minutes = 0;
	RTC_TimeStructure.RTC_Seconds = 0;

	/* Configure the RTC time register */
	if(RTC_SetTime(RTC_Format_BIN, &RTC_TimeStructure) == ERROR)
 8002164:	4669      	mov	r1, sp
 8002166:	2000      	movs	r0, #0
		// TODO - Tratar o retorno
		//printf("\n\r>> !! RTC Set Date failed. !! <<\n\r");
	}

	RTC_TimeStructure.RTC_H12     = RTC_H12_AM;
	RTC_TimeStructure.RTC_Hours   = 8;
 8002168:	7013      	strb	r3, [r2, #0]
	RTC_TimeStructure.RTC_Minutes = 0;
 800216a:	7054      	strb	r4, [r2, #1]
	RTC_TimeStructure.RTC_Seconds = 0;
 800216c:	7094      	strb	r4, [r2, #2]

	/* Configure the RTC time register */
	if(RTC_SetTime(RTC_Format_BIN, &RTC_TimeStructure) == ERROR)
 800216e:	f004 fc13 	bl	8006998 <RTC_SetTime>
	{
		// TODO - Tratar o retorno
		//printf("\n\r>> !! RTC Set Time failed. !! <<\n\r");
	}
}
 8002172:	b002      	add	sp, #8
 8002174:	bd10      	pop	{r4, pc}
 8002176:	46c0      	nop			; (mov r8, r8)

08002178 <RTCC_Init>:

//==================================================================================================
//
//==================================================================================================
void RTCC_Init (void)
{
 8002178:	b500      	push	{lr}
 800217a:	b085      	sub	sp, #20
	RTC_InitTypeDef RTC_InitStructure;

	/* RTC configuration  */
	RTCC_Config();
 800217c:	f7ff ffb6 	bl	80020ec <RTCC_Config>

	/* Configure the RTC data register and RTC prescaler */
	RTC_InitStructure.RTC_AsynchPrediv = AsynchPrediv;
 8002180:	4b06      	ldr	r3, [pc, #24]	; (800219c <RTCC_Init+0x24>)
	RTC_InitStructure.RTC_SynchPrediv  = SynchPrediv;
	RTC_InitStructure.RTC_HourFormat   = RTC_HourFormat_24;

	/* Check on RTC init */
	if (RTC_Init(&RTC_InitStructure) == ERROR)
 8002182:	a801      	add	r0, sp, #4

	/* RTC configuration  */
	RTCC_Config();

	/* Configure the RTC data register and RTC prescaler */
	RTC_InitStructure.RTC_AsynchPrediv = AsynchPrediv;
 8002184:	685a      	ldr	r2, [r3, #4]
	RTC_InitStructure.RTC_SynchPrediv  = SynchPrediv;
 8002186:	681b      	ldr	r3, [r3, #0]

	/* RTC configuration  */
	RTCC_Config();

	/* Configure the RTC data register and RTC prescaler */
	RTC_InitStructure.RTC_AsynchPrediv = AsynchPrediv;
 8002188:	9202      	str	r2, [sp, #8]
	RTC_InitStructure.RTC_SynchPrediv  = SynchPrediv;
 800218a:	9303      	str	r3, [sp, #12]
	RTC_InitStructure.RTC_HourFormat   = RTC_HourFormat_24;
 800218c:	2300      	movs	r3, #0
 800218e:	9301      	str	r3, [sp, #4]

	/* Check on RTC init */
	if (RTC_Init(&RTC_InitStructure) == ERROR)
 8002190:	f004 fb42 	bl	8006818 <RTC_Init>
	{
		// TODO - Tratar o retorno
		//printf("\n\r        /!\\***** RTC Prescaler Config failed ********/!\\ \n\r");
	}

	RTCC_TimeRegulate();
 8002194:	f7ff ffd2 	bl	800213c <RTCC_TimeRegulate>

}
 8002198:	b005      	add	sp, #20
 800219a:	bd00      	pop	{pc}
 800219c:	200001cc 	.word	0x200001cc

080021a0 <RTCC_SetTimeDate>:

//==================================================================================================
//
//==================================================================================================
void RTCC_SetTimeDate(RTCC_TimeDateTypeDef RTCC_TimeDate)
{
 80021a0:	1c02      	adds	r2, r0, #0
 80021a2:	1c03      	adds	r3, r0, #0
 80021a4:	b510      	push	{r4, lr}
 80021a6:	b084      	sub	sp, #16
 80021a8:	9101      	str	r1, [sp, #4]
	RTC_TimeTypeDef RTC_TimeStructure;
	RTC_DateTypeDef RTC_DateStruct;

	RTC_DateStruct.RTC_WeekDay = RTCC_TimeDate.WeekDay;
 80021aa:	a903      	add	r1, sp, #12
 80021ac:	7008      	strb	r0, [r1, #0]
	RTC_DateStruct.RTC_Month   = RTCC_TimeDate.Month;
	RTC_DateStruct.RTC_Date    = RTCC_TimeDate.Date;
	RTC_DateStruct.RTC_Year    = RTCC_TimeDate.Year;
 80021ae:	0e00      	lsrs	r0, r0, #24

//==================================================================================================
//
//==================================================================================================
void RTCC_SetTimeDate(RTCC_TimeDateTypeDef RTCC_TimeDate)
{
 80021b0:	0c12      	lsrs	r2, r2, #16
 80021b2:	0a1b      	lsrs	r3, r3, #8
	RTC_DateTypeDef RTC_DateStruct;

	RTC_DateStruct.RTC_WeekDay = RTCC_TimeDate.WeekDay;
	RTC_DateStruct.RTC_Month   = RTCC_TimeDate.Month;
	RTC_DateStruct.RTC_Date    = RTCC_TimeDate.Date;
	RTC_DateStruct.RTC_Year    = RTCC_TimeDate.Year;
 80021b4:	70c8      	strb	r0, [r1, #3]

	/* Configure the RTC time register */
	if(RTC_SetDate(RTC_Format_BIN, &RTC_DateStruct) == ERROR)
 80021b6:	2000      	movs	r0, #0
{
	RTC_TimeTypeDef RTC_TimeStructure;
	RTC_DateTypeDef RTC_DateStruct;

	RTC_DateStruct.RTC_WeekDay = RTCC_TimeDate.WeekDay;
	RTC_DateStruct.RTC_Month   = RTCC_TimeDate.Month;
 80021b8:	704a      	strb	r2, [r1, #1]
	RTC_DateStruct.RTC_Date    = RTCC_TimeDate.Date;
 80021ba:	708b      	strb	r3, [r1, #2]
	RTC_DateStruct.RTC_Year    = RTCC_TimeDate.Year;

	/* Configure the RTC time register */
	if(RTC_SetDate(RTC_Format_BIN, &RTC_DateStruct) == ERROR)
 80021bc:	f004 fc94 	bl	8006ae8 <RTC_SetDate>
	{
		// TODO - Tratar o retorno
		//printf("\n\r>> !! RTC Set Date failed. !! <<\n\r");
	}

	RTC_TimeStructure.RTC_H12     = RTC_H12_AM;
 80021c0:	2300      	movs	r3, #0
 80021c2:	a902      	add	r1, sp, #8
 80021c4:	70cb      	strb	r3, [r1, #3]
	RTC_TimeStructure.RTC_Hours   = RTCC_TimeDate.Hours;
 80021c6:	466b      	mov	r3, sp
 80021c8:	791b      	ldrb	r3, [r3, #4]
	RTC_TimeStructure.RTC_Minutes = RTCC_TimeDate.Minutes;
	RTC_TimeStructure.RTC_Seconds = RTCC_TimeDate.Seconds;

	/* Configure the RTC time register */
	if(RTC_SetTime(RTC_Format_BIN, &RTC_TimeStructure) == ERROR)
 80021ca:	2000      	movs	r0, #0
		// TODO - Tratar o retorno
		//printf("\n\r>> !! RTC Set Date failed. !! <<\n\r");
	}

	RTC_TimeStructure.RTC_H12     = RTC_H12_AM;
	RTC_TimeStructure.RTC_Hours   = RTCC_TimeDate.Hours;
 80021cc:	700b      	strb	r3, [r1, #0]
	RTC_TimeStructure.RTC_Minutes = RTCC_TimeDate.Minutes;
 80021ce:	466b      	mov	r3, sp
 80021d0:	795b      	ldrb	r3, [r3, #5]
 80021d2:	704b      	strb	r3, [r1, #1]
	RTC_TimeStructure.RTC_Seconds = RTCC_TimeDate.Seconds;
 80021d4:	466b      	mov	r3, sp
 80021d6:	799b      	ldrb	r3, [r3, #6]
 80021d8:	708b      	strb	r3, [r1, #2]

	/* Configure the RTC time register */
	if(RTC_SetTime(RTC_Format_BIN, &RTC_TimeStructure) == ERROR)
 80021da:	f004 fbdd 	bl	8006998 <RTC_SetTime>
	{
		// TODO - Tratar o retorno
		//printf("\n\r>> !! RTC Set Time failed. !! <<\n\r");
	}
}
 80021de:	b004      	add	sp, #16
 80021e0:	bd10      	pop	{r4, pc}
 80021e2:	46c0      	nop			; (mov r8, r8)

080021e4 <RTCC_GetTimeDate>:

//==================================================================================================
//
//==================================================================================================
void RTCC_GetTimeDate(RTCC_TimeDateTypeDef* RTCC_TimeDate)
{
 80021e4:	b530      	push	{r4, r5, lr}
 80021e6:	1c04      	adds	r4, r0, #0
 80021e8:	b083      	sub	sp, #12
	RTC_TimeTypeDef RTC_TimeStructure;
	RTC_DateTypeDef RTC_DateStruct;

	/* Get the current Time */
	RTC_GetTime(RTC_Format_BIN, &RTC_TimeStructure);
	RTC_GetDate(RTC_Format_BIN, &RTC_DateStruct);
 80021ea:	ad01      	add	r5, sp, #4
{
	RTC_TimeTypeDef RTC_TimeStructure;
	RTC_DateTypeDef RTC_DateStruct;

	/* Get the current Time */
	RTC_GetTime(RTC_Format_BIN, &RTC_TimeStructure);
 80021ec:	4669      	mov	r1, sp
 80021ee:	2000      	movs	r0, #0
 80021f0:	f004 fc48 	bl	8006a84 <RTC_GetTime>
	RTC_GetDate(RTC_Format_BIN, &RTC_DateStruct);
 80021f4:	2000      	movs	r0, #0
 80021f6:	1c29      	adds	r1, r5, #0
 80021f8:	f004 fce8 	bl	8006bcc <RTC_GetDate>

	RTCC_TimeDate->WeekDay = RTC_DateStruct.RTC_WeekDay;
 80021fc:	782b      	ldrb	r3, [r5, #0]
 80021fe:	7023      	strb	r3, [r4, #0]
	RTCC_TimeDate->Date    = RTC_DateStruct.RTC_Date;
 8002200:	78ab      	ldrb	r3, [r5, #2]
 8002202:	7063      	strb	r3, [r4, #1]
	RTCC_TimeDate->Month   = RTC_DateStruct.RTC_Month;
 8002204:	786b      	ldrb	r3, [r5, #1]
 8002206:	70a3      	strb	r3, [r4, #2]
	RTCC_TimeDate->Year    = RTC_DateStruct.RTC_Year;
 8002208:	78eb      	ldrb	r3, [r5, #3]
 800220a:	70e3      	strb	r3, [r4, #3]

	RTCC_TimeDate->Hours   = RTC_TimeStructure.RTC_Hours;
 800220c:	466b      	mov	r3, sp
 800220e:	781b      	ldrb	r3, [r3, #0]
 8002210:	7123      	strb	r3, [r4, #4]
	RTCC_TimeDate->Minutes = RTC_TimeStructure.RTC_Minutes;
 8002212:	466b      	mov	r3, sp
 8002214:	785b      	ldrb	r3, [r3, #1]
 8002216:	7163      	strb	r3, [r4, #5]
	RTCC_TimeDate->Seconds = RTC_TimeStructure.RTC_Seconds;
 8002218:	466b      	mov	r3, sp
 800221a:	789b      	ldrb	r3, [r3, #2]
 800221c:	71a3      	strb	r3, [r4, #6]
}
 800221e:	b003      	add	sp, #12
 8002220:	bd30      	pop	{r4, r5, pc}
 8002222:	46c0      	nop			; (mov r8, r8)

08002224 <RTCC_SecondsCounter>:

void RTCC_SecondsCounter(void)
{

}
 8002224:	4770      	bx	lr
 8002226:	46c0      	nop			; (mov r8, r8)

08002228 <EE_VerifyPageFullWriteVariable>:
*           - PAGE_FULL: if valid page is full
*           - NO_VALID_PAGE: if no valid page was found
*           - Flash error code: on write Flash error
*/
static uint16_t EE_VerifyPageFullWriteVariable(uint16_t VirtAddress, uint16_t Data)
{
 8002228:	b538      	push	{r3, r4, r5, lr}

	/* Get Page0 actual status */
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);// PAGE0_BASE_ADDRESS = 0x0800F800 + 0x0000

	/* Get Page1 actual status */
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);// PAGE1_BASE_ADDRESS = 0x0800F800 + 0x0400
 800222a:	4a1c      	ldr	r2, [pc, #112]	; (800229c <EE_VerifyPageFullWriteVariable+0x74>)
static uint16_t EE_FindValidPage(uint8_t Operation)
{
	uint16_t PageStatus0 = 6, PageStatus1 = 6;

	/* Get Page0 actual status */
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);// PAGE0_BASE_ADDRESS = 0x0800F800 + 0x0000
 800222c:	4b1c      	ldr	r3, [pc, #112]	; (80022a0 <EE_VerifyPageFullWriteVariable+0x78>)
*           - PAGE_FULL: if valid page is full
*           - NO_VALID_PAGE: if no valid page was found
*           - Flash error code: on write Flash error
*/
static uint16_t EE_VerifyPageFullWriteVariable(uint16_t VirtAddress, uint16_t Data)
{
 800222e:	1c05      	adds	r5, r0, #0
static uint16_t EE_FindValidPage(uint8_t Operation)
{
	uint16_t PageStatus0 = 6, PageStatus1 = 6;

	/* Get Page0 actual status */
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);// PAGE0_BASE_ADDRESS = 0x0800F800 + 0x0000
 8002230:	881b      	ldrh	r3, [r3, #0]

	/* Get Page1 actual status */
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);// PAGE1_BASE_ADDRESS = 0x0800F800 + 0x0400
 8002232:	8812      	ldrh	r2, [r2, #0]
static uint16_t EE_FindValidPage(uint8_t Operation)
{
	uint16_t PageStatus0 = 6, PageStatus1 = 6;

	/* Get Page0 actual status */
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);// PAGE0_BASE_ADDRESS = 0x0800F800 + 0x0000
 8002234:	b29b      	uxth	r3, r3

	/* Get Page1 actual status */
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);// PAGE1_BASE_ADDRESS = 0x0800F800 + 0x0400
 8002236:	b292      	uxth	r2, r2
	/* Write or read operation */
	switch(Operation)
	{
	case WRITE_IN_VALID_PAGE:   /* ---- Write operation ---- */
		 //WRITE_IN_VALID_PAGE = 1
		if(PageStatus1 == VALID_PAGE)// VALID_PAGE = 0
 8002238:	2a00      	cmp	r2, #0
 800223a:	d11d      	bne.n	8002278 <EE_VerifyPageFullWriteVariable+0x50>
		{
			/* Page0 receiving data */
			if(PageStatus0 == RECEIVE_DATA)// RECEIVE_DATA = 0xEEEE
 800223c:	4a19      	ldr	r2, [pc, #100]	; (80022a4 <EE_VerifyPageFullWriteVariable+0x7c>)
 800223e:	4694      	mov	ip, r2
 8002240:	4463      	add	r3, ip
 8002242:	1e5a      	subs	r2, r3, #1
 8002244:	4193      	sbcs	r3, r2
		else if(PageStatus0 == VALID_PAGE)// VALID_PAGE = 0
		{
			/* Page1 receiving data */
			if (PageStatus1 == RECEIVE_DATA)// RECEIVE_DATA = 0xEEEE
			{
				return PAGE1;         /* Page1 valid */
 8002246:	b29b      	uxth	r3, r3
	{
		return  NO_VALID_PAGE;
	}

	/* Get the valid Page start Address */
	Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 8002248:	4a17      	ldr	r2, [pc, #92]	; (80022a8 <EE_VerifyPageFullWriteVariable+0x80>)
 800224a:	189c      	adds	r4, r3, r2

	/* Get the valid Page end Address */
	PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * PAGE_SIZE));
 800224c:	4a17      	ldr	r2, [pc, #92]	; (80022ac <EE_VerifyPageFullWriteVariable+0x84>)
 800224e:	3301      	adds	r3, #1
 8002250:	4694      	mov	ip, r2
 8002252:	029b      	lsls	r3, r3, #10
 8002254:	4463      	add	r3, ip
	{
		return  NO_VALID_PAGE;
	}

	/* Get the valid Page start Address */
	Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 8002256:	02a4      	lsls	r4, r4, #10

	/* Get the valid Page end Address */
	PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * PAGE_SIZE));

	/* Check each active page address starting from begining */
	while (Address < PageEndAddress)
 8002258:	429c      	cmp	r4, r3
 800225a:	d303      	bcc.n	8002264 <EE_VerifyPageFullWriteVariable+0x3c>
 800225c:	e015      	b.n	800228a <EE_VerifyPageFullWriteVariable+0x62>
			return FlashStatus;
		}
		else
		{
			/* Next address location */
			Address = Address + 4;
 800225e:	3404      	adds	r4, #4

	/* Get the valid Page end Address */
	PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * PAGE_SIZE));

	/* Check each active page address starting from begining */
	while (Address < PageEndAddress)
 8002260:	42a3      	cmp	r3, r4
 8002262:	d912      	bls.n	800228a <EE_VerifyPageFullWriteVariable+0x62>
	{
		/* Verify if Address and Address+2 contents are 0xFFFFFFFF */
		if ((*(__IO uint32_t*)Address) == 0xFFFFFFFF)
 8002264:	6822      	ldr	r2, [r4, #0]
 8002266:	3201      	adds	r2, #1
 8002268:	d1f9      	bne.n	800225e <EE_VerifyPageFullWriteVariable+0x36>
		{
			/* Set variable data */
			FlashStatus = FLASH_ProgramHalfWord(Address, Data);
 800226a:	1c20      	adds	r0, r4, #0
 800226c:	f003 fb98 	bl	80059a0 <FLASH_ProgramHalfWord>
			/* If program operation was failed, a Flash error code is returned */
			if (FlashStatus != FLASH_COMPLETE)
 8002270:	2804      	cmp	r0, #4
 8002272:	d00c      	beq.n	800228e <EE_VerifyPageFullWriteVariable+0x66>
				return FlashStatus;
			}
			/* Set variable virtual address */
			FlashStatus = FLASH_ProgramHalfWord(Address + 2, VirtAddress);
			/* Return program operation status */
			return FlashStatus;
 8002274:	b280      	uxth	r0, r0
		}
	}

	/* Return PAGE_FULL in case the valid page is full */
	return PAGE_FULL;
}
 8002276:	bd38      	pop	{r3, r4, r5, pc}
	ValidPage = EE_FindValidPage(WRITE_IN_VALID_PAGE);

	/* Check if there is no valid page */
	if (ValidPage == NO_VALID_PAGE)
	{
		return  NO_VALID_PAGE;
 8002278:	20ab      	movs	r0, #171	; 0xab
			else
			{
				return PAGE1;         /* Page1 valid */
			}
		}
		else if(PageStatus0 == VALID_PAGE)// VALID_PAGE = 0
 800227a:	2b00      	cmp	r3, #0
 800227c:	d1fb      	bne.n	8002276 <EE_VerifyPageFullWriteVariable+0x4e>
		{
			/* Page1 receiving data */
			if (PageStatus1 == RECEIVE_DATA)// RECEIVE_DATA = 0xEEEE
 800227e:	4b09      	ldr	r3, [pc, #36]	; (80022a4 <EE_VerifyPageFullWriteVariable+0x7c>)
 8002280:	18d3      	adds	r3, r2, r3
 8002282:	425a      	negs	r2, r3
 8002284:	4153      	adcs	r3, r2
			{
				return PAGE1;         /* Page1 valid */
 8002286:	b29b      	uxth	r3, r3
 8002288:	e7de      	b.n	8002248 <EE_VerifyPageFullWriteVariable+0x20>
			Address = Address + 4;
		}
	}

	/* Return PAGE_FULL in case the valid page is full */
	return PAGE_FULL;
 800228a:	2080      	movs	r0, #128	; 0x80
 800228c:	e7f3      	b.n	8002276 <EE_VerifyPageFullWriteVariable+0x4e>
			if (FlashStatus != FLASH_COMPLETE)
			{
				return FlashStatus;
			}
			/* Set variable virtual address */
			FlashStatus = FLASH_ProgramHalfWord(Address + 2, VirtAddress);
 800228e:	1ca0      	adds	r0, r4, #2
 8002290:	1c29      	adds	r1, r5, #0
 8002292:	f003 fb85 	bl	80059a0 <FLASH_ProgramHalfWord>
			/* Return program operation status */
			return FlashStatus;
 8002296:	b280      	uxth	r0, r0
 8002298:	e7ed      	b.n	8002276 <EE_VerifyPageFullWriteVariable+0x4e>
 800229a:	46c0      	nop			; (mov r8, r8)
 800229c:	0800fc00 	.word	0x0800fc00
 80022a0:	0800f800 	.word	0x0800f800
 80022a4:	ffff1112 	.word	0xffff1112
 80022a8:	0002003e 	.word	0x0002003e
 80022ac:	0800f7fe 	.word	0x0800f7fe

080022b0 <EE_Format>:
* @param  None
* @retval Status of the last operation (Flash write or erase) done during
*         EEPROM formating
*/
static FLASH_Status EE_Format(void)
{
 80022b0:	b508      	push	{r3, lr}
	FLASH_Status FlashStatus = FLASH_COMPLETE;

	/* Erase Page0 */
	FlashStatus = FLASH_ErasePage(PAGE0_BASE_ADDRESS);
 80022b2:	4808      	ldr	r0, [pc, #32]	; (80022d4 <EE_Format+0x24>)
 80022b4:	f003 fb0c 	bl	80058d0 <FLASH_ErasePage>

	/* If erase operation was failed, a Flash error code is returned */
	if (FlashStatus != FLASH_COMPLETE)
 80022b8:	2804      	cmp	r0, #4
 80022ba:	d000      	beq.n	80022be <EE_Format+0xe>
	/* Erase Page1 */
	FlashStatus = FLASH_ErasePage(PAGE1_BASE_ADDRESS);

	/* Return Page1 erase operation status */
	return FlashStatus;
}
 80022bc:	bd08      	pop	{r3, pc}
	{
		return FlashStatus;
	}

	/* Set Page0 as valid page: Write VALID_PAGE at Page0 base address */
	FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
 80022be:	4805      	ldr	r0, [pc, #20]	; (80022d4 <EE_Format+0x24>)
 80022c0:	2100      	movs	r1, #0
 80022c2:	f003 fb6d 	bl	80059a0 <FLASH_ProgramHalfWord>

	/* If program operation was failed, a Flash error code is returned */
	if (FlashStatus != FLASH_COMPLETE)
 80022c6:	2804      	cmp	r0, #4
 80022c8:	d1f8      	bne.n	80022bc <EE_Format+0xc>
	{
		return FlashStatus;
	}

	/* Erase Page1 */
	FlashStatus = FLASH_ErasePage(PAGE1_BASE_ADDRESS);
 80022ca:	4803      	ldr	r0, [pc, #12]	; (80022d8 <EE_Format+0x28>)
 80022cc:	f003 fb00 	bl	80058d0 <FLASH_ErasePage>
 80022d0:	e7f4      	b.n	80022bc <EE_Format+0xc>
 80022d2:	46c0      	nop			; (mov r8, r8)
 80022d4:	0800f800 	.word	0x0800f800
 80022d8:	0800fc00 	.word	0x0800fc00

080022dc <EE_ReadVariable>:
static uint16_t EE_FindValidPage(uint8_t Operation)
{
	uint16_t PageStatus0 = 6, PageStatus1 = 6;

	/* Get Page0 actual status */
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);// PAGE0_BASE_ADDRESS = 0x0800F800 + 0x0000
 80022dc:	4b11      	ldr	r3, [pc, #68]	; (8002324 <EE_ReadVariable+0x48>)
*           - 0: if variable was found
*           - 1: if the variable was not found
*           - NO_VALID_PAGE: if no valid page was found.
*/
uint16_t EE_ReadVariable(uint16_t VirtAddress, uint16_t* Data)
{
 80022de:	b510      	push	{r4, lr}
static uint16_t EE_FindValidPage(uint8_t Operation)
{
	uint16_t PageStatus0 = 6, PageStatus1 = 6;

	/* Get Page0 actual status */
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);// PAGE0_BASE_ADDRESS = 0x0800F800 + 0x0000
 80022e0:	881a      	ldrh	r2, [r3, #0]

	/* Get Page1 actual status */
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);// PAGE1_BASE_ADDRESS = 0x0800F800 + 0x0400
 80022e2:	4b11      	ldr	r3, [pc, #68]	; (8002328 <EE_ReadVariable+0x4c>)
 80022e4:	881b      	ldrh	r3, [r3, #0]
 80022e6:	b29b      	uxth	r3, r3
			// NO_VALID_PAGE = 0x00AB = 171
		}

	case READ_FROM_VALID_PAGE:  /* ---- Read operation ---- */
		 // READ_FROM_VALID_PAGE = 0
		if (PageStatus0 == VALID_PAGE)// VALID_PAGE = 0
 80022e8:	2a00      	cmp	r2, #0
 80022ea:	d012      	beq.n	8002312 <EE_ReadVariable+0x36>
		{
			return PAGE0;           /* Page0 valid */
		}
		else if (PageStatus1 == VALID_PAGE)// VALID_PAGE = 0
 80022ec:	2b00      	cmp	r3, #0
 80022ee:	d001      	beq.n	80022f4 <EE_ReadVariable+0x18>
	ValidPage = EE_FindValidPage(READ_FROM_VALID_PAGE); // READ_FROM_VALID_PAGE = 0

	/* Check if there is no valid page */
	if (ValidPage == NO_VALID_PAGE) // NO_VALID_PAGE = 0x00AB == 171
	{
		return  NO_VALID_PAGE;
 80022f0:	20ab      	movs	r0, #171	; 0xab
		}
	}

	/* Return ReadStatus value: (0: variable exist, 1: variable doesn't exist) */
	return ReadStatus;
}
 80022f2:	bd10      	pop	{r4, pc}
		 // READ_FROM_VALID_PAGE = 0
		if (PageStatus0 == VALID_PAGE)// VALID_PAGE = 0
		{
			return PAGE0;           /* Page0 valid */
		}
		else if (PageStatus1 == VALID_PAGE)// VALID_PAGE = 0
 80022f4:	4b0d      	ldr	r3, [pc, #52]	; (800232c <EE_ReadVariable+0x50>)
 80022f6:	4c0e      	ldr	r4, [pc, #56]	; (8002330 <EE_ReadVariable+0x54>)
 80022f8:	1c1a      	adds	r2, r3, #0

	/* Check each active page address starting from end */
	while (Address > (PageStartAddress + 2))
	{
		/* Get the current location content to be compared with virtual address */
		AddressValue = (*(__IO uint16_t*)Address);
 80022fa:	8812      	ldrh	r2, [r2, #0]

		/* Compare the read address with the virtual address */
		if (AddressValue == VirtAddress)
 80022fc:	4282      	cmp	r2, r0
 80022fe:	d103      	bne.n	8002308 <EE_ReadVariable+0x2c>
 8002300:	e00b      	b.n	800231a <EE_ReadVariable+0x3e>

	/* Check each active page address starting from end */
	while (Address > (PageStartAddress + 2))
	{
		/* Get the current location content to be compared with virtual address */
		AddressValue = (*(__IO uint16_t*)Address);
 8002302:	881a      	ldrh	r2, [r3, #0]

		/* Compare the read address with the virtual address */
		if (AddressValue == VirtAddress)
 8002304:	4282      	cmp	r2, r0
 8002306:	d008      	beq.n	800231a <EE_ReadVariable+0x3e>
			break;
		}
		else
		{
			/* Next address location */
			Address = Address - 4;
 8002308:	3b04      	subs	r3, #4
	/* Get the valid Page end Address */
	Address = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * PAGE_SIZE)); //PAGE_SIZE = 0x0400, Page size = 1KByte
		// Address = (0x0800F800 - 2) + [(ValidPage + 1) * 0x400]

	/* Check each active page address starting from end */
	while (Address > (PageStartAddress + 2))
 800230a:	429c      	cmp	r4, r3
 800230c:	d3f9      	bcc.n	8002302 <EE_ReadVariable+0x26>
*/
uint16_t EE_ReadVariable(uint16_t VirtAddress, uint16_t* Data)
{
	uint16_t ValidPage 	  = PAGE0; // PAGE0 = 0
	uint16_t AddressValue = 0x5555;
	uint16_t ReadStatus   = 1;
 800230e:	2001      	movs	r0, #1
 8002310:	e7ef      	b.n	80022f2 <EE_ReadVariable+0x16>
			// NO_VALID_PAGE = 0x00AB = 171
		}

	case READ_FROM_VALID_PAGE:  /* ---- Read operation ---- */
		 // READ_FROM_VALID_PAGE = 0
		if (PageStatus0 == VALID_PAGE)// VALID_PAGE = 0
 8002312:	4b08      	ldr	r3, [pc, #32]	; (8002334 <EE_ReadVariable+0x58>)
 8002314:	4c08      	ldr	r4, [pc, #32]	; (8002338 <EE_ReadVariable+0x5c>)
 8002316:	1c1a      	adds	r2, r3, #0
 8002318:	e7ef      	b.n	80022fa <EE_ReadVariable+0x1e>

		/* Compare the read address with the virtual address */
		if (AddressValue == VirtAddress)
		{
			/* Get content of Address-2 which is variable value */
			*Data = (*(__IO uint16_t*)(Address - 2));
 800231a:	3b02      	subs	r3, #2
 800231c:	881b      	ldrh	r3, [r3, #0]

			/* In case variable value is read, reset ReadStatus flag */
			ReadStatus = 0;
 800231e:	2000      	movs	r0, #0

		/* Compare the read address with the virtual address */
		if (AddressValue == VirtAddress)
		{
			/* Get content of Address-2 which is variable value */
			*Data = (*(__IO uint16_t*)(Address - 2));
 8002320:	800b      	strh	r3, [r1, #0]

			/* In case variable value is read, reset ReadStatus flag */
			ReadStatus = 0;

			break;
 8002322:	e7e6      	b.n	80022f2 <EE_ReadVariable+0x16>
 8002324:	0800f800 	.word	0x0800f800
 8002328:	0800fc00 	.word	0x0800fc00
 800232c:	0800fffe 	.word	0x0800fffe
 8002330:	0800fc02 	.word	0x0800fc02
 8002334:	0800fbfe 	.word	0x0800fbfe
 8002338:	0800f802 	.word	0x0800f802

0800233c <EE_Init>:
* @param  None.
* @retval - Flash error code: on write Flash error
*         - FLASH_COMPLETE: on success
*/
uint16_t EE_Init(void)
{
 800233c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800233e:	4647      	mov	r7, r8
	uint16_t EepromStatus = 0, ReadStatus = 0;
	int16_t x = -1;
	uint16_t  FlashStatus;

	/* Get Page0 status */
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8002340:	4c4e      	ldr	r4, [pc, #312]	; (800247c <EE_Init+0x140>)
	/* Get Page1 status */
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8002342:	4d4f      	ldr	r5, [pc, #316]	; (8002480 <EE_Init+0x144>)
	uint16_t EepromStatus = 0, ReadStatus = 0;
	int16_t x = -1;
	uint16_t  FlashStatus;

	/* Get Page0 status */
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8002344:	8823      	ldrh	r3, [r4, #0]
	/* Get Page1 status */
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);

	/* Check for invalid header states and repair if necessary */
	switch (PageStatus0)
 8002346:	494f      	ldr	r1, [pc, #316]	; (8002484 <EE_Init+0x148>)
	uint16_t  FlashStatus;

	/* Get Page0 status */
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
	/* Get Page1 status */
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8002348:	882a      	ldrh	r2, [r5, #0]
	uint16_t EepromStatus = 0, ReadStatus = 0;
	int16_t x = -1;
	uint16_t  FlashStatus;

	/* Get Page0 status */
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 800234a:	b29b      	uxth	r3, r3
* @param  None.
* @retval - Flash error code: on write Flash error
*         - FLASH_COMPLETE: on success
*/
uint16_t EE_Init(void)
{
 800234c:	b480      	push	{r7}
	uint16_t  FlashStatus;

	/* Get Page0 status */
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
	/* Get Page1 status */
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 800234e:	b292      	uxth	r2, r2

	/* Check for invalid header states and repair if necessary */
	switch (PageStatus0)
 8002350:	428b      	cmp	r3, r1
 8002352:	d048      	beq.n	80023e6 <EE_Init+0xaa>
 8002354:	484c      	ldr	r0, [pc, #304]	; (8002488 <EE_Init+0x14c>)
 8002356:	4283      	cmp	r3, r0
 8002358:	d035      	beq.n	80023c6 <EE_Init+0x8a>
 800235a:	2b00      	cmp	r3, #0
 800235c:	d005      	beq.n	800236a <EE_Init+0x2e>
			}
		break;

		default:  /* Any other state -> format eeprom */
			/* Erase both Page0 and Page1 and set Page0 as valid page */
			FlashStatus = EE_Format();
 800235e:	f7ff ffa7 	bl	80022b0 <EE_Format>
 8002362:	b280      	uxth	r0, r0
			}
		break;
	}

	return FLASH_COMPLETE;
}// uint16_t EE_Init(void)
 8002364:	bc04      	pop	{r2}
 8002366:	4690      	mov	r8, r2
 8002368:	bdf0      	pop	{r4, r5, r6, r7, pc}
				}
			}
		break;

		case VALID_PAGE:
			if (PageStatus1 == VALID_PAGE) /* Invalid state -> format eeprom */
 800236a:	2a00      	cmp	r2, #0
 800236c:	d0f7      	beq.n	800235e <EE_Init+0x22>
				if (FlashStatus != FLASH_COMPLETE)
				{
					return FlashStatus;
				}
			}
			else if (PageStatus1 == ERASED) /* Page0 valid, Page1 erased */
 800236e:	4282      	cmp	r2, r0
 8002370:	d100      	bne.n	8002374 <EE_Init+0x38>
 8002372:	e07e      	b.n	8002472 <EE_Init+0x136>
						x = VarIdx;
					}
					if (VarIdx != x)
					{
						/* Read the last variables' updates */
						ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 8002374:	4b45      	ldr	r3, [pc, #276]	; (800248c <EE_Init+0x150>)
				if (FlashStatus != FLASH_COMPLETE)
				{
					return FlashStatus;
				}
			}
			else if (PageStatus1 == ERASED) /* Page0 valid, Page1 erased */
 8002376:	2500      	movs	r5, #0
 8002378:	1c04      	adds	r4, r0, #0
						x = VarIdx;
					}
					if (VarIdx != x)
					{
						/* Read the last variables' updates */
						ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 800237a:	4698      	mov	r8, r3
 800237c:	4e44      	ldr	r6, [pc, #272]	; (8002490 <EE_Init+0x154>)
			else /* Page0 valid, Page1 receive */
			{
				/* Transfer data from Page0 to Page1 */
				for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
				{
					if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 800237e:	4f45      	ldr	r7, [pc, #276]	; (8002494 <EE_Init+0x158>)
 8002380:	883b      	ldrh	r3, [r7, #0]
 8002382:	8830      	ldrh	r0, [r6, #0]
 8002384:	4283      	cmp	r3, r0
 8002386:	d070      	beq.n	800246a <EE_Init+0x12e>
					{
						x = VarIdx;
					}
					if (VarIdx != x)
 8002388:	b223      	sxth	r3, r4
 800238a:	429d      	cmp	r5, r3
 800238c:	d00b      	beq.n	80023a6 <EE_Init+0x6a>
					{
						/* Read the last variables' updates */
						ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 800238e:	4641      	mov	r1, r8
 8002390:	f7ff ffa4 	bl	80022dc <EE_ReadVariable>
						/* In case variable corresponding to the virtual address was found */
						if (ReadStatus != 0x1)
 8002394:	2801      	cmp	r0, #1
 8002396:	d006      	beq.n	80023a6 <EE_Init+0x6a>
						{
							/* Transfer the variable to the Page1 */
							EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
 8002398:	4643      	mov	r3, r8
 800239a:	8830      	ldrh	r0, [r6, #0]
 800239c:	8819      	ldrh	r1, [r3, #0]
 800239e:	f7ff ff43 	bl	8002228 <EE_VerifyPageFullWriteVariable>
							/* If program operation was failed, a Flash error code is returned */
							if (EepromStatus != FLASH_COMPLETE)
 80023a2:	2804      	cmp	r0, #4
 80023a4:	d1de      	bne.n	8002364 <EE_Init+0x28>
 80023a6:	3501      	adds	r5, #1
 80023a8:	3602      	adds	r6, #2
				}
			}
			else /* Page0 valid, Page1 receive */
			{
				/* Transfer data from Page0 to Page1 */
				for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 80023aa:	2d03      	cmp	r5, #3
 80023ac:	d1e8      	bne.n	8002380 <EE_Init+0x44>
							}
						}
					}
				}
				/* Mark Page1 as valid */
				FlashStatus = FLASH_ProgramHalfWord(PAGE1_BASE_ADDRESS, VALID_PAGE);
 80023ae:	4834      	ldr	r0, [pc, #208]	; (8002480 <EE_Init+0x144>)
 80023b0:	2100      	movs	r1, #0
 80023b2:	f003 faf5 	bl	80059a0 <FLASH_ProgramHalfWord>
 80023b6:	b280      	uxth	r0, r0
				/* If program operation was failed, a Flash error code is returned */
				if (FlashStatus != FLASH_COMPLETE)
 80023b8:	2804      	cmp	r0, #4
 80023ba:	d1d3      	bne.n	8002364 <EE_Init+0x28>
				{
					return FlashStatus;
				}
				/* Erase Page0 */
				FlashStatus = FLASH_ErasePage(PAGE0_BASE_ADDRESS);
 80023bc:	482f      	ldr	r0, [pc, #188]	; (800247c <EE_Init+0x140>)
 80023be:	f003 fa87 	bl	80058d0 <FLASH_ErasePage>
 80023c2:	b280      	uxth	r0, r0
 80023c4:	e7ce      	b.n	8002364 <EE_Init+0x28>

	/* Check for invalid header states and repair if necessary */
	switch (PageStatus0)
	{
		case ERASED:
			if (PageStatus1 == VALID_PAGE) /* Page0 erased, Page1 valid */
 80023c6:	2a00      	cmp	r2, #0
 80023c8:	d04a      	beq.n	8002460 <EE_Init+0x124>
				if (FlashStatus != FLASH_COMPLETE)
				{
					return FlashStatus;
				}
			}
			else if (PageStatus1 == RECEIVE_DATA) /* Page0 erased, Page1 receive */
 80023ca:	428a      	cmp	r2, r1
 80023cc:	d1c7      	bne.n	800235e <EE_Init+0x22>
			{
				/* Erase Page0 */
				FlashStatus = FLASH_ErasePage(PAGE0_BASE_ADDRESS);
 80023ce:	1c20      	adds	r0, r4, #0
 80023d0:	f003 fa7e 	bl	80058d0 <FLASH_ErasePage>
 80023d4:	b280      	uxth	r0, r0
				/* If erase operation was failed, a Flash error code is returned */
				if (FlashStatus != FLASH_COMPLETE)
 80023d6:	2804      	cmp	r0, #4
 80023d8:	d1c4      	bne.n	8002364 <EE_Init+0x28>
				{
					return FlashStatus;
				}
				/* Mark Page1 as valid */
				FlashStatus = FLASH_ProgramHalfWord(PAGE1_BASE_ADDRESS, VALID_PAGE);
 80023da:	1c28      	adds	r0, r5, #0
 80023dc:	2100      	movs	r1, #0
 80023de:	f003 fadf 	bl	80059a0 <FLASH_ProgramHalfWord>
 80023e2:	b280      	uxth	r0, r0
 80023e4:	e7be      	b.n	8002364 <EE_Init+0x28>
				}
			}
		break;

		case RECEIVE_DATA:
			if (PageStatus1 == VALID_PAGE) /* Page0 receive, Page1 valid */
 80023e6:	2a00      	cmp	r2, #0
 80023e8:	d129      	bne.n	800243e <EE_Init+0x102>
						x = VarIdx;
					}
					if (VarIdx != x)
					{
						/* Read the last variables' updates */
						ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 80023ea:	4b28      	ldr	r3, [pc, #160]	; (800248c <EE_Init+0x150>)
				}
			}
		break;

		case RECEIVE_DATA:
			if (PageStatus1 == VALID_PAGE) /* Page0 receive, Page1 valid */
 80023ec:	2400      	movs	r4, #0
						x = VarIdx;
					}
					if (VarIdx != x)
					{
						/* Read the last variables' updates */
						ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 80023ee:	4698      	mov	r8, r3
 80023f0:	4d27      	ldr	r5, [pc, #156]	; (8002490 <EE_Init+0x154>)
				}
			}
		break;

		case RECEIVE_DATA:
			if (PageStatus1 == VALID_PAGE) /* Page0 receive, Page1 valid */
 80023f2:	4e25      	ldr	r6, [pc, #148]	; (8002488 <EE_Init+0x14c>)
			{
				/* Transfer data from Page1 to Page0 */
				for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
				{
					if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 80023f4:	4f28      	ldr	r7, [pc, #160]	; (8002498 <EE_Init+0x15c>)
 80023f6:	883b      	ldrh	r3, [r7, #0]
 80023f8:	8828      	ldrh	r0, [r5, #0]
 80023fa:	4283      	cmp	r3, r0
 80023fc:	d037      	beq.n	800246e <EE_Init+0x132>
					{
						x = VarIdx;
					}
					if (VarIdx != x)
 80023fe:	b233      	sxth	r3, r6
 8002400:	429c      	cmp	r4, r3
 8002402:	d00b      	beq.n	800241c <EE_Init+0xe0>
					{
						/* Read the last variables' updates */
						ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 8002404:	4641      	mov	r1, r8
 8002406:	f7ff ff69 	bl	80022dc <EE_ReadVariable>
						/* In case variable corresponding to the virtual address was found */
						if (ReadStatus != 0x1)
 800240a:	2801      	cmp	r0, #1
 800240c:	d006      	beq.n	800241c <EE_Init+0xe0>
						{
							/* Transfer the variable to the Page0 */
							EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
 800240e:	4643      	mov	r3, r8
 8002410:	8828      	ldrh	r0, [r5, #0]
 8002412:	8819      	ldrh	r1, [r3, #0]
 8002414:	f7ff ff08 	bl	8002228 <EE_VerifyPageFullWriteVariable>
							/* If program operation was failed, a Flash error code is returned */
							if (EepromStatus != FLASH_COMPLETE)
 8002418:	2804      	cmp	r0, #4
 800241a:	d1a3      	bne.n	8002364 <EE_Init+0x28>
 800241c:	3401      	adds	r4, #1
 800241e:	3502      	adds	r5, #2

		case RECEIVE_DATA:
			if (PageStatus1 == VALID_PAGE) /* Page0 receive, Page1 valid */
			{
				/* Transfer data from Page1 to Page0 */
				for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 8002420:	2c03      	cmp	r4, #3
 8002422:	d1e8      	bne.n	80023f6 <EE_Init+0xba>
							}
						}
					}
				}
				/* Mark Page0 as valid */
				FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
 8002424:	4815      	ldr	r0, [pc, #84]	; (800247c <EE_Init+0x140>)
 8002426:	2100      	movs	r1, #0
 8002428:	f003 faba 	bl	80059a0 <FLASH_ProgramHalfWord>
 800242c:	b280      	uxth	r0, r0
				/* If program operation was failed, a Flash error code is returned */
				if (FlashStatus != FLASH_COMPLETE)
 800242e:	2804      	cmp	r0, #4
 8002430:	d000      	beq.n	8002434 <EE_Init+0xf8>
 8002432:	e797      	b.n	8002364 <EE_Init+0x28>
				{
					return FlashStatus;
				}
				/* Erase Page1 */
				FlashStatus = FLASH_ErasePage(PAGE1_BASE_ADDRESS);
 8002434:	4812      	ldr	r0, [pc, #72]	; (8002480 <EE_Init+0x144>)
 8002436:	f003 fa4b 	bl	80058d0 <FLASH_ErasePage>
 800243a:	b280      	uxth	r0, r0
 800243c:	e792      	b.n	8002364 <EE_Init+0x28>
				if (FlashStatus != FLASH_COMPLETE)
				{
					return FlashStatus;
				}
			}
			else if (PageStatus1 == ERASED) /* Page0 receive, Page1 erased */
 800243e:	4b12      	ldr	r3, [pc, #72]	; (8002488 <EE_Init+0x14c>)
 8002440:	429a      	cmp	r2, r3
 8002442:	d000      	beq.n	8002446 <EE_Init+0x10a>
 8002444:	e78b      	b.n	800235e <EE_Init+0x22>
			{
				/* Erase Page1 */
				FlashStatus = FLASH_ErasePage(PAGE1_BASE_ADDRESS);
 8002446:	1c28      	adds	r0, r5, #0
 8002448:	f003 fa42 	bl	80058d0 <FLASH_ErasePage>
 800244c:	b280      	uxth	r0, r0
				/* If erase operation was failed, a Flash error code is returned */
				if (FlashStatus != FLASH_COMPLETE)
 800244e:	2804      	cmp	r0, #4
 8002450:	d000      	beq.n	8002454 <EE_Init+0x118>
 8002452:	e787      	b.n	8002364 <EE_Init+0x28>
				{
					return FlashStatus;
				}
				/* Mark Page0 as valid */
				FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
 8002454:	1c20      	adds	r0, r4, #0
 8002456:	2100      	movs	r1, #0
 8002458:	f003 faa2 	bl	80059a0 <FLASH_ProgramHalfWord>
 800245c:	b280      	uxth	r0, r0
 800245e:	e781      	b.n	8002364 <EE_Init+0x28>
	{
		case ERASED:
			if (PageStatus1 == VALID_PAGE) /* Page0 erased, Page1 valid */
			{
				/* Erase Page0 */
				FlashStatus = FLASH_ErasePage(PAGE0_BASE_ADDRESS);
 8002460:	1c20      	adds	r0, r4, #0
 8002462:	f003 fa35 	bl	80058d0 <FLASH_ErasePage>
 8002466:	b280      	uxth	r0, r0
 8002468:	e77c      	b.n	8002364 <EE_Init+0x28>
				/* Transfer data from Page0 to Page1 */
				for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
				{
					if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
					{
						x = VarIdx;
 800246a:	b2ac      	uxth	r4, r5
 800246c:	e78c      	b.n	8002388 <EE_Init+0x4c>
				/* Transfer data from Page1 to Page0 */
				for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
				{
					if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
					{
						x = VarIdx;
 800246e:	b2a6      	uxth	r6, r4
 8002470:	e7c5      	b.n	80023fe <EE_Init+0xc2>
				}
			}
			else if (PageStatus1 == ERASED) /* Page0 valid, Page1 erased */
			{
				/* Erase Page1 */
				FlashStatus = FLASH_ErasePage(PAGE1_BASE_ADDRESS);
 8002472:	1c28      	adds	r0, r5, #0
 8002474:	f003 fa2c 	bl	80058d0 <FLASH_ErasePage>
 8002478:	b280      	uxth	r0, r0
 800247a:	e773      	b.n	8002364 <EE_Init+0x28>
 800247c:	0800f800 	.word	0x0800f800
 8002480:	0800fc00 	.word	0x0800fc00
 8002484:	0000eeee 	.word	0x0000eeee
 8002488:	0000ffff 	.word	0x0000ffff
 800248c:	200001d4 	.word	0x200001d4
 8002490:	20000014 	.word	0x20000014
 8002494:	0800fc06 	.word	0x0800fc06
 8002498:	0800f806 	.word	0x0800f806

0800249c <EE_WriteVariable>:
*           - PAGE_FULL: if valid page is full
*           - NO_VALID_PAGE: if no valid page was found
*           - Flash error code: on write Flash error
*/
uint16_t EE_WriteVariable(uint16_t VirtAddress, uint16_t Data)
{
 800249c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800249e:	4656      	mov	r6, sl
 80024a0:	464d      	mov	r5, r9
 80024a2:	4644      	mov	r4, r8
 80024a4:	465f      	mov	r7, fp
 80024a6:	b4f0      	push	{r4, r5, r6, r7}
 80024a8:	1c05      	adds	r5, r0, #0
 80024aa:	1c0e      	adds	r6, r1, #0
	uint16_t Status = 0;

	/* Write the variable virtual address and value in the EEPROM */
	Status = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 80024ac:	f7ff febc 	bl	8002228 <EE_VerifyPageFullWriteVariable>
 80024b0:	1e04      	subs	r4, r0, #0

	/* In case the EEPROM active page is full */
	if (Status == PAGE_FULL)
 80024b2:	2c80      	cmp	r4, #128	; 0x80
 80024b4:	d006      	beq.n	80024c4 <EE_WriteVariable+0x28>
		Status = EE_PageTransfer(VirtAddress, Data);
	}

	/* Return last operation status */
	return Status;
}
 80024b6:	1c20      	adds	r0, r4, #0
 80024b8:	bc3c      	pop	{r2, r3, r4, r5}
 80024ba:	4690      	mov	r8, r2
 80024bc:	4699      	mov	r9, r3
 80024be:	46a2      	mov	sl, r4
 80024c0:	46ab      	mov	fp, r5
 80024c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
static uint16_t EE_FindValidPage(uint8_t Operation)
{
	uint16_t PageStatus0 = 6, PageStatus1 = 6;

	/* Get Page0 actual status */
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);// PAGE0_BASE_ADDRESS = 0x0800F800 + 0x0000
 80024c4:	4f23      	ldr	r7, [pc, #140]	; (8002554 <EE_WriteVariable+0xb8>)

	/* Get Page1 actual status */
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);// PAGE1_BASE_ADDRESS = 0x0800F800 + 0x0400
 80024c6:	4824      	ldr	r0, [pc, #144]	; (8002558 <EE_WriteVariable+0xbc>)
static uint16_t EE_FindValidPage(uint8_t Operation)
{
	uint16_t PageStatus0 = 6, PageStatus1 = 6;

	/* Get Page0 actual status */
	PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);// PAGE0_BASE_ADDRESS = 0x0800F800 + 0x0000
 80024c8:	883a      	ldrh	r2, [r7, #0]

	/* Get Page1 actual status */
	PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);// PAGE1_BASE_ADDRESS = 0x0800F800 + 0x0400
 80024ca:	8803      	ldrh	r3, [r0, #0]
 80024cc:	b29b      	uxth	r3, r3
			// NO_VALID_PAGE = 0x00AB = 171
		}

	case READ_FROM_VALID_PAGE:  /* ---- Read operation ---- */
		 // READ_FROM_VALID_PAGE = 0
		if (PageStatus0 == VALID_PAGE)// VALID_PAGE = 0
 80024ce:	2a00      	cmp	r2, #0
 80024d0:	d00b      	beq.n	80024ea <EE_WriteVariable+0x4e>
		/* Old page address where variable will be taken from */
		OldPageAddress = PAGE0_BASE_ADDRESS;
	}
	else
	{
		return NO_VALID_PAGE;       /* No valid Page */
 80024d2:	342b      	adds	r4, #43	; 0x2b
	{
		/* New page address where variable will be moved to */
		NewPageAddress = PAGE0_BASE_ADDRESS;

		/* Old page address where variable will be taken from */
		OldPageAddress = PAGE1_BASE_ADDRESS;
 80024d4:	4680      	mov	r8, r0
		 // READ_FROM_VALID_PAGE = 0
		if (PageStatus0 == VALID_PAGE)// VALID_PAGE = 0
		{
			return PAGE0;           /* Page0 valid */
		}
		else if (PageStatus1 == VALID_PAGE)// VALID_PAGE = 0
 80024d6:	2b00      	cmp	r3, #0
 80024d8:	d1ed      	bne.n	80024b6 <EE_WriteVariable+0x1a>
	{
		return NO_VALID_PAGE;       /* No valid Page */
	}

	/* Set the new Page status to RECEIVE_DATA status */
	FlashStatus = FLASH_ProgramHalfWord(NewPageAddress, RECEIVE_DATA);
 80024da:	1c38      	adds	r0, r7, #0
 80024dc:	491f      	ldr	r1, [pc, #124]	; (800255c <EE_WriteVariable+0xc0>)
 80024de:	f003 fa5f 	bl	80059a0 <FLASH_ProgramHalfWord>
	/* If program operation was failed, a Flash error code is returned */
	if (FlashStatus != FLASH_COMPLETE)
 80024e2:	2804      	cmp	r0, #4
 80024e4:	d004      	beq.n	80024f0 <EE_WriteVariable+0x54>
	/* Set new Page status to VALID_PAGE status */
	FlashStatus = FLASH_ProgramHalfWord(NewPageAddress, VALID_PAGE);
	/* If program operation was failed, a Flash error code is returned */
	if (FlashStatus != FLASH_COMPLETE)
	{
		return FlashStatus;
 80024e6:	b284      	uxth	r4, r0
 80024e8:	e7e5      	b.n	80024b6 <EE_WriteVariable+0x1a>
	{
		/* New page address where variable will be moved to */
		NewPageAddress = PAGE1_BASE_ADDRESS;

		/* Old page address where variable will be taken from */
		OldPageAddress = PAGE0_BASE_ADDRESS;
 80024ea:	46b8      	mov	r8, r7
		OldPageAddress = PAGE1_BASE_ADDRESS;
	}
	else if (ValidPage == PAGE0)  /* Page0 valid */
	{
		/* New page address where variable will be moved to */
		NewPageAddress = PAGE1_BASE_ADDRESS;
 80024ec:	1c07      	adds	r7, r0, #0
 80024ee:	e7f4      	b.n	80024da <EE_WriteVariable+0x3e>
	{
		return FlashStatus;
	}

	/* Write the variable passed as parameter in the new active page */
	EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 80024f0:	1c28      	adds	r0, r5, #0
 80024f2:	1c31      	adds	r1, r6, #0
 80024f4:	f7ff fe98 	bl	8002228 <EE_VerifyPageFullWriteVariable>
 80024f8:	1e04      	subs	r4, r0, #0
	/* If program operation was failed, a Flash error code is returned */
	if (EepromStatus != FLASH_COMPLETE)
 80024fa:	2c04      	cmp	r4, #4
 80024fc:	d1db      	bne.n	80024b6 <EE_WriteVariable+0x1a>
 80024fe:	4b18      	ldr	r3, [pc, #96]	; (8002560 <EE_WriteVariable+0xc4>)
 8002500:	2600      	movs	r6, #0
 8002502:	469a      	mov	sl, r3
	for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
	{
		if (VirtAddVarTab[VarIdx] != VirtAddress)  /* Check each variable except the one passed as parameter */
		{
			/* Read the other last variable updates */
			ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 8002504:	4b17      	ldr	r3, [pc, #92]	; (8002564 <EE_WriteVariable+0xc8>)
 8002506:	469b      	mov	fp, r3
	}

	/* Transfer process: transfer variables from old to the new active page */
	for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
	{
		if (VirtAddVarTab[VarIdx] != VirtAddress)  /* Check each variable except the one passed as parameter */
 8002508:	46b1      	mov	r9, r6
 800250a:	44d1      	add	r9, sl
 800250c:	464b      	mov	r3, r9
 800250e:	8818      	ldrh	r0, [r3, #0]
 8002510:	4285      	cmp	r5, r0
 8002512:	d00c      	beq.n	800252e <EE_WriteVariable+0x92>
		{
			/* Read the other last variable updates */
			ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
 8002514:	4659      	mov	r1, fp
 8002516:	f7ff fee1 	bl	80022dc <EE_ReadVariable>
			/* In case variable corresponding to the virtual address was found */
			if (ReadStatus != 0x1)
 800251a:	2801      	cmp	r0, #1
 800251c:	d007      	beq.n	800252e <EE_WriteVariable+0x92>
			{
				/* Transfer the variable to the new active page */
				EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
 800251e:	464b      	mov	r3, r9
 8002520:	8818      	ldrh	r0, [r3, #0]
 8002522:	465b      	mov	r3, fp
 8002524:	8819      	ldrh	r1, [r3, #0]
 8002526:	f7ff fe7f 	bl	8002228 <EE_VerifyPageFullWriteVariable>
				/* If program operation was failed, a Flash error code is returned */
				if (EepromStatus != FLASH_COMPLETE)
 800252a:	2804      	cmp	r0, #4
 800252c:	d10f      	bne.n	800254e <EE_WriteVariable+0xb2>
 800252e:	3602      	adds	r6, #2
	{
		return EepromStatus;
	}

	/* Transfer process: transfer variables from old to the new active page */
	for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 8002530:	2e06      	cmp	r6, #6
 8002532:	d1e9      	bne.n	8002508 <EE_WriteVariable+0x6c>
			}
		}
	}

	/* Erase the old Page: Set old Page status to ERASED status */
	FlashStatus = FLASH_ErasePage(OldPageAddress);
 8002534:	4640      	mov	r0, r8
 8002536:	f003 f9cb 	bl	80058d0 <FLASH_ErasePage>
	/* If erase operation was failed, a Flash error code is returned */
	if (FlashStatus != FLASH_COMPLETE)
 800253a:	2804      	cmp	r0, #4
 800253c:	d1d3      	bne.n	80024e6 <EE_WriteVariable+0x4a>
	{
		return FlashStatus;
	}

	/* Set new Page status to VALID_PAGE status */
	FlashStatus = FLASH_ProgramHalfWord(NewPageAddress, VALID_PAGE);
 800253e:	1c38      	adds	r0, r7, #0
 8002540:	2100      	movs	r1, #0
 8002542:	f003 fa2d 	bl	80059a0 <FLASH_ProgramHalfWord>
	/* If program operation was failed, a Flash error code is returned */
	if (FlashStatus != FLASH_COMPLETE)
 8002546:	2804      	cmp	r0, #4
 8002548:	d0b5      	beq.n	80024b6 <EE_WriteVariable+0x1a>
	{
		return FlashStatus;
 800254a:	b284      	uxth	r4, r0
 800254c:	e7b3      	b.n	80024b6 <EE_WriteVariable+0x1a>
			if (ReadStatus != 0x1)
			{
				/* Transfer the variable to the new active page */
				EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
				/* If program operation was failed, a Flash error code is returned */
				if (EepromStatus != FLASH_COMPLETE)
 800254e:	1c04      	adds	r4, r0, #0
 8002550:	e7b1      	b.n	80024b6 <EE_WriteVariable+0x1a>
 8002552:	46c0      	nop			; (mov r8, r8)
 8002554:	0800f800 	.word	0x0800f800
 8002558:	0800fc00 	.word	0x0800fc00
 800255c:	0000eeee 	.word	0x0000eeee
 8002560:	20000014 	.word	0x20000014
 8002564:	200001d4 	.word	0x200001d4

08002568 <EE_FlashErase>:
	/* Return last operation flash status */
	return FlashStatus;
}

void EE_FlashErase(void)
{
 8002568:	b510      	push	{r4, lr}
	/* Clear all variable values on Flash Virtual Address */
	EE_WriteVariable(EEPROM_ADDRESS_LITERS, 0);
 800256a:	2100      	movs	r1, #0
 800256c:	4819      	ldr	r0, [pc, #100]	; (80025d4 <EE_FlashErase+0x6c>)
 800256e:	f7ff ff95 	bl	800249c <EE_WriteVariable>
	EE_WriteVariable(EEPROM_ADDRESS_HOUERS, 0);
 8002572:	2100      	movs	r1, #0
 8002574:	4818      	ldr	r0, [pc, #96]	; (80025d8 <EE_FlashErase+0x70>)
 8002576:	f7ff ff91 	bl	800249c <EE_WriteVariable>
	EE_WriteVariable(EEPROM_ADDRESS_NUMBER, 0);
 800257a:	2100      	movs	r1, #0
 800257c:	4817      	ldr	r0, [pc, #92]	; (80025dc <EE_FlashErase+0x74>)
 800257e:	f7ff ff8d 	bl	800249c <EE_WriteVariable>

	EE_WriteVariable(EEPROM_ADDRESS_MAX_POT, 0);
 8002582:	2100      	movs	r1, #0
 8002584:	4816      	ldr	r0, [pc, #88]	; (80025e0 <EE_FlashErase+0x78>)
 8002586:	f7ff ff89 	bl	800249c <EE_WriteVariable>
	EE_WriteVariable(EEPROM_ADDRESS_MIN_POT, 8000);
 800258a:	21fa      	movs	r1, #250	; 0xfa
	EE_WriteVariable(EEPROM_ADDRESS_MID_POT, 0);

	EE_WriteVariable(EEPROM_ADDRESS_MAX_IN_TEMP, 0);
	EE_WriteVariable(EEPROM_ADDRESS_MIN_IN_TEMP, 500);
 800258c:	24fa      	movs	r4, #250	; 0xfa
	EE_WriteVariable(EEPROM_ADDRESS_LITERS, 0);
	EE_WriteVariable(EEPROM_ADDRESS_HOUERS, 0);
	EE_WriteVariable(EEPROM_ADDRESS_NUMBER, 0);

	EE_WriteVariable(EEPROM_ADDRESS_MAX_POT, 0);
	EE_WriteVariable(EEPROM_ADDRESS_MIN_POT, 8000);
 800258e:	0149      	lsls	r1, r1, #5
 8002590:	4814      	ldr	r0, [pc, #80]	; (80025e4 <EE_FlashErase+0x7c>)
 8002592:	f7ff ff83 	bl	800249c <EE_WriteVariable>
	EE_WriteVariable(EEPROM_ADDRESS_MID_POT, 0);
 8002596:	2100      	movs	r1, #0
 8002598:	4813      	ldr	r0, [pc, #76]	; (80025e8 <EE_FlashErase+0x80>)
 800259a:	f7ff ff7f 	bl	800249c <EE_WriteVariable>

	EE_WriteVariable(EEPROM_ADDRESS_MAX_IN_TEMP, 0);
	EE_WriteVariable(EEPROM_ADDRESS_MIN_IN_TEMP, 500);
 800259e:	0064      	lsls	r4, r4, #1

	EE_WriteVariable(EEPROM_ADDRESS_MAX_POT, 0);
	EE_WriteVariable(EEPROM_ADDRESS_MIN_POT, 8000);
	EE_WriteVariable(EEPROM_ADDRESS_MID_POT, 0);

	EE_WriteVariable(EEPROM_ADDRESS_MAX_IN_TEMP, 0);
 80025a0:	2100      	movs	r1, #0
 80025a2:	4812      	ldr	r0, [pc, #72]	; (80025ec <EE_FlashErase+0x84>)
 80025a4:	f7ff ff7a 	bl	800249c <EE_WriteVariable>
	EE_WriteVariable(EEPROM_ADDRESS_MIN_IN_TEMP, 500);
 80025a8:	1c21      	adds	r1, r4, #0
 80025aa:	4811      	ldr	r0, [pc, #68]	; (80025f0 <EE_FlashErase+0x88>)
 80025ac:	f7ff ff76 	bl	800249c <EE_WriteVariable>
	EE_WriteVariable(EEPROM_ADDRESS_MID_IN_TEMP, 0);
 80025b0:	2100      	movs	r1, #0
 80025b2:	4810      	ldr	r0, [pc, #64]	; (80025f4 <EE_FlashErase+0x8c>)
 80025b4:	f7ff ff72 	bl	800249c <EE_WriteVariable>

	EE_WriteVariable(EEPROM_ADDRESS_MAX_OUT_TEMP, 0);
 80025b8:	2100      	movs	r1, #0
 80025ba:	480f      	ldr	r0, [pc, #60]	; (80025f8 <EE_FlashErase+0x90>)
 80025bc:	f7ff ff6e 	bl	800249c <EE_WriteVariable>
	EE_WriteVariable(EEPROM_ADDRESS_MIN_OUT_TEMP, 500);
 80025c0:	1c21      	adds	r1, r4, #0
 80025c2:	480e      	ldr	r0, [pc, #56]	; (80025fc <EE_FlashErase+0x94>)
 80025c4:	f7ff ff6a 	bl	800249c <EE_WriteVariable>
	EE_WriteVariable(EEPROM_ADDRESS_MID_OUT_TEMP, 0);
 80025c8:	2100      	movs	r1, #0
 80025ca:	480d      	ldr	r0, [pc, #52]	; (8002600 <EE_FlashErase+0x98>)
 80025cc:	f7ff ff66 	bl	800249c <EE_WriteVariable>
}
 80025d0:	bd10      	pop	{r4, pc}
 80025d2:	46c0      	nop			; (mov r8, r8)
 80025d4:	00001111 	.word	0x00001111
 80025d8:	00002222 	.word	0x00002222
 80025dc:	00003333 	.word	0x00003333
 80025e0:	00004444 	.word	0x00004444
 80025e4:	00005555 	.word	0x00005555
 80025e8:	00006666 	.word	0x00006666
 80025ec:	00007777 	.word	0x00007777
 80025f0:	00008888 	.word	0x00008888
 80025f4:	00009999 	.word	0x00009999
 80025f8:	0000aaaa 	.word	0x0000aaaa
 80025fc:	0000bbbb 	.word	0x0000bbbb
 8002600:	0000cccc 	.word	0x0000cccc

08002604 <Controller_GetSetPoint>:
//==================================================================================================
//
//==================================================================================================
uint16_t Controller_GetSetPoint()
{
	return TemperatureSetPoint;
 8002604:	4b01      	ldr	r3, [pc, #4]	; (800260c <Controller_GetSetPoint+0x8>)
 8002606:	8818      	ldrh	r0, [r3, #0]
}
 8002608:	4770      	bx	lr
 800260a:	46c0      	nop			; (mov r8, r8)
 800260c:	200001d8 	.word	0x200001d8

08002610 <Controller_ResetPID>:
//==================================================================================================
// Funcao que reseta os calculos
//==================================================================================================
void Controller_ResetPID(void)
{
	Saida_PID = 0;
 8002610:	2200      	movs	r2, #0
 8002612:	4b04      	ldr	r3, [pc, #16]	; (8002624 <Controller_ResetPID+0x14>)
 8002614:	805a      	strh	r2, [r3, #2]
	Soma_PID  = 0;
 8002616:	809a      	strh	r2, [r3, #4]
	Integral  = 0;
 8002618:	80da      	strh	r2, [r3, #6]

	Calculo_Derivativo 	 = 0;
 800261a:	811a      	strh	r2, [r3, #8]
	Calculo_Integral 	 = 0;
 800261c:	815a      	strh	r2, [r3, #10]
	Calculo_Proporcional = 0;
 800261e:	819a      	strh	r2, [r3, #12]
}
 8002620:	4770      	bx	lr
 8002622:	46c0      	nop			; (mov r8, r8)
 8002624:	200001d8 	.word	0x200001d8

08002628 <Calculo_PID>:

//==================================================================================================
//
//==================================================================================================
void Calculo_PID(int16_t Erro_Pid)
{
 8002628:	b5f0      	push	{r4, r5, r6, r7, lr}
 800262a:	4656      	mov	r6, sl
 800262c:	4644      	mov	r4, r8
 800262e:	465f      	mov	r7, fp
 8002630:	464d      	mov	r5, r9
 8002632:	b4f0      	push	{r4, r5, r6, r7}
 8002634:	b083      	sub	sp, #12
	int16_t acc;

	//--------------------------------------
	//         PROPORCIONAL
	//--------------------------------------
	Prop = (int16_t)((int16_t)KP * (int16_t)Erro_Pid); // Ajustado para ponto fixo
 8002636:	466a      	mov	r2, sp
 8002638:	80d0      	strh	r0, [r2, #6]
 800263a:	88d3      	ldrh	r3, [r2, #6]
 800263c:	4c43      	ldr	r4, [pc, #268]	; (800274c <Calculo_PID+0x124>)
 800263e:	4699      	mov	r9, r3
 8002640:	009b      	lsls	r3, r3, #2
 8002642:	444b      	add	r3, r9
 8002644:	009f      	lsls	r7, r3, #2
 8002646:	19df      	adds	r7, r3, r7

	if (Prop > LS*100)// 10000 e' o mesmo que 100 pelo ponto fixo
 8002648:	8a66      	ldrh	r6, [r4, #18]
 800264a:	8a23      	ldrh	r3, [r4, #16]
	int16_t acc;

	//--------------------------------------
	//         PROPORCIONAL
	//--------------------------------------
	Prop = (int16_t)((int16_t)KP * (int16_t)Erro_Pid); // Ajustado para ponto fixo
 800264c:	b2bf      	uxth	r7, r7

	if (Prop > LS*100)// 10000 e' o mesmo que 100 pelo ponto fixo
 800264e:	1b9e      	subs	r6, r3, r6
 8002650:	2364      	movs	r3, #100	; 0x64
 8002652:	b2b6      	uxth	r6, r6
 8002654:	4373      	muls	r3, r6

//==================================================================================================
//
//==================================================================================================
void Calculo_PID(int16_t Erro_Pid)
{
 8002656:	4680      	mov	r8, r0
	//--------------------------------------
	//         PROPORCIONAL
	//--------------------------------------
	Prop = (int16_t)((int16_t)KP * (int16_t)Erro_Pid); // Ajustado para ponto fixo

	if (Prop > LS*100)// 10000 e' o mesmo que 100 pelo ponto fixo
 8002658:	b238      	sxth	r0, r7
	int16_t acc;

	//--------------------------------------
	//         PROPORCIONAL
	//--------------------------------------
	Prop = (int16_t)((int16_t)KP * (int16_t)Erro_Pid); // Ajustado para ponto fixo
 800265a:	81e7      	strh	r7, [r4, #14]

	if (Prop > LS*100)// 10000 e' o mesmo que 100 pelo ponto fixo
 800265c:	469a      	mov	sl, r3
 800265e:	4298      	cmp	r0, r3
 8002660:	dd03      	ble.n	800266a <Calculo_PID+0x42>
	{
		Prop = LS*100;
 8002662:	80d3      	strh	r3, [r2, #6]
 8002664:	88d7      	ldrh	r7, [r2, #6]
 8002666:	81e7      	strh	r7, [r4, #14]
 8002668:	b238      	sxth	r0, r7
	}
	if(Prop < 0)
 800266a:	2800      	cmp	r0, #0
 800266c:	db61      	blt.n	8002732 <Calculo_PID+0x10a>
 800266e:	2164      	movs	r1, #100	; 0x64
 8002670:	f001 f910 	bl	8003894 <__aeabi_idiv>
 8002674:	b2bb      	uxth	r3, r7
 8002676:	469b      	mov	fp, r3
 8002678:	b240      	sxtb	r0, r0
 800267a:	b280      	uxth	r0, r0
	Calculo_Proporcional = (signed char) (Prop/100);// resultado devolve para inteiro

	//--------------------------------------
	//         INTEGRAL
	//--------------------------------------
	Integral = Integral + (int16_t)((int16_t)Erro_Pid*(int16_t)KI);
 800267c:	464b      	mov	r3, r9
 800267e:	005d      	lsls	r5, r3, #1
 8002680:	88e3      	ldrh	r3, [r4, #6]
	if(Prop < 0)
	{
		Prop = 0;
	}

	Calculo_Proporcional = (signed char) (Prop/100);// resultado devolve para inteiro
 8002682:	81a0      	strh	r0, [r4, #12]

	//--------------------------------------
	//         INTEGRAL
	//--------------------------------------
	Integral = Integral + (int16_t)((int16_t)Erro_Pid*(int16_t)KI);
 8002684:	18ed      	adds	r5, r5, r3

	acc = Integral + Prop;
 8002686:	465b      	mov	r3, fp
	Calculo_Proporcional = (signed char) (Prop/100);// resultado devolve para inteiro

	//--------------------------------------
	//         INTEGRAL
	//--------------------------------------
	Integral = Integral + (int16_t)((int16_t)Erro_Pid*(int16_t)KI);
 8002688:	b2ad      	uxth	r5, r5

	acc = Integral + Prop;
 800268a:	195f      	adds	r7, r3, r5

	if (acc > LS*100)
 800268c:	b23b      	sxth	r3, r7
 800268e:	459a      	cmp	sl, r3
 8002690:	da39      	bge.n	8002706 <Calculo_PID+0xde>
	{
		Integral = LS*100 - Prop;
 8002692:	2564      	movs	r5, #100	; 0x64
 8002694:	465b      	mov	r3, fp
 8002696:	4375      	muls	r5, r6
 8002698:	1aed      	subs	r5, r5, r3
 800269a:	b2ad      	uxth	r5, r5
 800269c:	b2a8      	uxth	r0, r5
 800269e:	80e0      	strh	r0, [r4, #6]
 80026a0:	2164      	movs	r1, #100	; 0x64
 80026a2:	b200      	sxth	r0, r0
 80026a4:	f001 f8f6 	bl	8003894 <__aeabi_idiv>
 80026a8:	445d      	add	r5, fp
 80026aa:	1c2f      	adds	r7, r5, #0
 80026ac:	b240      	sxtb	r0, r0
 80026ae:	b280      	uxth	r0, r0
	else if (acc < 0)
	{
		Integral = 0;
	}

	Calculo_Integral = (signed char)(Integral/100);
 80026b0:	8160      	strh	r0, [r4, #10]

	//--------------------------------------
	//         DERIVATIVO
	//--------------------------------------
	if ((Erro_Pid - Ultimo_Erro) != 0)
 80026b2:	8aa0      	ldrh	r0, [r4, #20]
 80026b4:	b203      	sxth	r3, r0
 80026b6:	4598      	cmp	r8, r3
 80026b8:	d034      	beq.n	8002724 <Calculo_PID+0xfc>
	{
		Derivativo = (int16_t)((int16_t)( Erro_Pid - Ultimo_Erro )*(int16_t)KD);
 80026ba:	464b      	mov	r3, r9
 80026bc:	2564      	movs	r5, #100	; 0x64
 80026be:	1a1b      	subs	r3, r3, r0
 80026c0:	436b      	muls	r3, r5
 80026c2:	b29d      	uxth	r5, r3
 80026c4:	b2a8      	uxth	r0, r5
 80026c6:	82e0      	strh	r0, [r4, #22]
 80026c8:	2164      	movs	r1, #100	; 0x64
 80026ca:	b200      	sxth	r0, r0
 80026cc:	f001 f8e2 	bl	8003894 <__aeabi_idiv>
 80026d0:	b240      	sxtb	r0, r0
 80026d2:	b280      	uxth	r0, r0
	else
	{
		Derivativo = 0;
	}

	Ultimo_Erro = Erro_Pid;
 80026d4:	4643      	mov	r3, r8

	Calculo_Derivativo = (signed char)(Derivativo/100);
 80026d6:	8120      	strh	r0, [r4, #8]

	//--------------------------------------
	//            SOMATORIO
	//--------------------------------------
	Soma_PID = (Prop + Integral + Derivativo);
 80026d8:	19e8      	adds	r0, r5, r7
	else
	{
		Derivativo = 0;
	}

	Ultimo_Erro = Erro_Pid;
 80026da:	82a3      	strh	r3, [r4, #20]
	//--------------------------------------
	//            SOMATORIO
	//--------------------------------------
	Soma_PID = (Prop + Integral + Derivativo);

	Soma_PID /= 100;
 80026dc:	b200      	sxth	r0, r0
 80026de:	2164      	movs	r1, #100	; 0x64
 80026e0:	f001 f8d8 	bl	8003894 <__aeabi_idiv>
 80026e4:	b280      	uxth	r0, r0

	if((int16_t)Soma_PID > LS)
 80026e6:	b203      	sxth	r3, r0
	//--------------------------------------
	//            SOMATORIO
	//--------------------------------------
	Soma_PID = (Prop + Integral + Derivativo);

	Soma_PID /= 100;
 80026e8:	80a0      	strh	r0, [r4, #4]

	if((int16_t)Soma_PID > LS)
 80026ea:	429e      	cmp	r6, r3
 80026ec:	db1f      	blt.n	800272e <Calculo_PID+0x106>
	{
		Saida_PID = LS;
	}
	else if((int16_t)Soma_PID < LI)
 80026ee:	2b00      	cmp	r3, #0
 80026f0:	db29      	blt.n	8002746 <Calculo_PID+0x11e>
	{
		Saida_PID = LI;
	}
	else
	{
		Saida_PID =(unsigned char)Soma_PID;
 80026f2:	23ff      	movs	r3, #255	; 0xff
 80026f4:	4018      	ands	r0, r3
 80026f6:	8060      	strh	r0, [r4, #2]
	}
}
 80026f8:	b003      	add	sp, #12
 80026fa:	bc3c      	pop	{r2, r3, r4, r5}
 80026fc:	4690      	mov	r8, r2
 80026fe:	4699      	mov	r9, r3
 8002700:	46a2      	mov	sl, r4
 8002702:	46ab      	mov	fp, r5
 8002704:	bdf0      	pop	{r4, r5, r6, r7, pc}

	if (acc > LS*100)
	{
		Integral = LS*100 - Prop;
	}
	else if (acc < 0)
 8002706:	2b00      	cmp	r3, #0
 8002708:	db18      	blt.n	800273c <Calculo_PID+0x114>
	Calculo_Proporcional = (signed char) (Prop/100);// resultado devolve para inteiro

	//--------------------------------------
	//         INTEGRAL
	//--------------------------------------
	Integral = Integral + (int16_t)((int16_t)Erro_Pid*(int16_t)KI);
 800270a:	b2ad      	uxth	r5, r5
 800270c:	80e5      	strh	r5, [r4, #6]
 800270e:	b228      	sxth	r0, r5
 8002710:	2164      	movs	r1, #100	; 0x64
 8002712:	f001 f8bf 	bl	8003894 <__aeabi_idiv>
 8002716:	b240      	sxtb	r0, r0
 8002718:	b280      	uxth	r0, r0
	else if (acc < 0)
	{
		Integral = 0;
	}

	Calculo_Integral = (signed char)(Integral/100);
 800271a:	8160      	strh	r0, [r4, #10]

	//--------------------------------------
	//         DERIVATIVO
	//--------------------------------------
	if ((Erro_Pid - Ultimo_Erro) != 0)
 800271c:	8aa0      	ldrh	r0, [r4, #20]
 800271e:	b203      	sxth	r3, r0
 8002720:	4598      	cmp	r8, r3
 8002722:	d1ca      	bne.n	80026ba <Calculo_PID+0x92>
	{
		Derivativo = (int16_t)((int16_t)( Erro_Pid - Ultimo_Erro )*(int16_t)KD);
	}
	else
	{
		Derivativo = 0;
 8002724:	2300      	movs	r3, #0
 8002726:	2500      	movs	r5, #0
 8002728:	82e3      	strh	r3, [r4, #22]
 800272a:	2000      	movs	r0, #0
 800272c:	e7d2      	b.n	80026d4 <Calculo_PID+0xac>

	Soma_PID /= 100;

	if((int16_t)Soma_PID > LS)
	{
		Saida_PID = LS;
 800272e:	8066      	strh	r6, [r4, #2]
 8002730:	e7e2      	b.n	80026f8 <Calculo_PID+0xd0>
	{
		Prop = LS*100;
	}
	if(Prop < 0)
	{
		Prop = 0;
 8002732:	2300      	movs	r3, #0
 8002734:	2000      	movs	r0, #0
 8002736:	81e3      	strh	r3, [r4, #14]
 8002738:	469b      	mov	fp, r3
 800273a:	e79f      	b.n	800267c <Calculo_PID+0x54>
	{
		Integral = LS*100 - Prop;
	}
	else if (acc < 0)
	{
		Integral = 0;
 800273c:	2300      	movs	r3, #0
 800273e:	2000      	movs	r0, #0
 8002740:	80e3      	strh	r3, [r4, #6]
 8002742:	465f      	mov	r7, fp
 8002744:	e7b4      	b.n	80026b0 <Calculo_PID+0x88>
	{
		Saida_PID = LS;
	}
	else if((int16_t)Soma_PID < LI)
	{
		Saida_PID = LI;
 8002746:	2300      	movs	r3, #0
 8002748:	8063      	strh	r3, [r4, #2]
 800274a:	e7d5      	b.n	80026f8 <Calculo_PID+0xd0>
 800274c:	200001d8 	.word	0x200001d8

08002750 <PID_Task>:
//==================================================================================================
void PID_Task(void)
{
    int16_t erro;

	erro = (TemperatureSetPoint) - TemperaturaSaida;
 8002750:	4a08      	ldr	r2, [pc, #32]	; (8002774 <PID_Task+0x24>)

//==================================================================================================
//
//==================================================================================================
void PID_Task(void)
{
 8002752:	b508      	push	{r3, lr}
    int16_t erro;

	erro = (TemperatureSetPoint) - TemperaturaSaida;
 8002754:	8b10      	ldrh	r0, [r2, #24]
 8002756:	8813      	ldrh	r3, [r2, #0]
 8002758:	1a18      	subs	r0, r3, r0
 800275a:	b280      	uxth	r0, r0

	if((erro < -ZM) || (erro > ZM))
 800275c:	1cc3      	adds	r3, r0, #3
 800275e:	b29b      	uxth	r3, r3
 8002760:	2b06      	cmp	r3, #6
 8002762:	d803      	bhi.n	800276c <PID_Task+0x1c>
	{
		Calculo_PID(erro);
	}
	else
	{
		Calculo_PID(0);
 8002764:	2000      	movs	r0, #0
 8002766:	f7ff ff5f 	bl	8002628 <Calculo_PID>
	}
}
 800276a:	bd08      	pop	{r3, pc}

	erro = (TemperatureSetPoint) - TemperaturaSaida;

	if((erro < -ZM) || (erro > ZM))
	{
		Calculo_PID(erro);
 800276c:	b200      	sxth	r0, r0
 800276e:	f7ff ff5b 	bl	8002628 <Calculo_PID>
 8002772:	e7fa      	b.n	800276a <PID_Task+0x1a>
 8002774:	200001d8 	.word	0x200001d8

08002778 <Controle_Modo_Temperatura>:
void Controle_Modo_Temperatura()
{
    int16_t Acc;
    uint16_t Bcc;

    Acc = (TemperatureSetPoint) - TemperaturaSaida;
 8002778:	4b1d      	ldr	r3, [pc, #116]	; (80027f0 <Controle_Modo_Temperatura+0x78>)
 800277a:	8b19      	ldrh	r1, [r3, #24]
 800277c:	881a      	ldrh	r2, [r3, #0]
 800277e:	1a52      	subs	r2, r2, r1

    if (Acc > -15)
 8002780:	b212      	sxth	r2, r2
 8002782:	1c11      	adds	r1, r2, #0
 8002784:	310e      	adds	r1, #14
 8002786:	db13      	blt.n	80027b0 <Controle_Modo_Temperatura+0x38>
    {
        Bcc = Saida_PID + ucOffsetPID + (DerivadaFluxo/DIVISOR_DERIVADA);
 8002788:	8859      	ldrh	r1, [r3, #2]
 800278a:	8a5a      	ldrh	r2, [r3, #18]
 800278c:	188a      	adds	r2, r1, r2
 800278e:	201a      	movs	r0, #26
 8002790:	5e19      	ldrsh	r1, [r3, r0]
 8002792:	17c8      	asrs	r0, r1, #31
 8002794:	0f40      	lsrs	r0, r0, #29
 8002796:	1841      	adds	r1, r0, r1
 8002798:	10c9      	asrs	r1, r1, #3
 800279a:	1852      	adds	r2, r2, r1
    {
        Bcc = 0;
        Controller_ResetPID();
    }

    if (Bcc > ucMaximoPID)
 800279c:	8a19      	ldrh	r1, [r3, #16]

    Acc = (TemperatureSetPoint) - TemperaturaSaida;

    if (Acc > -15)
    {
        Bcc = Saida_PID + ucOffsetPID + (DerivadaFluxo/DIVISOR_DERIVADA);
 800279e:	b292      	uxth	r2, r2
    {
        Bcc = 0;
        Controller_ResetPID();
    }

    if (Bcc > ucMaximoPID)
 80027a0:	428a      	cmp	r2, r1
 80027a2:	d913      	bls.n	80027cc <Controle_Modo_Temperatura+0x54>
 80027a4:	1c0a      	adds	r2, r1, #0
 80027a6:	2964      	cmp	r1, #100	; 0x64
 80027a8:	d81d      	bhi.n	80027e6 <Controle_Modo_Temperatura+0x6e>
 80027aa:	b292      	uxth	r2, r2
    if (Bcc > 100)
    {
        Bcc = 100;
    }

    uiPower = Bcc;
 80027ac:	839a      	strh	r2, [r3, #28]
}
 80027ae:	4770      	bx	lr

    if (Acc > -15)
    {
        Bcc = Saida_PID + ucOffsetPID + (DerivadaFluxo/DIVISOR_DERIVADA);
    }
    else if ((Acc > -45))
 80027b0:	322c      	adds	r2, #44	; 0x2c
 80027b2:	db10      	blt.n	80027d6 <Controle_Modo_Temperatura+0x5e>
    {
        Bcc = ucOffsetPID + (DerivadaFluxo/DIVISOR_DERIVADA);
 80027b4:	221a      	movs	r2, #26
 80027b6:	5e99      	ldrsh	r1, [r3, r2]
 80027b8:	17ca      	asrs	r2, r1, #31
 80027ba:	0f52      	lsrs	r2, r2, #29
 80027bc:	1852      	adds	r2, r2, r1
 80027be:	8a59      	ldrh	r1, [r3, #18]
 80027c0:	10d2      	asrs	r2, r2, #3
 80027c2:	1852      	adds	r2, r2, r1
    {
        Bcc = 0;
        Controller_ResetPID();
    }

    if (Bcc > ucMaximoPID)
 80027c4:	8a19      	ldrh	r1, [r3, #16]
    {
        Bcc = Saida_PID + ucOffsetPID + (DerivadaFluxo/DIVISOR_DERIVADA);
    }
    else if ((Acc > -45))
    {
        Bcc = ucOffsetPID + (DerivadaFluxo/DIVISOR_DERIVADA);
 80027c6:	b292      	uxth	r2, r2
    {
        Bcc = 0;
        Controller_ResetPID();
    }

    if (Bcc > ucMaximoPID)
 80027c8:	428a      	cmp	r2, r1
 80027ca:	d8eb      	bhi.n	80027a4 <Controle_Modo_Temperatura+0x2c>
 80027cc:	1c11      	adds	r1, r2, #0
 80027ce:	2a64      	cmp	r2, #100	; 0x64
 80027d0:	d80b      	bhi.n	80027ea <Controle_Modo_Temperatura+0x72>
 80027d2:	b28a      	uxth	r2, r1
 80027d4:	e7ea      	b.n	80027ac <Controle_Modo_Temperatura+0x34>
//==================================================================================================
// Funcao que reseta os calculos
//==================================================================================================
void Controller_ResetPID(void)
{
	Saida_PID = 0;
 80027d6:	2200      	movs	r2, #0
 80027d8:	805a      	strh	r2, [r3, #2]
	Soma_PID  = 0;
 80027da:	809a      	strh	r2, [r3, #4]
	Integral  = 0;
 80027dc:	80da      	strh	r2, [r3, #6]

	Calculo_Derivativo 	 = 0;
 80027de:	811a      	strh	r2, [r3, #8]
	Calculo_Integral 	 = 0;
 80027e0:	815a      	strh	r2, [r3, #10]
	Calculo_Proporcional = 0;
 80027e2:	819a      	strh	r2, [r3, #12]
 80027e4:	e7e2      	b.n	80027ac <Controle_Modo_Temperatura+0x34>
 80027e6:	2264      	movs	r2, #100	; 0x64
 80027e8:	e7df      	b.n	80027aa <Controle_Modo_Temperatura+0x32>
 80027ea:	2164      	movs	r1, #100	; 0x64
 80027ec:	b28a      	uxth	r2, r1
 80027ee:	e7dd      	b.n	80027ac <Controle_Modo_Temperatura+0x34>
 80027f0:	200001d8 	.word	0x200001d8

080027f4 <Calcula_Offset_PID>:

//==================================================================================================
//
//==================================================================================================
void Calcula_Offset_PID()
{
 80027f4:	b510      	push	{r4, lr}
    static int16_t Delta;
    static int32_t Acc;

    Delta = (TemperatureSetPoint - TemperaturaEntrada);
 80027f6:	4c26      	ldr	r4, [pc, #152]	; (8002890 <Calcula_Offset_PID+0x9c>)
 80027f8:	8823      	ldrh	r3, [r4, #0]
 80027fa:	8be0      	ldrh	r0, [r4, #30]
 80027fc:	1a18      	subs	r0, r3, r0
 80027fe:	b280      	uxth	r0, r0
 8002800:	8420      	strh	r0, [r4, #32]

    if(Delta >= 10)
 8002802:	b200      	sxth	r0, r0
 8002804:	2809      	cmp	r0, #9
 8002806:	dd32      	ble.n	800286e <Calcula_Offset_PID+0x7a>
    {
        Acc = (int32_t)((int32_t)FluxoAgua*(int32_t)Delta);
 8002808:	2222      	movs	r2, #34	; 0x22
 800280a:	5ea3      	ldrsh	r3, [r4, r2]
 800280c:	4358      	muls	r0, r3
 800280e:	6260      	str	r0, [r4, #36]	; 0x24

		#if  (defined _127V)
			Delta = (Acc*0.00103) + 6.5;
		#else
			Delta = (Acc*0.00065) + 7.5;
 8002810:	f002 fac2 	bl	8004d98 <__aeabi_i2d>
 8002814:	4a1f      	ldr	r2, [pc, #124]	; (8002894 <Calcula_Offset_PID+0xa0>)
 8002816:	4b20      	ldr	r3, [pc, #128]	; (8002898 <Calcula_Offset_PID+0xa4>)
 8002818:	f001 fc74 	bl	8004104 <__aeabi_dmul>
 800281c:	2200      	movs	r2, #0
 800281e:	4b1f      	ldr	r3, [pc, #124]	; (800289c <Calcula_Offset_PID+0xa8>)
 8002820:	f001 f948 	bl	8003ab4 <__aeabi_dadd>
 8002824:	f002 fa82 	bl	8004d2c <__aeabi_d2iz>
 8002828:	b280      	uxth	r0, r0
		#endif

        if (Delta > 100)
 800282a:	b203      	sxth	r3, r0
 800282c:	2264      	movs	r2, #100	; 0x64
 800282e:	2b64      	cmp	r3, #100	; 0x64
 8002830:	dd21      	ble.n	8002876 <Calcula_Offset_PID+0x82>
        if (Delta < 0)
        {
            Delta = 0 ;
        }

        Delta = ucOffsetPID  + Delta;
 8002832:	8a63      	ldrh	r3, [r4, #18]
 8002834:	18d3      	adds	r3, r2, r3
 8002836:	b29b      	uxth	r3, r3
 8002838:	8423      	strh	r3, [r4, #32]

        ucOffsetPID = Delta/2 ;
 800283a:	b21b      	sxth	r3, r3
 800283c:	0fd8      	lsrs	r0, r3, #31
 800283e:	18c0      	adds	r0, r0, r3
 8002840:	1043      	asrs	r3, r0, #1
 8002842:	b298      	uxth	r0, r3
 8002844:	8260      	strh	r0, [r4, #18]

        if(ucOffsetPID > 80)
 8002846:	2850      	cmp	r0, #80	; 0x50
 8002848:	d81a      	bhi.n	8002880 <Calcula_Offset_PID+0x8c>
            ucOffsetPID = 80;
            ucMaximoPID = 100;
        }
        else
        {
            ucMaximoPID = (ucOffsetPID*1.5) + 18;
 800284a:	f002 faa5 	bl	8004d98 <__aeabi_i2d>
 800284e:	2200      	movs	r2, #0
 8002850:	4b13      	ldr	r3, [pc, #76]	; (80028a0 <Calcula_Offset_PID+0xac>)
 8002852:	f001 fc57 	bl	8004104 <__aeabi_dmul>
 8002856:	2200      	movs	r2, #0
 8002858:	4b12      	ldr	r3, [pc, #72]	; (80028a4 <Calcula_Offset_PID+0xb0>)
 800285a:	f001 f92b 	bl	8003ab4 <__aeabi_dadd>
 800285e:	f001 f90b 	bl	8003a78 <__aeabi_d2uiz>
 8002862:	b280      	uxth	r0, r0

            if(ucMaximoPID> 100)
 8002864:	2864      	cmp	r0, #100	; 0x64
 8002866:	d910      	bls.n	800288a <Calcula_Offset_PID+0x96>
            {
                ucMaximoPID = 100;
 8002868:	2364      	movs	r3, #100	; 0x64
 800286a:	8223      	strh	r3, [r4, #16]
 800286c:	e002      	b.n	8002874 <Calcula_Offset_PID+0x80>
            }
        }
    }
    else
    {
        ucMaximoPID = 0;
 800286e:	2300      	movs	r3, #0
 8002870:	8223      	strh	r3, [r4, #16]
        ucOffsetPID = 0;
 8002872:	8263      	strh	r3, [r4, #18]
    }
}
 8002874:	bd10      	pop	{r4, pc}
        if (Delta > 100)
        {
            Delta = 100 ;
        }

        if (Delta < 0)
 8002876:	2200      	movs	r2, #0
 8002878:	2b00      	cmp	r3, #0
 800287a:	dbda      	blt.n	8002832 <Calcula_Offset_PID+0x3e>
 800287c:	b282      	uxth	r2, r0
 800287e:	e7d8      	b.n	8002832 <Calcula_Offset_PID+0x3e>

        ucOffsetPID = Delta/2 ;

        if(ucOffsetPID > 80)
        {
            ucOffsetPID = 80;
 8002880:	2350      	movs	r3, #80	; 0x50
 8002882:	8263      	strh	r3, [r4, #18]
            ucMaximoPID = 100;
 8002884:	3314      	adds	r3, #20
 8002886:	8223      	strh	r3, [r4, #16]
 8002888:	e7f4      	b.n	8002874 <Calcula_Offset_PID+0x80>
        }
        else
        {
            ucMaximoPID = (ucOffsetPID*1.5) + 18;
 800288a:	8220      	strh	r0, [r4, #16]
 800288c:	e7f2      	b.n	8002874 <Calcula_Offset_PID+0x80>
 800288e:	46c0      	nop			; (mov r8, r8)
 8002890:	200001d8 	.word	0x200001d8
 8002894:	5f06f694 	.word	0x5f06f694
 8002898:	3f454c98 	.word	0x3f454c98
 800289c:	401e0000 	.word	0x401e0000
 80028a0:	3ff80000 	.word	0x3ff80000
 80028a4:	40320000 	.word	0x40320000

080028a8 <Controller_Task>:

//==================================================================================================
//
//==================================================================================================
uint16_t Controller_Task(uint16_t SetPoint)
{
 80028a8:	b510      	push	{r4, lr}
	TemperatureSetPoint = SetPoint;
 80028aa:	4c0b      	ldr	r4, [pc, #44]	; (80028d8 <Controller_Task+0x30>)
 80028ac:	8020      	strh	r0, [r4, #0]
    TemperaturaEntrada  = NTC_GetWaterTemperature(TEMPERATURE_INLET);
 80028ae:	2001      	movs	r0, #1
 80028b0:	f000 f94a 	bl	8002b48 <NTC_GetWaterTemperature>
 80028b4:	83e0      	strh	r0, [r4, #30]
    TemperaturaSaida    = NTC_GetWaterTemperature(TEMPERATURE_OUTLET);
 80028b6:	2002      	movs	r0, #2
 80028b8:	f000 f946 	bl	8002b48 <NTC_GetWaterTemperature>
 80028bc:	8320      	strh	r0, [r4, #24]
    FluxoAgua           = Flowmeter_GetFlow();
 80028be:	f7ff f893 	bl	80019e8 <Flowmeter_GetFlow>
 80028c2:	8460      	strh	r0, [r4, #34]	; 0x22
    DerivadaFluxo       = Flowmeter_GetFlowDerivative();
 80028c4:	f7ff f8a4 	bl	8001a10 <Flowmeter_GetFlowDerivative>
 80028c8:	8360      	strh	r0, [r4, #26]

    //PID_Task();
    Calcula_Offset_PID();
 80028ca:	f7ff ff93 	bl	80027f4 <Calcula_Offset_PID>
    Controle_Modo_Temperatura();
 80028ce:	f7ff ff53 	bl	8002778 <Controle_Modo_Temperatura>

    return uiPower;
 80028d2:	8ba0      	ldrh	r0, [r4, #28]
}
 80028d4:	bd10      	pop	{r4, pc}
 80028d6:	46c0      	nop			; (mov r8, r8)
 80028d8:	200001d8 	.word	0x200001d8

080028dc <TOUCH_Init>:

//==================================================================================================
//
//==================================================================================================
void TOUCH_Init (xQueueHandle *QueueHandler)
{
 80028dc:	b510      	push	{r4, lr}
 80028de:	1c04      	adds	r4, r0, #0
	PWM_Init();
 80028e0:	f7fe f9f4 	bl	8000ccc <PWM_Init>
	AD_Init();
 80028e4:	f7fe fe6a 	bl	80015bc <AD_Init>

	TouchQueueHandler = QueueHandler;
 80028e8:	4b01      	ldr	r3, [pc, #4]	; (80028f0 <TOUCH_Init+0x14>)
 80028ea:	601c      	str	r4, [r3, #0]
}
 80028ec:	bd10      	pop	{r4, pc}
 80028ee:	46c0      	nop			; (mov r8, r8)
 80028f0:	20000200 	.word	0x20000200

080028f4 <TOUCH_GetArithmeticMeanUp>:
//==================================================================================================
//
//==================================================================================================
int32_t TOUCH_GetArithmeticMeanUp (void)
{
	return DeltaUp;
 80028f4:	4b01      	ldr	r3, [pc, #4]	; (80028fc <TOUCH_GetArithmeticMeanUp+0x8>)
 80028f6:	6858      	ldr	r0, [r3, #4]
}
 80028f8:	4770      	bx	lr
 80028fa:	46c0      	nop			; (mov r8, r8)
 80028fc:	20000200 	.word	0x20000200

08002900 <TOUCH_GetArithmeticMeanDown>:
//==================================================================================================
//
//==================================================================================================
int32_t TOUCH_GetArithmeticMeanDown (void)
{
	return DeltaDown;
 8002900:	4b01      	ldr	r3, [pc, #4]	; (8002908 <TOUCH_GetArithmeticMeanDown+0x8>)
 8002902:	6898      	ldr	r0, [r3, #8]
}
 8002904:	4770      	bx	lr
 8002906:	46c0      	nop			; (mov r8, r8)
 8002908:	20000200 	.word	0x20000200

0800290c <TOUCH_Task>:

//==================================================================================================
//
//==================================================================================================
void TOUCH_Task (void)
{
 800290c:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t Data;

	static portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;

	LastMeanUp 	 = MeanUp;
 800290e:	4c4f      	ldr	r4, [pc, #316]	; (8002a4c <TOUCH_Task+0x140>)

//==================================================================================================
//
//==================================================================================================
void TOUCH_Task (void)
{
 8002910:	b083      	sub	sp, #12
	uint32_t Data;

	static portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;

	LastMeanUp 	 = MeanUp;
 8002912:	6923      	ldr	r3, [r4, #16]
	LastMeanDown = MeanDown;
	//Atualiza último valor da média

	MeanUp 	 = (LastMeanUp 	 + (int32_t)AD_GetValue(AD_TOUCH_UP))  /2;
 8002914:	2004      	movs	r0, #4
{
	uint32_t Data;

	static portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;

	LastMeanUp 	 = MeanUp;
 8002916:	60e3      	str	r3, [r4, #12]
	LastMeanDown = MeanDown;
 8002918:	69a3      	ldr	r3, [r4, #24]
 800291a:	6163      	str	r3, [r4, #20]
	//Atualiza último valor da média

	MeanUp 	 = (LastMeanUp 	 + (int32_t)AD_GetValue(AD_TOUCH_UP))  /2;
 800291c:	f7fe ff12 	bl	8001744 <AD_GetValue>
 8002920:	68e3      	ldr	r3, [r4, #12]
 8002922:	469c      	mov	ip, r3
 8002924:	4460      	add	r0, ip
 8002926:	0fc3      	lsrs	r3, r0, #31
 8002928:	1818      	adds	r0, r3, r0
 800292a:	1040      	asrs	r0, r0, #1
 800292c:	6120      	str	r0, [r4, #16]
	MeanDown = (LastMeanDown + (int32_t)AD_GetValue(AD_TOUCH_DOWN))/2;
 800292e:	2005      	movs	r0, #5
 8002930:	f7fe ff08 	bl	8001744 <AD_GetValue>
 8002934:	6961      	ldr	r1, [r4, #20]
	//Valor médio entre a última média e o valor atual lido no AD

	LastDeltaUp	  = DeltaUp;
 8002936:	6866      	ldr	r6, [r4, #4]
	LastMeanUp 	 = MeanUp;
	LastMeanDown = MeanDown;
	//Atualiza último valor da média

	MeanUp 	 = (LastMeanUp 	 + (int32_t)AD_GetValue(AD_TOUCH_UP))  /2;
	MeanDown = (LastMeanDown + (int32_t)AD_GetValue(AD_TOUCH_DOWN))/2;
 8002938:	1840      	adds	r0, r0, r1
 800293a:	0fc3      	lsrs	r3, r0, #31
 800293c:	1818      	adds	r0, r3, r0
	//Valor médio entre a última média e o valor atual lido no AD

	LastDeltaUp	  = DeltaUp;
	LastDeltaDown = DeltaDown;
 800293e:	68a5      	ldr	r5, [r4, #8]
	LastMeanUp 	 = MeanUp;
	LastMeanDown = MeanDown;
	//Atualiza último valor da média

	MeanUp 	 = (LastMeanUp 	 + (int32_t)AD_GetValue(AD_TOUCH_UP))  /2;
	MeanDown = (LastMeanDown + (int32_t)AD_GetValue(AD_TOUCH_DOWN))/2;
 8002940:	1040      	asrs	r0, r0, #1
 8002942:	61a0      	str	r0, [r4, #24]
	//Valor médio entre a última média e o valor atual lido no AD

	LastDeltaUp	  = DeltaUp;
 8002944:	61e6      	str	r6, [r4, #28]
	LastDeltaDown = DeltaDown;
 8002946:	6225      	str	r5, [r4, #32]
	//Atualiza último valor da diferença

	if((MeanDown - LastMeanDown) > 0)
 8002948:	1a43      	subs	r3, r0, r1
 800294a:	2b00      	cmp	r3, #0
 800294c:	dc00      	bgt.n	8002950 <TOUCH_Task+0x44>
 800294e:	e076      	b.n	8002a3e <TOUCH_Task+0x132>
	{
		DeltaDown = LastMeanDown - MeanDown;
	}
	//Diferença entre última medida e medida atual

	if((MeanUp - LastMeanUp) > 0)
 8002950:	6921      	ldr	r1, [r4, #16]
 8002952:	68e0      	ldr	r0, [r4, #12]
 8002954:	1a0a      	subs	r2, r1, r0
 8002956:	2a00      	cmp	r2, #0
 8002958:	dc00      	bgt.n	800295c <TOUCH_Task+0x50>
 800295a:	e06e      	b.n	8002a3a <TOUCH_Task+0x12e>
	{
		DeltaUp = LastMeanUp - MeanUp;
	}
	//Diferença entre última medida e medida atual

	DeltaUp	  = (LastDeltaUp + DeltaUp)/2;
 800295c:	18b2      	adds	r2, r6, r2
	DeltaDown = (LastDeltaDown + DeltaDown)/2;
 800295e:	18eb      	adds	r3, r5, r3
	{
		DeltaUp = LastMeanUp - MeanUp;
	}
	//Diferença entre última medida e medida atual

	DeltaUp	  = (LastDeltaUp + DeltaUp)/2;
 8002960:	0fd1      	lsrs	r1, r2, #31
	DeltaDown = (LastDeltaDown + DeltaDown)/2;
	//Media entre a última diferença e a diferença atual

	LastCountUp = CountUp;
 8002962:	2624      	movs	r6, #36	; 0x24
	{
		DeltaUp = LastMeanUp - MeanUp;
	}
	//Diferença entre última medida e medida atual

	DeltaUp	  = (LastDeltaUp + DeltaUp)/2;
 8002964:	188a      	adds	r2, r1, r2
	DeltaDown = (LastDeltaDown + DeltaDown)/2;
 8002966:	0fd9      	lsrs	r1, r3, #31
 8002968:	18cb      	adds	r3, r1, r3
	//Media entre a última diferença e a diferença atual

	LastCountUp = CountUp;
	LastCountDown = CountDown;
 800296a:	2526      	movs	r5, #38	; 0x26

	DeltaUp	  = (LastDeltaUp + DeltaUp)/2;
	DeltaDown = (LastDeltaDown + DeltaDown)/2;
	//Media entre a última diferença e a diferença atual

	LastCountUp = CountUp;
 800296c:	2125      	movs	r1, #37	; 0x25
	LastCountDown = CountDown;
 800296e:	2727      	movs	r7, #39	; 0x27

	DeltaUp	  = (LastDeltaUp + DeltaUp)/2;
	DeltaDown = (LastDeltaDown + DeltaDown)/2;
	//Media entre a última diferença e a diferença atual

	LastCountUp = CountUp;
 8002970:	5da0      	ldrb	r0, [r4, r6]
	{
		DeltaUp = LastMeanUp - MeanUp;
	}
	//Diferença entre última medida e medida atual

	DeltaUp	  = (LastDeltaUp + DeltaUp)/2;
 8002972:	1052      	asrs	r2, r2, #1
	DeltaDown = (LastDeltaDown + DeltaDown)/2;
	//Media entre a última diferença e a diferença atual

	LastCountUp = CountUp;
 8002974:	5460      	strb	r0, [r4, r1]
	LastCountDown = CountDown;
 8002976:	5d61      	ldrb	r1, [r4, r5]
		DeltaUp = LastMeanUp - MeanUp;
	}
	//Diferença entre última medida e medida atual

	DeltaUp	  = (LastDeltaUp + DeltaUp)/2;
	DeltaDown = (LastDeltaDown + DeltaDown)/2;
 8002978:	105b      	asrs	r3, r3, #1
	{
		DeltaUp = LastMeanUp - MeanUp;
	}
	//Diferença entre última medida e medida atual

	DeltaUp	  = (LastDeltaUp + DeltaUp)/2;
 800297a:	6062      	str	r2, [r4, #4]
	DeltaDown = (LastDeltaDown + DeltaDown)/2;
 800297c:	60a3      	str	r3, [r4, #8]
	//Media entre a última diferença e a diferença atual

	LastCountUp = CountUp;
	LastCountDown = CountDown;
 800297e:	55e1      	strb	r1, [r4, r7]
	//Atualiza último valor dos contadores

	if(DeltaDown > 150)		CountDown++;
 8002980:	2b96      	cmp	r3, #150	; 0x96
 8002982:	dd29      	ble.n	80029d8 <TOUCH_Task+0xcc>
 8002984:	1c4a      	adds	r2, r1, #1
 8002986:	b2d2      	uxtb	r2, r2
 8002988:	5562      	strb	r2, [r4, r5]
	else if(DeltaUp > 150)	CountUp++;

	if(LastCountUp 	 == CountUp)	MaxCountUp++;
 800298a:	2028      	movs	r0, #40	; 0x28
 800298c:	5c23      	ldrb	r3, [r4, r0]
 800298e:	3301      	adds	r3, #1
 8002990:	b2db      	uxtb	r3, r3
 8002992:	5423      	strb	r3, [r4, r0]
	if(LastCountDown == CountDown)	MaxCountDown++;
 8002994:	4291      	cmp	r1, r2
 8002996:	d026      	beq.n	80029e6 <TOUCH_Task+0xda>
 8002998:	2129      	movs	r1, #41	; 0x29
 800299a:	5c61      	ldrb	r1, [r4, r1]

	if(MaxCountUp > 20)
 800299c:	2b14      	cmp	r3, #20
 800299e:	d904      	bls.n	80029aa <TOUCH_Task+0x9e>
	{
		MaxCountUp = 0;
 80029a0:	2300      	movs	r3, #0
 80029a2:	2028      	movs	r0, #40	; 0x28
 80029a4:	5423      	strb	r3, [r4, r0]
		CountUp = 0;
 80029a6:	3804      	subs	r0, #4
 80029a8:	5423      	strb	r3, [r4, r0]
	}

	if(MaxCountDown > 20)
 80029aa:	2914      	cmp	r1, #20
 80029ac:	d921      	bls.n	80029f2 <TOUCH_Task+0xe6>
	{
		MaxCountDown = 0;
 80029ae:	2300      	movs	r3, #0
 80029b0:	2229      	movs	r2, #41	; 0x29
 80029b2:	54a3      	strb	r3, [r4, r2]
		CountDown = 0;
 80029b4:	3a03      	subs	r2, #3
 80029b6:	54a3      	strb	r3, [r4, r2]
	}

	if((CountDown > 3) || (CountUp > 3))
 80029b8:	2324      	movs	r3, #36	; 0x24
 80029ba:	5ce3      	ldrb	r3, [r4, r3]
 80029bc:	2b03      	cmp	r3, #3
 80029be:	d940      	bls.n	8002a42 <TOUCH_Task+0x136>
	{
		CountUpRelease = 0;
 80029c0:	2300      	movs	r3, #0
 80029c2:	2230      	movs	r2, #48	; 0x30
 80029c4:	54a3      	strb	r3, [r4, r2]
		CountDownRelease = 0;
 80029c6:	3201      	adds	r2, #1
 80029c8:	54a3      	strb	r3, [r4, r2]

		MaxCountUp = 0;
 80029ca:	3a09      	subs	r2, #9
 80029cc:	54a3      	strb	r3, [r4, r2]
		MaxCountDown = 0;
 80029ce:	3201      	adds	r2, #1
 80029d0:	54a3      	strb	r3, [r4, r2]
		{
			Data = 0x24DB09F6; // Equal to D2 in "IrDA.h"
		}
		else if(CountUp > 3)
		{
			Data = 0x24DB51AE; // Equal to B2 in "IrDA.h"
 80029d2:	4b1f      	ldr	r3, [pc, #124]	; (8002a50 <TOUCH_Task+0x144>)
 80029d4:	9301      	str	r3, [sp, #4]
 80029d6:	e019      	b.n	8002a0c <TOUCH_Task+0x100>
	LastCountUp = CountUp;
	LastCountDown = CountDown;
	//Atualiza último valor dos contadores

	if(DeltaDown > 150)		CountDown++;
	else if(DeltaUp > 150)	CountUp++;
 80029d8:	2a96      	cmp	r2, #150	; 0x96
 80029da:	dd2c      	ble.n	8002a36 <TOUCH_Task+0x12a>
 80029dc:	2328      	movs	r3, #40	; 0x28
 80029de:	1c0a      	adds	r2, r1, #0
 80029e0:	3001      	adds	r0, #1
 80029e2:	5ce3      	ldrb	r3, [r4, r3]
 80029e4:	55a0      	strb	r0, [r4, r6]

	if(LastCountUp 	 == CountUp)	MaxCountUp++;
	if(LastCountDown == CountDown)	MaxCountDown++;
 80029e6:	2029      	movs	r0, #41	; 0x29
 80029e8:	5c21      	ldrb	r1, [r4, r0]
 80029ea:	3101      	adds	r1, #1
 80029ec:	b2c9      	uxtb	r1, r1
 80029ee:	5421      	strb	r1, [r4, r0]
 80029f0:	e7d4      	b.n	800299c <TOUCH_Task+0x90>
	{
		MaxCountDown = 0;
		CountDown = 0;
	}

	if((CountDown > 3) || (CountUp > 3))
 80029f2:	2a03      	cmp	r2, #3
 80029f4:	d9e0      	bls.n	80029b8 <TOUCH_Task+0xac>
	{
		CountUpRelease = 0;
 80029f6:	2300      	movs	r3, #0
 80029f8:	2230      	movs	r2, #48	; 0x30
 80029fa:	54a3      	strb	r3, [r4, r2]
		CountDownRelease = 0;
 80029fc:	3201      	adds	r2, #1
 80029fe:	54a3      	strb	r3, [r4, r2]

		MaxCountUp = 0;
 8002a00:	3a09      	subs	r2, #9
 8002a02:	54a3      	strb	r3, [r4, r2]
		MaxCountDown = 0;
 8002a04:	3201      	adds	r2, #1
 8002a06:	54a3      	strb	r3, [r4, r2]

		if(CountDown > 3)
		{
			Data = 0x24DB09F6; // Equal to D2 in "IrDA.h"
 8002a08:	4b12      	ldr	r3, [pc, #72]	; (8002a54 <TOUCH_Task+0x148>)
 8002a0a:	9301      	str	r3, [sp, #4]
		else if(CountUp > 3)
		{
			Data = 0x24DB51AE; // Equal to B2 in "IrDA.h"
		}

		xQueueSendFromISR(*TouchQueueHandler, &Data, &xHigherPriorityTaskWoken);
 8002a0c:	1c22      	adds	r2, r4, #0
 8002a0e:	6823      	ldr	r3, [r4, #0]
 8002a10:	322c      	adds	r2, #44	; 0x2c
 8002a12:	6818      	ldr	r0, [r3, #0]
 8002a14:	a901      	add	r1, sp, #4
 8002a16:	2300      	movs	r3, #0
 8002a18:	f005 ffdc 	bl	80089d4 <xQueueGenericSendFromISR>

		CountDown = 0;
 8002a1c:	2300      	movs	r3, #0
 8002a1e:	2226      	movs	r2, #38	; 0x26
		CountUp   = 0;

		DeltaUp   = 0;
		DeltaDown = 0;

		vTaskDelay(400);
 8002a20:	20c8      	movs	r0, #200	; 0xc8
			Data = 0x24DB51AE; // Equal to B2 in "IrDA.h"
		}

		xQueueSendFromISR(*TouchQueueHandler, &Data, &xHigherPriorityTaskWoken);

		CountDown = 0;
 8002a22:	54a3      	strb	r3, [r4, r2]
		CountUp   = 0;

		DeltaUp   = 0;
		DeltaDown = 0;

		vTaskDelay(400);
 8002a24:	0040      	lsls	r0, r0, #1
		}

		xQueueSendFromISR(*TouchQueueHandler, &Data, &xHigherPriorityTaskWoken);

		CountDown = 0;
		CountUp   = 0;
 8002a26:	3a02      	subs	r2, #2
 8002a28:	54a3      	strb	r3, [r4, r2]

		DeltaUp   = 0;
 8002a2a:	6063      	str	r3, [r4, #4]
		DeltaDown = 0;
 8002a2c:	60a3      	str	r3, [r4, #8]

		vTaskDelay(400);
 8002a2e:	f006 fde3 	bl	80095f8 <vTaskDelay>
	}
	else
	{
		vTaskDelay(10);
	}
}
 8002a32:	b003      	add	sp, #12
 8002a34:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002a36:	1c0a      	adds	r2, r1, #0
 8002a38:	e7a7      	b.n	800298a <TOUCH_Task+0x7e>
	{
		DeltaUp = MeanUp - LastMeanUp;
	}
	else
	{
		DeltaUp = LastMeanUp - MeanUp;
 8002a3a:	1a42      	subs	r2, r0, r1
 8002a3c:	e78e      	b.n	800295c <TOUCH_Task+0x50>
	{
		DeltaDown = MeanDown - LastMeanDown;
	}
	else
	{
		DeltaDown = LastMeanDown - MeanDown;
 8002a3e:	1a0b      	subs	r3, r1, r0
 8002a40:	e786      	b.n	8002950 <TOUCH_Task+0x44>

		vTaskDelay(400);
	}
	else
	{
		vTaskDelay(10);
 8002a42:	200a      	movs	r0, #10
 8002a44:	f006 fdd8 	bl	80095f8 <vTaskDelay>
 8002a48:	e7f3      	b.n	8002a32 <TOUCH_Task+0x126>
 8002a4a:	46c0      	nop			; (mov r8, r8)
 8002a4c:	20000200 	.word	0x20000200
 8002a50:	24db51ae 	.word	0x24db51ae
 8002a54:	24db09f6 	.word	0x24db09f6

08002a58 <Voltmeter_Init>:

//==================================================================================================
//
//==================================================================================================
void Voltmeter_Init(void)
{
 8002a58:	b508      	push	{r3, lr}
	AD_Init();
 8002a5a:	f7fe fdaf 	bl	80015bc <AD_Init>
}
 8002a5e:	bd08      	pop	{r3, pc}

08002a60 <Voltmeter_GetVoltage>:

int16_t Voltmeter_GetVoltage(void)
{
 8002a60:	b508      	push	{r3, lr}
	return AD_GetValue(AD_VOLTMETER);
 8002a62:	2000      	movs	r0, #0
 8002a64:	f7fe fe6e 	bl	8001744 <AD_GetValue>
 8002a68:	b200      	sxth	r0, r0
}
 8002a6a:	bd08      	pop	{r3, pc}

08002a6c <Voltmeter_Task>:
			AD_Volt_Vector[i]=AD_GetValue(AD_VOLTMETER);
		}
		acont=1;
	}
	//return *AD_Volt_Vector;*/
}
 8002a6c:	4770      	bx	lr
 8002a6e:	46c0      	nop			; (mov r8, r8)

08002a70 <NTC_Init>:

//==================================================================================================
//
//==================================================================================================
void NTC_Init (void)
{
 8002a70:	b508      	push	{r3, lr}
	AD_Init();
 8002a72:	f7fe fda3 	bl	80015bc <AD_Init>
}
 8002a76:	bd08      	pop	{r3, pc}

08002a78 <NTC_Error>:

//==================================================================================================
//
//==================================================================================================
void NTC_Error()
{
 8002a78:	b538      	push	{r3, r4, r5, lr}
	NTCError = NTC_OK;
 8002a7a:	2300      	movs	r3, #0
 8002a7c:	4c30      	ldr	r4, [pc, #192]	; (8002b40 <NTC_Error+0xc8>)

	// Inlet temperature reading fail - if value is out of (5° ate 95°) range
	if((AD_GetValue(AD_NTC1)>950) || (AD_GetValue(AD_NTC1)<50))
 8002a7e:	2001      	movs	r0, #1
//==================================================================================================
//
//==================================================================================================
void NTC_Error()
{
	NTCError = NTC_OK;
 8002a80:	7023      	strb	r3, [r4, #0]

	// Inlet temperature reading fail - if value is out of (5° ate 95°) range
	if((AD_GetValue(AD_NTC1)>950) || (AD_GetValue(AD_NTC1)<50))
 8002a82:	f7fe fe5f 	bl	8001744 <AD_GetValue>
 8002a86:	4b2f      	ldr	r3, [pc, #188]	; (8002b44 <NTC_Error+0xcc>)
 8002a88:	4298      	cmp	r0, r3
 8002a8a:	d931      	bls.n	8002af0 <NTC_Error+0x78>
	{
		NTCError = NTC_ERROR_INLET_TEMPERATURE;
 8002a8c:	2301      	movs	r3, #1
	}

	// Outlet temperature reading fail - if value is out of (5° ate 95°) range
	if((AD_GetValue(AD_NTC2)>950) || (AD_GetValue(AD_NTC2)<50))
 8002a8e:	2002      	movs	r0, #2
	NTCError = NTC_OK;

	// Inlet temperature reading fail - if value is out of (5° ate 95°) range
	if((AD_GetValue(AD_NTC1)>950) || (AD_GetValue(AD_NTC1)<50))
	{
		NTCError = NTC_ERROR_INLET_TEMPERATURE;
 8002a90:	7023      	strb	r3, [r4, #0]
	}

	// Outlet temperature reading fail - if value is out of (5° ate 95°) range
	if((AD_GetValue(AD_NTC2)>950) || (AD_GetValue(AD_NTC2)<50))
 8002a92:	f7fe fe57 	bl	8001744 <AD_GetValue>
 8002a96:	4b2b      	ldr	r3, [pc, #172]	; (8002b44 <NTC_Error+0xcc>)
 8002a98:	4298      	cmp	r0, r3
 8002a9a:	d934      	bls.n	8002b06 <NTC_Error+0x8e>
	{
		NTCError = NTC_ERROR_OUTLET_TEMPERATURE;
 8002a9c:	2302      	movs	r3, #2
	}

	// Resistance temperature reading fail - if value is out of (5° ate 95°) range
	if((AD_GetValue(AD_NTC3)>950) || (AD_GetValue(AD_NTC3)<50))
 8002a9e:	2003      	movs	r0, #3
	}

	// Outlet temperature reading fail - if value is out of (5° ate 95°) range
	if((AD_GetValue(AD_NTC2)>950) || (AD_GetValue(AD_NTC2)<50))
	{
		NTCError = NTC_ERROR_OUTLET_TEMPERATURE;
 8002aa0:	7023      	strb	r3, [r4, #0]
	}

	// Resistance temperature reading fail - if value is out of (5° ate 95°) range
	if((AD_GetValue(AD_NTC3)>950) || (AD_GetValue(AD_NTC3)<50))
 8002aa2:	f7fe fe4f 	bl	8001744 <AD_GetValue>
 8002aa6:	4b27      	ldr	r3, [pc, #156]	; (8002b44 <NTC_Error+0xcc>)
 8002aa8:	4298      	cmp	r0, r3
 8002aaa:	d937      	bls.n	8002b1c <NTC_Error+0xa4>
	{
		NTCError = NTC_ERROR_RESISTANCE_TEMPERATURE;
 8002aac:	2303      	movs	r3, #3
 8002aae:	7023      	strb	r3, [r4, #0]
	}

	// Inlet sensor if (TE > TS) e (TE > TA)
	if((AD_GetValue(AD_NTC1)<AD_GetValue(AD_NTC2)) && (AD_GetValue(AD_NTC1)<AD_GetValue(AD_NTC3)))
 8002ab0:	2001      	movs	r0, #1
 8002ab2:	f7fe fe47 	bl	8001744 <AD_GetValue>
 8002ab6:	1c05      	adds	r5, r0, #0
 8002ab8:	2002      	movs	r0, #2
 8002aba:	f7fe fe43 	bl	8001744 <AD_GetValue>
 8002abe:	4285      	cmp	r5, r0
 8002ac0:	d332      	bcc.n	8002b28 <NTC_Error+0xb0>
	{
		NTCError = NTC_ERROR_INLET_SENSOR;
	}

	// Outlet sensor if (TS < TE)
	if(AD_GetValue(AD_NTC2)<AD_GetValue(AD_NTC1))
 8002ac2:	2002      	movs	r0, #2
 8002ac4:	f7fe fe3e 	bl	8001744 <AD_GetValue>
 8002ac8:	1c05      	adds	r5, r0, #0
 8002aca:	2001      	movs	r0, #1
 8002acc:	f7fe fe3a 	bl	8001744 <AD_GetValue>
 8002ad0:	4285      	cmp	r5, r0
 8002ad2:	d201      	bcs.n	8002ad8 <NTC_Error+0x60>
	{
		NTCError = NTC_ERROR_OUTLET_SENSOR;
 8002ad4:	2305      	movs	r3, #5
 8002ad6:	7023      	strb	r3, [r4, #0]
	}

	// Resistance sensor if (TA < TE)
	if(AD_GetValue(AD_NTC3)<AD_GetValue(AD_NTC1))
 8002ad8:	2003      	movs	r0, #3
 8002ada:	f7fe fe33 	bl	8001744 <AD_GetValue>
 8002ade:	1c05      	adds	r5, r0, #0
 8002ae0:	2001      	movs	r0, #1
 8002ae2:	f7fe fe2f 	bl	8001744 <AD_GetValue>
 8002ae6:	4285      	cmp	r5, r0
 8002ae8:	d201      	bcs.n	8002aee <NTC_Error+0x76>
	{
		NTCError = NTC_ERROR_RESISTANCE_SENSOR;
 8002aea:	2306      	movs	r3, #6
 8002aec:	7023      	strb	r3, [r4, #0]
	}
}
 8002aee:	bd38      	pop	{r3, r4, r5, pc}
void NTC_Error()
{
	NTCError = NTC_OK;

	// Inlet temperature reading fail - if value is out of (5° ate 95°) range
	if((AD_GetValue(AD_NTC1)>950) || (AD_GetValue(AD_NTC1)<50))
 8002af0:	2001      	movs	r0, #1
 8002af2:	f7fe fe27 	bl	8001744 <AD_GetValue>
 8002af6:	2831      	cmp	r0, #49	; 0x31
 8002af8:	d9c8      	bls.n	8002a8c <NTC_Error+0x14>
	{
		NTCError = NTC_ERROR_INLET_TEMPERATURE;
	}

	// Outlet temperature reading fail - if value is out of (5° ate 95°) range
	if((AD_GetValue(AD_NTC2)>950) || (AD_GetValue(AD_NTC2)<50))
 8002afa:	2002      	movs	r0, #2
 8002afc:	f7fe fe22 	bl	8001744 <AD_GetValue>
 8002b00:	4b10      	ldr	r3, [pc, #64]	; (8002b44 <NTC_Error+0xcc>)
 8002b02:	4298      	cmp	r0, r3
 8002b04:	d8ca      	bhi.n	8002a9c <NTC_Error+0x24>
 8002b06:	2002      	movs	r0, #2
 8002b08:	f7fe fe1c 	bl	8001744 <AD_GetValue>
 8002b0c:	2831      	cmp	r0, #49	; 0x31
 8002b0e:	d9c5      	bls.n	8002a9c <NTC_Error+0x24>
	{
		NTCError = NTC_ERROR_OUTLET_TEMPERATURE;
	}

	// Resistance temperature reading fail - if value is out of (5° ate 95°) range
	if((AD_GetValue(AD_NTC3)>950) || (AD_GetValue(AD_NTC3)<50))
 8002b10:	2003      	movs	r0, #3
 8002b12:	f7fe fe17 	bl	8001744 <AD_GetValue>
 8002b16:	4b0b      	ldr	r3, [pc, #44]	; (8002b44 <NTC_Error+0xcc>)
 8002b18:	4298      	cmp	r0, r3
 8002b1a:	d8c7      	bhi.n	8002aac <NTC_Error+0x34>
 8002b1c:	2003      	movs	r0, #3
 8002b1e:	f7fe fe11 	bl	8001744 <AD_GetValue>
 8002b22:	2831      	cmp	r0, #49	; 0x31
 8002b24:	d9c2      	bls.n	8002aac <NTC_Error+0x34>
 8002b26:	e7c3      	b.n	8002ab0 <NTC_Error+0x38>
	{
		NTCError = NTC_ERROR_RESISTANCE_TEMPERATURE;
	}

	// Inlet sensor if (TE > TS) e (TE > TA)
	if((AD_GetValue(AD_NTC1)<AD_GetValue(AD_NTC2)) && (AD_GetValue(AD_NTC1)<AD_GetValue(AD_NTC3)))
 8002b28:	2001      	movs	r0, #1
 8002b2a:	f7fe fe0b 	bl	8001744 <AD_GetValue>
 8002b2e:	1c05      	adds	r5, r0, #0
 8002b30:	2003      	movs	r0, #3
 8002b32:	f7fe fe07 	bl	8001744 <AD_GetValue>
 8002b36:	4285      	cmp	r5, r0
 8002b38:	d2c3      	bcs.n	8002ac2 <NTC_Error+0x4a>
	{
		NTCError = NTC_ERROR_INLET_SENSOR;
 8002b3a:	2304      	movs	r3, #4
 8002b3c:	7023      	strb	r3, [r4, #0]
 8002b3e:	e7c0      	b.n	8002ac2 <NTC_Error+0x4a>
 8002b40:	20000234 	.word	0x20000234
 8002b44:	000003b6 	.word	0x000003b6

08002b48 <NTC_GetWaterTemperature>:

//==================================================================================================
//
//==================================================================================================
int16_t NTC_GetWaterTemperature(uint8_t Type)
{
 8002b48:	b510      	push	{r4, lr}
	uint16_t AD_Value = 0;

	if(Type == TEMPERATURE_INLET)
 8002b4a:	2801      	cmp	r0, #1
 8002b4c:	d015      	beq.n	8002b7a <NTC_GetWaterTemperature+0x32>
	{
		AD_Value = AD_GetValue(AD_NTC1);
	}
	else if(Type == TEMPERATURE_OUTLET)
 8002b4e:	2802      	cmp	r0, #2
 8002b50:	d013      	beq.n	8002b7a <NTC_GetWaterTemperature+0x32>
 8002b52:	2400      	movs	r4, #0
	{
		AD_Value = AD_GetValue(AD_NTC2);
	}
	else if(Type == TEMPERATURE_RESISTANCE)
 8002b54:	2803      	cmp	r0, #3
 8002b56:	d010      	beq.n	8002b7a <NTC_GetWaterTemperature+0x32>
	{
		AD_Value = AD_GetValue(AD_NTC3);
	}

	 NTC_Error();
 8002b58:	f7ff ff8e 	bl	8002a78 <NTC_Error>
	/*   |     263     |   1891    |   */
	/*   +-------------+-----------+   */
    /*                                 */
    /***********************************/

	return (int16_t)((AD_Value*0.206)-126);
 8002b5c:	1c20      	adds	r0, r4, #0
 8002b5e:	f002 f91b 	bl	8004d98 <__aeabi_i2d>
 8002b62:	4a08      	ldr	r2, [pc, #32]	; (8002b84 <NTC_GetWaterTemperature+0x3c>)
 8002b64:	4b08      	ldr	r3, [pc, #32]	; (8002b88 <NTC_GetWaterTemperature+0x40>)
 8002b66:	f001 facd 	bl	8004104 <__aeabi_dmul>
 8002b6a:	2200      	movs	r2, #0
 8002b6c:	4b07      	ldr	r3, [pc, #28]	; (8002b8c <NTC_GetWaterTemperature+0x44>)
 8002b6e:	f001 fd63 	bl	8004638 <__aeabi_dsub>
 8002b72:	f002 f8db 	bl	8004d2c <__aeabi_d2iz>
 8002b76:	b200      	sxth	r0, r0
}
 8002b78:	bd10      	pop	{r4, pc}
	{
		AD_Value = AD_GetValue(AD_NTC2);
	}
	else if(Type == TEMPERATURE_RESISTANCE)
	{
		AD_Value = AD_GetValue(AD_NTC3);
 8002b7a:	f7fe fde3 	bl	8001744 <AD_GetValue>
 8002b7e:	1c04      	adds	r4, r0, #0
 8002b80:	e7ea      	b.n	8002b58 <NTC_GetWaterTemperature+0x10>
 8002b82:	46c0      	nop			; (mov r8, r8)
 8002b84:	3f7ced91 	.word	0x3f7ced91
 8002b88:	3fca5e35 	.word	0x3fca5e35
 8002b8c:	405f8000 	.word	0x405f8000

08002b90 <NTC_GetError>:
//==================================================================================================
// Get TRIAC Error
//==================================================================================================
uint8_t NTC_GetError()
{
	return NTCError;
 8002b90:	4b01      	ldr	r3, [pc, #4]	; (8002b98 <NTC_GetError+0x8>)
 8002b92:	7818      	ldrb	r0, [r3, #0]
}
 8002b94:	4770      	bx	lr
 8002b96:	46c0      	nop			; (mov r8, r8)
 8002b98:	20000234 	.word	0x20000234

08002b9c <Screen_ShowError>:

//==================================================================================================
//
//==================================================================================================
void Screen_ShowError()
{
 8002b9c:	b508      	push	{r3, lr}
	if(TRIAC_GetError() == TRIAC_ERROR_T1)
 8002b9e:	f7ff f845 	bl	8001c2c <TRIAC_GetError>
 8002ba2:	2801      	cmp	r0, #1
 8002ba4:	d011      	beq.n	8002bca <Screen_ShowError+0x2e>
	{
		Display_UpdateChar('T', '1'); // Short circuit in TRIAC 1
	}
	if(TRIAC_GetError() == TRIAC_ERROR_T2)
 8002ba6:	f7ff f841 	bl	8001c2c <TRIAC_GetError>
 8002baa:	2802      	cmp	r0, #2
 8002bac:	d015      	beq.n	8002bda <Screen_ShowError+0x3e>
	{
		Display_UpdateChar('T', '2'); // Short circuit in TRIAC 1
	}
	if(TRIAC_GetError() == TRIAC_ERROR_T3)
 8002bae:	f7ff f83d 	bl	8001c2c <TRIAC_GetError>
 8002bb2:	2803      	cmp	r0, #3
 8002bb4:	d019      	beq.n	8002bea <Screen_ShowError+0x4e>
	{
		Display_UpdateChar('T', '3'); // Short circuit in TRIAC 1 and TRIAC 2
	}
	if(TRIAC_GetError() == TRIAC_ERROR_LOST_EDGES)
 8002bb6:	f7ff f839 	bl	8001c2c <TRIAC_GetError>
 8002bba:	2804      	cmp	r0, #4
 8002bbc:	d000      	beq.n	8002bc0 <Screen_ShowError+0x24>
	//if(TRIAC_GetError() == TRIAC_LOST_EDGES_ERROR)
	{
		Display_UpdateChar('E', '8');
	}
}
 8002bbe:	bd08      	pop	{r3, pc}
		Display_UpdateChar('T', '3'); // Short circuit in TRIAC 1 and TRIAC 2
	}
	if(TRIAC_GetError() == TRIAC_ERROR_LOST_EDGES)
	//if(TRIAC_GetError() == TRIAC_LOST_EDGES_ERROR)
	{
		Display_UpdateChar('E', '8');
 8002bc0:	3041      	adds	r0, #65	; 0x41
 8002bc2:	2138      	movs	r1, #56	; 0x38
 8002bc4:	f7fe fad6 	bl	8001174 <Display_UpdateChar>
 8002bc8:	e7f9      	b.n	8002bbe <Screen_ShowError+0x22>
//==================================================================================================
void Screen_ShowError()
{
	if(TRIAC_GetError() == TRIAC_ERROR_T1)
	{
		Display_UpdateChar('T', '1'); // Short circuit in TRIAC 1
 8002bca:	3053      	adds	r0, #83	; 0x53
 8002bcc:	2131      	movs	r1, #49	; 0x31
 8002bce:	f7fe fad1 	bl	8001174 <Display_UpdateChar>
	}
	if(TRIAC_GetError() == TRIAC_ERROR_T2)
 8002bd2:	f7ff f82b 	bl	8001c2c <TRIAC_GetError>
 8002bd6:	2802      	cmp	r0, #2
 8002bd8:	d1e9      	bne.n	8002bae <Screen_ShowError+0x12>
	{
		Display_UpdateChar('T', '2'); // Short circuit in TRIAC 1
 8002bda:	3052      	adds	r0, #82	; 0x52
 8002bdc:	2132      	movs	r1, #50	; 0x32
 8002bde:	f7fe fac9 	bl	8001174 <Display_UpdateChar>
	}
	if(TRIAC_GetError() == TRIAC_ERROR_T3)
 8002be2:	f7ff f823 	bl	8001c2c <TRIAC_GetError>
 8002be6:	2803      	cmp	r0, #3
 8002be8:	d1e5      	bne.n	8002bb6 <Screen_ShowError+0x1a>
	{
		Display_UpdateChar('T', '3'); // Short circuit in TRIAC 1 and TRIAC 2
 8002bea:	3051      	adds	r0, #81	; 0x51
 8002bec:	2133      	movs	r1, #51	; 0x33
 8002bee:	f7fe fac1 	bl	8001174 <Display_UpdateChar>
 8002bf2:	e7e0      	b.n	8002bb6 <Screen_ShowError+0x1a>

08002bf4 <Screen_ShowMessage>:

//==================================================================================================
//
//==================================================================================================
void Screen_ShowMessage(char *Buff, uint8_t SizeBuff)
{
 8002bf4:	b570      	push	{r4, r5, r6, lr}
 8002bf6:	1c03      	adds	r3, r0, #0
	memset(DisplayBuffer, 0x00, sizeof(DisplayBuffer));
 8002bf8:	2500      	movs	r5, #0
 8002bfa:	4c09      	ldr	r4, [pc, #36]	; (8002c20 <Screen_ShowMessage+0x2c>)

//==================================================================================================
//
//==================================================================================================
void Screen_ShowMessage(char *Buff, uint8_t SizeBuff)
{
 8002bfc:	1c0e      	adds	r6, r1, #0
	memset(DisplayBuffer, 0x00, sizeof(DisplayBuffer));
 8002bfe:	6025      	str	r5, [r4, #0]
 8002c00:	6065      	str	r5, [r4, #4]
 8002c02:	60a5      	str	r5, [r4, #8]
 8002c04:	60e5      	str	r5, [r4, #12]
 8002c06:	6125      	str	r5, [r4, #16]
 8002c08:	6165      	str	r5, [r4, #20]
	sprintf((char*)DisplayBuffer, "%s", Buff);
 8002c0a:	1c19      	adds	r1, r3, #0
 8002c0c:	1c20      	adds	r0, r4, #0
 8002c0e:	f007 fc7d 	bl	800a50c <strcpy>
	iSize = SizeBuff;
	iSizeAux = 0;
	Screen = SCREEN_MSG;
 8002c12:	22b0      	movs	r2, #176	; 0xb0
 8002c14:	4b03      	ldr	r3, [pc, #12]	; (8002c24 <Screen_ShowMessage+0x30>)
//==================================================================================================
void Screen_ShowMessage(char *Buff, uint8_t SizeBuff)
{
	memset(DisplayBuffer, 0x00, sizeof(DisplayBuffer));
	sprintf((char*)DisplayBuffer, "%s", Buff);
	iSize = SizeBuff;
 8002c16:	7626      	strb	r6, [r4, #24]
	iSizeAux = 0;
 8002c18:	7665      	strb	r5, [r4, #25]
	Screen = SCREEN_MSG;
 8002c1a:	701a      	strb	r2, [r3, #0]
}
 8002c1c:	bd70      	pop	{r4, r5, r6, pc}
 8002c1e:	46c0      	nop			; (mov r8, r8)
 8002c20:	20000238 	.word	0x20000238
 8002c24:	20000036 	.word	0x20000036

08002c28 <Screen_ShowFrase>:

//==================================================================================================
//
//==================================================================================================
void Screen_ShowFrase(char *Buff, uint8_t SizeBuff)
{
 8002c28:	b570      	push	{r4, r5, r6, lr}
 8002c2a:	1c03      	adds	r3, r0, #0
	memset(DisplayBuffer, 0x00, sizeof(DisplayBuffer));
 8002c2c:	2500      	movs	r5, #0
 8002c2e:	4c08      	ldr	r4, [pc, #32]	; (8002c50 <Screen_ShowFrase+0x28>)

//==================================================================================================
//
//==================================================================================================
void Screen_ShowFrase(char *Buff, uint8_t SizeBuff)
{
 8002c30:	1c0e      	adds	r6, r1, #0
	memset(DisplayBuffer, 0x00, sizeof(DisplayBuffer));
 8002c32:	6025      	str	r5, [r4, #0]
 8002c34:	6065      	str	r5, [r4, #4]
 8002c36:	60a5      	str	r5, [r4, #8]
 8002c38:	60e5      	str	r5, [r4, #12]
 8002c3a:	6125      	str	r5, [r4, #16]
 8002c3c:	6165      	str	r5, [r4, #20]
	sprintf((char*)DisplayBuffer, "%s", Buff);
 8002c3e:	1c19      	adds	r1, r3, #0
 8002c40:	1c20      	adds	r0, r4, #0
 8002c42:	f007 fc63 	bl	800a50c <strcpy>
	iSize = SizeBuff;
	iSizeAux = 0;
	EndBuff = true;
 8002c46:	2301      	movs	r3, #1
//==================================================================================================
void Screen_ShowFrase(char *Buff, uint8_t SizeBuff)
{
	memset(DisplayBuffer, 0x00, sizeof(DisplayBuffer));
	sprintf((char*)DisplayBuffer, "%s", Buff);
	iSize = SizeBuff;
 8002c48:	7626      	strb	r6, [r4, #24]
	iSizeAux = 0;
 8002c4a:	7665      	strb	r5, [r4, #25]
	EndBuff = true;
 8002c4c:	76a3      	strb	r3, [r4, #26]
}
 8002c4e:	bd70      	pop	{r4, r5, r6, pc}
 8002c50:	20000238 	.word	0x20000238

08002c54 <Screen_GetEndMessage>:
  * @param  None
  * @retval TRUE if End of Message or FALSE if Message is being written.
  */
bool Screen_GetEndMessage()
{
	return EndMessage;
 8002c54:	4b01      	ldr	r3, [pc, #4]	; (8002c5c <Screen_GetEndMessage+0x8>)
 8002c56:	7ed8      	ldrb	r0, [r3, #27]
}
 8002c58:	4770      	bx	lr
 8002c5a:	46c0      	nop			; (mov r8, r8)
 8002c5c:	20000238 	.word	0x20000238

08002c60 <Screen_Task>:
//==================================================================================================
//
//==================================================================================================
void Screen_Task(uint16_t TSP, uint8_t PSP, uint8_t UI, uint32_t TPSM, uint16_t VWC,
				 uint16_t EMC, uint16_t GRD, uint16_t EC, uint8_t PD1, uint8_t PD2)
{
 8002c60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002c62:	465f      	mov	r7, fp
 8002c64:	4656      	mov	r6, sl
 8002c66:	464d      	mov	r5, r9
 8002c68:	4644      	mov	r4, r8
 8002c6a:	b4f0      	push	{r4, r5, r6, r7}
 8002c6c:	b083      	sub	sp, #12
 8002c6e:	469a      	mov	sl, r3
 8002c70:	ab0c      	add	r3, sp, #48	; 0x30
 8002c72:	881b      	ldrh	r3, [r3, #0]
 8002c74:	4681      	mov	r9, r0
 8002c76:	4698      	mov	r8, r3
 8002c78:	ab0d      	add	r3, sp, #52	; 0x34
 8002c7a:	881b      	ldrh	r3, [r3, #0]
 8002c7c:	1c0e      	adds	r6, r1, #0
 8002c7e:	469b      	mov	fp, r3
 8002c80:	ab0e      	add	r3, sp, #56	; 0x38
 8002c82:	881b      	ldrh	r3, [r3, #0]
 8002c84:	1c17      	adds	r7, r2, #0
 8002c86:	9300      	str	r3, [sp, #0]
 8002c88:	ab0f      	add	r3, sp, #60	; 0x3c
 8002c8a:	881b      	ldrh	r3, [r3, #0]
 8002c8c:	9301      	str	r3, [sp, #4]
	// PD1	= Password Digit 1
	// PD2	= Password Digit 2

	//static uint8_t PreviousPD1 = 0, PreviousPD2 = 0;

	if((TRIAC_GetError() != TRIAC_OK) && (TRIAC_GetError() != TRIAC_ERROR_LOST_EDGES))
 8002c8e:	f7fe ffcd 	bl	8001c2c <TRIAC_GetError>
 8002c92:	2800      	cmp	r0, #0
 8002c94:	d147      	bne.n	8002d26 <Screen_Task+0xc6>
	{
		Screen_ShowError();
	}
	else
	{
		switch(Screen)
 8002c96:	4dc5      	ldr	r5, [pc, #788]	; (8002fac <Screen_Task+0x34c>)
 8002c98:	782c      	ldrb	r4, [r5, #0]
 8002c9a:	2c23      	cmp	r4, #35	; 0x23
 8002c9c:	d100      	bne.n	8002ca0 <Screen_Task+0x40>
 8002c9e:	e0c9      	b.n	8002e34 <Screen_Task+0x1d4>
 8002ca0:	d821      	bhi.n	8002ce6 <Screen_Task+0x86>
 8002ca2:	2c08      	cmp	r4, #8
 8002ca4:	d100      	bne.n	8002ca8 <Screen_Task+0x48>
 8002ca6:	e07c      	b.n	8002da2 <Screen_Task+0x142>
 8002ca8:	d967      	bls.n	8002d7a <Screen_Task+0x11a>
 8002caa:	2c09      	cmp	r4, #9
 8002cac:	d100      	bne.n	8002cb0 <Screen_Task+0x50>
 8002cae:	e07e      	b.n	8002dae <Screen_Task+0x14e>
 8002cb0:	2c10      	cmp	r4, #16
 8002cb2:	d140      	bne.n	8002d36 <Screen_Task+0xd6>
				break;
			}
			//-------------------------------------------- Show power set point
			case SCREEN_POWER_SETPOINT:
			{
				Display_UpdateChar('P', PSP + 0x30 );
 8002cb4:	2050      	movs	r0, #80	; 0x50
 8002cb6:	3630      	adds	r6, #48	; 0x30
 8002cb8:	b2f1      	uxtb	r1, r6
 8002cba:	f7fe fa5b 	bl	8001174 <Display_UpdateChar>
				if(TimeoutScreen++> TIMEOUT_SCREEN_POWER)
 8002cbe:	4ebc      	ldr	r6, [pc, #752]	; (8002fb0 <Screen_Task+0x350>)
 8002cc0:	7f73      	ldrb	r3, [r6, #29]
 8002cc2:	1c5a      	adds	r2, r3, #1
 8002cc4:	7772      	strb	r2, [r6, #29]
 8002cc6:	2b28      	cmp	r3, #40	; 0x28
 8002cc8:	d969      	bls.n	8002d9e <Screen_Task+0x13e>
			//	Shows the water flow in displays
			{
				Display_UpdateValue(Flowmeter_GetFlow()/10);
				if(TimeoutScreen++> TIMEOUT_SCREEN_FLOW)
				{
					TimeoutScreen = 0;
 8002cca:	2300      	movs	r3, #0
 8002ccc:	7773      	strb	r3, [r6, #29]
					Screen = SCREEN_MAIN;
 8002cce:	33b1      	adds	r3, #177	; 0xb1
 8002cd0:	702b      	strb	r3, [r5, #0]
    {
    	vTaskDelay(600);
    }
    else
    {
    	vTaskDelay(100);
 8002cd2:	2064      	movs	r0, #100	; 0x64
 8002cd4:	f006 fc90 	bl	80095f8 <vTaskDelay>
    }
}
 8002cd8:	b003      	add	sp, #12
 8002cda:	bc3c      	pop	{r2, r3, r4, r5}
 8002cdc:	4690      	mov	r8, r2
 8002cde:	4699      	mov	r9, r3
 8002ce0:	46a2      	mov	sl, r4
 8002ce2:	46ab      	mov	fp, r5
 8002ce4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	{
		Screen_ShowError();
	}
	else
	{
		switch(Screen)
 8002ce6:	2c28      	cmp	r4, #40	; 0x28
 8002ce8:	d100      	bne.n	8002cec <Screen_Task+0x8c>
 8002cea:	e0bb      	b.n	8002e64 <Screen_Task+0x204>
 8002cec:	d92c      	bls.n	8002d48 <Screen_Task+0xe8>
 8002cee:	2cb0      	cmp	r4, #176	; 0xb0
 8002cf0:	d100      	bne.n	8002cf4 <Screen_Task+0x94>
 8002cf2:	e0c0      	b.n	8002e76 <Screen_Task+0x216>
 8002cf4:	2cb1      	cmp	r4, #177	; 0xb1
 8002cf6:	d11e      	bne.n	8002d36 <Screen_Task+0xd6>
			 * -IDLE - It shows in displays two things:
			 * 		every time it shows "--". Times and times it shows the Welcome Message.
			 */
			case SCREEN_MAIN:
			{
				if(MainSubScreen == SCREEN_MAIN_POWER) // POWER
 8002cf8:	78ab      	ldrb	r3, [r5, #2]
 8002cfa:	2b32      	cmp	r3, #50	; 0x32
 8002cfc:	d100      	bne.n	8002d00 <Screen_Task+0xa0>
 8002cfe:	e21a      	b.n	8003136 <Screen_Task+0x4d6>
				{
					Display_UpdateChar('P', PSP + 0x30);
				}
				else if(MainSubScreen == SCREEN_MAIN_TEMPERATURE) // TEMPERATURE
 8002d00:	2b31      	cmp	r3, #49	; 0x31
 8002d02:	d100      	bne.n	8002d06 <Screen_Task+0xa6>
 8002d04:	e21e      	b.n	8003144 <Screen_Task+0x4e4>
				{
					Display_UpdateValue(NTC_GetWaterTemperature(TEMPERATURE_OUTLET));
				}
				else // IDLE, without operation
				{
					if(TimeoutWellcomeMsg > TIMEOUT_WELLCOME_MSG)
 8002d06:	2396      	movs	r3, #150	; 0x96
 8002d08:	4ea9      	ldr	r6, [pc, #676]	; (8002fb0 <Screen_Task+0x350>)
 8002d0a:	00db      	lsls	r3, r3, #3
 8002d0c:	8bf2      	ldrh	r2, [r6, #30]
 8002d0e:	429a      	cmp	r2, r3
 8002d10:	d800      	bhi.n	8002d14 <Screen_Task+0xb4>
 8002d12:	e0d1      	b.n	8002eb8 <Screen_Task+0x258>
					{
						TimeoutWellcomeMsg = 0;
 8002d14:	2300      	movs	r3, #0
						Screen_ShowMessage(MSG_WELLCOME, MSG_WELLCOME_SIZE);
 8002d16:	48a7      	ldr	r0, [pc, #668]	; (8002fb4 <Screen_Task+0x354>)
 8002d18:	210c      	movs	r1, #12
				}
				else // IDLE, without operation
				{
					if(TimeoutWellcomeMsg > TIMEOUT_WELLCOME_MSG)
					{
						TimeoutWellcomeMsg = 0;
 8002d1a:	83f3      	strh	r3, [r6, #30]
						Screen_ShowMessage(MSG_WELLCOME, MSG_WELLCOME_SIZE);
 8002d1c:	f7ff ff6a 	bl	8002bf4 <Screen_ShowMessage>
						NextScreen = SCREEN_MAIN;
 8002d20:	706c      	strb	r4, [r5, #1]
 8002d22:	782c      	ldrb	r4, [r5, #0]
 8002d24:	e007      	b.n	8002d36 <Screen_Task+0xd6>
	// PD1	= Password Digit 1
	// PD2	= Password Digit 2

	//static uint8_t PreviousPD1 = 0, PreviousPD2 = 0;

	if((TRIAC_GetError() != TRIAC_OK) && (TRIAC_GetError() != TRIAC_ERROR_LOST_EDGES))
 8002d26:	f7fe ff81 	bl	8001c2c <TRIAC_GetError>
 8002d2a:	2804      	cmp	r0, #4
 8002d2c:	d0b3      	beq.n	8002c96 <Screen_Task+0x36>
	{
		Screen_ShowError();
 8002d2e:	f7ff ff35 	bl	8002b9c <Screen_ShowError>
 8002d32:	4b9e      	ldr	r3, [pc, #632]	; (8002fac <Screen_Task+0x34c>)
 8002d34:	781c      	ldrb	r4, [r3, #0]
				break;
			}
		}
	}

    if((Screen == SCREEN_MSG) || (Screen == SCREEN_LOGS))
 8002d36:	2cb0      	cmp	r4, #176	; 0xb0
 8002d38:	d001      	beq.n	8002d3e <Screen_Task+0xde>
 8002d3a:	2c28      	cmp	r4, #40	; 0x28
 8002d3c:	d1c9      	bne.n	8002cd2 <Screen_Task+0x72>
    {
    	vTaskDelay(600);
 8002d3e:	2096      	movs	r0, #150	; 0x96
 8002d40:	0080      	lsls	r0, r0, #2
 8002d42:	f006 fc59 	bl	80095f8 <vTaskDelay>
 8002d46:	e7c7      	b.n	8002cd8 <Screen_Task+0x78>
	{
		Screen_ShowError();
	}
	else
	{
		switch(Screen)
 8002d48:	2c24      	cmp	r4, #36	; 0x24
 8002d4a:	d100      	bne.n	8002d4e <Screen_Task+0xee>
 8002d4c:	e086      	b.n	8002e5c <Screen_Task+0x1fc>
 8002d4e:	2c25      	cmp	r4, #37	; 0x25
 8002d50:	d1f1      	bne.n	8002d36 <Screen_Task+0xd6>
				break;
			}
			//-------------------------------------------- Show litters
			case SCREEN_LITERS:
			{
				Display_UpdateValue(VWC/10);
 8002d52:	210a      	movs	r1, #10
 8002d54:	4640      	mov	r0, r8
 8002d56:	f000 fd0d 	bl	8003774 <__aeabi_uidiv>
 8002d5a:	b280      	uxth	r0, r0
 8002d5c:	f7fe fa8c 	bl	8001278 <Display_UpdateValue>
				if(TimeoutScreen++ > TIMEOUT_SCREEN_LITERS)
 8002d60:	4b93      	ldr	r3, [pc, #588]	; (8002fb0 <Screen_Task+0x350>)
 8002d62:	7f5a      	ldrb	r2, [r3, #29]
 8002d64:	1c51      	adds	r1, r2, #1
 8002d66:	7759      	strb	r1, [r3, #29]
 8002d68:	2a28      	cmp	r2, #40	; 0x28
 8002d6a:	d918      	bls.n	8002d9e <Screen_Task+0x13e>
				{
					TimeoutScreen = 0;
 8002d6c:	2200      	movs	r2, #0
 8002d6e:	775a      	strb	r2, [r3, #29]
					TimeoutWellcomeMsg = TIMEOUT_WELLCOME_MSG + 1;
 8002d70:	4a91      	ldr	r2, [pc, #580]	; (8002fb8 <Screen_Task+0x358>)
 8002d72:	83da      	strh	r2, [r3, #30]
					Screen = SCREEN_MAIN;
 8002d74:	23b1      	movs	r3, #177	; 0xb1
 8002d76:	702b      	strb	r3, [r5, #0]
 8002d78:	e7ab      	b.n	8002cd2 <Screen_Task+0x72>
	{
		Screen_ShowError();
	}
	else
	{
		switch(Screen)
 8002d7a:	2c02      	cmp	r4, #2
 8002d7c:	d036      	beq.n	8002dec <Screen_Task+0x18c>
 8002d7e:	2c07      	cmp	r4, #7
 8002d80:	d1d9      	bne.n	8002d36 <Screen_Task+0xd6>
			}
			//-------------------------------------------- Show water flow
			case SCREEN_FLOW:
			//	Shows the water flow in displays
			{
				Display_UpdateValue(Flowmeter_GetFlow()/10);
 8002d82:	f7fe fe31 	bl	80019e8 <Flowmeter_GetFlow>
 8002d86:	210a      	movs	r1, #10
 8002d88:	f000 fcf4 	bl	8003774 <__aeabi_uidiv>
 8002d8c:	b280      	uxth	r0, r0
 8002d8e:	f7fe fa73 	bl	8001278 <Display_UpdateValue>
				if(TimeoutScreen++> TIMEOUT_SCREEN_FLOW)
 8002d92:	4e87      	ldr	r6, [pc, #540]	; (8002fb0 <Screen_Task+0x350>)
 8002d94:	7f73      	ldrb	r3, [r6, #29]
 8002d96:	1c5a      	adds	r2, r3, #1
 8002d98:	7772      	strb	r2, [r6, #29]
 8002d9a:	2b50      	cmp	r3, #80	; 0x50
 8002d9c:	d895      	bhi.n	8002cca <Screen_Task+0x6a>
 8002d9e:	782c      	ldrb	r4, [r5, #0]
 8002da0:	e7c9      	b.n	8002d36 <Screen_Task+0xd6>
				break;
			}
			//-------------------------------------------- Show temperature
			case SCREEN_TEMPERATURE:
			{
				Display_UpdateValue(NTC_GetWaterTemperature(TEMPERATURE_OUTLET));
 8002da2:	2002      	movs	r0, #2
 8002da4:	f7ff fed0 	bl	8002b48 <NTC_GetWaterTemperature>
 8002da8:	f7fe fa66 	bl	8001278 <Display_UpdateValue>
 8002dac:	e787      	b.n	8002cbe <Screen_Task+0x5e>
				break;
			}
			//-------------------------------------------- Show temperature set point
			case SCREEN_TEMPERATURE_SETPOINT:
			{
				Display_UpdateValue(TSP); // Temperature mode
 8002dae:	4648      	mov	r0, r9
 8002db0:	f7fe fa62 	bl	8001278 <Display_UpdateValue>

				/* Frequency of dot blink */
				if(TimeoutScreenBlink++> TIMEOUT_SCREEN_DOT_BLINK) // 0,4s
 8002db4:	2320      	movs	r3, #32
 8002db6:	4e7e      	ldr	r6, [pc, #504]	; (8002fb0 <Screen_Task+0x350>)
 8002db8:	5cf2      	ldrb	r2, [r6, r3]
 8002dba:	1c51      	adds	r1, r2, #1
 8002dbc:	54f1      	strb	r1, [r6, r3]
 8002dbe:	2a04      	cmp	r2, #4
 8002dc0:	d872      	bhi.n	8002ea8 <Screen_Task+0x248>
 8002dc2:	3301      	adds	r3, #1
 8002dc4:	5cf0      	ldrb	r0, [r6, r3]
					// blink = 0x00 -> DOT off
					// blink = 0xFF -> DOT on
					TimeoutScreenBlink = 0;
				}

				Display_UpdatePoints(blink, DISPLAY_POINT_MIDDLE | DISPLAY_POINT_RIGHT);
 8002dc6:	2111      	movs	r1, #17
 8002dc8:	f7fe fa0a 	bl	80011e0 <Display_UpdatePoints>

				/* Time that dots stay blinking */
				if(TimeoutScreen++> TIMEOUT_SCREEN_SETPOINT) // 4s
 8002dcc:	7f73      	ldrb	r3, [r6, #29]
 8002dce:	1c5a      	adds	r2, r3, #1
 8002dd0:	7772      	strb	r2, [r6, #29]
 8002dd2:	2b28      	cmp	r3, #40	; 0x28
 8002dd4:	d9e3      	bls.n	8002d9e <Screen_Task+0x13e>
				{
					blink = 0;
 8002dd6:	2321      	movs	r3, #33	; 0x21
 8002dd8:	2400      	movs	r4, #0
					Display_UpdatePoints(0, DISPLAY_POINT_MIDDLE | DISPLAY_POINT_RIGHT);
 8002dda:	2000      	movs	r0, #0
 8002ddc:	2111      	movs	r1, #17
				Display_UpdatePoints(blink, DISPLAY_POINT_MIDDLE | DISPLAY_POINT_RIGHT);

				/* Time that dots stay blinking */
				if(TimeoutScreen++> TIMEOUT_SCREEN_SETPOINT) // 4s
				{
					blink = 0;
 8002dde:	54f4      	strb	r4, [r6, r3]
					Display_UpdatePoints(0, DISPLAY_POINT_MIDDLE | DISPLAY_POINT_RIGHT);
 8002de0:	f7fe f9fe 	bl	80011e0 <Display_UpdatePoints>
					TimeoutScreen = 0;
					Screen = SCREEN_MAIN;
 8002de4:	23b1      	movs	r3, #177	; 0xb1
				/* Time that dots stay blinking */
				if(TimeoutScreen++> TIMEOUT_SCREEN_SETPOINT) // 4s
				{
					blink = 0;
					Display_UpdatePoints(0, DISPLAY_POINT_MIDDLE | DISPLAY_POINT_RIGHT);
					TimeoutScreen = 0;
 8002de6:	7774      	strb	r4, [r6, #29]
					Screen = SCREEN_MAIN;
 8002de8:	702b      	strb	r3, [r5, #0]
 8002dea:	e772      	b.n	8002cd2 <Screen_Task+0x72>
				break;
			}
			//-------------------------------------------- Show menu
			case SCREEN_MENU:
			{
				TimeoutScreen++;
 8002dec:	4e70      	ldr	r6, [pc, #448]	; (8002fb0 <Screen_Task+0x350>)

				if(MenuSubScreen == SCREEN_MENU_TE) // Temperatura de entrada
 8002dee:	78ea      	ldrb	r2, [r5, #3]
				break;
			}
			//-------------------------------------------- Show menu
			case SCREEN_MENU:
			{
				TimeoutScreen++;
 8002df0:	7f73      	ldrb	r3, [r6, #29]
 8002df2:	3301      	adds	r3, #1
 8002df4:	b2db      	uxtb	r3, r3
 8002df6:	7773      	strb	r3, [r6, #29]

				if(MenuSubScreen == SCREEN_MENU_TE) // Temperatura de entrada
 8002df8:	2aa1      	cmp	r2, #161	; 0xa1
 8002dfa:	d100      	bne.n	8002dfe <Screen_Task+0x19e>
 8002dfc:	e16c      	b.n	80030d8 <Screen_Task+0x478>
					else
					{
						Display_UpdateValue(NTC_GetWaterTemperature(TEMPERATURE_INLET));
					}
				}
				else if(MenuSubScreen == SCREEN_MENU_TS) // Temperatura de saída
 8002dfe:	2aa2      	cmp	r2, #162	; 0xa2
 8002e00:	d063      	beq.n	8002eca <Screen_Task+0x26a>
					else
					{
						Display_UpdateValue(NTC_GetWaterTemperature(TEMPERATURE_OUTLET));
					}
				}
				else if(MenuSubScreen == SCREEN_MENU_LT) // Litros
 8002e02:	2aa3      	cmp	r2, #163	; 0xa3
 8002e04:	d100      	bne.n	8002e08 <Screen_Task+0x1a8>
 8002e06:	e188      	b.n	800311a <Screen_Task+0x4ba>
					{
						Display_UpdateValue(VWC/10);
						//Display_UpdateChar2(SHORTMSG_NOT_APPLIED);
					}
				}
				else if(MenuSubScreen == SCREEN_MENU_VZ) // Vazão
 8002e08:	2aa4      	cmp	r2, #164	; 0xa4
 8002e0a:	d100      	bne.n	8002e0e <Screen_Task+0x1ae>
 8002e0c:	e1a1      	b.n	8003152 <Screen_Task+0x4f2>
					else
					{
						Display_UpdateValue(Flowmeter_GetFlow()/10);
					}
				}
				else if(MenuSubScreen == SCREEN_MENU_TB) // Tempo de banho
 8002e0e:	2aa5      	cmp	r2, #165	; 0xa5
 8002e10:	d100      	bne.n	8002e14 <Screen_Task+0x1b4>
 8002e12:	e1b2      	b.n	800317a <Screen_Task+0x51a>
					else
					{
						Display_UpdateTimeValue(TPSM);
					}
				}
				else if(MenuSubScreen == SCREEN_MENU_LG) // Logs
 8002e14:	2aa6      	cmp	r2, #166	; 0xa6
 8002e16:	d100      	bne.n	8002e1a <Screen_Task+0x1ba>
 8002e18:	e1bf      	b.n	800319a <Screen_Task+0x53a>
						Screen = SCREEN_LOGS;
						EndBuff = false;
						StateLogs = 0;
					}
				}
				else if( MenuSubScreen == SCREEN_MENU_CB) // Custo de banho
 8002e1a:	2aa7      	cmp	r2, #167	; 0xa7
 8002e1c:	d100      	bne.n	8002e20 <Screen_Task+0x1c0>
 8002e1e:	e1ef      	b.n	8003200 <Screen_Task+0x5a0>
					{
						Display_UpdateValue(EMC);
					}
				}

				if(TimeoutScreen > (TIMEOUT_SCREEN_MENU_MSG + TIMEOUT_SCREEN_MENU_DATA))
 8002e20:	2b8c      	cmp	r3, #140	; 0x8c
 8002e22:	d800      	bhi.n	8002e26 <Screen_Task+0x1c6>
 8002e24:	e755      	b.n	8002cd2 <Screen_Task+0x72>
				{
					Screen = ((MenuSubScreen == SCREEN_MENU_LG) ? SCREEN_LOGS : SCREEN_MAIN);
 8002e26:	24b1      	movs	r4, #177	; 0xb1
					MenuSubScreen = SCREEN_MENU_RESET;
 8002e28:	23a0      	movs	r3, #160	; 0xa0
 8002e2a:	70eb      	strb	r3, [r5, #3]
					TimeoutScreen = 0;
 8002e2c:	2300      	movs	r3, #0
					}
				}

				if(TimeoutScreen > (TIMEOUT_SCREEN_MENU_MSG + TIMEOUT_SCREEN_MENU_DATA))
				{
					Screen = ((MenuSubScreen == SCREEN_MENU_LG) ? SCREEN_LOGS : SCREEN_MAIN);
 8002e2e:	702c      	strb	r4, [r5, #0]
					MenuSubScreen = SCREEN_MENU_RESET;
					TimeoutScreen = 0;
 8002e30:	7773      	strb	r3, [r6, #29]
 8002e32:	e780      	b.n	8002d36 <Screen_Task+0xd6>
			//-------------------------------------------- Show TIMER ***************TIMER*****************
			case SCREEN_PASSWORD:
			{
				static uint8_t PasswordDigit1, PasswordDigit2;

				switch(StatePassword)
 8002e34:	2322      	movs	r3, #34	; 0x22
 8002e36:	4e5e      	ldr	r6, [pc, #376]	; (8002fb0 <Screen_Task+0x350>)
 8002e38:	4698      	mov	r8, r3
 8002e3a:	5cf7      	ldrb	r7, [r6, r3]
 8002e3c:	2f01      	cmp	r7, #1
 8002e3e:	d100      	bne.n	8002e42 <Screen_Task+0x1e2>
 8002e40:	e151      	b.n	80030e6 <Screen_Task+0x486>
 8002e42:	2f00      	cmp	r7, #0
 8002e44:	d050      	beq.n	8002ee8 <Screen_Task+0x288>
 8002e46:	2f02      	cmp	r7, #2
 8002e48:	d100      	bne.n	8002e4c <Screen_Task+0x1ec>
 8002e4a:	e15a      	b.n	8003102 <Screen_Task+0x4a2>
						break;
					}

					default:
					{
						Screen = SCREEN_MAIN;
 8002e4c:	23b1      	movs	r3, #177	; 0xb1
 8002e4e:	702b      	strb	r3, [r5, #0]
						TimeoutWellcomeMsg = TIMEOUT_WELLCOME_MSG + 1;
 8002e50:	4b59      	ldr	r3, [pc, #356]	; (8002fb8 <Screen_Task+0x358>)
						StatePassword = 0;
 8002e52:	4642      	mov	r2, r8
					}

					default:
					{
						Screen = SCREEN_MAIN;
						TimeoutWellcomeMsg = TIMEOUT_WELLCOME_MSG + 1;
 8002e54:	83f3      	strh	r3, [r6, #30]
						StatePassword = 0;
 8002e56:	2300      	movs	r3, #0
 8002e58:	54b3      	strb	r3, [r6, r2]
						break;
 8002e5a:	e73a      	b.n	8002cd2 <Screen_Task+0x72>
				break;
			}
			//-------------------------------------------- Show user
			case SCREEN_USER:
			{
				Display_UpdateChar('u',(UI + 1) + 0x30);
 8002e5c:	3731      	adds	r7, #49	; 0x31
 8002e5e:	b2f9      	uxtb	r1, r7
 8002e60:	2075      	movs	r0, #117	; 0x75
 8002e62:	e72a      	b.n	8002cba <Screen_Task+0x5a>
				break;
			}
			//-------------------------------------------- Show Logs
			case SCREEN_LOGS:
			{
				switch(StateLogs)
 8002e64:	4e52      	ldr	r6, [pc, #328]	; (8002fb0 <Screen_Task+0x350>)
 8002e66:	7f33      	ldrb	r3, [r6, #28]
 8002e68:	2b0a      	cmp	r3, #10
 8002e6a:	d900      	bls.n	8002e6e <Screen_Task+0x20e>
 8002e6c:	e17f      	b.n	800316e <Screen_Task+0x50e>
 8002e6e:	4a53      	ldr	r2, [pc, #332]	; (8002fbc <Screen_Task+0x35c>)
 8002e70:	009b      	lsls	r3, r3, #2
 8002e72:	58d3      	ldr	r3, [r2, r3]
 8002e74:	469f      	mov	pc, r3
		switch(Screen)
		{
			//-------------------------------------------- Write message
			case SCREEN_MSG:
			{
				EndMessage = false;
 8002e76:	2600      	movs	r6, #0
 8002e78:	4c4d      	ldr	r4, [pc, #308]	; (8002fb0 <Screen_Task+0x350>)
				StateLogs = 0;
				Display_UpdateChar(DisplayBuffer[iSizeAux], DisplayBuffer[iSizeAux + 1]);
 8002e7a:	7e63      	ldrb	r3, [r4, #25]
		switch(Screen)
		{
			//-------------------------------------------- Write message
			case SCREEN_MSG:
			{
				EndMessage = false;
 8002e7c:	76e6      	strb	r6, [r4, #27]
				StateLogs = 0;
				Display_UpdateChar(DisplayBuffer[iSizeAux], DisplayBuffer[iSizeAux + 1]);
 8002e7e:	5ce0      	ldrb	r0, [r4, r3]
 8002e80:	18e3      	adds	r3, r4, r3
 8002e82:	7859      	ldrb	r1, [r3, #1]
		{
			//-------------------------------------------- Write message
			case SCREEN_MSG:
			{
				EndMessage = false;
				StateLogs = 0;
 8002e84:	7726      	strb	r6, [r4, #28]
				Display_UpdateChar(DisplayBuffer[iSizeAux], DisplayBuffer[iSizeAux + 1]);
 8002e86:	f7fe f975 	bl	8001174 <Display_UpdateChar>
				iSizeAux++;
 8002e8a:	7e63      	ldrb	r3, [r4, #25]
				if(iSizeAux > iSize)
 8002e8c:	7e22      	ldrb	r2, [r4, #24]
			case SCREEN_MSG:
			{
				EndMessage = false;
				StateLogs = 0;
				Display_UpdateChar(DisplayBuffer[iSizeAux], DisplayBuffer[iSizeAux + 1]);
				iSizeAux++;
 8002e8e:	3301      	adds	r3, #1
 8002e90:	b2db      	uxtb	r3, r3
 8002e92:	7663      	strb	r3, [r4, #25]
				if(iSizeAux > iSize)
 8002e94:	429a      	cmp	r2, r3
 8002e96:	d282      	bcs.n	8002d9e <Screen_Task+0x13e>
				{
					iSize = 0;
					iSizeAux = 0;
					TimeoutScreen = 0;
					EndMessage = true;
 8002e98:	2301      	movs	r3, #1
				StateLogs = 0;
				Display_UpdateChar(DisplayBuffer[iSizeAux], DisplayBuffer[iSizeAux + 1]);
				iSizeAux++;
				if(iSizeAux > iSize)
				{
					iSize = 0;
 8002e9a:	7626      	strb	r6, [r4, #24]
					iSizeAux = 0;
 8002e9c:	7666      	strb	r6, [r4, #25]
					TimeoutScreen = 0;
 8002e9e:	7766      	strb	r6, [r4, #29]
					EndMessage = true;
 8002ea0:	76e3      	strb	r3, [r4, #27]
					Screen = NextScreen;
 8002ea2:	786c      	ldrb	r4, [r5, #1]
 8002ea4:	702c      	strb	r4, [r5, #0]
 8002ea6:	e746      	b.n	8002d36 <Screen_Task+0xd6>
				Display_UpdateValue(TSP); // Temperature mode

				/* Frequency of dot blink */
				if(TimeoutScreenBlink++> TIMEOUT_SCREEN_DOT_BLINK) // 0,4s
				{
					blink = ~blink;
 8002ea8:	2221      	movs	r2, #33	; 0x21
 8002eaa:	5cb0      	ldrb	r0, [r6, r2]
 8002eac:	43c0      	mvns	r0, r0
 8002eae:	b2c0      	uxtb	r0, r0
 8002eb0:	54b0      	strb	r0, [r6, r2]
					// blink = 0x00 -> DOT off
					// blink = 0xFF -> DOT on
					TimeoutScreenBlink = 0;
 8002eb2:	2200      	movs	r2, #0
 8002eb4:	54f2      	strb	r2, [r6, r3]
 8002eb6:	e786      	b.n	8002dc6 <Screen_Task+0x166>
						Screen_ShowMessage(MSG_WELLCOME, MSG_WELLCOME_SIZE);
						NextScreen = SCREEN_MAIN;
					}
					else
					{
						Display_UpdateChar('-','-');
 8002eb8:	202d      	movs	r0, #45	; 0x2d
 8002eba:	212d      	movs	r1, #45	; 0x2d
 8002ebc:	f7fe f95a 	bl	8001174 <Display_UpdateChar>
						TimeoutWellcomeMsg++;
 8002ec0:	8bf3      	ldrh	r3, [r6, #30]
 8002ec2:	782c      	ldrb	r4, [r5, #0]
 8002ec4:	3301      	adds	r3, #1
 8002ec6:	83f3      	strh	r3, [r6, #30]
 8002ec8:	e735      	b.n	8002d36 <Screen_Task+0xd6>
						Display_UpdateValue(NTC_GetWaterTemperature(TEMPERATURE_INLET));
					}
				}
				else if(MenuSubScreen == SCREEN_MENU_TS) // Temperatura de saída
				{
					if(TimeoutScreen < TIMEOUT_SCREEN_MENU_MSG)
 8002eca:	2b27      	cmp	r3, #39	; 0x27
 8002ecc:	d900      	bls.n	8002ed0 <Screen_Task+0x270>
 8002ece:	e147      	b.n	8003160 <Screen_Task+0x500>
					{
						Display_UpdateChar2(SHORTMSG_OUTLET_TEMPERATURE);
 8002ed0:	483b      	ldr	r0, [pc, #236]	; (8002fc0 <Screen_Task+0x360>)
 8002ed2:	f7fe f969 	bl	80011a8 <Display_UpdateChar2>
 8002ed6:	7f73      	ldrb	r3, [r6, #29]
					{
						Display_UpdateValue(EMC);
					}
				}

				if(TimeoutScreen > (TIMEOUT_SCREEN_MENU_MSG + TIMEOUT_SCREEN_MENU_DATA))
 8002ed8:	2b8c      	cmp	r3, #140	; 0x8c
 8002eda:	d800      	bhi.n	8002ede <Screen_Task+0x27e>
 8002edc:	e75f      	b.n	8002d9e <Screen_Task+0x13e>
				{
					Screen = ((MenuSubScreen == SCREEN_MENU_LG) ? SCREEN_LOGS : SCREEN_MAIN);
 8002ede:	78eb      	ldrb	r3, [r5, #3]
 8002ee0:	2ba6      	cmp	r3, #166	; 0xa6
 8002ee2:	d1a0      	bne.n	8002e26 <Screen_Task+0x1c6>
 8002ee4:	2428      	movs	r4, #40	; 0x28
 8002ee6:	e79f      	b.n	8002e28 <Screen_Task+0x1c8>

				switch(StatePassword)
				{
					case 0:
					{
						PasswordDigit1 = PasswordDigit2 = 16; // 16 -->> "_"
 8002ee8:	2310      	movs	r3, #16
 8002eea:	2224      	movs	r2, #36	; 0x24
						Display_UpdateDecimal(PasswordDigit1, PasswordDigit2); // Print "_ _"
 8002eec:	2010      	movs	r0, #16
 8002eee:	2110      	movs	r1, #16

				switch(StatePassword)
				{
					case 0:
					{
						PasswordDigit1 = PasswordDigit2 = 16; // 16 -->> "_"
 8002ef0:	5533      	strb	r3, [r6, r4]
 8002ef2:	54b3      	strb	r3, [r6, r2]
						Display_UpdateDecimal(PasswordDigit1, PasswordDigit2); // Print "_ _"
 8002ef4:	f7fe f980 	bl	80011f8 <Display_UpdateDecimal>

						//PreviousPD1 = PD1;
						//PreviousPD2 = PD2;

						TimeoutScreen = 0;
						StatePassword = 1;
 8002ef8:	2301      	movs	r3, #1
 8002efa:	4642      	mov	r2, r8
						Display_UpdateDecimal(PasswordDigit1, PasswordDigit2); // Print "_ _"

						//PreviousPD1 = PD1;
						//PreviousPD2 = PD2;

						TimeoutScreen = 0;
 8002efc:	7777      	strb	r7, [r6, #29]
						StatePassword = 1;
 8002efe:	54b3      	strb	r3, [r6, r2]
 8002f00:	782c      	ldrb	r4, [r5, #0]
						break;
 8002f02:	e718      	b.n	8002d36 <Screen_Task+0xd6>
						}
						break;
					}
					case 9: //************************************ Show energy consumption
					{
						Display_UpdateValue(EMC);
 8002f04:	4658      	mov	r0, fp
 8002f06:	f7fe f9b7 	bl	8001278 <Display_UpdateValue>
						if(TimeoutScreen++ > TIMEOUT_SCREEN_GRADE)
 8002f0a:	7f73      	ldrb	r3, [r6, #29]
 8002f0c:	1c5a      	adds	r2, r3, #1
 8002f0e:	7772      	strb	r2, [r6, #29]
 8002f10:	2b03      	cmp	r3, #3
 8002f12:	d800      	bhi.n	8002f16 <Screen_Task+0x2b6>
 8002f14:	e170      	b.n	80031f8 <Screen_Task+0x598>
						{
							TimeoutScreen = 0;
 8002f16:	2300      	movs	r3, #0
 8002f18:	7773      	strb	r3, [r6, #29]
							StateLogs = 10;
 8002f1a:	330a      	adds	r3, #10
 8002f1c:	7733      	strb	r3, [r6, #28]
 8002f1e:	782c      	ldrb	r4, [r5, #0]
 8002f20:	e709      	b.n	8002d36 <Screen_Task+0xd6>
						break;
					}
					//-------------------------------------------- Show estimated monthly cost
					case 8:
					{
						if(!EndBuff)
 8002f22:	7eb3      	ldrb	r3, [r6, #26]
 8002f24:	2b00      	cmp	r3, #0
 8002f26:	d100      	bne.n	8002f2a <Screen_Task+0x2ca>
 8002f28:	e185      	b.n	8003236 <Screen_Task+0x5d6>
						{
							Screen_ShowFrase(MSG_ESTIMATED_MONTHLY_COST, MSG_ESTIMATED_MONTHLY_COST_SIZE);
						}
						Display_UpdateChar(DisplayBuffer[iSizeAux], DisplayBuffer[iSizeAux + 1]);
 8002f2a:	7e73      	ldrb	r3, [r6, #25]
 8002f2c:	5cf0      	ldrb	r0, [r6, r3]
 8002f2e:	18f3      	adds	r3, r6, r3
 8002f30:	7859      	ldrb	r1, [r3, #1]
 8002f32:	f7fe f91f 	bl	8001174 <Display_UpdateChar>
						iSizeAux++;
 8002f36:	7e73      	ldrb	r3, [r6, #25]
						if(iSizeAux > iSize)
 8002f38:	7e32      	ldrb	r2, [r6, #24]
						if(!EndBuff)
						{
							Screen_ShowFrase(MSG_ESTIMATED_MONTHLY_COST, MSG_ESTIMATED_MONTHLY_COST_SIZE);
						}
						Display_UpdateChar(DisplayBuffer[iSizeAux], DisplayBuffer[iSizeAux + 1]);
						iSizeAux++;
 8002f3a:	3301      	adds	r3, #1
 8002f3c:	b2db      	uxtb	r3, r3
 8002f3e:	7673      	strb	r3, [r6, #25]
						if(iSizeAux > iSize)
 8002f40:	429a      	cmp	r2, r3
 8002f42:	d300      	bcc.n	8002f46 <Screen_Task+0x2e6>
 8002f44:	e13c      	b.n	80031c0 <Screen_Task+0x560>
						{
							iSize = 0;
 8002f46:	2300      	movs	r3, #0
 8002f48:	7633      	strb	r3, [r6, #24]
							iSizeAux = 0;
 8002f4a:	7673      	strb	r3, [r6, #25]
							TimeoutScreen = 0;
 8002f4c:	7773      	strb	r3, [r6, #29]
							EndBuff = false;
 8002f4e:	76b3      	strb	r3, [r6, #26]
							StateLogs = 9;
 8002f50:	3309      	adds	r3, #9
 8002f52:	7733      	strb	r3, [r6, #28]
 8002f54:	782c      	ldrb	r4, [r5, #0]
 8002f56:	e6ee      	b.n	8002d36 <Screen_Task+0xd6>
						}
						break;
					}
					case 5: //************************************ Show shower period
					{
						Display_UpdateValue(TPSM);
 8002f58:	4650      	mov	r0, sl
 8002f5a:	f7fe f98d 	bl	8001278 <Display_UpdateValue>
						if(TimeoutScreen++ > TIMEOUT_SCREEN_GRADE)
 8002f5e:	7f73      	ldrb	r3, [r6, #29]
 8002f60:	1c5a      	adds	r2, r3, #1
 8002f62:	7772      	strb	r2, [r6, #29]
 8002f64:	2b03      	cmp	r3, #3
 8002f66:	d800      	bhi.n	8002f6a <Screen_Task+0x30a>
 8002f68:	e122      	b.n	80031b0 <Screen_Task+0x550>
						{
							TimeoutScreen = 0;
 8002f6a:	2300      	movs	r3, #0
 8002f6c:	7773      	strb	r3, [r6, #29]
							StateLogs = 6;
 8002f6e:	3306      	adds	r3, #6
 8002f70:	7733      	strb	r3, [r6, #28]
 8002f72:	782c      	ldrb	r4, [r5, #0]
 8002f74:	e6df      	b.n	8002d36 <Screen_Task+0xd6>
						break;
					}
					//-------------------------------------------- Show shower period
					case 4:
					{
						if(!EndBuff)
 8002f76:	7eb3      	ldrb	r3, [r6, #26]
 8002f78:	2b00      	cmp	r3, #0
 8002f7a:	d100      	bne.n	8002f7e <Screen_Task+0x31e>
 8002f7c:	e14c      	b.n	8003218 <Screen_Task+0x5b8>
						{
							Screen_ShowFrase(MSG_SHOWER_PERIOD, MSG_SHOWER_PERIOD_SIZE);
						}

						Display_UpdateChar(DisplayBuffer[iSizeAux], DisplayBuffer[iSizeAux + 1]);
 8002f7e:	7e73      	ldrb	r3, [r6, #25]
 8002f80:	5cf0      	ldrb	r0, [r6, r3]
 8002f82:	18f3      	adds	r3, r6, r3
 8002f84:	7859      	ldrb	r1, [r3, #1]
 8002f86:	f7fe f8f5 	bl	8001174 <Display_UpdateChar>
						iSizeAux++;
 8002f8a:	7e73      	ldrb	r3, [r6, #25]
						if(iSizeAux > iSize)
 8002f8c:	7e32      	ldrb	r2, [r6, #24]
						{
							Screen_ShowFrase(MSG_SHOWER_PERIOD, MSG_SHOWER_PERIOD_SIZE);
						}

						Display_UpdateChar(DisplayBuffer[iSizeAux], DisplayBuffer[iSizeAux + 1]);
						iSizeAux++;
 8002f8e:	3301      	adds	r3, #1
 8002f90:	b2db      	uxtb	r3, r3
 8002f92:	7673      	strb	r3, [r6, #25]
						if(iSizeAux > iSize)
 8002f94:	429a      	cmp	r2, r3
 8002f96:	d300      	bcc.n	8002f9a <Screen_Task+0x33a>
 8002f98:	e12a      	b.n	80031f0 <Screen_Task+0x590>
						{
							iSize = 0;
 8002f9a:	2300      	movs	r3, #0
 8002f9c:	7633      	strb	r3, [r6, #24]
							iSizeAux = 0;
 8002f9e:	7673      	strb	r3, [r6, #25]
							TimeoutScreen = 0;
 8002fa0:	7773      	strb	r3, [r6, #29]
							EndBuff = false;
 8002fa2:	76b3      	strb	r3, [r6, #26]
							StateLogs = 5;
 8002fa4:	3305      	adds	r3, #5
 8002fa6:	7733      	strb	r3, [r6, #28]
 8002fa8:	782c      	ldrb	r4, [r5, #0]
 8002faa:	e6c4      	b.n	8002d36 <Screen_Task+0xd6>
 8002fac:	20000036 	.word	0x20000036
 8002fb0:	20000238 	.word	0x20000238
 8002fb4:	0800ab40 	.word	0x0800ab40
 8002fb8:	000004b1 	.word	0x000004b1
 8002fbc:	0800a944 	.word	0x0800a944
 8002fc0:	0800ab58 	.word	0x0800ab58
						}
						break;
					}
					case 7: //************************************ Show energy consumption
					{
						Display_UpdateValue(EC);
 8002fc4:	9801      	ldr	r0, [sp, #4]
 8002fc6:	f7fe f957 	bl	8001278 <Display_UpdateValue>
						if(TimeoutScreen++ > TIMEOUT_SCREEN_GRADE)
 8002fca:	7f73      	ldrb	r3, [r6, #29]
 8002fcc:	1c5a      	adds	r2, r3, #1
 8002fce:	7772      	strb	r2, [r6, #29]
 8002fd0:	2b03      	cmp	r3, #3
 8002fd2:	d800      	bhi.n	8002fd6 <Screen_Task+0x376>
 8002fd4:	e0f0      	b.n	80031b8 <Screen_Task+0x558>
						{
							TimeoutScreen = 0;
 8002fd6:	2300      	movs	r3, #0
 8002fd8:	7773      	strb	r3, [r6, #29]
							StateLogs = 8;
 8002fda:	3308      	adds	r3, #8
 8002fdc:	7733      	strb	r3, [r6, #28]
 8002fde:	782c      	ldrb	r4, [r5, #0]
 8002fe0:	e6a9      	b.n	8002d36 <Screen_Task+0xd6>
						break;
					}
					//-------------------------------------------- Show energy consumption
					case 6:
					{
						if(!EndBuff)
 8002fe2:	7eb3      	ldrb	r3, [r6, #26]
 8002fe4:	2b00      	cmp	r3, #0
 8002fe6:	d100      	bne.n	8002fea <Screen_Task+0x38a>
 8002fe8:	e11b      	b.n	8003222 <Screen_Task+0x5c2>
						{
							Screen_ShowFrase(MSG_ENERGY_CONSUMPTION, MSG_ENERGY_CONSUMPTION_SIZE);
						}
						Display_UpdateChar(DisplayBuffer[iSizeAux], DisplayBuffer[iSizeAux + 1]);
 8002fea:	7e73      	ldrb	r3, [r6, #25]
 8002fec:	5cf0      	ldrb	r0, [r6, r3]
 8002fee:	18f3      	adds	r3, r6, r3
 8002ff0:	7859      	ldrb	r1, [r3, #1]
 8002ff2:	f7fe f8bf 	bl	8001174 <Display_UpdateChar>
						iSizeAux++;
 8002ff6:	7e73      	ldrb	r3, [r6, #25]
						if(iSizeAux > iSize)
 8002ff8:	7e32      	ldrb	r2, [r6, #24]
						if(!EndBuff)
						{
							Screen_ShowFrase(MSG_ENERGY_CONSUMPTION, MSG_ENERGY_CONSUMPTION_SIZE);
						}
						Display_UpdateChar(DisplayBuffer[iSizeAux], DisplayBuffer[iSizeAux + 1]);
						iSizeAux++;
 8002ffa:	3301      	adds	r3, #1
 8002ffc:	b2db      	uxtb	r3, r3
 8002ffe:	7673      	strb	r3, [r6, #25]
						if(iSizeAux > iSize)
 8003000:	429a      	cmp	r2, r3
 8003002:	d300      	bcc.n	8003006 <Screen_Task+0x3a6>
 8003004:	e0e4      	b.n	80031d0 <Screen_Task+0x570>
						{
							iSize = 0;
 8003006:	2300      	movs	r3, #0
 8003008:	7633      	strb	r3, [r6, #24]
							iSizeAux = 0;
 800300a:	7673      	strb	r3, [r6, #25]
							TimeoutScreen = 0;
 800300c:	7773      	strb	r3, [r6, #29]
							EndBuff = false;
 800300e:	76b3      	strb	r3, [r6, #26]
							StateLogs = 7;
 8003010:	3307      	adds	r3, #7
 8003012:	7733      	strb	r3, [r6, #28]
 8003014:	782c      	ldrb	r4, [r5, #0]
 8003016:	e68e      	b.n	8002d36 <Screen_Task+0xd6>

						break;
					}
					case 1: //************************************ Show grade value
					{
						Display_UpdateValue(GRD);
 8003018:	9800      	ldr	r0, [sp, #0]
 800301a:	f7fe f92d 	bl	8001278 <Display_UpdateValue>
						if(TimeoutScreen++ > TIMEOUT_SCREEN_GRADE)
 800301e:	7f73      	ldrb	r3, [r6, #29]
 8003020:	1c5a      	adds	r2, r3, #1
 8003022:	7772      	strb	r2, [r6, #29]
 8003024:	2b03      	cmp	r3, #3
 8003026:	d800      	bhi.n	800302a <Screen_Task+0x3ca>
 8003028:	e0da      	b.n	80031e0 <Screen_Task+0x580>
						{
							TimeoutScreen = 0;
 800302a:	2300      	movs	r3, #0
 800302c:	7773      	strb	r3, [r6, #29]
							StateLogs = 2;
 800302e:	3302      	adds	r3, #2
 8003030:	7733      	strb	r3, [r6, #28]
 8003032:	782c      	ldrb	r4, [r5, #0]
 8003034:	e67f      	b.n	8002d36 <Screen_Task+0xd6>
				switch(StateLogs)
				{
					//-------------------------------------------- Show grade
					case 0:
					{
						if(!EndBuff)
 8003036:	7eb3      	ldrb	r3, [r6, #26]
 8003038:	2b00      	cmp	r3, #0
 800303a:	d100      	bne.n	800303e <Screen_Task+0x3de>
 800303c:	e100      	b.n	8003240 <Screen_Task+0x5e0>
						{
							Screen_ShowFrase(MSG_GRADE, MSG_GRADE_SIZE);
						}

						Display_UpdateChar(DisplayBuffer[iSizeAux], DisplayBuffer[iSizeAux + 1]);
 800303e:	7e73      	ldrb	r3, [r6, #25]
 8003040:	5cf0      	ldrb	r0, [r6, r3]
 8003042:	18f3      	adds	r3, r6, r3
 8003044:	7859      	ldrb	r1, [r3, #1]
 8003046:	f7fe f895 	bl	8001174 <Display_UpdateChar>
						iSizeAux++;
 800304a:	7e73      	ldrb	r3, [r6, #25]

						if(iSizeAux > iSize)
 800304c:	7e32      	ldrb	r2, [r6, #24]
						{
							Screen_ShowFrase(MSG_GRADE, MSG_GRADE_SIZE);
						}

						Display_UpdateChar(DisplayBuffer[iSizeAux], DisplayBuffer[iSizeAux + 1]);
						iSizeAux++;
 800304e:	3301      	adds	r3, #1
 8003050:	b2db      	uxtb	r3, r3
 8003052:	7673      	strb	r3, [r6, #25]

						if(iSizeAux > iSize)
 8003054:	429a      	cmp	r2, r3
 8003056:	d300      	bcc.n	800305a <Screen_Task+0x3fa>
 8003058:	e0b6      	b.n	80031c8 <Screen_Task+0x568>
						{
							iSize = 0;
 800305a:	2300      	movs	r3, #0
 800305c:	7633      	strb	r3, [r6, #24]
							iSizeAux = 0;
 800305e:	7673      	strb	r3, [r6, #25]
							TimeoutScreen = 0;
 8003060:	7773      	strb	r3, [r6, #29]
							EndBuff = false;
 8003062:	76b3      	strb	r3, [r6, #26]
							StateLogs = 1;
 8003064:	3301      	adds	r3, #1
 8003066:	7733      	strb	r3, [r6, #28]
 8003068:	782c      	ldrb	r4, [r5, #0]
 800306a:	e664      	b.n	8002d36 <Screen_Task+0xd6>
						}
						break;
					}
					case 3: //************************************ Show water consumption
					{
						Display_UpdateValue(VWC/10);
 800306c:	210a      	movs	r1, #10
 800306e:	4640      	mov	r0, r8
 8003070:	f000 fb80 	bl	8003774 <__aeabi_uidiv>
 8003074:	b280      	uxth	r0, r0
 8003076:	f7fe f8ff 	bl	8001278 <Display_UpdateValue>
						if(TimeoutScreen++ > TIMEOUT_SCREEN_GRADE)
 800307a:	7f73      	ldrb	r3, [r6, #29]
 800307c:	1c5a      	adds	r2, r3, #1
 800307e:	7772      	strb	r2, [r6, #29]
 8003080:	2b03      	cmp	r3, #3
 8003082:	d800      	bhi.n	8003086 <Screen_Task+0x426>
 8003084:	e0b0      	b.n	80031e8 <Screen_Task+0x588>
						{
							TimeoutScreen = 0;
 8003086:	2300      	movs	r3, #0
 8003088:	7773      	strb	r3, [r6, #29]
							StateLogs = 4;
 800308a:	3304      	adds	r3, #4
 800308c:	7733      	strb	r3, [r6, #28]
 800308e:	782c      	ldrb	r4, [r5, #0]
 8003090:	e651      	b.n	8002d36 <Screen_Task+0xd6>
						break;
					}
					//-------------------------------------------- Show water consumption
					case 2:
					{
						if(!EndBuff)
 8003092:	7eb3      	ldrb	r3, [r6, #26]
 8003094:	2b00      	cmp	r3, #0
 8003096:	d100      	bne.n	800309a <Screen_Task+0x43a>
 8003098:	e0c8      	b.n	800322c <Screen_Task+0x5cc>
						{
							Screen_ShowFrase(MSG_WATER_CONSUMPTION, MSG_WATER_CONSUMPTION_SIZE);
						}

						Display_UpdateChar(DisplayBuffer[iSizeAux], DisplayBuffer[iSizeAux + 1]);
 800309a:	7e73      	ldrb	r3, [r6, #25]
 800309c:	5cf0      	ldrb	r0, [r6, r3]
 800309e:	18f3      	adds	r3, r6, r3
 80030a0:	7859      	ldrb	r1, [r3, #1]
 80030a2:	f7fe f867 	bl	8001174 <Display_UpdateChar>
						iSizeAux++;
 80030a6:	7e73      	ldrb	r3, [r6, #25]
						if(iSizeAux > iSize)
 80030a8:	7e32      	ldrb	r2, [r6, #24]
						{
							Screen_ShowFrase(MSG_WATER_CONSUMPTION, MSG_WATER_CONSUMPTION_SIZE);
						}

						Display_UpdateChar(DisplayBuffer[iSizeAux], DisplayBuffer[iSizeAux + 1]);
						iSizeAux++;
 80030aa:	3301      	adds	r3, #1
 80030ac:	b2db      	uxtb	r3, r3
 80030ae:	7673      	strb	r3, [r6, #25]
						if(iSizeAux > iSize)
 80030b0:	429a      	cmp	r2, r3
 80030b2:	d300      	bcc.n	80030b6 <Screen_Task+0x456>
 80030b4:	e090      	b.n	80031d8 <Screen_Task+0x578>
						{
							iSize = 0;
 80030b6:	2300      	movs	r3, #0
 80030b8:	7633      	strb	r3, [r6, #24]
							iSizeAux = 0;
 80030ba:	7673      	strb	r3, [r6, #25]
							TimeoutScreen = 0;
 80030bc:	7773      	strb	r3, [r6, #29]
							EndBuff = false;
 80030be:	76b3      	strb	r3, [r6, #26]
							StateLogs = 3;
 80030c0:	3303      	adds	r3, #3
 80030c2:	7733      	strb	r3, [r6, #28]
 80030c4:	782c      	ldrb	r4, [r5, #0]
 80030c6:	e636      	b.n	8002d36 <Screen_Task+0xd6>
					}

					//-------------------------------------------- End state machine
					case 10:
					{
						Screen = SCREEN_MAIN;
 80030c8:	23b1      	movs	r3, #177	; 0xb1
 80030ca:	702b      	strb	r3, [r5, #0]
						TimeoutWellcomeMsg = TIMEOUT_WELLCOME_MSG + 1;
 80030cc:	4b64      	ldr	r3, [pc, #400]	; (8003260 <Screen_Task+0x600>)
 80030ce:	83f3      	strh	r3, [r6, #30]
						EndBuff = false;
 80030d0:	2300      	movs	r3, #0
 80030d2:	76b3      	strb	r3, [r6, #26]
						StateLogs = 0;
 80030d4:	7733      	strb	r3, [r6, #28]
						break;
 80030d6:	e5fc      	b.n	8002cd2 <Screen_Task+0x72>
			{
				TimeoutScreen++;

				if(MenuSubScreen == SCREEN_MENU_TE) // Temperatura de entrada
				{
					if(TimeoutScreen < TIMEOUT_SCREEN_MENU_MSG)
 80030d8:	2b27      	cmp	r3, #39	; 0x27
 80030da:	d825      	bhi.n	8003128 <Screen_Task+0x4c8>
					{
						Display_UpdateChar2(SHORTMSG_INLET_TEMPERATURE);
 80030dc:	4861      	ldr	r0, [pc, #388]	; (8003264 <Screen_Task+0x604>)
 80030de:	f7fe f863 	bl	80011a8 <Display_UpdateChar2>
 80030e2:	7f73      	ldrb	r3, [r6, #29]
 80030e4:	e6f8      	b.n	8002ed8 <Screen_Task+0x278>
						break;
					}

					case 1:
					{
						if(TimeoutScreen++ > TIMEOUT_SCREEN_PASSWORD)
 80030e6:	7f73      	ldrb	r3, [r6, #29]
 80030e8:	1c5a      	adds	r2, r3, #1
 80030ea:	7772      	strb	r2, [r6, #29]
 80030ec:	2b28      	cmp	r3, #40	; 0x28
 80030ee:	d802      	bhi.n	80030f6 <Screen_Task+0x496>
									PasswordDigit2 = 0;
								}
								Display_UpdateDecimal(PasswordDigit2, PasswordDigit1);
							}*/

							StatePassword = 1;
 80030f0:	4643      	mov	r3, r8
 80030f2:	54f7      	strb	r7, [r6, r3]
 80030f4:	e5ed      	b.n	8002cd2 <Screen_Task+0x72>
					}
					case 2:
					{
						if(TimeoutScreen++ > TIMEOUT_SCREEN_PASSWORD)
						{
							TimeoutScreen = 0;
 80030f6:	2300      	movs	r3, #0
							StatePassword = 3;
 80030f8:	4642      	mov	r2, r8
					}
					case 2:
					{
						if(TimeoutScreen++ > TIMEOUT_SCREEN_PASSWORD)
						{
							TimeoutScreen = 0;
 80030fa:	7773      	strb	r3, [r6, #29]
							StatePassword = 3;
 80030fc:	3303      	adds	r3, #3
 80030fe:	54b3      	strb	r3, [r6, r2]
 8003100:	e5e7      	b.n	8002cd2 <Screen_Task+0x72>
						}
						break;
					}
					case 2:
					{
						if(TimeoutScreen++ > TIMEOUT_SCREEN_PASSWORD)
 8003102:	7f73      	ldrb	r3, [r6, #29]
 8003104:	1c5a      	adds	r2, r3, #1
 8003106:	7772      	strb	r2, [r6, #29]
 8003108:	2b28      	cmp	r3, #40	; 0x28
 800310a:	d8f4      	bhi.n	80030f6 <Screen_Task+0x496>
								}
								Display_UpdateDecimal(PasswordDigit2, PasswordDigit1);
							}
							*/

							Display_UpdateChar2(SHORTMSG_PERIOD_ON);
 800310c:	4856      	ldr	r0, [pc, #344]	; (8003268 <Screen_Task+0x608>)
 800310e:	f7fe f84b 	bl	80011a8 <Display_UpdateChar2>
							StatePassword = 2;
 8003112:	4643      	mov	r3, r8
 8003114:	782c      	ldrb	r4, [r5, #0]
 8003116:	54f7      	strb	r7, [r6, r3]
 8003118:	e60d      	b.n	8002d36 <Screen_Task+0xd6>
						Display_UpdateValue(NTC_GetWaterTemperature(TEMPERATURE_OUTLET));
					}
				}
				else if(MenuSubScreen == SCREEN_MENU_LT) // Litros
				{
					if(TimeoutScreen < TIMEOUT_SCREEN_MENU_MSG)
 800311a:	2b27      	cmp	r3, #39	; 0x27
 800311c:	d834      	bhi.n	8003188 <Screen_Task+0x528>
					{
						Display_UpdateChar2(SHORTMSG_LITERS);
 800311e:	4853      	ldr	r0, [pc, #332]	; (800326c <Screen_Task+0x60c>)
 8003120:	f7fe f842 	bl	80011a8 <Display_UpdateChar2>
 8003124:	7f73      	ldrb	r3, [r6, #29]
 8003126:	e6d7      	b.n	8002ed8 <Screen_Task+0x278>
					{
						Display_UpdateChar2(SHORTMSG_INLET_TEMPERATURE);
					}
					else
					{
						Display_UpdateValue(NTC_GetWaterTemperature(TEMPERATURE_INLET));
 8003128:	2001      	movs	r0, #1
 800312a:	f7ff fd0d 	bl	8002b48 <NTC_GetWaterTemperature>
 800312e:	f7fe f8a3 	bl	8001278 <Display_UpdateValue>
 8003132:	7f73      	ldrb	r3, [r6, #29]
 8003134:	e6d0      	b.n	8002ed8 <Screen_Task+0x278>
			 */
			case SCREEN_MAIN:
			{
				if(MainSubScreen == SCREEN_MAIN_POWER) // POWER
				{
					Display_UpdateChar('P', PSP + 0x30);
 8003136:	3630      	adds	r6, #48	; 0x30
 8003138:	b2f1      	uxtb	r1, r6
 800313a:	2050      	movs	r0, #80	; 0x50
 800313c:	f7fe f81a 	bl	8001174 <Display_UpdateChar>
 8003140:	782c      	ldrb	r4, [r5, #0]
 8003142:	e5f8      	b.n	8002d36 <Screen_Task+0xd6>
				}
				else if(MainSubScreen == SCREEN_MAIN_TEMPERATURE) // TEMPERATURE
				{
					Display_UpdateValue(NTC_GetWaterTemperature(TEMPERATURE_OUTLET));
 8003144:	2002      	movs	r0, #2
 8003146:	f7ff fcff 	bl	8002b48 <NTC_GetWaterTemperature>
 800314a:	f7fe f895 	bl	8001278 <Display_UpdateValue>
 800314e:	782c      	ldrb	r4, [r5, #0]
 8003150:	e5f1      	b.n	8002d36 <Screen_Task+0xd6>
						//Display_UpdateChar2(SHORTMSG_NOT_APPLIED);
					}
				}
				else if(MenuSubScreen == SCREEN_MENU_VZ) // Vazão
				{
					if(TimeoutScreen < TIMEOUT_SCREEN_MENU_MSG)
 8003152:	2b27      	cmp	r3, #39	; 0x27
 8003154:	d829      	bhi.n	80031aa <Screen_Task+0x54a>
					{
						Display_UpdateChar2(SHORTMSG_FLOW);
 8003156:	4846      	ldr	r0, [pc, #280]	; (8003270 <Screen_Task+0x610>)
 8003158:	f7fe f826 	bl	80011a8 <Display_UpdateChar2>
 800315c:	7f73      	ldrb	r3, [r6, #29]
 800315e:	e6bb      	b.n	8002ed8 <Screen_Task+0x278>
					{
						Display_UpdateChar2(SHORTMSG_OUTLET_TEMPERATURE);
					}
					else
					{
						Display_UpdateValue(NTC_GetWaterTemperature(TEMPERATURE_OUTLET));
 8003160:	2002      	movs	r0, #2
 8003162:	f7ff fcf1 	bl	8002b48 <NTC_GetWaterTemperature>
 8003166:	f7fe f887 	bl	8001278 <Display_UpdateValue>
 800316a:	7f73      	ldrb	r3, [r6, #29]
 800316c:	e6b4      	b.n	8002ed8 <Screen_Task+0x278>
						StateLogs = 0;
						break;
					}
					default:
					{
						Screen = SCREEN_MAIN;
 800316e:	23b1      	movs	r3, #177	; 0xb1
 8003170:	702b      	strb	r3, [r5, #0]
						EndBuff = false;
 8003172:	2300      	movs	r3, #0
 8003174:	76b3      	strb	r3, [r6, #26]
						StateLogs = 0;
 8003176:	7733      	strb	r3, [r6, #28]
						break;
 8003178:	e5ab      	b.n	8002cd2 <Screen_Task+0x72>
						Display_UpdateValue(Flowmeter_GetFlow()/10);
					}
				}
				else if(MenuSubScreen == SCREEN_MENU_TB) // Tempo de banho
				{
					if(TimeoutScreen < TIMEOUT_SCREEN_MENU_MSG)
 800317a:	2b27      	cmp	r3, #39	; 0x27
 800317c:	d847      	bhi.n	800320e <Screen_Task+0x5ae>
					{
						Display_UpdateChar2(SHORTMSG_SHOWER_TIME);
 800317e:	483d      	ldr	r0, [pc, #244]	; (8003274 <Screen_Task+0x614>)
 8003180:	f7fe f812 	bl	80011a8 <Display_UpdateChar2>
 8003184:	7f73      	ldrb	r3, [r6, #29]
 8003186:	e6a7      	b.n	8002ed8 <Screen_Task+0x278>
					{
						Display_UpdateChar2(SHORTMSG_LITERS);
					}
					else
					{
						Display_UpdateValue(VWC/10);
 8003188:	4640      	mov	r0, r8
					{
						Display_UpdateChar2(SHORTMSG_FLOW);
					}
					else
					{
						Display_UpdateValue(Flowmeter_GetFlow()/10);
 800318a:	210a      	movs	r1, #10
 800318c:	f000 faf2 	bl	8003774 <__aeabi_uidiv>
 8003190:	b280      	uxth	r0, r0
 8003192:	f7fe f871 	bl	8001278 <Display_UpdateValue>
 8003196:	7f73      	ldrb	r3, [r6, #29]
 8003198:	e69e      	b.n	8002ed8 <Screen_Task+0x278>
						Display_UpdateTimeValue(TPSM);
					}
				}
				else if(MenuSubScreen == SCREEN_MENU_LG) // Logs
				{
					if(TimeoutScreen < TIMEOUT_SCREEN_MENU_MSG)
 800319a:	2b27      	cmp	r3, #39	; 0x27
 800319c:	d95a      	bls.n	8003254 <Screen_Task+0x5f4>
					{
						Display_UpdateChar2(SHORTMSG_LOG);
					}
					else
					{
						Screen = SCREEN_LOGS;
 800319e:	2228      	movs	r2, #40	; 0x28
 80031a0:	702a      	strb	r2, [r5, #0]
						EndBuff = false;
 80031a2:	2200      	movs	r2, #0
 80031a4:	76b2      	strb	r2, [r6, #26]
						StateLogs = 0;
 80031a6:	7732      	strb	r2, [r6, #28]
 80031a8:	e696      	b.n	8002ed8 <Screen_Task+0x278>
					{
						Display_UpdateChar2(SHORTMSG_FLOW);
					}
					else
					{
						Display_UpdateValue(Flowmeter_GetFlow()/10);
 80031aa:	f7fe fc1d 	bl	80019e8 <Flowmeter_GetFlow>
 80031ae:	e7ec      	b.n	800318a <Screen_Task+0x52a>
							TimeoutScreen = 0;
							StateLogs = 6;
						}
						else
						{
							StateLogs = 5;
 80031b0:	2305      	movs	r3, #5
 80031b2:	782c      	ldrb	r4, [r5, #0]
 80031b4:	7733      	strb	r3, [r6, #28]
 80031b6:	e5be      	b.n	8002d36 <Screen_Task+0xd6>
							TimeoutScreen = 0;
							StateLogs = 8;
						}
						else
						{
							StateLogs = 7;
 80031b8:	2307      	movs	r3, #7
 80031ba:	782c      	ldrb	r4, [r5, #0]
 80031bc:	7733      	strb	r3, [r6, #28]
 80031be:	e5ba      	b.n	8002d36 <Screen_Task+0xd6>
							EndBuff = false;
							StateLogs = 9;
						}
						else
						{
							StateLogs = 8;
 80031c0:	2308      	movs	r3, #8
 80031c2:	782c      	ldrb	r4, [r5, #0]
 80031c4:	7733      	strb	r3, [r6, #28]
 80031c6:	e5b6      	b.n	8002d36 <Screen_Task+0xd6>
							EndBuff = false;
							StateLogs = 1;
						}
						else
						{
							StateLogs = 0;
 80031c8:	2300      	movs	r3, #0
 80031ca:	782c      	ldrb	r4, [r5, #0]
 80031cc:	7733      	strb	r3, [r6, #28]
 80031ce:	e5b2      	b.n	8002d36 <Screen_Task+0xd6>
							EndBuff = false;
							StateLogs = 7;
						}
						else
						{
							StateLogs = 6;
 80031d0:	2306      	movs	r3, #6
 80031d2:	782c      	ldrb	r4, [r5, #0]
 80031d4:	7733      	strb	r3, [r6, #28]
 80031d6:	e5ae      	b.n	8002d36 <Screen_Task+0xd6>
							EndBuff = false;
							StateLogs = 3;
						}
						else
						{
							StateLogs = 2;
 80031d8:	2302      	movs	r3, #2
 80031da:	782c      	ldrb	r4, [r5, #0]
 80031dc:	7733      	strb	r3, [r6, #28]
 80031de:	e5aa      	b.n	8002d36 <Screen_Task+0xd6>
							TimeoutScreen = 0;
							StateLogs = 2;
						}
						else
						{
							StateLogs = 1;
 80031e0:	2301      	movs	r3, #1
 80031e2:	782c      	ldrb	r4, [r5, #0]
 80031e4:	7733      	strb	r3, [r6, #28]
 80031e6:	e5a6      	b.n	8002d36 <Screen_Task+0xd6>
							TimeoutScreen = 0;
							StateLogs = 4;
						}
						else
						{
							StateLogs = 3;
 80031e8:	2303      	movs	r3, #3
 80031ea:	782c      	ldrb	r4, [r5, #0]
 80031ec:	7733      	strb	r3, [r6, #28]
 80031ee:	e5a2      	b.n	8002d36 <Screen_Task+0xd6>
							EndBuff = false;
							StateLogs = 5;
						}
						else
						{
							StateLogs = 4;
 80031f0:	2304      	movs	r3, #4
 80031f2:	782c      	ldrb	r4, [r5, #0]
 80031f4:	7733      	strb	r3, [r6, #28]
 80031f6:	e59e      	b.n	8002d36 <Screen_Task+0xd6>
							TimeoutScreen = 0;
							StateLogs = 10;
						}
						else
						{
							StateLogs = 9;
 80031f8:	2309      	movs	r3, #9
 80031fa:	782c      	ldrb	r4, [r5, #0]
 80031fc:	7733      	strb	r3, [r6, #28]
 80031fe:	e59a      	b.n	8002d36 <Screen_Task+0xd6>
						StateLogs = 0;
					}
				}
				else if( MenuSubScreen == SCREEN_MENU_CB) // Custo de banho
				{
					if(TimeoutScreen < TIMEOUT_SCREEN_MENU_MSG)
 8003200:	2b27      	cmp	r3, #39	; 0x27
 8003202:	d822      	bhi.n	800324a <Screen_Task+0x5ea>
					{
						Display_UpdateChar2(SHORTMSG_MONTH_COMSUMPTION);
 8003204:	481c      	ldr	r0, [pc, #112]	; (8003278 <Screen_Task+0x618>)
 8003206:	f7fd ffcf 	bl	80011a8 <Display_UpdateChar2>
 800320a:	7f73      	ldrb	r3, [r6, #29]
 800320c:	e664      	b.n	8002ed8 <Screen_Task+0x278>
					{
						Display_UpdateChar2(SHORTMSG_SHOWER_TIME);
					}
					else
					{
						Display_UpdateTimeValue(TPSM);
 800320e:	4650      	mov	r0, sl
 8003210:	f7fe f87c 	bl	800130c <Display_UpdateTimeValue>
 8003214:	7f73      	ldrb	r3, [r6, #29]
 8003216:	e65f      	b.n	8002ed8 <Screen_Task+0x278>
					//-------------------------------------------- Show shower period
					case 4:
					{
						if(!EndBuff)
						{
							Screen_ShowFrase(MSG_SHOWER_PERIOD, MSG_SHOWER_PERIOD_SIZE);
 8003218:	4818      	ldr	r0, [pc, #96]	; (800327c <Screen_Task+0x61c>)
 800321a:	2111      	movs	r1, #17
 800321c:	f7ff fd04 	bl	8002c28 <Screen_ShowFrase>
 8003220:	e6ad      	b.n	8002f7e <Screen_Task+0x31e>
					//-------------------------------------------- Show energy consumption
					case 6:
					{
						if(!EndBuff)
						{
							Screen_ShowFrase(MSG_ENERGY_CONSUMPTION, MSG_ENERGY_CONSUMPTION_SIZE);
 8003222:	4817      	ldr	r0, [pc, #92]	; (8003280 <Screen_Task+0x620>)
 8003224:	2115      	movs	r1, #21
 8003226:	f7ff fcff 	bl	8002c28 <Screen_ShowFrase>
 800322a:	e6de      	b.n	8002fea <Screen_Task+0x38a>
					//-------------------------------------------- Show water consumption
					case 2:
					{
						if(!EndBuff)
						{
							Screen_ShowFrase(MSG_WATER_CONSUMPTION, MSG_WATER_CONSUMPTION_SIZE);
 800322c:	4815      	ldr	r0, [pc, #84]	; (8003284 <Screen_Task+0x624>)
 800322e:	2112      	movs	r1, #18
 8003230:	f7ff fcfa 	bl	8002c28 <Screen_ShowFrase>
 8003234:	e731      	b.n	800309a <Screen_Task+0x43a>
					//-------------------------------------------- Show estimated monthly cost
					case 8:
					{
						if(!EndBuff)
						{
							Screen_ShowFrase(MSG_ESTIMATED_MONTHLY_COST, MSG_ESTIMATED_MONTHLY_COST_SIZE);
 8003236:	4814      	ldr	r0, [pc, #80]	; (8003288 <Screen_Task+0x628>)
 8003238:	2118      	movs	r1, #24
 800323a:	f7ff fcf5 	bl	8002c28 <Screen_ShowFrase>
 800323e:	e674      	b.n	8002f2a <Screen_Task+0x2ca>
					//-------------------------------------------- Show grade
					case 0:
					{
						if(!EndBuff)
						{
							Screen_ShowFrase(MSG_GRADE, MSG_GRADE_SIZE);
 8003240:	4812      	ldr	r0, [pc, #72]	; (800328c <Screen_Task+0x62c>)
 8003242:	2106      	movs	r1, #6
 8003244:	f7ff fcf0 	bl	8002c28 <Screen_ShowFrase>
 8003248:	e6f9      	b.n	800303e <Screen_Task+0x3de>
					{
						Display_UpdateChar2(SHORTMSG_MONTH_COMSUMPTION);
					}
					else
					{
						Display_UpdateValue(EMC);
 800324a:	4658      	mov	r0, fp
 800324c:	f7fe f814 	bl	8001278 <Display_UpdateValue>
 8003250:	7f73      	ldrb	r3, [r6, #29]
 8003252:	e641      	b.n	8002ed8 <Screen_Task+0x278>
				}
				else if(MenuSubScreen == SCREEN_MENU_LG) // Logs
				{
					if(TimeoutScreen < TIMEOUT_SCREEN_MENU_MSG)
					{
						Display_UpdateChar2(SHORTMSG_LOG);
 8003254:	480e      	ldr	r0, [pc, #56]	; (8003290 <Screen_Task+0x630>)
 8003256:	f7fd ffa7 	bl	80011a8 <Display_UpdateChar2>
 800325a:	7f73      	ldrb	r3, [r6, #29]
 800325c:	e63c      	b.n	8002ed8 <Screen_Task+0x278>
 800325e:	46c0      	nop			; (mov r8, r8)
 8003260:	000004b1 	.word	0x000004b1
 8003264:	0800ab54 	.word	0x0800ab54
 8003268:	0800ab50 	.word	0x0800ab50
 800326c:	0800ab5c 	.word	0x0800ab5c
 8003270:	0800ab60 	.word	0x0800ab60
 8003274:	0800ab64 	.word	0x0800ab64
 8003278:	0800ab6c 	.word	0x0800ab6c
 800327c:	0800ab8c 	.word	0x0800ab8c
 8003280:	0800aba0 	.word	0x0800aba0
 8003284:	0800ab78 	.word	0x0800ab78
 8003288:	0800abb8 	.word	0x0800abb8
 800328c:	0800ab70 	.word	0x0800ab70
 8003290:	0800ab68 	.word	0x0800ab68

08003294 <Screen_SetMainSubScreen>:
//==================================================================================================
//
//==================================================================================================
void Screen_SetMainSubScreen(uint8_t Scr)
{
	MainSubScreen = Scr;
 8003294:	4b01      	ldr	r3, [pc, #4]	; (800329c <Screen_SetMainSubScreen+0x8>)
 8003296:	7098      	strb	r0, [r3, #2]
}
 8003298:	4770      	bx	lr
 800329a:	46c0      	nop			; (mov r8, r8)
 800329c:	20000036 	.word	0x20000036

080032a0 <Screen_Show>:
//==================================================================================================
//
//==================================================================================================
void Screen_Show(uint8_t Scr)
{
	EndMessage = false;
 80032a0:	2300      	movs	r3, #0

//==================================================================================================
//
//==================================================================================================
void Screen_Show(uint8_t Scr)
{
 80032a2:	b510      	push	{r4, lr}
	EndMessage = false;
 80032a4:	4c51      	ldr	r4, [pc, #324]	; (80033ec <Screen_Show+0x14c>)
 80032a6:	76e3      	strb	r3, [r4, #27]

    switch(Scr)
 80032a8:	2829      	cmp	r0, #41	; 0x29
 80032aa:	d900      	bls.n	80032ae <Screen_Show+0xe>
 80032ac:	e092      	b.n	80033d4 <Screen_Show+0x134>
 80032ae:	4b50      	ldr	r3, [pc, #320]	; (80033f0 <Screen_Show+0x150>)
 80032b0:	0080      	lsls	r0, r0, #2
 80032b2:	581b      	ldr	r3, [r3, r0]
 80032b4:	469f      	mov	pc, r3
			break;
		}
		//--------------------------------------------
		case SCREEN_END_SHOWER:
		{
			Screen_ShowMessage(MSG_END_SHOWER, MSG_END_SHOWER_SIZE);
 80032b6:	484f      	ldr	r0, [pc, #316]	; (80033f4 <Screen_Show+0x154>)
 80032b8:	210e      	movs	r1, #14
 80032ba:	f7ff fc9b 	bl	8002bf4 <Screen_ShowMessage>
			StateLogs = 0;
 80032be:	2300      	movs	r3, #0
			EndBuff = false;
			NextScreen = SCREEN_LOGS;
 80032c0:	2228      	movs	r2, #40	; 0x28
		}
		//--------------------------------------------
		case SCREEN_END_SHOWER:
		{
			Screen_ShowMessage(MSG_END_SHOWER, MSG_END_SHOWER_SIZE);
			StateLogs = 0;
 80032c2:	7723      	strb	r3, [r4, #28]
			EndBuff = false;
 80032c4:	76a3      	strb	r3, [r4, #26]
			NextScreen = SCREEN_LOGS;
 80032c6:	4b4c      	ldr	r3, [pc, #304]	; (80033f8 <Screen_Show+0x158>)
 80032c8:	705a      	strb	r2, [r3, #1]
			Screen_ShowMessage(MSG_ERROR, MSG_ERROR_SIZE);
			NextScreen = SCREEN_MAIN;
			break;
		}
	}
}
 80032ca:	bd10      	pop	{r4, pc}
    		break;
    	}
    	//--------------------------------------------
    	case SCREEN_LOGS:
    	{
    		TimeoutScreen = 0;
 80032cc:	2300      	movs	r3, #0
    		Screen = SCREEN_LOGS;
 80032ce:	2228      	movs	r2, #40	; 0x28
    		break;
    	}
    	//--------------------------------------------
    	case SCREEN_LOGS:
    	{
    		TimeoutScreen = 0;
 80032d0:	7763      	strb	r3, [r4, #29]
    		Screen = SCREEN_LOGS;
 80032d2:	4b49      	ldr	r3, [pc, #292]	; (80033f8 <Screen_Show+0x158>)
 80032d4:	701a      	strb	r2, [r3, #0]
    		NextScreen = SCREEN_LOGS;
 80032d6:	705a      	strb	r2, [r3, #1]
    		break;
 80032d8:	e7f7      	b.n	80032ca <Screen_Show+0x2a>
			break;
		}
		//--------------------------------------------
		case SCREEN_LITERS:
		{
			Screen_ShowMessage(MSG_LITERS, MSG_LITERS_SIZE);
 80032da:	4848      	ldr	r0, [pc, #288]	; (80033fc <Screen_Show+0x15c>)
 80032dc:	2108      	movs	r1, #8
 80032de:	f7ff fc89 	bl	8002bf4 <Screen_ShowMessage>
			NextScreen = SCREEN_LITERS;
 80032e2:	2225      	movs	r2, #37	; 0x25
 80032e4:	4b44      	ldr	r3, [pc, #272]	; (80033f8 <Screen_Show+0x158>)
 80032e6:	705a      	strb	r2, [r3, #1]
			break;
 80032e8:	e7ef      	b.n	80032ca <Screen_Show+0x2a>
			break;
		}
		//--------------------------------------------
		case SCREEN_USER:
		{
			TimeoutScreen = 0;
 80032ea:	2300      	movs	r3, #0
			Screen = SCREEN_USER;
 80032ec:	2224      	movs	r2, #36	; 0x24
			break;
		}
		//--------------------------------------------
		case SCREEN_USER:
		{
			TimeoutScreen = 0;
 80032ee:	7763      	strb	r3, [r4, #29]
			Screen = SCREEN_USER;
 80032f0:	4b41      	ldr	r3, [pc, #260]	; (80033f8 <Screen_Show+0x158>)
 80032f2:	701a      	strb	r2, [r3, #0]
			break;
 80032f4:	e7e9      	b.n	80032ca <Screen_Show+0x2a>
			break;
		}
		//--------------------------------------------
		case SCREEN_PASSWORD:
		{
			Screen_ShowMessage(MSG_PASSWORD, MSG_PASSWORD_SIZE);
 80032f6:	4842      	ldr	r0, [pc, #264]	; (8003400 <Screen_Show+0x160>)
 80032f8:	2107      	movs	r1, #7
 80032fa:	f7ff fc7b 	bl	8002bf4 <Screen_ShowMessage>
			StatePassword = 0;
 80032fe:	2200      	movs	r2, #0
 8003300:	2322      	movs	r3, #34	; 0x22
 8003302:	54e2      	strb	r2, [r4, r3]
			NextScreen = SCREEN_PASSWORD;
 8003304:	4b3c      	ldr	r3, [pc, #240]	; (80033f8 <Screen_Show+0x158>)
 8003306:	3223      	adds	r2, #35	; 0x23
 8003308:	705a      	strb	r2, [r3, #1]
			break;
 800330a:	e7de      	b.n	80032ca <Screen_Show+0x2a>
			break;
		}
		//--------------------------------------------
		case SCREEN_MESSAGE_WELLCOME:
		{
			Screen_ShowMessage(MSG_WELLCOME, MSG_WELLCOME_SIZE);
 800330c:	483d      	ldr	r0, [pc, #244]	; (8003404 <Screen_Show+0x164>)
 800330e:	210c      	movs	r1, #12
 8003310:	f7ff fc70 	bl	8002bf4 <Screen_ShowMessage>
			NextScreen = SCREEN_MAIN;
 8003314:	22b1      	movs	r2, #177	; 0xb1
 8003316:	4b38      	ldr	r3, [pc, #224]	; (80033f8 <Screen_Show+0x158>)
 8003318:	705a      	strb	r2, [r3, #1]
			break;
 800331a:	e7d6      	b.n	80032ca <Screen_Show+0x2a>
			break;
		}
		//--------------------------------------------
		case SCREEN_MESSAGE_BIP_OFF:
		{
			Screen_ShowMessage(MSG_BIP_OFF, MSG_BIP_OFF_SIZE);
 800331c:	483a      	ldr	r0, [pc, #232]	; (8003408 <Screen_Show+0x168>)
 800331e:	2109      	movs	r1, #9
 8003320:	f7ff fc68 	bl	8002bf4 <Screen_ShowMessage>
			NextScreen = SCREEN_MAIN;
 8003324:	22b1      	movs	r2, #177	; 0xb1
 8003326:	4b34      	ldr	r3, [pc, #208]	; (80033f8 <Screen_Show+0x158>)
 8003328:	705a      	strb	r2, [r3, #1]
			break;
 800332a:	e7ce      	b.n	80032ca <Screen_Show+0x2a>
			break;
		}
		//--------------------------------------------
		case SCREEN_MESSAGE_BIP_ON:
		{
			Screen_ShowMessage(MSG_BIP_ON, MSG_BIP_ON_SIZE);
 800332c:	4837      	ldr	r0, [pc, #220]	; (800340c <Screen_Show+0x16c>)
 800332e:	2108      	movs	r1, #8
 8003330:	f7ff fc60 	bl	8002bf4 <Screen_ShowMessage>
			NextScreen = SCREEN_MAIN;
 8003334:	22b1      	movs	r2, #177	; 0xb1
 8003336:	4b30      	ldr	r3, [pc, #192]	; (80033f8 <Screen_Show+0x158>)
 8003338:	705a      	strb	r2, [r3, #1]
			break;
 800333a:	e7c6      	b.n	80032ca <Screen_Show+0x2a>
			break;
		}
		//--------------------------------------------
		case SCREEN_MESSAGE_LED_POWER:
		{
			Screen_ShowMessage(MSG_LED_POWER, MSG_LED_POWER_SIZE);
 800333c:	4834      	ldr	r0, [pc, #208]	; (8003410 <Screen_Show+0x170>)
 800333e:	210e      	movs	r1, #14
 8003340:	f7ff fc58 	bl	8002bf4 <Screen_ShowMessage>
			NextScreen = SCREEN_MAIN;
 8003344:	22b1      	movs	r2, #177	; 0xb1
 8003346:	4b2c      	ldr	r3, [pc, #176]	; (80033f8 <Screen_Show+0x158>)
 8003348:	705a      	strb	r2, [r3, #1]
			break;
 800334a:	e7be      	b.n	80032ca <Screen_Show+0x2a>
			break;
		}
		//--------------------------------------------
		case SCREEN_MESSAGE_LED_FIXED:
		{
			Screen_ShowMessage(MSG_LED_FIXED, MSG_LED_FIXED_SIZE);
 800334c:	4831      	ldr	r0, [pc, #196]	; (8003414 <Screen_Show+0x174>)
 800334e:	210b      	movs	r1, #11
 8003350:	f7ff fc50 	bl	8002bf4 <Screen_ShowMessage>
			NextScreen = SCREEN_MAIN;
 8003354:	22b1      	movs	r2, #177	; 0xb1
 8003356:	4b28      	ldr	r3, [pc, #160]	; (80033f8 <Screen_Show+0x158>)
 8003358:	705a      	strb	r2, [r3, #1]
			break;
 800335a:	e7b6      	b.n	80032ca <Screen_Show+0x2a>
			break;
		}
		//--------------------------------------------
		case SCREEN_MESSAGE_LED_AUTO:
		{
			Screen_ShowMessage(MSG_LED_AUTO, MSG_LED_AUTO_SIZE);
 800335c:	482e      	ldr	r0, [pc, #184]	; (8003418 <Screen_Show+0x178>)
 800335e:	210a      	movs	r1, #10
 8003360:	f7ff fc48 	bl	8002bf4 <Screen_ShowMessage>
			NextScreen = SCREEN_MAIN;
 8003364:	22b1      	movs	r2, #177	; 0xb1
 8003366:	4b24      	ldr	r3, [pc, #144]	; (80033f8 <Screen_Show+0x158>)
 8003368:	705a      	strb	r2, [r3, #1]
			break;
 800336a:	e7ae      	b.n	80032ca <Screen_Show+0x2a>
			break;
		}
		//--------------------------------------------
		case SCREEN_MESSAGE_LED_TEMPERATURE:
		{
			Screen_ShowMessage(MSG_LED_TEMPERATURE, MSG_LED_TEMPERATURE_SIZE);
 800336c:	482b      	ldr	r0, [pc, #172]	; (800341c <Screen_Show+0x17c>)
 800336e:	2111      	movs	r1, #17
 8003370:	f7ff fc40 	bl	8002bf4 <Screen_ShowMessage>
			NextScreen = SCREEN_MAIN;
 8003374:	22b1      	movs	r2, #177	; 0xb1
 8003376:	4b20      	ldr	r3, [pc, #128]	; (80033f8 <Screen_Show+0x158>)
 8003378:	705a      	strb	r2, [r3, #1]
			break;
 800337a:	e7a6      	b.n	80032ca <Screen_Show+0x2a>
			break;
		}
		//--------------------------------------------
		case SCREEN_MESSAGE_LED_ON:
		{
			Screen_ShowMessage(MSG_LED_ON, MSG_LED_ON_SIZE);
 800337c:	4828      	ldr	r0, [pc, #160]	; (8003420 <Screen_Show+0x180>)
 800337e:	e7d6      	b.n	800332e <Screen_Show+0x8e>
			break;
		}
		//--------------------------------------------
		case SCREEN_MESSAGE_LED_OFF:
		{
			Screen_ShowMessage(MSG_LED_OFF, MSG_LED_OFF_SIZE);
 8003380:	4828      	ldr	r0, [pc, #160]	; (8003424 <Screen_Show+0x184>)
 8003382:	e7cc      	b.n	800331e <Screen_Show+0x7e>
    		break;
    	}
		//--------------------------------------------
		case SCREEN_POWER_SETPOINT:
		{
			TimeoutScreen = 0;
 8003384:	2300      	movs	r3, #0
			Screen = SCREEN_POWER_SETPOINT;
 8003386:	2210      	movs	r2, #16
    		break;
    	}
		//--------------------------------------------
		case SCREEN_POWER_SETPOINT:
		{
			TimeoutScreen = 0;
 8003388:	7763      	strb	r3, [r4, #29]
			Screen = SCREEN_POWER_SETPOINT;
 800338a:	4b1b      	ldr	r3, [pc, #108]	; (80033f8 <Screen_Show+0x158>)
 800338c:	701a      	strb	r2, [r3, #0]
			break;
 800338e:	e79c      	b.n	80032ca <Screen_Show+0x2a>
			break;
		}
    	//--------------------------------------------
    	case SCREEN_TEMPERATURE_SETPOINT:
    	{
    		TimeoutScreen = 0;
 8003390:	2300      	movs	r3, #0
    		Screen = SCREEN_TEMPERATURE_SETPOINT;
 8003392:	2209      	movs	r2, #9
			break;
		}
    	//--------------------------------------------
    	case SCREEN_TEMPERATURE_SETPOINT:
    	{
    		TimeoutScreen = 0;
 8003394:	7763      	strb	r3, [r4, #29]
    		Screen = SCREEN_TEMPERATURE_SETPOINT;
 8003396:	4b18      	ldr	r3, [pc, #96]	; (80033f8 <Screen_Show+0x158>)
 8003398:	701a      	strb	r2, [r3, #0]
    		break;
 800339a:	e796      	b.n	80032ca <Screen_Show+0x2a>
			break;
		}
		//--------------------------------------------
		case SCREEN_TEMPERATURE:
		{
			TimeoutScreen = 0;
 800339c:	2300      	movs	r3, #0
			Screen = SCREEN_TEMPERATURE;
 800339e:	2208      	movs	r2, #8
			break;
		}
		//--------------------------------------------
		case SCREEN_TEMPERATURE:
		{
			TimeoutScreen = 0;
 80033a0:	7763      	strb	r3, [r4, #29]
			Screen = SCREEN_TEMPERATURE;
 80033a2:	4b15      	ldr	r3, [pc, #84]	; (80033f8 <Screen_Show+0x158>)
 80033a4:	701a      	strb	r2, [r3, #0]
			break;
 80033a6:	e790      	b.n	80032ca <Screen_Show+0x2a>
    		break;
    	}
		//--------------------------------------------
		case SCREEN_FLOW:
		{
			TimeoutScreen = 0;
 80033a8:	2300      	movs	r3, #0
			Screen = SCREEN_FLOW;
 80033aa:	2207      	movs	r2, #7
    		break;
    	}
		//--------------------------------------------
		case SCREEN_FLOW:
		{
			TimeoutScreen = 0;
 80033ac:	7763      	strb	r3, [r4, #29]
			Screen = SCREEN_FLOW;
 80033ae:	4b12      	ldr	r3, [pc, #72]	; (80033f8 <Screen_Show+0x158>)
 80033b0:	701a      	strb	r2, [r3, #0]
			break;
 80033b2:	e78a      	b.n	80032ca <Screen_Show+0x2a>
			break;
		}
    	//--------------------------------------------
    	case SCREEN_MENU:
    	{
    		if(MenuSubScreen < SCREEN_MENU_CB)
 80033b4:	4b10      	ldr	r3, [pc, #64]	; (80033f8 <Screen_Show+0x158>)
 80033b6:	78da      	ldrb	r2, [r3, #3]
 80033b8:	2aa6      	cmp	r2, #166	; 0xa6
 80033ba:	d813      	bhi.n	80033e4 <Screen_Show+0x144>
    		{
    			MenuSubScreen++;
 80033bc:	3201      	adds	r2, #1
 80033be:	70da      	strb	r2, [r3, #3]
    		else
    		{
    			MenuSubScreen = SCREEN_MENU_TE;
    		}

    		TimeoutScreen = 0;
 80033c0:	2200      	movs	r2, #0
 80033c2:	7762      	strb	r2, [r4, #29]
    		Screen = SCREEN_MENU;
 80033c4:	3202      	adds	r2, #2
 80033c6:	701a      	strb	r2, [r3, #0]
    		break;
 80033c8:	e77f      	b.n	80032ca <Screen_Show+0x2a>
    switch(Scr)
	{
		//--------------------------------------------
		case SCREEN_VERSION:
		{
			Display_Version(VERSION_MAJOR, VERSION_MINOR);
 80033ca:	2000      	movs	r0, #0
 80033cc:	2100      	movs	r1, #0
 80033ce:	f7fe f813 	bl	80013f8 <Display_Version>
			// VERSION_MAJOR and VERSION_MINOR defined in "Makefile"
			break;
 80033d2:	e77a      	b.n	80032ca <Screen_Show+0x2a>
			break;
		}
		//--------------------------------------------
		default:
		{
			Screen_ShowMessage(MSG_ERROR, MSG_ERROR_SIZE);
 80033d4:	4814      	ldr	r0, [pc, #80]	; (8003428 <Screen_Show+0x188>)
 80033d6:	2106      	movs	r1, #6
 80033d8:	f7ff fc0c 	bl	8002bf4 <Screen_ShowMessage>
			NextScreen = SCREEN_MAIN;
 80033dc:	22b1      	movs	r2, #177	; 0xb1
 80033de:	4b06      	ldr	r3, [pc, #24]	; (80033f8 <Screen_Show+0x158>)
 80033e0:	705a      	strb	r2, [r3, #1]
			break;
 80033e2:	e772      	b.n	80032ca <Screen_Show+0x2a>
    		{
    			MenuSubScreen++;
    		}
    		else
    		{
    			MenuSubScreen = SCREEN_MENU_TE;
 80033e4:	22a1      	movs	r2, #161	; 0xa1
 80033e6:	70da      	strb	r2, [r3, #3]
 80033e8:	e7ea      	b.n	80033c0 <Screen_Show+0x120>
 80033ea:	46c0      	nop			; (mov r8, r8)
 80033ec:	20000238 	.word	0x20000238
 80033f0:	0800a970 	.word	0x0800a970
 80033f4:	0800ac54 	.word	0x0800ac54
 80033f8:	20000036 	.word	0x20000036
 80033fc:	0800ac40 	.word	0x0800ac40
 8003400:	0800ac4c 	.word	0x0800ac4c
 8003404:	0800ab40 	.word	0x0800ab40
 8003408:	0800ac34 	.word	0x0800ac34
 800340c:	0800ac28 	.word	0x0800ac28
 8003410:	0800ac18 	.word	0x0800ac18
 8003414:	0800ac0c 	.word	0x0800ac0c
 8003418:	0800ac00 	.word	0x0800ac00
 800341c:	0800abec 	.word	0x0800abec
 8003420:	0800abe0 	.word	0x0800abe0
 8003424:	0800abd4 	.word	0x0800abd4
 8003428:	0800ac64 	.word	0x0800ac64

0800342c <Screen_Init>:
  * @brief  Prints in Displays the Firmware Version and the Welcome Message
  * @param  None
  * @retval None
  */
void Screen_Init()
{
 800342c:	b508      	push	{r3, lr}
	Display_Version(VERSION_MAJOR, VERSION_MINOR);
 800342e:	2100      	movs	r1, #0
 8003430:	2000      	movs	r0, #0
 8003432:	f7fd ffe1 	bl	80013f8 <Display_Version>

	vTaskDelay(2000);
 8003436:	20fa      	movs	r0, #250	; 0xfa
 8003438:	00c0      	lsls	r0, r0, #3
 800343a:	f006 f8dd 	bl	80095f8 <vTaskDelay>

	Screen_Show(SCREEN_MESSAGE_WELLCOME);
 800343e:	2020      	movs	r0, #32
 8003440:	f7ff ff2e 	bl	80032a0 <Screen_Show>
}
 8003444:	bd08      	pop	{r3, pc}
 8003446:	46c0      	nop			; (mov r8, r8)

08003448 <ShowerController_RemoteControl>:
//-------------------------------------------
//
static uint8_t TakingShower = SHOWER_TIME_IDLE;

void ShowerController_RemoteControl(void)
{
 8003448:	b5f0      	push	{r4, r5, r6, r7, lr}
 800344a:	464f      	mov	r7, r9
 800344c:	4646      	mov	r6, r8
 800344e:	b4c0      	push	{r6, r7}
	uint32_t Data[COMMANDS_QUEUE_SIZE];
	uint8_t  UserIndex = 0;
	uint8_t  PowerSetPoint = 0;
	uint16_t TemperatureSetPoint = 0;

	IrDA_Init(&CommandsQueueHandler);
 8003450:	4bab      	ldr	r3, [pc, #684]	; (8003700 <ShowerController_RemoteControl+0x2b8>)
//-------------------------------------------
//
static uint8_t TakingShower = SHOWER_TIME_IDLE;

void ShowerController_RemoteControl(void)
{
 8003452:	b083      	sub	sp, #12
	uint32_t Data[COMMANDS_QUEUE_SIZE];
	uint8_t  UserIndex = 0;
	uint8_t  PowerSetPoint = 0;
	uint16_t TemperatureSetPoint = 0;

	IrDA_Init(&CommandsQueueHandler);
 8003454:	1c18      	adds	r0, r3, #0
 8003456:	4699      	mov	r9, r3
 8003458:	f7fd ffde 	bl	8001418 <IrDA_Init>

	Flowmeter_ForceGetFlow(0);
 800345c:	2000      	movs	r0, #0
 800345e:	f7fe facb 	bl	80019f8 <Flowmeter_ForceGetFlow>

		UserIndex = User_GetIndex();
		PowerSetPoint = User_GetPowerSetPoint(UserIndex);
		TemperatureSetPoint = User_GetTemperatureSetPoint(UserIndex);

		switch(Data[0])
 8003462:	4da8      	ldr	r5, [pc, #672]	; (8003704 <ShowerController_RemoteControl+0x2bc>)
 8003464:	4ea8      	ldr	r6, [pc, #672]	; (8003708 <ShowerController_RemoteControl+0x2c0>)

	Flowmeter_ForceGetFlow(0);

	for(;;)
	{
		xQueueReceive(CommandsQueueHandler, &Data, portMAX_DELAY);
 8003466:	464b      	mov	r3, r9
 8003468:	2201      	movs	r2, #1
 800346a:	6818      	ldr	r0, [r3, #0]
 800346c:	4252      	negs	r2, r2
 800346e:	2300      	movs	r3, #0
 8003470:	a901      	add	r1, sp, #4
 8003472:	f005 faef 	bl	8008a54 <xQueueGenericReceive>

		Buzzer_Beep(25, 1);
 8003476:	2101      	movs	r1, #1
 8003478:	2019      	movs	r0, #25
 800347a:	f7fe fe1d 	bl	80020b8 <Buzzer_Beep>

		UserIndex = User_GetIndex();
 800347e:	f7fd faaf 	bl	80009e0 <User_GetIndex>
 8003482:	1c04      	adds	r4, r0, #0
		PowerSetPoint = User_GetPowerSetPoint(UserIndex);
 8003484:	f7fd fa70 	bl	8000968 <User_GetPowerSetPoint>
 8003488:	4680      	mov	r8, r0
		TemperatureSetPoint = User_GetTemperatureSetPoint(UserIndex);
 800348a:	1c20      	adds	r0, r4, #0
 800348c:	f7fd fa58 	bl	8000940 <User_GetTemperatureSetPoint>

		switch(Data[0])
 8003490:	9b01      	ldr	r3, [sp, #4]

		Buzzer_Beep(25, 1);

		UserIndex = User_GetIndex();
		PowerSetPoint = User_GetPowerSetPoint(UserIndex);
		TemperatureSetPoint = User_GetTemperatureSetPoint(UserIndex);
 8003492:	1c07      	adds	r7, r0, #0

		switch(Data[0])
 8003494:	42ab      	cmp	r3, r5
 8003496:	d06c      	beq.n	8003572 <ShowerController_RemoteControl+0x12a>
 8003498:	d823      	bhi.n	80034e2 <ShowerController_RemoteControl+0x9a>
 800349a:	4a9c      	ldr	r2, [pc, #624]	; (800370c <ShowerController_RemoteControl+0x2c4>)
 800349c:	4293      	cmp	r3, r2
 800349e:	d0dd      	beq.n	800345c <ShowerController_RemoteControl+0x14>
 80034a0:	d93c      	bls.n	800351c <ShowerController_RemoteControl+0xd4>
 80034a2:	4a9b      	ldr	r2, [pc, #620]	; (8003710 <ShowerController_RemoteControl+0x2c8>)
 80034a4:	4293      	cmp	r3, r2
 80034a6:	d056      	beq.n	8003556 <ShowerController_RemoteControl+0x10e>
 80034a8:	4a9a      	ldr	r2, [pc, #616]	; (8003714 <ShowerController_RemoteControl+0x2cc>)
 80034aa:	4293      	cmp	r3, r2
 80034ac:	d04a      	beq.n	8003544 <ShowerController_RemoteControl+0xfc>
 80034ae:	4a9a      	ldr	r2, [pc, #616]	; (8003718 <ShowerController_RemoteControl+0x2d0>)
 80034b0:	4293      	cmp	r3, r2
 80034b2:	d1d8      	bne.n	8003466 <ShowerController_RemoteControl+0x1e>
				break;
			}
			//----------------------------------------------------------------------------------------------
			case KEY_UP:
			{
				switch(User_GetShowerMode(UserIndex))
 80034b4:	1c20      	adds	r0, r4, #0
 80034b6:	f7fd fa0b 	bl	80008d0 <User_GetShowerMode>
 80034ba:	2801      	cmp	r0, #1
 80034bc:	d100      	bne.n	80034c0 <ShowerController_RemoteControl+0x78>
 80034be:	e0b7      	b.n	8003630 <ShowerController_RemoteControl+0x1e8>
 80034c0:	2802      	cmp	r0, #2
 80034c2:	d000      	beq.n	80034c6 <ShowerController_RemoteControl+0x7e>
 80034c4:	e0a4      	b.n	8003610 <ShowerController_RemoteControl+0x1c8>
				{
					case SHOWER_MODE_POWER:
					{
						if(PowerSetPoint < 9)
 80034c6:	4643      	mov	r3, r8
 80034c8:	2b08      	cmp	r3, #8
 80034ca:	d900      	bls.n	80034ce <ShowerController_RemoteControl+0x86>
 80034cc:	e0ab      	b.n	8003626 <ShowerController_RemoteControl+0x1de>
						{
							PowerSetPoint++;
 80034ce:	4640      	mov	r0, r8
 80034d0:	3001      	adds	r0, #1
							User_SetPowerSetPoint(PowerSetPoint, UserIndex);
 80034d2:	b2c0      	uxtb	r0, r0
 80034d4:	1c21      	adds	r1, r4, #0
 80034d6:	f7fd fa51 	bl	800097c <User_SetPowerSetPoint>
			}
			//----------------------------------------------------------------------------------------------
			case KEY_POWER:
			{
				User_SetShowerMode(SHOWER_MODE_POWER, UserIndex);
				Screen_Show(SCREEN_POWER_SETPOINT);
 80034da:	2010      	movs	r0, #16
 80034dc:	f7ff fee0 	bl	80032a0 <Screen_Show>
				break;
 80034e0:	e7bf      	b.n	8003462 <ShowerController_RemoteControl+0x1a>

		UserIndex = User_GetIndex();
		PowerSetPoint = User_GetPowerSetPoint(UserIndex);
		TemperatureSetPoint = User_GetTemperatureSetPoint(UserIndex);

		switch(Data[0])
 80034e2:	42b3      	cmp	r3, r6
 80034e4:	d066      	beq.n	80035b4 <ShowerController_RemoteControl+0x16c>
 80034e6:	d922      	bls.n	800352e <ShowerController_RemoteControl+0xe6>
 80034e8:	4a8c      	ldr	r2, [pc, #560]	; (800371c <ShowerController_RemoteControl+0x2d4>)
 80034ea:	4293      	cmp	r3, r2
 80034ec:	d07b      	beq.n	80035e6 <ShowerController_RemoteControl+0x19e>
 80034ee:	4a8c      	ldr	r2, [pc, #560]	; (8003720 <ShowerController_RemoteControl+0x2d8>)
 80034f0:	4293      	cmp	r3, r2
 80034f2:	d056      	beq.n	80035a2 <ShowerController_RemoteControl+0x15a>
 80034f4:	4a8b      	ldr	r2, [pc, #556]	; (8003724 <ShowerController_RemoteControl+0x2dc>)
 80034f6:	4293      	cmp	r3, r2
 80034f8:	d1b5      	bne.n	8003466 <ShowerController_RemoteControl+0x1e>
				break;
			}
			//----------------------------------------------------------------------------------------------
			case KEY_BIP:
			{
				if(User_GetBuzzer(UserIndex) == BUZZER_DISABLE)
 80034fa:	1c20      	adds	r0, r4, #0
 80034fc:	f7fd fa5c 	bl	80009b8 <User_GetBuzzer>
 8003500:	28f0      	cmp	r0, #240	; 0xf0
 8003502:	d100      	bne.n	8003506 <ShowerController_RemoteControl+0xbe>
 8003504:	e0bd      	b.n	8003682 <ShowerController_RemoteControl+0x23a>
					Screen_Show(SCREEN_MESSAGE_BIP_ON);
					Buzzer_Control(BUZZER_ENABLED);
				}
				else
				{
					User_SetBuzzer(BUZZER_DISABLE, UserIndex);
 8003506:	1c21      	adds	r1, r4, #0
 8003508:	20f0      	movs	r0, #240	; 0xf0
 800350a:	f7fd fa5f 	bl	80009cc <User_SetBuzzer>
					Screen_Show(SCREEN_MESSAGE_BIP_OFF);
 800350e:	2019      	movs	r0, #25
 8003510:	f7ff fec6 	bl	80032a0 <Screen_Show>
					Buzzer_Control(BUZZER_DISABLE);
 8003514:	20f0      	movs	r0, #240	; 0xf0
 8003516:	f7fe fde3 	bl	80020e0 <Buzzer_Control>
 800351a:	e7a2      	b.n	8003462 <ShowerController_RemoteControl+0x1a>

		UserIndex = User_GetIndex();
		PowerSetPoint = User_GetPowerSetPoint(UserIndex);
		TemperatureSetPoint = User_GetTemperatureSetPoint(UserIndex);

		switch(Data[0])
 800351c:	4a82      	ldr	r2, [pc, #520]	; (8003728 <ShowerController_RemoteControl+0x2e0>)
 800351e:	4293      	cmp	r3, r2
 8003520:	d065      	beq.n	80035ee <ShowerController_RemoteControl+0x1a6>
 8003522:	4a82      	ldr	r2, [pc, #520]	; (800372c <ShowerController_RemoteControl+0x2e4>)
 8003524:	4293      	cmp	r3, r2
 8003526:	d19e      	bne.n	8003466 <ShowerController_RemoteControl+0x1e>
				break;
			}
			//----------------------------------------------------------------------------------------------
			case E1:
			{
				EE_FlashErase(); // Clear Emulated EEPROM variables
 8003528:	f7ff f81e 	bl	8002568 <EE_FlashErase>
				break;
 800352c:	e799      	b.n	8003462 <ShowerController_RemoteControl+0x1a>

		UserIndex = User_GetIndex();
		PowerSetPoint = User_GetPowerSetPoint(UserIndex);
		TemperatureSetPoint = User_GetTemperatureSetPoint(UserIndex);

		switch(Data[0])
 800352e:	4a80      	ldr	r2, [pc, #512]	; (8003730 <ShowerController_RemoteControl+0x2e8>)
 8003530:	4293      	cmp	r3, r2
 8003532:	d00c      	beq.n	800354e <ShowerController_RemoteControl+0x106>
 8003534:	4a7f      	ldr	r2, [pc, #508]	; (8003734 <ShowerController_RemoteControl+0x2ec>)
 8003536:	4293      	cmp	r3, r2
 8003538:	d195      	bne.n	8003466 <ShowerController_RemoteControl+0x1e>
			}
			//----------------------------------------------------------------------------------------------
			case A1:
			{
				// Desliga a leitura do fluxômetro e força um fluxo
				Flowmeter_ForceGetFlow(350);
 800353a:	20af      	movs	r0, #175	; 0xaf
 800353c:	0040      	lsls	r0, r0, #1
 800353e:	f7fe fa5b 	bl	80019f8 <Flowmeter_ForceGetFlow>
				break;
 8003542:	e78e      	b.n	8003462 <ShowerController_RemoteControl+0x1a>
				break;
			}
			//----------------------------------------------------------------------------------------------
			case KEY_POWER:
			{
				User_SetShowerMode(SHOWER_MODE_POWER, UserIndex);
 8003544:	2002      	movs	r0, #2
 8003546:	1c21      	adds	r1, r4, #0
 8003548:	f7fd f9ca 	bl	80008e0 <User_SetShowerMode>
 800354c:	e7c5      	b.n	80034da <ShowerController_RemoteControl+0x92>
		switch(Data[0])
		{
			//----------------------------------------------------------------------------------------------
			case KEY_MENU:
			{
				Screen_Show(SCREEN_MENU);
 800354e:	2002      	movs	r0, #2
 8003550:	f7ff fea6 	bl	80032a0 <Screen_Show>
				break;
 8003554:	e785      	b.n	8003462 <ShowerController_RemoteControl+0x1a>
			}

			//----------------------------------------------------------------------------------------------
			case KEY_TEMPERATURE:
			{
				if(User_GetShowerMode(UserIndex) == SHOWER_MODE_POWER)
 8003556:	1c20      	adds	r0, r4, #0
 8003558:	f7fd f9ba 	bl	80008d0 <User_GetShowerMode>
 800355c:	2802      	cmp	r0, #2
 800355e:	d100      	bne.n	8003562 <ShowerController_RemoteControl+0x11a>
 8003560:	e0bd      	b.n	80036de <ShowerController_RemoteControl+0x296>
				{
					Controller_ResetPID();
				}

				User_SetShowerMode(SHOWER_MODE_TEMPERATURE, UserIndex);
 8003562:	2001      	movs	r0, #1
 8003564:	1c21      	adds	r1, r4, #0
 8003566:	f7fd f9bb 	bl	80008e0 <User_SetShowerMode>
				Screen_Show(SCREEN_TEMPERATURE);
 800356a:	2008      	movs	r0, #8
 800356c:	f7ff fe98 	bl	80032a0 <Screen_Show>
				break;
 8003570:	e777      	b.n	8003462 <ShowerController_RemoteControl+0x1a>
			//----------------------------------------------------------------------------------------------
			case KEY_LED_OFF:
			{
				static uint8_t Last_LedMode;

				if(User_GetLedMode(UserIndex) != LED_OFF)
 8003572:	1c20      	adds	r0, r4, #0
 8003574:	f7fd f9bc 	bl	80008f0 <User_GetLedMode>
 8003578:	2801      	cmp	r0, #1
 800357a:	d100      	bne.n	800357e <ShowerController_RemoteControl+0x136>
 800357c:	e08c      	b.n	8003698 <ShowerController_RemoteControl+0x250>
				{
					Last_LedMode = User_GetLedMode(UserIndex);
 800357e:	1c20      	adds	r0, r4, #0
 8003580:	f7fd f9b6 	bl	80008f0 <User_GetLedMode>
 8003584:	464b      	mov	r3, r9
					User_SetLedMode(LED_OFF, UserIndex);
 8003586:	1c21      	adds	r1, r4, #0
			{
				static uint8_t Last_LedMode;

				if(User_GetLedMode(UserIndex) != LED_OFF)
				{
					Last_LedMode = User_GetLedMode(UserIndex);
 8003588:	7118      	strb	r0, [r3, #4]
					User_SetLedMode(LED_OFF, UserIndex);
 800358a:	2001      	movs	r0, #1
 800358c:	f7fd f9ba 	bl	8000904 <User_SetLedMode>
					Screen_Show(SCREEN_MESSAGE_LED_OFF);
 8003590:	2011      	movs	r0, #17
 8003592:	f7ff fe85 	bl	80032a0 <Screen_Show>
				else
				{
					Screen_Show(SCREEN_MESSAGE_LED_OFF);
				}

				LED_SetMode(User_GetLedMode(UserIndex));
 8003596:	1c20      	adds	r0, r4, #0
 8003598:	f7fd f9aa 	bl	80008f0 <User_GetLedMode>
 800359c:	f7fd fd18 	bl	8000fd0 <LED_SetMode>
				break;
 80035a0:	e75f      	b.n	8003462 <ShowerController_RemoteControl+0x1a>
				break;
			}
			//----------------------------------------------------------------------------------------------
			case KEY_USER:
			{
				if(UserIndex >= 5)
 80035a2:	2c04      	cmp	r4, #4
 80035a4:	d93a      	bls.n	800361c <ShowerController_RemoteControl+0x1d4>
				{
					User_SetIndex(0);
 80035a6:	2000      	movs	r0, #0
 80035a8:	f7fd fa20 	bl	80009ec <User_SetIndex>
				else
				{
					User_SetIndex(++UserIndex);
				}

				Screen_Show(SCREEN_USER);
 80035ac:	2024      	movs	r0, #36	; 0x24
 80035ae:	f7ff fe77 	bl	80032a0 <Screen_Show>
				break;
 80035b2:	e756      	b.n	8003462 <ShowerController_RemoteControl+0x1a>
				break;
			}
			//----------------------------------------------------------------------------------------------
			case KEY_LED_AUTO:
			{
				if(User_GetLedMode(UserIndex) == LED_POWER)
 80035b4:	1c20      	adds	r0, r4, #0
 80035b6:	f7fd f99b 	bl	80008f0 <User_GetLedMode>
 80035ba:	2803      	cmp	r0, #3
 80035bc:	d059      	beq.n	8003672 <ShowerController_RemoteControl+0x22a>
				{
					User_SetLedMode(LED_TEMPERATURE, UserIndex);
					Screen_Show(SCREEN_MESSAGE_LED_TEMPERATURE);
				}
				else if(User_GetLedMode(UserIndex) == LED_TEMPERATURE)
 80035be:	1c20      	adds	r0, r4, #0
 80035c0:	f7fd f996 	bl	80008f0 <User_GetLedMode>
 80035c4:	2802      	cmp	r0, #2
 80035c6:	d070      	beq.n	80036aa <ShowerController_RemoteControl+0x262>
				{
					User_SetLedMode(LED_AUTO, UserIndex);
					Screen_Show(SCREEN_MESSAGE_LED_AUTO);
				}
				else if(User_GetLedMode(UserIndex) == LED_AUTO)
 80035c8:	1c20      	adds	r0, r4, #0
 80035ca:	f7fd f991 	bl	80008f0 <User_GetLedMode>
 80035ce:	2804      	cmp	r0, #4
 80035d0:	d073      	beq.n	80036ba <ShowerController_RemoteControl+0x272>
					User_SetLedColor(LED_GetColor(), UserIndex);
					LED_SetFixedColor(User_GetLedColor(UserIndex));

					Screen_Show(SCREEN_MESSAGE_LED_FIXED);
				}
				else if(User_GetLedMode(UserIndex) == LED_FIXED)
 80035d2:	1c20      	adds	r0, r4, #0
 80035d4:	f7fd f98c 	bl	80008f0 <User_GetLedMode>
 80035d8:	2805      	cmp	r0, #5
 80035da:	d100      	bne.n	80035de <ShowerController_RemoteControl+0x196>
 80035dc:	e082      	b.n	80036e4 <ShowerController_RemoteControl+0x29c>
					User_SetLedMode(LED_POWER, UserIndex);
					Screen_Show(SCREEN_MESSAGE_LED_POWER);
				}
				else
				{
					Screen_Show(SCREEN_MESSAGE_LED_OFF);
 80035de:	2011      	movs	r0, #17
 80035e0:	f7ff fe5e 	bl	80032a0 <Screen_Show>
 80035e4:	e7d7      	b.n	8003596 <ShowerController_RemoteControl+0x14e>
				break;
			}
			//----------------------------------------------------------------------------------------------
			case KEY_LITERS:
			{
				Screen_Show(SCREEN_LITERS);
 80035e6:	2025      	movs	r0, #37	; 0x25
 80035e8:	f7ff fe5a 	bl	80032a0 <Screen_Show>
				break;
 80035ec:	e739      	b.n	8003462 <ShowerController_RemoteControl+0x1a>
				break;
			}
			//----------------------------------------------------------------------------------------------
			case KEY_DOWN:
			{
				switch(User_GetShowerMode(UserIndex))
 80035ee:	1c20      	adds	r0, r4, #0
 80035f0:	f7fd f96e 	bl	80008d0 <User_GetShowerMode>
 80035f4:	2801      	cmp	r0, #1
 80035f6:	d028      	beq.n	800364a <ShowerController_RemoteControl+0x202>
 80035f8:	2802      	cmp	r0, #2
 80035fa:	d109      	bne.n	8003610 <ShowerController_RemoteControl+0x1c8>
				{
					case SHOWER_MODE_POWER:
					{
						if(PowerSetPoint >0)
 80035fc:	4643      	mov	r3, r8
 80035fe:	2b00      	cmp	r3, #0
 8003600:	d011      	beq.n	8003626 <ShowerController_RemoteControl+0x1de>
						{
							PowerSetPoint--;
 8003602:	4640      	mov	r0, r8
 8003604:	3801      	subs	r0, #1
							User_SetPowerSetPoint(PowerSetPoint, UserIndex);
 8003606:	b2c0      	uxtb	r0, r0
 8003608:	1c21      	adds	r1, r4, #0
 800360a:	f7fd f9b7 	bl	800097c <User_SetPowerSetPoint>
 800360e:	e764      	b.n	80034da <ShowerController_RemoteControl+0x92>
						break;
					}*/

					default:
					{
						Buzzer_Beep(500, 3);
 8003610:	20fa      	movs	r0, #250	; 0xfa
 8003612:	2103      	movs	r1, #3
 8003614:	0040      	lsls	r0, r0, #1
 8003616:	f7fe fd4f 	bl	80020b8 <Buzzer_Beep>
						break;
 800361a:	e722      	b.n	8003462 <ShowerController_RemoteControl+0x1a>
				{
					User_SetIndex(0);
				}
				else
				{
					User_SetIndex(++UserIndex);
 800361c:	3401      	adds	r4, #1
 800361e:	b2e0      	uxtb	r0, r4
 8003620:	f7fd f9e4 	bl	80009ec <User_SetIndex>
 8003624:	e7c2      	b.n	80035ac <ShowerController_RemoteControl+0x164>
							PowerSetPoint++;
							User_SetPowerSetPoint(PowerSetPoint, UserIndex);
						}
						else
						{
							Buzzer_Beep(40, 3);
 8003626:	2028      	movs	r0, #40	; 0x28
 8003628:	2103      	movs	r1, #3
 800362a:	f7fe fd45 	bl	80020b8 <Buzzer_Beep>
 800362e:	e754      	b.n	80034da <ShowerController_RemoteControl+0x92>
						Screen_Show(SCREEN_POWER_SETPOINT);
						break;
					}
					case SHOWER_MODE_TEMPERATURE:
					{
						if(TemperatureSetPoint < MAX_SETPOINT) // MAX_SETPOINT = 455
 8003630:	23e3      	movs	r3, #227	; 0xe3
 8003632:	005b      	lsls	r3, r3, #1
 8003634:	429f      	cmp	r7, r3
 8003636:	d817      	bhi.n	8003668 <ShowerController_RemoteControl+0x220>
						{
							TemperatureSetPoint += 10;
 8003638:	370a      	adds	r7, #10
							User_SetTemperatureSetPoint(TemperatureSetPoint, UserIndex);
 800363a:	b2b8      	uxth	r0, r7
 800363c:	1c21      	adds	r1, r4, #0
 800363e:	f7fd f989 	bl	8000954 <User_SetTemperatureSetPoint>
						else
						{
							Buzzer_Beep(40, 3);
						}

						Screen_Show(SCREEN_TEMPERATURE_SETPOINT);
 8003642:	2009      	movs	r0, #9
 8003644:	f7ff fe2c 	bl	80032a0 <Screen_Show>
						break;
 8003648:	e70b      	b.n	8003462 <ShowerController_RemoteControl+0x1a>
						break;
					}
					case SHOWER_MODE_TEMPERATURE:
					{
						/* Lower temperature must be equal to the inlet temperature */
						if(TemperatureSetPoint > ((NTC_GetWaterTemperature(TEMPERATURE_INLET) > MIN_SETPOINT) ? NTC_GetWaterTemperature(TEMPERATURE_INLET) : MIN_SETPOINT))
 800364a:	2001      	movs	r0, #1
 800364c:	f7ff fa7c 	bl	8002b48 <NTC_GetWaterTemperature>
 8003650:	23cd      	movs	r3, #205	; 0xcd
 8003652:	28cd      	cmp	r0, #205	; 0xcd
 8003654:	dc4e      	bgt.n	80036f4 <ShowerController_RemoteControl+0x2ac>
 8003656:	42bb      	cmp	r3, r7
 8003658:	da06      	bge.n	8003668 <ShowerController_RemoteControl+0x220>
						{
							TemperatureSetPoint -= 10;
 800365a:	1c38      	adds	r0, r7, #0
 800365c:	380a      	subs	r0, #10
							User_SetTemperatureSetPoint(TemperatureSetPoint, UserIndex);
 800365e:	b280      	uxth	r0, r0
 8003660:	1c21      	adds	r1, r4, #0
 8003662:	f7fd f977 	bl	8000954 <User_SetTemperatureSetPoint>
 8003666:	e7ec      	b.n	8003642 <ShowerController_RemoteControl+0x1fa>
							TemperatureSetPoint += 10;
							User_SetTemperatureSetPoint(TemperatureSetPoint, UserIndex);
						}
						else
						{
							Buzzer_Beep(40, 3);
 8003668:	2028      	movs	r0, #40	; 0x28
 800366a:	2103      	movs	r1, #3
 800366c:	f7fe fd24 	bl	80020b8 <Buzzer_Beep>
 8003670:	e7e7      	b.n	8003642 <ShowerController_RemoteControl+0x1fa>
			//----------------------------------------------------------------------------------------------
			case KEY_LED_AUTO:
			{
				if(User_GetLedMode(UserIndex) == LED_POWER)
				{
					User_SetLedMode(LED_TEMPERATURE, UserIndex);
 8003672:	3801      	subs	r0, #1
 8003674:	1c21      	adds	r1, r4, #0
 8003676:	f7fd f945 	bl	8000904 <User_SetLedMode>
					Screen_Show(SCREEN_MESSAGE_LED_TEMPERATURE);
 800367a:	2013      	movs	r0, #19
 800367c:	f7ff fe10 	bl	80032a0 <Screen_Show>
 8003680:	e789      	b.n	8003596 <ShowerController_RemoteControl+0x14e>
			//----------------------------------------------------------------------------------------------
			case KEY_BIP:
			{
				if(User_GetBuzzer(UserIndex) == BUZZER_DISABLE)
				{
					User_SetBuzzer(BUZZER_ENABLED, UserIndex);
 8003682:	1c21      	adds	r1, r4, #0
 8003684:	38e1      	subs	r0, #225	; 0xe1
 8003686:	f7fd f9a1 	bl	80009cc <User_SetBuzzer>
					Screen_Show(SCREEN_MESSAGE_BIP_ON);
 800368a:	2018      	movs	r0, #24
 800368c:	f7ff fe08 	bl	80032a0 <Screen_Show>
					Buzzer_Control(BUZZER_ENABLED);
 8003690:	200f      	movs	r0, #15
 8003692:	f7fe fd25 	bl	80020e0 <Buzzer_Control>
 8003696:	e6e4      	b.n	8003462 <ShowerController_RemoteControl+0x1a>
					User_SetLedMode(LED_OFF, UserIndex);
					Screen_Show(SCREEN_MESSAGE_LED_OFF);
				}
				else
				{
					User_SetLedMode(Last_LedMode, UserIndex);
 8003698:	464b      	mov	r3, r9
 800369a:	1c21      	adds	r1, r4, #0
 800369c:	7918      	ldrb	r0, [r3, #4]
 800369e:	f7fd f931 	bl	8000904 <User_SetLedMode>
					Screen_Show(SCREEN_MESSAGE_LED_ON);
 80036a2:	2012      	movs	r0, #18
 80036a4:	f7ff fdfc 	bl	80032a0 <Screen_Show>
 80036a8:	e775      	b.n	8003596 <ShowerController_RemoteControl+0x14e>
					User_SetLedMode(LED_TEMPERATURE, UserIndex);
					Screen_Show(SCREEN_MESSAGE_LED_TEMPERATURE);
				}
				else if(User_GetLedMode(UserIndex) == LED_TEMPERATURE)
				{
					User_SetLedMode(LED_AUTO, UserIndex);
 80036aa:	3002      	adds	r0, #2
 80036ac:	1c21      	adds	r1, r4, #0
 80036ae:	f7fd f929 	bl	8000904 <User_SetLedMode>
					Screen_Show(SCREEN_MESSAGE_LED_AUTO);
 80036b2:	2014      	movs	r0, #20
 80036b4:	f7ff fdf4 	bl	80032a0 <Screen_Show>
 80036b8:	e76d      	b.n	8003596 <ShowerController_RemoteControl+0x14e>
				}
				else if(User_GetLedMode(UserIndex) == LED_AUTO)
				{
					User_SetLedMode(LED_FIXED, UserIndex);
 80036ba:	1c21      	adds	r1, r4, #0
 80036bc:	3001      	adds	r0, #1
 80036be:	f7fd f921 	bl	8000904 <User_SetLedMode>
					User_SetLedColor(LED_GetColor(), UserIndex);
 80036c2:	f7fd fc7f 	bl	8000fc4 <LED_GetColor>
 80036c6:	1c21      	adds	r1, r4, #0
 80036c8:	f7fd f930 	bl	800092c <User_SetLedColor>
					LED_SetFixedColor(User_GetLedColor(UserIndex));
 80036cc:	1c20      	adds	r0, r4, #0
 80036ce:	f7fd f923 	bl	8000918 <User_GetLedColor>
 80036d2:	f7fd fc71 	bl	8000fb8 <LED_SetFixedColor>

					Screen_Show(SCREEN_MESSAGE_LED_FIXED);
 80036d6:	2015      	movs	r0, #21
 80036d8:	f7ff fde2 	bl	80032a0 <Screen_Show>
 80036dc:	e75b      	b.n	8003596 <ShowerController_RemoteControl+0x14e>
			//----------------------------------------------------------------------------------------------
			case KEY_TEMPERATURE:
			{
				if(User_GetShowerMode(UserIndex) == SHOWER_MODE_POWER)
				{
					Controller_ResetPID();
 80036de:	f7fe ff97 	bl	8002610 <Controller_ResetPID>
 80036e2:	e73e      	b.n	8003562 <ShowerController_RemoteControl+0x11a>

					Screen_Show(SCREEN_MESSAGE_LED_FIXED);
				}
				else if(User_GetLedMode(UserIndex) == LED_FIXED)
				{
					User_SetLedMode(LED_POWER, UserIndex);
 80036e4:	3802      	subs	r0, #2
 80036e6:	1c21      	adds	r1, r4, #0
 80036e8:	f7fd f90c 	bl	8000904 <User_SetLedMode>
					Screen_Show(SCREEN_MESSAGE_LED_POWER);
 80036ec:	2016      	movs	r0, #22
 80036ee:	f7ff fdd7 	bl	80032a0 <Screen_Show>
 80036f2:	e750      	b.n	8003596 <ShowerController_RemoteControl+0x14e>
						break;
					}
					case SHOWER_MODE_TEMPERATURE:
					{
						/* Lower temperature must be equal to the inlet temperature */
						if(TemperatureSetPoint > ((NTC_GetWaterTemperature(TEMPERATURE_INLET) > MIN_SETPOINT) ? NTC_GetWaterTemperature(TEMPERATURE_INLET) : MIN_SETPOINT))
 80036f4:	2001      	movs	r0, #1
 80036f6:	f7ff fa27 	bl	8002b48 <NTC_GetWaterTemperature>
 80036fa:	1c03      	adds	r3, r0, #0
 80036fc:	e7ab      	b.n	8003656 <ShowerController_RemoteControl+0x20e>
 80036fe:	46c0      	nop			; (mov r8, r8)
 8003700:	20000260 	.word	0x20000260
 8003704:	24db9a65 	.word	0x24db9a65
 8003708:	24dbc13e 	.word	0x24dbc13e
 800370c:	24db32cd 	.word	0x24db32cd
 8003710:	24db817e 	.word	0x24db817e
 8003714:	24db9966 	.word	0x24db9966
 8003718:	24db51ae 	.word	0x24db51ae
 800371c:	24dbc43b 	.word	0x24dbc43b
 8003720:	24dbec13 	.word	0x24dbec13
 8003724:	24dbc23d 	.word	0x24dbc23d
 8003728:	24db09f6 	.word	0x24db09f6
 800372c:	24db10ef 	.word	0x24db10ef
 8003730:	24dba15e 	.word	0x24dba15e
 8003734:	24dbb04f 	.word	0x24dbb04f

08003738 <ShowerController_Init>:

	vTaskDelete(NULL);
}

void ShowerController_Init(void)
{
 8003738:	b508      	push	{r3, lr}
	CommandsQueueHandler = xQueueCreate(COMMANDS_QUEUE_SIZE, sizeof(uint32_t));
 800373a:	2104      	movs	r1, #4
 800373c:	2200      	movs	r2, #0
 800373e:	2001      	movs	r0, #1
 8003740:	f005 f858 	bl	80087f4 <xQueueGenericCreate>
 8003744:	4b02      	ldr	r3, [pc, #8]	; (8003750 <ShowerController_Init+0x18>)
 8003746:	6018      	str	r0, [r3, #0]
	TOUCH_Init(&CommandsQueueHandler);
 8003748:	1c18      	adds	r0, r3, #0
 800374a:	f7ff f8c7 	bl	80028dc <TOUCH_Init>
}
 800374e:	bd08      	pop	{r3, pc}
 8003750:	20000260 	.word	0x20000260

08003754 <ShowerController_Task>:

void ShowerController_Task(void)
{
 8003754:	b508      	push	{r3, lr}
	ShowerController_RemoteControl();
 8003756:	f7ff fe77 	bl	8003448 <ShowerController_RemoteControl>
 800375a:	46c0      	nop			; (mov r8, r8)

0800375c <ShowerController_SetShowerState>:
	TOUCH_Task();
}

void ShowerController_SetShowerState(uint8_t ShowerState)
{
	TakingShower = ShowerState;
 800375c:	4b01      	ldr	r3, [pc, #4]	; (8003764 <ShowerController_SetShowerState+0x8>)
 800375e:	7018      	strb	r0, [r3, #0]
}
 8003760:	4770      	bx	lr
 8003762:	46c0      	nop			; (mov r8, r8)
 8003764:	2000003a 	.word	0x2000003a

08003768 <ShowerController_GetShowerState>:

uint8_t ShowerController_GetShowerState(void)
{
	return TakingShower;
 8003768:	4b01      	ldr	r3, [pc, #4]	; (8003770 <ShowerController_GetShowerState+0x8>)
 800376a:	7818      	ldrb	r0, [r3, #0]
}
 800376c:	4770      	bx	lr
 800376e:	46c0      	nop			; (mov r8, r8)
 8003770:	2000003a 	.word	0x2000003a

08003774 <__aeabi_uidiv>:
 8003774:	2200      	movs	r2, #0
 8003776:	0843      	lsrs	r3, r0, #1
 8003778:	428b      	cmp	r3, r1
 800377a:	d374      	bcc.n	8003866 <__aeabi_uidiv+0xf2>
 800377c:	0903      	lsrs	r3, r0, #4
 800377e:	428b      	cmp	r3, r1
 8003780:	d35f      	bcc.n	8003842 <__aeabi_uidiv+0xce>
 8003782:	0a03      	lsrs	r3, r0, #8
 8003784:	428b      	cmp	r3, r1
 8003786:	d344      	bcc.n	8003812 <__aeabi_uidiv+0x9e>
 8003788:	0b03      	lsrs	r3, r0, #12
 800378a:	428b      	cmp	r3, r1
 800378c:	d328      	bcc.n	80037e0 <__aeabi_uidiv+0x6c>
 800378e:	0c03      	lsrs	r3, r0, #16
 8003790:	428b      	cmp	r3, r1
 8003792:	d30d      	bcc.n	80037b0 <__aeabi_uidiv+0x3c>
 8003794:	22ff      	movs	r2, #255	; 0xff
 8003796:	0209      	lsls	r1, r1, #8
 8003798:	ba12      	rev	r2, r2
 800379a:	0c03      	lsrs	r3, r0, #16
 800379c:	428b      	cmp	r3, r1
 800379e:	d302      	bcc.n	80037a6 <__aeabi_uidiv+0x32>
 80037a0:	1212      	asrs	r2, r2, #8
 80037a2:	0209      	lsls	r1, r1, #8
 80037a4:	d065      	beq.n	8003872 <__aeabi_uidiv+0xfe>
 80037a6:	0b03      	lsrs	r3, r0, #12
 80037a8:	428b      	cmp	r3, r1
 80037aa:	d319      	bcc.n	80037e0 <__aeabi_uidiv+0x6c>
 80037ac:	e000      	b.n	80037b0 <__aeabi_uidiv+0x3c>
 80037ae:	0a09      	lsrs	r1, r1, #8
 80037b0:	0bc3      	lsrs	r3, r0, #15
 80037b2:	428b      	cmp	r3, r1
 80037b4:	d301      	bcc.n	80037ba <__aeabi_uidiv+0x46>
 80037b6:	03cb      	lsls	r3, r1, #15
 80037b8:	1ac0      	subs	r0, r0, r3
 80037ba:	4152      	adcs	r2, r2
 80037bc:	0b83      	lsrs	r3, r0, #14
 80037be:	428b      	cmp	r3, r1
 80037c0:	d301      	bcc.n	80037c6 <__aeabi_uidiv+0x52>
 80037c2:	038b      	lsls	r3, r1, #14
 80037c4:	1ac0      	subs	r0, r0, r3
 80037c6:	4152      	adcs	r2, r2
 80037c8:	0b43      	lsrs	r3, r0, #13
 80037ca:	428b      	cmp	r3, r1
 80037cc:	d301      	bcc.n	80037d2 <__aeabi_uidiv+0x5e>
 80037ce:	034b      	lsls	r3, r1, #13
 80037d0:	1ac0      	subs	r0, r0, r3
 80037d2:	4152      	adcs	r2, r2
 80037d4:	0b03      	lsrs	r3, r0, #12
 80037d6:	428b      	cmp	r3, r1
 80037d8:	d301      	bcc.n	80037de <__aeabi_uidiv+0x6a>
 80037da:	030b      	lsls	r3, r1, #12
 80037dc:	1ac0      	subs	r0, r0, r3
 80037de:	4152      	adcs	r2, r2
 80037e0:	0ac3      	lsrs	r3, r0, #11
 80037e2:	428b      	cmp	r3, r1
 80037e4:	d301      	bcc.n	80037ea <__aeabi_uidiv+0x76>
 80037e6:	02cb      	lsls	r3, r1, #11
 80037e8:	1ac0      	subs	r0, r0, r3
 80037ea:	4152      	adcs	r2, r2
 80037ec:	0a83      	lsrs	r3, r0, #10
 80037ee:	428b      	cmp	r3, r1
 80037f0:	d301      	bcc.n	80037f6 <__aeabi_uidiv+0x82>
 80037f2:	028b      	lsls	r3, r1, #10
 80037f4:	1ac0      	subs	r0, r0, r3
 80037f6:	4152      	adcs	r2, r2
 80037f8:	0a43      	lsrs	r3, r0, #9
 80037fa:	428b      	cmp	r3, r1
 80037fc:	d301      	bcc.n	8003802 <__aeabi_uidiv+0x8e>
 80037fe:	024b      	lsls	r3, r1, #9
 8003800:	1ac0      	subs	r0, r0, r3
 8003802:	4152      	adcs	r2, r2
 8003804:	0a03      	lsrs	r3, r0, #8
 8003806:	428b      	cmp	r3, r1
 8003808:	d301      	bcc.n	800380e <__aeabi_uidiv+0x9a>
 800380a:	020b      	lsls	r3, r1, #8
 800380c:	1ac0      	subs	r0, r0, r3
 800380e:	4152      	adcs	r2, r2
 8003810:	d2cd      	bcs.n	80037ae <__aeabi_uidiv+0x3a>
 8003812:	09c3      	lsrs	r3, r0, #7
 8003814:	428b      	cmp	r3, r1
 8003816:	d301      	bcc.n	800381c <__aeabi_uidiv+0xa8>
 8003818:	01cb      	lsls	r3, r1, #7
 800381a:	1ac0      	subs	r0, r0, r3
 800381c:	4152      	adcs	r2, r2
 800381e:	0983      	lsrs	r3, r0, #6
 8003820:	428b      	cmp	r3, r1
 8003822:	d301      	bcc.n	8003828 <__aeabi_uidiv+0xb4>
 8003824:	018b      	lsls	r3, r1, #6
 8003826:	1ac0      	subs	r0, r0, r3
 8003828:	4152      	adcs	r2, r2
 800382a:	0943      	lsrs	r3, r0, #5
 800382c:	428b      	cmp	r3, r1
 800382e:	d301      	bcc.n	8003834 <__aeabi_uidiv+0xc0>
 8003830:	014b      	lsls	r3, r1, #5
 8003832:	1ac0      	subs	r0, r0, r3
 8003834:	4152      	adcs	r2, r2
 8003836:	0903      	lsrs	r3, r0, #4
 8003838:	428b      	cmp	r3, r1
 800383a:	d301      	bcc.n	8003840 <__aeabi_uidiv+0xcc>
 800383c:	010b      	lsls	r3, r1, #4
 800383e:	1ac0      	subs	r0, r0, r3
 8003840:	4152      	adcs	r2, r2
 8003842:	08c3      	lsrs	r3, r0, #3
 8003844:	428b      	cmp	r3, r1
 8003846:	d301      	bcc.n	800384c <__aeabi_uidiv+0xd8>
 8003848:	00cb      	lsls	r3, r1, #3
 800384a:	1ac0      	subs	r0, r0, r3
 800384c:	4152      	adcs	r2, r2
 800384e:	0883      	lsrs	r3, r0, #2
 8003850:	428b      	cmp	r3, r1
 8003852:	d301      	bcc.n	8003858 <__aeabi_uidiv+0xe4>
 8003854:	008b      	lsls	r3, r1, #2
 8003856:	1ac0      	subs	r0, r0, r3
 8003858:	4152      	adcs	r2, r2
 800385a:	0843      	lsrs	r3, r0, #1
 800385c:	428b      	cmp	r3, r1
 800385e:	d301      	bcc.n	8003864 <__aeabi_uidiv+0xf0>
 8003860:	004b      	lsls	r3, r1, #1
 8003862:	1ac0      	subs	r0, r0, r3
 8003864:	4152      	adcs	r2, r2
 8003866:	1a41      	subs	r1, r0, r1
 8003868:	d200      	bcs.n	800386c <__aeabi_uidiv+0xf8>
 800386a:	4601      	mov	r1, r0
 800386c:	4152      	adcs	r2, r2
 800386e:	4610      	mov	r0, r2
 8003870:	4770      	bx	lr
 8003872:	e7ff      	b.n	8003874 <__aeabi_uidiv+0x100>
 8003874:	b501      	push	{r0, lr}
 8003876:	2000      	movs	r0, #0
 8003878:	f000 f8fc 	bl	8003a74 <__aeabi_idiv0>
 800387c:	bd02      	pop	{r1, pc}
 800387e:	46c0      	nop			; (mov r8, r8)

08003880 <__aeabi_uidivmod>:
 8003880:	2900      	cmp	r1, #0
 8003882:	d0f7      	beq.n	8003874 <__aeabi_uidiv+0x100>
 8003884:	b503      	push	{r0, r1, lr}
 8003886:	f7ff ff75 	bl	8003774 <__aeabi_uidiv>
 800388a:	bc0e      	pop	{r1, r2, r3}
 800388c:	4342      	muls	r2, r0
 800388e:	1a89      	subs	r1, r1, r2
 8003890:	4718      	bx	r3
 8003892:	46c0      	nop			; (mov r8, r8)

08003894 <__aeabi_idiv>:
 8003894:	4603      	mov	r3, r0
 8003896:	430b      	orrs	r3, r1
 8003898:	d47f      	bmi.n	800399a <__aeabi_idiv+0x106>
 800389a:	2200      	movs	r2, #0
 800389c:	0843      	lsrs	r3, r0, #1
 800389e:	428b      	cmp	r3, r1
 80038a0:	d374      	bcc.n	800398c <__aeabi_idiv+0xf8>
 80038a2:	0903      	lsrs	r3, r0, #4
 80038a4:	428b      	cmp	r3, r1
 80038a6:	d35f      	bcc.n	8003968 <__aeabi_idiv+0xd4>
 80038a8:	0a03      	lsrs	r3, r0, #8
 80038aa:	428b      	cmp	r3, r1
 80038ac:	d344      	bcc.n	8003938 <__aeabi_idiv+0xa4>
 80038ae:	0b03      	lsrs	r3, r0, #12
 80038b0:	428b      	cmp	r3, r1
 80038b2:	d328      	bcc.n	8003906 <__aeabi_idiv+0x72>
 80038b4:	0c03      	lsrs	r3, r0, #16
 80038b6:	428b      	cmp	r3, r1
 80038b8:	d30d      	bcc.n	80038d6 <__aeabi_idiv+0x42>
 80038ba:	22ff      	movs	r2, #255	; 0xff
 80038bc:	0209      	lsls	r1, r1, #8
 80038be:	ba12      	rev	r2, r2
 80038c0:	0c03      	lsrs	r3, r0, #16
 80038c2:	428b      	cmp	r3, r1
 80038c4:	d302      	bcc.n	80038cc <__aeabi_idiv+0x38>
 80038c6:	1212      	asrs	r2, r2, #8
 80038c8:	0209      	lsls	r1, r1, #8
 80038ca:	d065      	beq.n	8003998 <__aeabi_idiv+0x104>
 80038cc:	0b03      	lsrs	r3, r0, #12
 80038ce:	428b      	cmp	r3, r1
 80038d0:	d319      	bcc.n	8003906 <__aeabi_idiv+0x72>
 80038d2:	e000      	b.n	80038d6 <__aeabi_idiv+0x42>
 80038d4:	0a09      	lsrs	r1, r1, #8
 80038d6:	0bc3      	lsrs	r3, r0, #15
 80038d8:	428b      	cmp	r3, r1
 80038da:	d301      	bcc.n	80038e0 <__aeabi_idiv+0x4c>
 80038dc:	03cb      	lsls	r3, r1, #15
 80038de:	1ac0      	subs	r0, r0, r3
 80038e0:	4152      	adcs	r2, r2
 80038e2:	0b83      	lsrs	r3, r0, #14
 80038e4:	428b      	cmp	r3, r1
 80038e6:	d301      	bcc.n	80038ec <__aeabi_idiv+0x58>
 80038e8:	038b      	lsls	r3, r1, #14
 80038ea:	1ac0      	subs	r0, r0, r3
 80038ec:	4152      	adcs	r2, r2
 80038ee:	0b43      	lsrs	r3, r0, #13
 80038f0:	428b      	cmp	r3, r1
 80038f2:	d301      	bcc.n	80038f8 <__aeabi_idiv+0x64>
 80038f4:	034b      	lsls	r3, r1, #13
 80038f6:	1ac0      	subs	r0, r0, r3
 80038f8:	4152      	adcs	r2, r2
 80038fa:	0b03      	lsrs	r3, r0, #12
 80038fc:	428b      	cmp	r3, r1
 80038fe:	d301      	bcc.n	8003904 <__aeabi_idiv+0x70>
 8003900:	030b      	lsls	r3, r1, #12
 8003902:	1ac0      	subs	r0, r0, r3
 8003904:	4152      	adcs	r2, r2
 8003906:	0ac3      	lsrs	r3, r0, #11
 8003908:	428b      	cmp	r3, r1
 800390a:	d301      	bcc.n	8003910 <__aeabi_idiv+0x7c>
 800390c:	02cb      	lsls	r3, r1, #11
 800390e:	1ac0      	subs	r0, r0, r3
 8003910:	4152      	adcs	r2, r2
 8003912:	0a83      	lsrs	r3, r0, #10
 8003914:	428b      	cmp	r3, r1
 8003916:	d301      	bcc.n	800391c <__aeabi_idiv+0x88>
 8003918:	028b      	lsls	r3, r1, #10
 800391a:	1ac0      	subs	r0, r0, r3
 800391c:	4152      	adcs	r2, r2
 800391e:	0a43      	lsrs	r3, r0, #9
 8003920:	428b      	cmp	r3, r1
 8003922:	d301      	bcc.n	8003928 <__aeabi_idiv+0x94>
 8003924:	024b      	lsls	r3, r1, #9
 8003926:	1ac0      	subs	r0, r0, r3
 8003928:	4152      	adcs	r2, r2
 800392a:	0a03      	lsrs	r3, r0, #8
 800392c:	428b      	cmp	r3, r1
 800392e:	d301      	bcc.n	8003934 <__aeabi_idiv+0xa0>
 8003930:	020b      	lsls	r3, r1, #8
 8003932:	1ac0      	subs	r0, r0, r3
 8003934:	4152      	adcs	r2, r2
 8003936:	d2cd      	bcs.n	80038d4 <__aeabi_idiv+0x40>
 8003938:	09c3      	lsrs	r3, r0, #7
 800393a:	428b      	cmp	r3, r1
 800393c:	d301      	bcc.n	8003942 <__aeabi_idiv+0xae>
 800393e:	01cb      	lsls	r3, r1, #7
 8003940:	1ac0      	subs	r0, r0, r3
 8003942:	4152      	adcs	r2, r2
 8003944:	0983      	lsrs	r3, r0, #6
 8003946:	428b      	cmp	r3, r1
 8003948:	d301      	bcc.n	800394e <__aeabi_idiv+0xba>
 800394a:	018b      	lsls	r3, r1, #6
 800394c:	1ac0      	subs	r0, r0, r3
 800394e:	4152      	adcs	r2, r2
 8003950:	0943      	lsrs	r3, r0, #5
 8003952:	428b      	cmp	r3, r1
 8003954:	d301      	bcc.n	800395a <__aeabi_idiv+0xc6>
 8003956:	014b      	lsls	r3, r1, #5
 8003958:	1ac0      	subs	r0, r0, r3
 800395a:	4152      	adcs	r2, r2
 800395c:	0903      	lsrs	r3, r0, #4
 800395e:	428b      	cmp	r3, r1
 8003960:	d301      	bcc.n	8003966 <__aeabi_idiv+0xd2>
 8003962:	010b      	lsls	r3, r1, #4
 8003964:	1ac0      	subs	r0, r0, r3
 8003966:	4152      	adcs	r2, r2
 8003968:	08c3      	lsrs	r3, r0, #3
 800396a:	428b      	cmp	r3, r1
 800396c:	d301      	bcc.n	8003972 <__aeabi_idiv+0xde>
 800396e:	00cb      	lsls	r3, r1, #3
 8003970:	1ac0      	subs	r0, r0, r3
 8003972:	4152      	adcs	r2, r2
 8003974:	0883      	lsrs	r3, r0, #2
 8003976:	428b      	cmp	r3, r1
 8003978:	d301      	bcc.n	800397e <__aeabi_idiv+0xea>
 800397a:	008b      	lsls	r3, r1, #2
 800397c:	1ac0      	subs	r0, r0, r3
 800397e:	4152      	adcs	r2, r2
 8003980:	0843      	lsrs	r3, r0, #1
 8003982:	428b      	cmp	r3, r1
 8003984:	d301      	bcc.n	800398a <__aeabi_idiv+0xf6>
 8003986:	004b      	lsls	r3, r1, #1
 8003988:	1ac0      	subs	r0, r0, r3
 800398a:	4152      	adcs	r2, r2
 800398c:	1a41      	subs	r1, r0, r1
 800398e:	d200      	bcs.n	8003992 <__aeabi_idiv+0xfe>
 8003990:	4601      	mov	r1, r0
 8003992:	4152      	adcs	r2, r2
 8003994:	4610      	mov	r0, r2
 8003996:	4770      	bx	lr
 8003998:	e05d      	b.n	8003a56 <__aeabi_idiv+0x1c2>
 800399a:	0fca      	lsrs	r2, r1, #31
 800399c:	d000      	beq.n	80039a0 <__aeabi_idiv+0x10c>
 800399e:	4249      	negs	r1, r1
 80039a0:	1003      	asrs	r3, r0, #32
 80039a2:	d300      	bcc.n	80039a6 <__aeabi_idiv+0x112>
 80039a4:	4240      	negs	r0, r0
 80039a6:	4053      	eors	r3, r2
 80039a8:	2200      	movs	r2, #0
 80039aa:	469c      	mov	ip, r3
 80039ac:	0903      	lsrs	r3, r0, #4
 80039ae:	428b      	cmp	r3, r1
 80039b0:	d32d      	bcc.n	8003a0e <__aeabi_idiv+0x17a>
 80039b2:	0a03      	lsrs	r3, r0, #8
 80039b4:	428b      	cmp	r3, r1
 80039b6:	d312      	bcc.n	80039de <__aeabi_idiv+0x14a>
 80039b8:	22fc      	movs	r2, #252	; 0xfc
 80039ba:	0189      	lsls	r1, r1, #6
 80039bc:	ba12      	rev	r2, r2
 80039be:	0a03      	lsrs	r3, r0, #8
 80039c0:	428b      	cmp	r3, r1
 80039c2:	d30c      	bcc.n	80039de <__aeabi_idiv+0x14a>
 80039c4:	0189      	lsls	r1, r1, #6
 80039c6:	1192      	asrs	r2, r2, #6
 80039c8:	428b      	cmp	r3, r1
 80039ca:	d308      	bcc.n	80039de <__aeabi_idiv+0x14a>
 80039cc:	0189      	lsls	r1, r1, #6
 80039ce:	1192      	asrs	r2, r2, #6
 80039d0:	428b      	cmp	r3, r1
 80039d2:	d304      	bcc.n	80039de <__aeabi_idiv+0x14a>
 80039d4:	0189      	lsls	r1, r1, #6
 80039d6:	d03a      	beq.n	8003a4e <__aeabi_idiv+0x1ba>
 80039d8:	1192      	asrs	r2, r2, #6
 80039da:	e000      	b.n	80039de <__aeabi_idiv+0x14a>
 80039dc:	0989      	lsrs	r1, r1, #6
 80039de:	09c3      	lsrs	r3, r0, #7
 80039e0:	428b      	cmp	r3, r1
 80039e2:	d301      	bcc.n	80039e8 <__aeabi_idiv+0x154>
 80039e4:	01cb      	lsls	r3, r1, #7
 80039e6:	1ac0      	subs	r0, r0, r3
 80039e8:	4152      	adcs	r2, r2
 80039ea:	0983      	lsrs	r3, r0, #6
 80039ec:	428b      	cmp	r3, r1
 80039ee:	d301      	bcc.n	80039f4 <__aeabi_idiv+0x160>
 80039f0:	018b      	lsls	r3, r1, #6
 80039f2:	1ac0      	subs	r0, r0, r3
 80039f4:	4152      	adcs	r2, r2
 80039f6:	0943      	lsrs	r3, r0, #5
 80039f8:	428b      	cmp	r3, r1
 80039fa:	d301      	bcc.n	8003a00 <__aeabi_idiv+0x16c>
 80039fc:	014b      	lsls	r3, r1, #5
 80039fe:	1ac0      	subs	r0, r0, r3
 8003a00:	4152      	adcs	r2, r2
 8003a02:	0903      	lsrs	r3, r0, #4
 8003a04:	428b      	cmp	r3, r1
 8003a06:	d301      	bcc.n	8003a0c <__aeabi_idiv+0x178>
 8003a08:	010b      	lsls	r3, r1, #4
 8003a0a:	1ac0      	subs	r0, r0, r3
 8003a0c:	4152      	adcs	r2, r2
 8003a0e:	08c3      	lsrs	r3, r0, #3
 8003a10:	428b      	cmp	r3, r1
 8003a12:	d301      	bcc.n	8003a18 <__aeabi_idiv+0x184>
 8003a14:	00cb      	lsls	r3, r1, #3
 8003a16:	1ac0      	subs	r0, r0, r3
 8003a18:	4152      	adcs	r2, r2
 8003a1a:	0883      	lsrs	r3, r0, #2
 8003a1c:	428b      	cmp	r3, r1
 8003a1e:	d301      	bcc.n	8003a24 <__aeabi_idiv+0x190>
 8003a20:	008b      	lsls	r3, r1, #2
 8003a22:	1ac0      	subs	r0, r0, r3
 8003a24:	4152      	adcs	r2, r2
 8003a26:	d2d9      	bcs.n	80039dc <__aeabi_idiv+0x148>
 8003a28:	0843      	lsrs	r3, r0, #1
 8003a2a:	428b      	cmp	r3, r1
 8003a2c:	d301      	bcc.n	8003a32 <__aeabi_idiv+0x19e>
 8003a2e:	004b      	lsls	r3, r1, #1
 8003a30:	1ac0      	subs	r0, r0, r3
 8003a32:	4152      	adcs	r2, r2
 8003a34:	1a41      	subs	r1, r0, r1
 8003a36:	d200      	bcs.n	8003a3a <__aeabi_idiv+0x1a6>
 8003a38:	4601      	mov	r1, r0
 8003a3a:	4663      	mov	r3, ip
 8003a3c:	4152      	adcs	r2, r2
 8003a3e:	105b      	asrs	r3, r3, #1
 8003a40:	4610      	mov	r0, r2
 8003a42:	d301      	bcc.n	8003a48 <__aeabi_idiv+0x1b4>
 8003a44:	4240      	negs	r0, r0
 8003a46:	2b00      	cmp	r3, #0
 8003a48:	d500      	bpl.n	8003a4c <__aeabi_idiv+0x1b8>
 8003a4a:	4249      	negs	r1, r1
 8003a4c:	4770      	bx	lr
 8003a4e:	4663      	mov	r3, ip
 8003a50:	105b      	asrs	r3, r3, #1
 8003a52:	d300      	bcc.n	8003a56 <__aeabi_idiv+0x1c2>
 8003a54:	4240      	negs	r0, r0
 8003a56:	b501      	push	{r0, lr}
 8003a58:	2000      	movs	r0, #0
 8003a5a:	f000 f80b 	bl	8003a74 <__aeabi_idiv0>
 8003a5e:	bd02      	pop	{r1, pc}

08003a60 <__aeabi_idivmod>:
 8003a60:	2900      	cmp	r1, #0
 8003a62:	d0f8      	beq.n	8003a56 <__aeabi_idiv+0x1c2>
 8003a64:	b503      	push	{r0, r1, lr}
 8003a66:	f7ff ff15 	bl	8003894 <__aeabi_idiv>
 8003a6a:	bc0e      	pop	{r1, r2, r3}
 8003a6c:	4342      	muls	r2, r0
 8003a6e:	1a89      	subs	r1, r1, r2
 8003a70:	4718      	bx	r3
 8003a72:	46c0      	nop			; (mov r8, r8)

08003a74 <__aeabi_idiv0>:
 8003a74:	4770      	bx	lr
 8003a76:	46c0      	nop			; (mov r8, r8)

08003a78 <__aeabi_d2uiz>:
 8003a78:	b538      	push	{r3, r4, r5, lr}
 8003a7a:	2200      	movs	r2, #0
 8003a7c:	4b0c      	ldr	r3, [pc, #48]	; (8003ab0 <__aeabi_d2uiz+0x38>)
 8003a7e:	1c04      	adds	r4, r0, #0
 8003a80:	1c0d      	adds	r5, r1, #0
 8003a82:	f001 fa2b 	bl	8004edc <__aeabi_dcmpge>
 8003a86:	2800      	cmp	r0, #0
 8003a88:	d104      	bne.n	8003a94 <__aeabi_d2uiz+0x1c>
 8003a8a:	1c20      	adds	r0, r4, #0
 8003a8c:	1c29      	adds	r1, r5, #0
 8003a8e:	f001 f94d 	bl	8004d2c <__aeabi_d2iz>
 8003a92:	bd38      	pop	{r3, r4, r5, pc}
 8003a94:	4b06      	ldr	r3, [pc, #24]	; (8003ab0 <__aeabi_d2uiz+0x38>)
 8003a96:	2200      	movs	r2, #0
 8003a98:	1c20      	adds	r0, r4, #0
 8003a9a:	1c29      	adds	r1, r5, #0
 8003a9c:	f000 fdcc 	bl	8004638 <__aeabi_dsub>
 8003aa0:	f001 f944 	bl	8004d2c <__aeabi_d2iz>
 8003aa4:	2380      	movs	r3, #128	; 0x80
 8003aa6:	061b      	lsls	r3, r3, #24
 8003aa8:	469c      	mov	ip, r3
 8003aaa:	4460      	add	r0, ip
 8003aac:	e7f1      	b.n	8003a92 <__aeabi_d2uiz+0x1a>
 8003aae:	46c0      	nop			; (mov r8, r8)
 8003ab0:	41e00000 	.word	0x41e00000

08003ab4 <__aeabi_dadd>:
 8003ab4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003ab6:	4645      	mov	r5, r8
 8003ab8:	4657      	mov	r7, sl
 8003aba:	464e      	mov	r6, r9
 8003abc:	4694      	mov	ip, r2
 8003abe:	004c      	lsls	r4, r1, #1
 8003ac0:	030a      	lsls	r2, r1, #12
 8003ac2:	0fc9      	lsrs	r1, r1, #31
 8003ac4:	b4e0      	push	{r5, r6, r7}
 8003ac6:	4688      	mov	r8, r1
 8003ac8:	1c0e      	adds	r6, r1, #0
 8003aca:	0319      	lsls	r1, r3, #12
 8003acc:	0f47      	lsrs	r7, r0, #29
 8003ace:	00c5      	lsls	r5, r0, #3
 8003ad0:	0a48      	lsrs	r0, r1, #9
 8003ad2:	4661      	mov	r1, ip
 8003ad4:	0f49      	lsrs	r1, r1, #29
 8003ad6:	4301      	orrs	r1, r0
 8003ad8:	4660      	mov	r0, ip
 8003ada:	0a52      	lsrs	r2, r2, #9
 8003adc:	4317      	orrs	r7, r2
 8003ade:	00c0      	lsls	r0, r0, #3
 8003ae0:	005a      	lsls	r2, r3, #1
 8003ae2:	0d64      	lsrs	r4, r4, #21
 8003ae4:	0d52      	lsrs	r2, r2, #21
 8003ae6:	0fdb      	lsrs	r3, r3, #31
 8003ae8:	4684      	mov	ip, r0
 8003aea:	4598      	cmp	r8, r3
 8003aec:	d100      	bne.n	8003af0 <__aeabi_dadd+0x3c>
 8003aee:	e0a7      	b.n	8003c40 <__aeabi_dadd+0x18c>
 8003af0:	1aa0      	subs	r0, r4, r2
 8003af2:	2800      	cmp	r0, #0
 8003af4:	dc00      	bgt.n	8003af8 <__aeabi_dadd+0x44>
 8003af6:	e101      	b.n	8003cfc <__aeabi_dadd+0x248>
 8003af8:	2a00      	cmp	r2, #0
 8003afa:	d13d      	bne.n	8003b78 <__aeabi_dadd+0xc4>
 8003afc:	4663      	mov	r3, ip
 8003afe:	430b      	orrs	r3, r1
 8003b00:	d000      	beq.n	8003b04 <__aeabi_dadd+0x50>
 8003b02:	e0d4      	b.n	8003cae <__aeabi_dadd+0x1fa>
 8003b04:	076b      	lsls	r3, r5, #29
 8003b06:	d100      	bne.n	8003b0a <__aeabi_dadd+0x56>
 8003b08:	e088      	b.n	8003c1c <__aeabi_dadd+0x168>
 8003b0a:	230f      	movs	r3, #15
 8003b0c:	402b      	ands	r3, r5
 8003b0e:	2b04      	cmp	r3, #4
 8003b10:	d100      	bne.n	8003b14 <__aeabi_dadd+0x60>
 8003b12:	e083      	b.n	8003c1c <__aeabi_dadd+0x168>
 8003b14:	1d2a      	adds	r2, r5, #4
 8003b16:	42aa      	cmp	r2, r5
 8003b18:	41ad      	sbcs	r5, r5
 8003b1a:	2380      	movs	r3, #128	; 0x80
 8003b1c:	426d      	negs	r5, r5
 8003b1e:	197f      	adds	r7, r7, r5
 8003b20:	041b      	lsls	r3, r3, #16
 8003b22:	403b      	ands	r3, r7
 8003b24:	4646      	mov	r6, r8
 8003b26:	1c15      	adds	r5, r2, #0
 8003b28:	2b00      	cmp	r3, #0
 8003b2a:	d100      	bne.n	8003b2e <__aeabi_dadd+0x7a>
 8003b2c:	e07c      	b.n	8003c28 <__aeabi_dadd+0x174>
 8003b2e:	4bcc      	ldr	r3, [pc, #816]	; (8003e60 <__aeabi_dadd+0x3ac>)
 8003b30:	3401      	adds	r4, #1
 8003b32:	429c      	cmp	r4, r3
 8003b34:	d100      	bne.n	8003b38 <__aeabi_dadd+0x84>
 8003b36:	e0fd      	b.n	8003d34 <__aeabi_dadd+0x280>
 8003b38:	1c3a      	adds	r2, r7, #0
 8003b3a:	4bca      	ldr	r3, [pc, #808]	; (8003e64 <__aeabi_dadd+0x3b0>)
 8003b3c:	08ed      	lsrs	r5, r5, #3
 8003b3e:	401a      	ands	r2, r3
 8003b40:	0750      	lsls	r0, r2, #29
 8003b42:	0564      	lsls	r4, r4, #21
 8003b44:	0252      	lsls	r2, r2, #9
 8003b46:	4305      	orrs	r5, r0
 8003b48:	0b12      	lsrs	r2, r2, #12
 8003b4a:	0d64      	lsrs	r4, r4, #21
 8003b4c:	2100      	movs	r1, #0
 8003b4e:	0312      	lsls	r2, r2, #12
 8003b50:	0d0b      	lsrs	r3, r1, #20
 8003b52:	051b      	lsls	r3, r3, #20
 8003b54:	0564      	lsls	r4, r4, #21
 8003b56:	0b12      	lsrs	r2, r2, #12
 8003b58:	431a      	orrs	r2, r3
 8003b5a:	0863      	lsrs	r3, r4, #1
 8003b5c:	4cc2      	ldr	r4, [pc, #776]	; (8003e68 <__aeabi_dadd+0x3b4>)
 8003b5e:	07f6      	lsls	r6, r6, #31
 8003b60:	4014      	ands	r4, r2
 8003b62:	431c      	orrs	r4, r3
 8003b64:	0064      	lsls	r4, r4, #1
 8003b66:	0864      	lsrs	r4, r4, #1
 8003b68:	4334      	orrs	r4, r6
 8003b6a:	1c28      	adds	r0, r5, #0
 8003b6c:	1c21      	adds	r1, r4, #0
 8003b6e:	bc1c      	pop	{r2, r3, r4}
 8003b70:	4690      	mov	r8, r2
 8003b72:	4699      	mov	r9, r3
 8003b74:	46a2      	mov	sl, r4
 8003b76:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003b78:	4bb9      	ldr	r3, [pc, #740]	; (8003e60 <__aeabi_dadd+0x3ac>)
 8003b7a:	429c      	cmp	r4, r3
 8003b7c:	d0c2      	beq.n	8003b04 <__aeabi_dadd+0x50>
 8003b7e:	2380      	movs	r3, #128	; 0x80
 8003b80:	041b      	lsls	r3, r3, #16
 8003b82:	4319      	orrs	r1, r3
 8003b84:	2838      	cmp	r0, #56	; 0x38
 8003b86:	dd00      	ble.n	8003b8a <__aeabi_dadd+0xd6>
 8003b88:	e0ec      	b.n	8003d64 <__aeabi_dadd+0x2b0>
 8003b8a:	281f      	cmp	r0, #31
 8003b8c:	dd00      	ble.n	8003b90 <__aeabi_dadd+0xdc>
 8003b8e:	e121      	b.n	8003dd4 <__aeabi_dadd+0x320>
 8003b90:	2220      	movs	r2, #32
 8003b92:	1c0e      	adds	r6, r1, #0
 8003b94:	4663      	mov	r3, ip
 8003b96:	1a12      	subs	r2, r2, r0
 8003b98:	4096      	lsls	r6, r2
 8003b9a:	40c3      	lsrs	r3, r0
 8003b9c:	4333      	orrs	r3, r6
 8003b9e:	4666      	mov	r6, ip
 8003ba0:	4096      	lsls	r6, r2
 8003ba2:	1c32      	adds	r2, r6, #0
 8003ba4:	1e56      	subs	r6, r2, #1
 8003ba6:	41b2      	sbcs	r2, r6
 8003ba8:	4313      	orrs	r3, r2
 8003baa:	1c0a      	adds	r2, r1, #0
 8003bac:	40c2      	lsrs	r2, r0
 8003bae:	1aeb      	subs	r3, r5, r3
 8003bb0:	429d      	cmp	r5, r3
 8003bb2:	41b6      	sbcs	r6, r6
 8003bb4:	1c1d      	adds	r5, r3, #0
 8003bb6:	1aba      	subs	r2, r7, r2
 8003bb8:	4276      	negs	r6, r6
 8003bba:	1b97      	subs	r7, r2, r6
 8003bbc:	023b      	lsls	r3, r7, #8
 8003bbe:	d400      	bmi.n	8003bc2 <__aeabi_dadd+0x10e>
 8003bc0:	e097      	b.n	8003cf2 <__aeabi_dadd+0x23e>
 8003bc2:	027a      	lsls	r2, r7, #9
 8003bc4:	0a56      	lsrs	r6, r2, #9
 8003bc6:	2e00      	cmp	r6, #0
 8003bc8:	d100      	bne.n	8003bcc <__aeabi_dadd+0x118>
 8003bca:	e0b6      	b.n	8003d3a <__aeabi_dadd+0x286>
 8003bcc:	1c30      	adds	r0, r6, #0
 8003bce:	f001 f98f 	bl	8004ef0 <__clzsi2>
 8003bd2:	1c03      	adds	r3, r0, #0
 8003bd4:	3b08      	subs	r3, #8
 8003bd6:	2b1f      	cmp	r3, #31
 8003bd8:	dd00      	ble.n	8003bdc <__aeabi_dadd+0x128>
 8003bda:	e0b7      	b.n	8003d4c <__aeabi_dadd+0x298>
 8003bdc:	409e      	lsls	r6, r3
 8003bde:	1c37      	adds	r7, r6, #0
 8003be0:	2628      	movs	r6, #40	; 0x28
 8003be2:	1c2a      	adds	r2, r5, #0
 8003be4:	1a36      	subs	r6, r6, r0
 8003be6:	40f2      	lsrs	r2, r6
 8003be8:	1c16      	adds	r6, r2, #0
 8003bea:	409d      	lsls	r5, r3
 8003bec:	433e      	orrs	r6, r7
 8003bee:	429c      	cmp	r4, r3
 8003bf0:	dd00      	ble.n	8003bf4 <__aeabi_dadd+0x140>
 8003bf2:	e0b2      	b.n	8003d5a <__aeabi_dadd+0x2a6>
 8003bf4:	1b1c      	subs	r4, r3, r4
 8003bf6:	1c62      	adds	r2, r4, #1
 8003bf8:	2a1f      	cmp	r2, #31
 8003bfa:	dd00      	ble.n	8003bfe <__aeabi_dadd+0x14a>
 8003bfc:	e0d8      	b.n	8003db0 <__aeabi_dadd+0x2fc>
 8003bfe:	231f      	movs	r3, #31
 8003c00:	1c29      	adds	r1, r5, #0
 8003c02:	1b1c      	subs	r4, r3, r4
 8003c04:	1c33      	adds	r3, r6, #0
 8003c06:	40a5      	lsls	r5, r4
 8003c08:	40a3      	lsls	r3, r4
 8003c0a:	40d1      	lsrs	r1, r2
 8003c0c:	1e6c      	subs	r4, r5, #1
 8003c0e:	41a5      	sbcs	r5, r4
 8003c10:	40d6      	lsrs	r6, r2
 8003c12:	4319      	orrs	r1, r3
 8003c14:	430d      	orrs	r5, r1
 8003c16:	1c37      	adds	r7, r6, #0
 8003c18:	2400      	movs	r4, #0
 8003c1a:	e773      	b.n	8003b04 <__aeabi_dadd+0x50>
 8003c1c:	2380      	movs	r3, #128	; 0x80
 8003c1e:	041b      	lsls	r3, r3, #16
 8003c20:	403b      	ands	r3, r7
 8003c22:	4646      	mov	r6, r8
 8003c24:	d000      	beq.n	8003c28 <__aeabi_dadd+0x174>
 8003c26:	e782      	b.n	8003b2e <__aeabi_dadd+0x7a>
 8003c28:	4b8d      	ldr	r3, [pc, #564]	; (8003e60 <__aeabi_dadd+0x3ac>)
 8003c2a:	08ed      	lsrs	r5, r5, #3
 8003c2c:	0778      	lsls	r0, r7, #29
 8003c2e:	4305      	orrs	r5, r0
 8003c30:	08fa      	lsrs	r2, r7, #3
 8003c32:	429c      	cmp	r4, r3
 8003c34:	d032      	beq.n	8003c9c <__aeabi_dadd+0x1e8>
 8003c36:	0312      	lsls	r2, r2, #12
 8003c38:	0564      	lsls	r4, r4, #21
 8003c3a:	0b12      	lsrs	r2, r2, #12
 8003c3c:	0d64      	lsrs	r4, r4, #21
 8003c3e:	e785      	b.n	8003b4c <__aeabi_dadd+0x98>
 8003c40:	1aa3      	subs	r3, r4, r2
 8003c42:	2b00      	cmp	r3, #0
 8003c44:	dc00      	bgt.n	8003c48 <__aeabi_dadd+0x194>
 8003c46:	e094      	b.n	8003d72 <__aeabi_dadd+0x2be>
 8003c48:	2a00      	cmp	r2, #0
 8003c4a:	d03c      	beq.n	8003cc6 <__aeabi_dadd+0x212>
 8003c4c:	4a84      	ldr	r2, [pc, #528]	; (8003e60 <__aeabi_dadd+0x3ac>)
 8003c4e:	4294      	cmp	r4, r2
 8003c50:	d100      	bne.n	8003c54 <__aeabi_dadd+0x1a0>
 8003c52:	e757      	b.n	8003b04 <__aeabi_dadd+0x50>
 8003c54:	2280      	movs	r2, #128	; 0x80
 8003c56:	0412      	lsls	r2, r2, #16
 8003c58:	4311      	orrs	r1, r2
 8003c5a:	2b38      	cmp	r3, #56	; 0x38
 8003c5c:	dc00      	bgt.n	8003c60 <__aeabi_dadd+0x1ac>
 8003c5e:	e105      	b.n	8003e6c <__aeabi_dadd+0x3b8>
 8003c60:	4663      	mov	r3, ip
 8003c62:	4319      	orrs	r1, r3
 8003c64:	1e48      	subs	r0, r1, #1
 8003c66:	4181      	sbcs	r1, r0
 8003c68:	2200      	movs	r2, #0
 8003c6a:	b2c8      	uxtb	r0, r1
 8003c6c:	1940      	adds	r0, r0, r5
 8003c6e:	42a8      	cmp	r0, r5
 8003c70:	419b      	sbcs	r3, r3
 8003c72:	1c05      	adds	r5, r0, #0
 8003c74:	19d2      	adds	r2, r2, r7
 8003c76:	425b      	negs	r3, r3
 8003c78:	18d7      	adds	r7, r2, r3
 8003c7a:	023b      	lsls	r3, r7, #8
 8003c7c:	d539      	bpl.n	8003cf2 <__aeabi_dadd+0x23e>
 8003c7e:	4b78      	ldr	r3, [pc, #480]	; (8003e60 <__aeabi_dadd+0x3ac>)
 8003c80:	3401      	adds	r4, #1
 8003c82:	429c      	cmp	r4, r3
 8003c84:	d100      	bne.n	8003c88 <__aeabi_dadd+0x1d4>
 8003c86:	e14c      	b.n	8003f22 <__aeabi_dadd+0x46e>
 8003c88:	2001      	movs	r0, #1
 8003c8a:	4a76      	ldr	r2, [pc, #472]	; (8003e64 <__aeabi_dadd+0x3b0>)
 8003c8c:	086b      	lsrs	r3, r5, #1
 8003c8e:	403a      	ands	r2, r7
 8003c90:	4028      	ands	r0, r5
 8003c92:	4318      	orrs	r0, r3
 8003c94:	07d5      	lsls	r5, r2, #31
 8003c96:	4305      	orrs	r5, r0
 8003c98:	0857      	lsrs	r7, r2, #1
 8003c9a:	e733      	b.n	8003b04 <__aeabi_dadd+0x50>
 8003c9c:	1c2b      	adds	r3, r5, #0
 8003c9e:	4313      	orrs	r3, r2
 8003ca0:	d048      	beq.n	8003d34 <__aeabi_dadd+0x280>
 8003ca2:	2380      	movs	r3, #128	; 0x80
 8003ca4:	031b      	lsls	r3, r3, #12
 8003ca6:	431a      	orrs	r2, r3
 8003ca8:	0312      	lsls	r2, r2, #12
 8003caa:	0b12      	lsrs	r2, r2, #12
 8003cac:	e74e      	b.n	8003b4c <__aeabi_dadd+0x98>
 8003cae:	3801      	subs	r0, #1
 8003cb0:	2800      	cmp	r0, #0
 8003cb2:	d178      	bne.n	8003da6 <__aeabi_dadd+0x2f2>
 8003cb4:	4663      	mov	r3, ip
 8003cb6:	1aee      	subs	r6, r5, r3
 8003cb8:	42b5      	cmp	r5, r6
 8003cba:	419b      	sbcs	r3, r3
 8003cbc:	1a7a      	subs	r2, r7, r1
 8003cbe:	425b      	negs	r3, r3
 8003cc0:	1ad7      	subs	r7, r2, r3
 8003cc2:	1c35      	adds	r5, r6, #0
 8003cc4:	e77a      	b.n	8003bbc <__aeabi_dadd+0x108>
 8003cc6:	1c02      	adds	r2, r0, #0
 8003cc8:	430a      	orrs	r2, r1
 8003cca:	d100      	bne.n	8003cce <__aeabi_dadd+0x21a>
 8003ccc:	e71a      	b.n	8003b04 <__aeabi_dadd+0x50>
 8003cce:	3b01      	subs	r3, #1
 8003cd0:	2b00      	cmp	r3, #0
 8003cd2:	d000      	beq.n	8003cd6 <__aeabi_dadd+0x222>
 8003cd4:	e0f2      	b.n	8003ebc <__aeabi_dadd+0x408>
 8003cd6:	1940      	adds	r0, r0, r5
 8003cd8:	42a8      	cmp	r0, r5
 8003cda:	419b      	sbcs	r3, r3
 8003cdc:	19ca      	adds	r2, r1, r7
 8003cde:	425b      	negs	r3, r3
 8003ce0:	18d7      	adds	r7, r2, r3
 8003ce2:	1c05      	adds	r5, r0, #0
 8003ce4:	e7c9      	b.n	8003c7a <__aeabi_dadd+0x1c6>
 8003ce6:	1c13      	adds	r3, r2, #0
 8003ce8:	4333      	orrs	r3, r6
 8003cea:	d100      	bne.n	8003cee <__aeabi_dadd+0x23a>
 8003cec:	e118      	b.n	8003f20 <__aeabi_dadd+0x46c>
 8003cee:	1c17      	adds	r7, r2, #0
 8003cf0:	1c35      	adds	r5, r6, #0
 8003cf2:	4646      	mov	r6, r8
 8003cf4:	076b      	lsls	r3, r5, #29
 8003cf6:	d000      	beq.n	8003cfa <__aeabi_dadd+0x246>
 8003cf8:	e707      	b.n	8003b0a <__aeabi_dadd+0x56>
 8003cfa:	e795      	b.n	8003c28 <__aeabi_dadd+0x174>
 8003cfc:	2800      	cmp	r0, #0
 8003cfe:	d17a      	bne.n	8003df6 <__aeabi_dadd+0x342>
 8003d00:	1c62      	adds	r2, r4, #1
 8003d02:	0552      	lsls	r2, r2, #21
 8003d04:	0d52      	lsrs	r2, r2, #21
 8003d06:	2a01      	cmp	r2, #1
 8003d08:	dc00      	bgt.n	8003d0c <__aeabi_dadd+0x258>
 8003d0a:	e0fb      	b.n	8003f04 <__aeabi_dadd+0x450>
 8003d0c:	4662      	mov	r2, ip
 8003d0e:	1aaa      	subs	r2, r5, r2
 8003d10:	4295      	cmp	r5, r2
 8003d12:	41b6      	sbcs	r6, r6
 8003d14:	4691      	mov	r9, r2
 8003d16:	1a78      	subs	r0, r7, r1
 8003d18:	4272      	negs	r2, r6
 8003d1a:	1a86      	subs	r6, r0, r2
 8003d1c:	0232      	lsls	r2, r6, #8
 8003d1e:	d400      	bmi.n	8003d22 <__aeabi_dadd+0x26e>
 8003d20:	e093      	b.n	8003e4a <__aeabi_dadd+0x396>
 8003d22:	4662      	mov	r2, ip
 8003d24:	1b55      	subs	r5, r2, r5
 8003d26:	45ac      	cmp	ip, r5
 8003d28:	4180      	sbcs	r0, r0
 8003d2a:	1bcf      	subs	r7, r1, r7
 8003d2c:	4240      	negs	r0, r0
 8003d2e:	1a3e      	subs	r6, r7, r0
 8003d30:	4698      	mov	r8, r3
 8003d32:	e748      	b.n	8003bc6 <__aeabi_dadd+0x112>
 8003d34:	2200      	movs	r2, #0
 8003d36:	2500      	movs	r5, #0
 8003d38:	e708      	b.n	8003b4c <__aeabi_dadd+0x98>
 8003d3a:	1c28      	adds	r0, r5, #0
 8003d3c:	f001 f8d8 	bl	8004ef0 <__clzsi2>
 8003d40:	3020      	adds	r0, #32
 8003d42:	1c03      	adds	r3, r0, #0
 8003d44:	3b08      	subs	r3, #8
 8003d46:	2b1f      	cmp	r3, #31
 8003d48:	dc00      	bgt.n	8003d4c <__aeabi_dadd+0x298>
 8003d4a:	e747      	b.n	8003bdc <__aeabi_dadd+0x128>
 8003d4c:	3828      	subs	r0, #40	; 0x28
 8003d4e:	4085      	lsls	r5, r0
 8003d50:	1c2e      	adds	r6, r5, #0
 8003d52:	2500      	movs	r5, #0
 8003d54:	429c      	cmp	r4, r3
 8003d56:	dc00      	bgt.n	8003d5a <__aeabi_dadd+0x2a6>
 8003d58:	e74c      	b.n	8003bf4 <__aeabi_dadd+0x140>
 8003d5a:	4a42      	ldr	r2, [pc, #264]	; (8003e64 <__aeabi_dadd+0x3b0>)
 8003d5c:	1ae4      	subs	r4, r4, r3
 8003d5e:	4016      	ands	r6, r2
 8003d60:	1c37      	adds	r7, r6, #0
 8003d62:	e6cf      	b.n	8003b04 <__aeabi_dadd+0x50>
 8003d64:	4663      	mov	r3, ip
 8003d66:	4319      	orrs	r1, r3
 8003d68:	1e4b      	subs	r3, r1, #1
 8003d6a:	4199      	sbcs	r1, r3
 8003d6c:	2200      	movs	r2, #0
 8003d6e:	b2cb      	uxtb	r3, r1
 8003d70:	e71d      	b.n	8003bae <__aeabi_dadd+0xfa>
 8003d72:	2b00      	cmp	r3, #0
 8003d74:	d000      	beq.n	8003d78 <__aeabi_dadd+0x2c4>
 8003d76:	e0f2      	b.n	8003f5e <__aeabi_dadd+0x4aa>
 8003d78:	1c60      	adds	r0, r4, #1
 8003d7a:	0543      	lsls	r3, r0, #21
 8003d7c:	0d5b      	lsrs	r3, r3, #21
 8003d7e:	2b01      	cmp	r3, #1
 8003d80:	dc00      	bgt.n	8003d84 <__aeabi_dadd+0x2d0>
 8003d82:	e0a4      	b.n	8003ece <__aeabi_dadd+0x41a>
 8003d84:	4b36      	ldr	r3, [pc, #216]	; (8003e60 <__aeabi_dadd+0x3ac>)
 8003d86:	4298      	cmp	r0, r3
 8003d88:	d100      	bne.n	8003d8c <__aeabi_dadd+0x2d8>
 8003d8a:	e121      	b.n	8003fd0 <__aeabi_dadd+0x51c>
 8003d8c:	4663      	mov	r3, ip
 8003d8e:	195c      	adds	r4, r3, r5
 8003d90:	42ac      	cmp	r4, r5
 8003d92:	419b      	sbcs	r3, r3
 8003d94:	19cf      	adds	r7, r1, r7
 8003d96:	425b      	negs	r3, r3
 8003d98:	18fa      	adds	r2, r7, r3
 8003d9a:	0864      	lsrs	r4, r4, #1
 8003d9c:	07d5      	lsls	r5, r2, #31
 8003d9e:	4325      	orrs	r5, r4
 8003da0:	0857      	lsrs	r7, r2, #1
 8003da2:	1c04      	adds	r4, r0, #0
 8003da4:	e6ae      	b.n	8003b04 <__aeabi_dadd+0x50>
 8003da6:	4b2e      	ldr	r3, [pc, #184]	; (8003e60 <__aeabi_dadd+0x3ac>)
 8003da8:	429c      	cmp	r4, r3
 8003daa:	d000      	beq.n	8003dae <__aeabi_dadd+0x2fa>
 8003dac:	e6ea      	b.n	8003b84 <__aeabi_dadd+0xd0>
 8003dae:	e6a9      	b.n	8003b04 <__aeabi_dadd+0x50>
 8003db0:	1c21      	adds	r1, r4, #0
 8003db2:	1c33      	adds	r3, r6, #0
 8003db4:	391f      	subs	r1, #31
 8003db6:	40cb      	lsrs	r3, r1
 8003db8:	1c19      	adds	r1, r3, #0
 8003dba:	2a20      	cmp	r2, #32
 8003dbc:	d100      	bne.n	8003dc0 <__aeabi_dadd+0x30c>
 8003dbe:	e082      	b.n	8003ec6 <__aeabi_dadd+0x412>
 8003dc0:	233f      	movs	r3, #63	; 0x3f
 8003dc2:	1b1c      	subs	r4, r3, r4
 8003dc4:	40a6      	lsls	r6, r4
 8003dc6:	4335      	orrs	r5, r6
 8003dc8:	1e6e      	subs	r6, r5, #1
 8003dca:	41b5      	sbcs	r5, r6
 8003dcc:	2700      	movs	r7, #0
 8003dce:	430d      	orrs	r5, r1
 8003dd0:	2400      	movs	r4, #0
 8003dd2:	e78e      	b.n	8003cf2 <__aeabi_dadd+0x23e>
 8003dd4:	1c03      	adds	r3, r0, #0
 8003dd6:	1c0e      	adds	r6, r1, #0
 8003dd8:	3b20      	subs	r3, #32
 8003dda:	40de      	lsrs	r6, r3
 8003ddc:	2820      	cmp	r0, #32
 8003dde:	d074      	beq.n	8003eca <__aeabi_dadd+0x416>
 8003de0:	2340      	movs	r3, #64	; 0x40
 8003de2:	1a1b      	subs	r3, r3, r0
 8003de4:	4099      	lsls	r1, r3
 8003de6:	1c0b      	adds	r3, r1, #0
 8003de8:	4662      	mov	r2, ip
 8003dea:	4313      	orrs	r3, r2
 8003dec:	1e59      	subs	r1, r3, #1
 8003dee:	418b      	sbcs	r3, r1
 8003df0:	2200      	movs	r2, #0
 8003df2:	4333      	orrs	r3, r6
 8003df4:	e6db      	b.n	8003bae <__aeabi_dadd+0xfa>
 8003df6:	2c00      	cmp	r4, #0
 8003df8:	d050      	beq.n	8003e9c <__aeabi_dadd+0x3e8>
 8003dfa:	4c19      	ldr	r4, [pc, #100]	; (8003e60 <__aeabi_dadd+0x3ac>)
 8003dfc:	42a2      	cmp	r2, r4
 8003dfe:	d100      	bne.n	8003e02 <__aeabi_dadd+0x34e>
 8003e00:	e0a8      	b.n	8003f54 <__aeabi_dadd+0x4a0>
 8003e02:	2480      	movs	r4, #128	; 0x80
 8003e04:	0424      	lsls	r4, r4, #16
 8003e06:	4240      	negs	r0, r0
 8003e08:	4327      	orrs	r7, r4
 8003e0a:	2838      	cmp	r0, #56	; 0x38
 8003e0c:	dd00      	ble.n	8003e10 <__aeabi_dadd+0x35c>
 8003e0e:	e0d9      	b.n	8003fc4 <__aeabi_dadd+0x510>
 8003e10:	281f      	cmp	r0, #31
 8003e12:	dd00      	ble.n	8003e16 <__aeabi_dadd+0x362>
 8003e14:	e139      	b.n	800408a <__aeabi_dadd+0x5d6>
 8003e16:	2420      	movs	r4, #32
 8003e18:	1c3e      	adds	r6, r7, #0
 8003e1a:	1a24      	subs	r4, r4, r0
 8003e1c:	40a6      	lsls	r6, r4
 8003e1e:	46b0      	mov	r8, r6
 8003e20:	1c2e      	adds	r6, r5, #0
 8003e22:	46a1      	mov	r9, r4
 8003e24:	40c6      	lsrs	r6, r0
 8003e26:	4644      	mov	r4, r8
 8003e28:	4326      	orrs	r6, r4
 8003e2a:	464c      	mov	r4, r9
 8003e2c:	40a5      	lsls	r5, r4
 8003e2e:	1e6c      	subs	r4, r5, #1
 8003e30:	41a5      	sbcs	r5, r4
 8003e32:	40c7      	lsrs	r7, r0
 8003e34:	4335      	orrs	r5, r6
 8003e36:	4660      	mov	r0, ip
 8003e38:	1b45      	subs	r5, r0, r5
 8003e3a:	1bcf      	subs	r7, r1, r7
 8003e3c:	45ac      	cmp	ip, r5
 8003e3e:	4189      	sbcs	r1, r1
 8003e40:	4249      	negs	r1, r1
 8003e42:	1a7f      	subs	r7, r7, r1
 8003e44:	1c14      	adds	r4, r2, #0
 8003e46:	4698      	mov	r8, r3
 8003e48:	e6b8      	b.n	8003bbc <__aeabi_dadd+0x108>
 8003e4a:	464b      	mov	r3, r9
 8003e4c:	464d      	mov	r5, r9
 8003e4e:	4333      	orrs	r3, r6
 8003e50:	d000      	beq.n	8003e54 <__aeabi_dadd+0x3a0>
 8003e52:	e6b8      	b.n	8003bc6 <__aeabi_dadd+0x112>
 8003e54:	2600      	movs	r6, #0
 8003e56:	2700      	movs	r7, #0
 8003e58:	2400      	movs	r4, #0
 8003e5a:	2500      	movs	r5, #0
 8003e5c:	e6e4      	b.n	8003c28 <__aeabi_dadd+0x174>
 8003e5e:	46c0      	nop			; (mov r8, r8)
 8003e60:	000007ff 	.word	0x000007ff
 8003e64:	ff7fffff 	.word	0xff7fffff
 8003e68:	800fffff 	.word	0x800fffff
 8003e6c:	2b1f      	cmp	r3, #31
 8003e6e:	dc5b      	bgt.n	8003f28 <__aeabi_dadd+0x474>
 8003e70:	2220      	movs	r2, #32
 8003e72:	1c08      	adds	r0, r1, #0
 8003e74:	1ad2      	subs	r2, r2, r3
 8003e76:	4090      	lsls	r0, r2
 8003e78:	4681      	mov	r9, r0
 8003e7a:	4660      	mov	r0, ip
 8003e7c:	4692      	mov	sl, r2
 8003e7e:	40d8      	lsrs	r0, r3
 8003e80:	464a      	mov	r2, r9
 8003e82:	4310      	orrs	r0, r2
 8003e84:	4681      	mov	r9, r0
 8003e86:	4652      	mov	r2, sl
 8003e88:	4660      	mov	r0, ip
 8003e8a:	4090      	lsls	r0, r2
 8003e8c:	1c02      	adds	r2, r0, #0
 8003e8e:	1e50      	subs	r0, r2, #1
 8003e90:	4182      	sbcs	r2, r0
 8003e92:	4648      	mov	r0, r9
 8003e94:	4310      	orrs	r0, r2
 8003e96:	1c0a      	adds	r2, r1, #0
 8003e98:	40da      	lsrs	r2, r3
 8003e9a:	e6e7      	b.n	8003c6c <__aeabi_dadd+0x1b8>
 8003e9c:	1c3c      	adds	r4, r7, #0
 8003e9e:	432c      	orrs	r4, r5
 8003ea0:	d058      	beq.n	8003f54 <__aeabi_dadd+0x4a0>
 8003ea2:	43c0      	mvns	r0, r0
 8003ea4:	2800      	cmp	r0, #0
 8003ea6:	d151      	bne.n	8003f4c <__aeabi_dadd+0x498>
 8003ea8:	4660      	mov	r0, ip
 8003eaa:	1b45      	subs	r5, r0, r5
 8003eac:	45ac      	cmp	ip, r5
 8003eae:	4180      	sbcs	r0, r0
 8003eb0:	1bcf      	subs	r7, r1, r7
 8003eb2:	4240      	negs	r0, r0
 8003eb4:	1a3f      	subs	r7, r7, r0
 8003eb6:	1c14      	adds	r4, r2, #0
 8003eb8:	4698      	mov	r8, r3
 8003eba:	e67f      	b.n	8003bbc <__aeabi_dadd+0x108>
 8003ebc:	4a8f      	ldr	r2, [pc, #572]	; (80040fc <__aeabi_dadd+0x648>)
 8003ebe:	4294      	cmp	r4, r2
 8003ec0:	d000      	beq.n	8003ec4 <__aeabi_dadd+0x410>
 8003ec2:	e6ca      	b.n	8003c5a <__aeabi_dadd+0x1a6>
 8003ec4:	e61e      	b.n	8003b04 <__aeabi_dadd+0x50>
 8003ec6:	2600      	movs	r6, #0
 8003ec8:	e77d      	b.n	8003dc6 <__aeabi_dadd+0x312>
 8003eca:	2300      	movs	r3, #0
 8003ecc:	e78c      	b.n	8003de8 <__aeabi_dadd+0x334>
 8003ece:	1c3b      	adds	r3, r7, #0
 8003ed0:	432b      	orrs	r3, r5
 8003ed2:	2c00      	cmp	r4, #0
 8003ed4:	d000      	beq.n	8003ed8 <__aeabi_dadd+0x424>
 8003ed6:	e0bd      	b.n	8004054 <__aeabi_dadd+0x5a0>
 8003ed8:	2b00      	cmp	r3, #0
 8003eda:	d100      	bne.n	8003ede <__aeabi_dadd+0x42a>
 8003edc:	e0f5      	b.n	80040ca <__aeabi_dadd+0x616>
 8003ede:	4663      	mov	r3, ip
 8003ee0:	430b      	orrs	r3, r1
 8003ee2:	d100      	bne.n	8003ee6 <__aeabi_dadd+0x432>
 8003ee4:	e60e      	b.n	8003b04 <__aeabi_dadd+0x50>
 8003ee6:	4663      	mov	r3, ip
 8003ee8:	195b      	adds	r3, r3, r5
 8003eea:	42ab      	cmp	r3, r5
 8003eec:	4180      	sbcs	r0, r0
 8003eee:	19ca      	adds	r2, r1, r7
 8003ef0:	4240      	negs	r0, r0
 8003ef2:	1817      	adds	r7, r2, r0
 8003ef4:	023a      	lsls	r2, r7, #8
 8003ef6:	d400      	bmi.n	8003efa <__aeabi_dadd+0x446>
 8003ef8:	e0fc      	b.n	80040f4 <__aeabi_dadd+0x640>
 8003efa:	4a81      	ldr	r2, [pc, #516]	; (8004100 <__aeabi_dadd+0x64c>)
 8003efc:	1c1d      	adds	r5, r3, #0
 8003efe:	4017      	ands	r7, r2
 8003f00:	3401      	adds	r4, #1
 8003f02:	e5ff      	b.n	8003b04 <__aeabi_dadd+0x50>
 8003f04:	1c3a      	adds	r2, r7, #0
 8003f06:	432a      	orrs	r2, r5
 8003f08:	2c00      	cmp	r4, #0
 8003f0a:	d151      	bne.n	8003fb0 <__aeabi_dadd+0x4fc>
 8003f0c:	2a00      	cmp	r2, #0
 8003f0e:	d000      	beq.n	8003f12 <__aeabi_dadd+0x45e>
 8003f10:	e085      	b.n	800401e <__aeabi_dadd+0x56a>
 8003f12:	4662      	mov	r2, ip
 8003f14:	430a      	orrs	r2, r1
 8003f16:	d003      	beq.n	8003f20 <__aeabi_dadd+0x46c>
 8003f18:	1c0f      	adds	r7, r1, #0
 8003f1a:	4665      	mov	r5, ip
 8003f1c:	4698      	mov	r8, r3
 8003f1e:	e5f1      	b.n	8003b04 <__aeabi_dadd+0x50>
 8003f20:	2600      	movs	r6, #0
 8003f22:	2700      	movs	r7, #0
 8003f24:	2500      	movs	r5, #0
 8003f26:	e67f      	b.n	8003c28 <__aeabi_dadd+0x174>
 8003f28:	1c18      	adds	r0, r3, #0
 8003f2a:	1c0a      	adds	r2, r1, #0
 8003f2c:	3820      	subs	r0, #32
 8003f2e:	40c2      	lsrs	r2, r0
 8003f30:	2b20      	cmp	r3, #32
 8003f32:	d100      	bne.n	8003f36 <__aeabi_dadd+0x482>
 8003f34:	e0a7      	b.n	8004086 <__aeabi_dadd+0x5d2>
 8003f36:	2040      	movs	r0, #64	; 0x40
 8003f38:	1ac0      	subs	r0, r0, r3
 8003f3a:	4081      	lsls	r1, r0
 8003f3c:	1c08      	adds	r0, r1, #0
 8003f3e:	4663      	mov	r3, ip
 8003f40:	4318      	orrs	r0, r3
 8003f42:	1e41      	subs	r1, r0, #1
 8003f44:	4188      	sbcs	r0, r1
 8003f46:	4310      	orrs	r0, r2
 8003f48:	2200      	movs	r2, #0
 8003f4a:	e68f      	b.n	8003c6c <__aeabi_dadd+0x1b8>
 8003f4c:	4c6b      	ldr	r4, [pc, #428]	; (80040fc <__aeabi_dadd+0x648>)
 8003f4e:	42a2      	cmp	r2, r4
 8003f50:	d000      	beq.n	8003f54 <__aeabi_dadd+0x4a0>
 8003f52:	e75a      	b.n	8003e0a <__aeabi_dadd+0x356>
 8003f54:	1c0f      	adds	r7, r1, #0
 8003f56:	4665      	mov	r5, ip
 8003f58:	1c14      	adds	r4, r2, #0
 8003f5a:	4698      	mov	r8, r3
 8003f5c:	e5d2      	b.n	8003b04 <__aeabi_dadd+0x50>
 8003f5e:	2c00      	cmp	r4, #0
 8003f60:	d13a      	bne.n	8003fd8 <__aeabi_dadd+0x524>
 8003f62:	1c38      	adds	r0, r7, #0
 8003f64:	4328      	orrs	r0, r5
 8003f66:	d071      	beq.n	800404c <__aeabi_dadd+0x598>
 8003f68:	43db      	mvns	r3, r3
 8003f6a:	2b00      	cmp	r3, #0
 8003f6c:	d018      	beq.n	8003fa0 <__aeabi_dadd+0x4ec>
 8003f6e:	4863      	ldr	r0, [pc, #396]	; (80040fc <__aeabi_dadd+0x648>)
 8003f70:	4282      	cmp	r2, r0
 8003f72:	d06b      	beq.n	800404c <__aeabi_dadd+0x598>
 8003f74:	2b38      	cmp	r3, #56	; 0x38
 8003f76:	dd00      	ble.n	8003f7a <__aeabi_dadd+0x4c6>
 8003f78:	e09d      	b.n	80040b6 <__aeabi_dadd+0x602>
 8003f7a:	2b1f      	cmp	r3, #31
 8003f7c:	dd00      	ble.n	8003f80 <__aeabi_dadd+0x4cc>
 8003f7e:	e0a7      	b.n	80040d0 <__aeabi_dadd+0x61c>
 8003f80:	2020      	movs	r0, #32
 8003f82:	1c3c      	adds	r4, r7, #0
 8003f84:	1ac0      	subs	r0, r0, r3
 8003f86:	4084      	lsls	r4, r0
 8003f88:	46a1      	mov	r9, r4
 8003f8a:	1c2c      	adds	r4, r5, #0
 8003f8c:	4682      	mov	sl, r0
 8003f8e:	40dc      	lsrs	r4, r3
 8003f90:	4648      	mov	r0, r9
 8003f92:	4304      	orrs	r4, r0
 8003f94:	4650      	mov	r0, sl
 8003f96:	4085      	lsls	r5, r0
 8003f98:	1e68      	subs	r0, r5, #1
 8003f9a:	4185      	sbcs	r5, r0
 8003f9c:	40df      	lsrs	r7, r3
 8003f9e:	4325      	orrs	r5, r4
 8003fa0:	4465      	add	r5, ip
 8003fa2:	4565      	cmp	r5, ip
 8003fa4:	419b      	sbcs	r3, r3
 8003fa6:	187f      	adds	r7, r7, r1
 8003fa8:	425b      	negs	r3, r3
 8003faa:	18ff      	adds	r7, r7, r3
 8003fac:	1c14      	adds	r4, r2, #0
 8003fae:	e664      	b.n	8003c7a <__aeabi_dadd+0x1c6>
 8003fb0:	2a00      	cmp	r2, #0
 8003fb2:	d119      	bne.n	8003fe8 <__aeabi_dadd+0x534>
 8003fb4:	4662      	mov	r2, ip
 8003fb6:	430a      	orrs	r2, r1
 8003fb8:	d077      	beq.n	80040aa <__aeabi_dadd+0x5f6>
 8003fba:	1c0f      	adds	r7, r1, #0
 8003fbc:	4665      	mov	r5, ip
 8003fbe:	4698      	mov	r8, r3
 8003fc0:	4c4e      	ldr	r4, [pc, #312]	; (80040fc <__aeabi_dadd+0x648>)
 8003fc2:	e59f      	b.n	8003b04 <__aeabi_dadd+0x50>
 8003fc4:	433d      	orrs	r5, r7
 8003fc6:	1e6f      	subs	r7, r5, #1
 8003fc8:	41bd      	sbcs	r5, r7
 8003fca:	2700      	movs	r7, #0
 8003fcc:	b2ed      	uxtb	r5, r5
 8003fce:	e732      	b.n	8003e36 <__aeabi_dadd+0x382>
 8003fd0:	1c04      	adds	r4, r0, #0
 8003fd2:	2700      	movs	r7, #0
 8003fd4:	2500      	movs	r5, #0
 8003fd6:	e627      	b.n	8003c28 <__aeabi_dadd+0x174>
 8003fd8:	4848      	ldr	r0, [pc, #288]	; (80040fc <__aeabi_dadd+0x648>)
 8003fda:	4282      	cmp	r2, r0
 8003fdc:	d036      	beq.n	800404c <__aeabi_dadd+0x598>
 8003fde:	2080      	movs	r0, #128	; 0x80
 8003fe0:	0400      	lsls	r0, r0, #16
 8003fe2:	425b      	negs	r3, r3
 8003fe4:	4307      	orrs	r7, r0
 8003fe6:	e7c5      	b.n	8003f74 <__aeabi_dadd+0x4c0>
 8003fe8:	4662      	mov	r2, ip
 8003fea:	430a      	orrs	r2, r1
 8003fec:	d049      	beq.n	8004082 <__aeabi_dadd+0x5ce>
 8003fee:	2480      	movs	r4, #128	; 0x80
 8003ff0:	08ed      	lsrs	r5, r5, #3
 8003ff2:	0778      	lsls	r0, r7, #29
 8003ff4:	08fa      	lsrs	r2, r7, #3
 8003ff6:	0324      	lsls	r4, r4, #12
 8003ff8:	4328      	orrs	r0, r5
 8003ffa:	4222      	tst	r2, r4
 8003ffc:	d009      	beq.n	8004012 <__aeabi_dadd+0x55e>
 8003ffe:	08ce      	lsrs	r6, r1, #3
 8004000:	4226      	tst	r6, r4
 8004002:	d106      	bne.n	8004012 <__aeabi_dadd+0x55e>
 8004004:	4662      	mov	r2, ip
 8004006:	074f      	lsls	r7, r1, #29
 8004008:	1c38      	adds	r0, r7, #0
 800400a:	08d2      	lsrs	r2, r2, #3
 800400c:	4310      	orrs	r0, r2
 800400e:	4698      	mov	r8, r3
 8004010:	1c32      	adds	r2, r6, #0
 8004012:	00d2      	lsls	r2, r2, #3
 8004014:	0f47      	lsrs	r7, r0, #29
 8004016:	4317      	orrs	r7, r2
 8004018:	00c5      	lsls	r5, r0, #3
 800401a:	4c38      	ldr	r4, [pc, #224]	; (80040fc <__aeabi_dadd+0x648>)
 800401c:	e572      	b.n	8003b04 <__aeabi_dadd+0x50>
 800401e:	4662      	mov	r2, ip
 8004020:	430a      	orrs	r2, r1
 8004022:	d100      	bne.n	8004026 <__aeabi_dadd+0x572>
 8004024:	e56e      	b.n	8003b04 <__aeabi_dadd+0x50>
 8004026:	4662      	mov	r2, ip
 8004028:	1aae      	subs	r6, r5, r2
 800402a:	42b5      	cmp	r5, r6
 800402c:	4192      	sbcs	r2, r2
 800402e:	1a78      	subs	r0, r7, r1
 8004030:	4252      	negs	r2, r2
 8004032:	1a82      	subs	r2, r0, r2
 8004034:	0210      	lsls	r0, r2, #8
 8004036:	d400      	bmi.n	800403a <__aeabi_dadd+0x586>
 8004038:	e655      	b.n	8003ce6 <__aeabi_dadd+0x232>
 800403a:	4662      	mov	r2, ip
 800403c:	1b55      	subs	r5, r2, r5
 800403e:	45ac      	cmp	ip, r5
 8004040:	4180      	sbcs	r0, r0
 8004042:	1bca      	subs	r2, r1, r7
 8004044:	4240      	negs	r0, r0
 8004046:	1a17      	subs	r7, r2, r0
 8004048:	4698      	mov	r8, r3
 800404a:	e55b      	b.n	8003b04 <__aeabi_dadd+0x50>
 800404c:	1c0f      	adds	r7, r1, #0
 800404e:	4665      	mov	r5, ip
 8004050:	1c14      	adds	r4, r2, #0
 8004052:	e557      	b.n	8003b04 <__aeabi_dadd+0x50>
 8004054:	2b00      	cmp	r3, #0
 8004056:	d034      	beq.n	80040c2 <__aeabi_dadd+0x60e>
 8004058:	4663      	mov	r3, ip
 800405a:	430b      	orrs	r3, r1
 800405c:	d011      	beq.n	8004082 <__aeabi_dadd+0x5ce>
 800405e:	2480      	movs	r4, #128	; 0x80
 8004060:	08ed      	lsrs	r5, r5, #3
 8004062:	0778      	lsls	r0, r7, #29
 8004064:	08fa      	lsrs	r2, r7, #3
 8004066:	0324      	lsls	r4, r4, #12
 8004068:	4328      	orrs	r0, r5
 800406a:	4222      	tst	r2, r4
 800406c:	d0d1      	beq.n	8004012 <__aeabi_dadd+0x55e>
 800406e:	08cb      	lsrs	r3, r1, #3
 8004070:	4223      	tst	r3, r4
 8004072:	d1ce      	bne.n	8004012 <__aeabi_dadd+0x55e>
 8004074:	4662      	mov	r2, ip
 8004076:	074f      	lsls	r7, r1, #29
 8004078:	1c38      	adds	r0, r7, #0
 800407a:	08d2      	lsrs	r2, r2, #3
 800407c:	4310      	orrs	r0, r2
 800407e:	1c1a      	adds	r2, r3, #0
 8004080:	e7c7      	b.n	8004012 <__aeabi_dadd+0x55e>
 8004082:	4c1e      	ldr	r4, [pc, #120]	; (80040fc <__aeabi_dadd+0x648>)
 8004084:	e53e      	b.n	8003b04 <__aeabi_dadd+0x50>
 8004086:	2000      	movs	r0, #0
 8004088:	e759      	b.n	8003f3e <__aeabi_dadd+0x48a>
 800408a:	1c04      	adds	r4, r0, #0
 800408c:	1c3e      	adds	r6, r7, #0
 800408e:	3c20      	subs	r4, #32
 8004090:	40e6      	lsrs	r6, r4
 8004092:	1c34      	adds	r4, r6, #0
 8004094:	2820      	cmp	r0, #32
 8004096:	d02b      	beq.n	80040f0 <__aeabi_dadd+0x63c>
 8004098:	2640      	movs	r6, #64	; 0x40
 800409a:	1a30      	subs	r0, r6, r0
 800409c:	4087      	lsls	r7, r0
 800409e:	433d      	orrs	r5, r7
 80040a0:	1e6f      	subs	r7, r5, #1
 80040a2:	41bd      	sbcs	r5, r7
 80040a4:	2700      	movs	r7, #0
 80040a6:	4325      	orrs	r5, r4
 80040a8:	e6c5      	b.n	8003e36 <__aeabi_dadd+0x382>
 80040aa:	2780      	movs	r7, #128	; 0x80
 80040ac:	2600      	movs	r6, #0
 80040ae:	03ff      	lsls	r7, r7, #15
 80040b0:	4c12      	ldr	r4, [pc, #72]	; (80040fc <__aeabi_dadd+0x648>)
 80040b2:	2500      	movs	r5, #0
 80040b4:	e5b8      	b.n	8003c28 <__aeabi_dadd+0x174>
 80040b6:	433d      	orrs	r5, r7
 80040b8:	1e6f      	subs	r7, r5, #1
 80040ba:	41bd      	sbcs	r5, r7
 80040bc:	2700      	movs	r7, #0
 80040be:	b2ed      	uxtb	r5, r5
 80040c0:	e76e      	b.n	8003fa0 <__aeabi_dadd+0x4ec>
 80040c2:	1c0f      	adds	r7, r1, #0
 80040c4:	4665      	mov	r5, ip
 80040c6:	4c0d      	ldr	r4, [pc, #52]	; (80040fc <__aeabi_dadd+0x648>)
 80040c8:	e51c      	b.n	8003b04 <__aeabi_dadd+0x50>
 80040ca:	1c0f      	adds	r7, r1, #0
 80040cc:	4665      	mov	r5, ip
 80040ce:	e519      	b.n	8003b04 <__aeabi_dadd+0x50>
 80040d0:	1c1c      	adds	r4, r3, #0
 80040d2:	1c38      	adds	r0, r7, #0
 80040d4:	3c20      	subs	r4, #32
 80040d6:	40e0      	lsrs	r0, r4
 80040d8:	1c04      	adds	r4, r0, #0
 80040da:	2b20      	cmp	r3, #32
 80040dc:	d00c      	beq.n	80040f8 <__aeabi_dadd+0x644>
 80040de:	2040      	movs	r0, #64	; 0x40
 80040e0:	1ac3      	subs	r3, r0, r3
 80040e2:	409f      	lsls	r7, r3
 80040e4:	433d      	orrs	r5, r7
 80040e6:	1e6f      	subs	r7, r5, #1
 80040e8:	41bd      	sbcs	r5, r7
 80040ea:	2700      	movs	r7, #0
 80040ec:	4325      	orrs	r5, r4
 80040ee:	e757      	b.n	8003fa0 <__aeabi_dadd+0x4ec>
 80040f0:	2700      	movs	r7, #0
 80040f2:	e7d4      	b.n	800409e <__aeabi_dadd+0x5ea>
 80040f4:	1c1d      	adds	r5, r3, #0
 80040f6:	e5fc      	b.n	8003cf2 <__aeabi_dadd+0x23e>
 80040f8:	2700      	movs	r7, #0
 80040fa:	e7f3      	b.n	80040e4 <__aeabi_dadd+0x630>
 80040fc:	000007ff 	.word	0x000007ff
 8004100:	ff7fffff 	.word	0xff7fffff

08004104 <__aeabi_dmul>:
 8004104:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004106:	465f      	mov	r7, fp
 8004108:	4656      	mov	r6, sl
 800410a:	464d      	mov	r5, r9
 800410c:	4644      	mov	r4, r8
 800410e:	b4f0      	push	{r4, r5, r6, r7}
 8004110:	1c05      	adds	r5, r0, #0
 8004112:	1c06      	adds	r6, r0, #0
 8004114:	0308      	lsls	r0, r1, #12
 8004116:	b087      	sub	sp, #28
 8004118:	4699      	mov	r9, r3
 800411a:	004f      	lsls	r7, r1, #1
 800411c:	0b03      	lsrs	r3, r0, #12
 800411e:	0fcc      	lsrs	r4, r1, #31
 8004120:	4692      	mov	sl, r2
 8004122:	469b      	mov	fp, r3
 8004124:	0d7f      	lsrs	r7, r7, #21
 8004126:	9401      	str	r4, [sp, #4]
 8004128:	d067      	beq.n	80041fa <__aeabi_dmul+0xf6>
 800412a:	4b6c      	ldr	r3, [pc, #432]	; (80042dc <__aeabi_dmul+0x1d8>)
 800412c:	429f      	cmp	r7, r3
 800412e:	d036      	beq.n	800419e <__aeabi_dmul+0x9a>
 8004130:	2080      	movs	r0, #128	; 0x80
 8004132:	465b      	mov	r3, fp
 8004134:	0340      	lsls	r0, r0, #13
 8004136:	4318      	orrs	r0, r3
 8004138:	00c0      	lsls	r0, r0, #3
 800413a:	0f6b      	lsrs	r3, r5, #29
 800413c:	4318      	orrs	r0, r3
 800413e:	4b68      	ldr	r3, [pc, #416]	; (80042e0 <__aeabi_dmul+0x1dc>)
 8004140:	4683      	mov	fp, r0
 8004142:	469c      	mov	ip, r3
 8004144:	2300      	movs	r3, #0
 8004146:	4698      	mov	r8, r3
 8004148:	00ee      	lsls	r6, r5, #3
 800414a:	4467      	add	r7, ip
 800414c:	9300      	str	r3, [sp, #0]
 800414e:	464b      	mov	r3, r9
 8004150:	4649      	mov	r1, r9
 8004152:	031d      	lsls	r5, r3, #12
 8004154:	0fc9      	lsrs	r1, r1, #31
 8004156:	005b      	lsls	r3, r3, #1
 8004158:	4652      	mov	r2, sl
 800415a:	0b2d      	lsrs	r5, r5, #12
 800415c:	0d5b      	lsrs	r3, r3, #21
 800415e:	4689      	mov	r9, r1
 8004160:	d100      	bne.n	8004164 <__aeabi_dmul+0x60>
 8004162:	e06e      	b.n	8004242 <__aeabi_dmul+0x13e>
 8004164:	495d      	ldr	r1, [pc, #372]	; (80042dc <__aeabi_dmul+0x1d8>)
 8004166:	428b      	cmp	r3, r1
 8004168:	d064      	beq.n	8004234 <__aeabi_dmul+0x130>
 800416a:	2080      	movs	r0, #128	; 0x80
 800416c:	495c      	ldr	r1, [pc, #368]	; (80042e0 <__aeabi_dmul+0x1dc>)
 800416e:	0340      	lsls	r0, r0, #13
 8004170:	468c      	mov	ip, r1
 8004172:	2100      	movs	r1, #0
 8004174:	4305      	orrs	r5, r0
 8004176:	00ed      	lsls	r5, r5, #3
 8004178:	0f50      	lsrs	r0, r2, #29
 800417a:	4305      	orrs	r5, r0
 800417c:	00d2      	lsls	r2, r2, #3
 800417e:	4463      	add	r3, ip
 8004180:	4648      	mov	r0, r9
 8004182:	18ff      	adds	r7, r7, r3
 8004184:	1c7b      	adds	r3, r7, #1
 8004186:	469a      	mov	sl, r3
 8004188:	9b00      	ldr	r3, [sp, #0]
 800418a:	4060      	eors	r0, r4
 800418c:	9002      	str	r0, [sp, #8]
 800418e:	430b      	orrs	r3, r1
 8004190:	2b0f      	cmp	r3, #15
 8004192:	d900      	bls.n	8004196 <__aeabi_dmul+0x92>
 8004194:	e0ac      	b.n	80042f0 <__aeabi_dmul+0x1ec>
 8004196:	4853      	ldr	r0, [pc, #332]	; (80042e4 <__aeabi_dmul+0x1e0>)
 8004198:	009b      	lsls	r3, r3, #2
 800419a:	58c3      	ldr	r3, [r0, r3]
 800419c:	469f      	mov	pc, r3
 800419e:	465b      	mov	r3, fp
 80041a0:	431d      	orrs	r5, r3
 80041a2:	d000      	beq.n	80041a6 <__aeabi_dmul+0xa2>
 80041a4:	e082      	b.n	80042ac <__aeabi_dmul+0x1a8>
 80041a6:	2308      	movs	r3, #8
 80041a8:	9300      	str	r3, [sp, #0]
 80041aa:	2300      	movs	r3, #0
 80041ac:	469b      	mov	fp, r3
 80041ae:	3302      	adds	r3, #2
 80041b0:	2600      	movs	r6, #0
 80041b2:	4698      	mov	r8, r3
 80041b4:	e7cb      	b.n	800414e <__aeabi_dmul+0x4a>
 80041b6:	9b02      	ldr	r3, [sp, #8]
 80041b8:	9301      	str	r3, [sp, #4]
 80041ba:	4643      	mov	r3, r8
 80041bc:	2b02      	cmp	r3, #2
 80041be:	d159      	bne.n	8004274 <__aeabi_dmul+0x170>
 80041c0:	2401      	movs	r4, #1
 80041c2:	2500      	movs	r5, #0
 80041c4:	2600      	movs	r6, #0
 80041c6:	9b01      	ldr	r3, [sp, #4]
 80041c8:	401c      	ands	r4, r3
 80041ca:	4b44      	ldr	r3, [pc, #272]	; (80042dc <__aeabi_dmul+0x1d8>)
 80041cc:	2100      	movs	r1, #0
 80041ce:	032d      	lsls	r5, r5, #12
 80041d0:	0d0a      	lsrs	r2, r1, #20
 80041d2:	0512      	lsls	r2, r2, #20
 80041d4:	0b2d      	lsrs	r5, r5, #12
 80041d6:	4315      	orrs	r5, r2
 80041d8:	4a43      	ldr	r2, [pc, #268]	; (80042e8 <__aeabi_dmul+0x1e4>)
 80041da:	051b      	lsls	r3, r3, #20
 80041dc:	4015      	ands	r5, r2
 80041de:	431d      	orrs	r5, r3
 80041e0:	006d      	lsls	r5, r5, #1
 80041e2:	07e4      	lsls	r4, r4, #31
 80041e4:	086d      	lsrs	r5, r5, #1
 80041e6:	4325      	orrs	r5, r4
 80041e8:	1c30      	adds	r0, r6, #0
 80041ea:	1c29      	adds	r1, r5, #0
 80041ec:	b007      	add	sp, #28
 80041ee:	bc3c      	pop	{r2, r3, r4, r5}
 80041f0:	4690      	mov	r8, r2
 80041f2:	4699      	mov	r9, r3
 80041f4:	46a2      	mov	sl, r4
 80041f6:	46ab      	mov	fp, r5
 80041f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80041fa:	432b      	orrs	r3, r5
 80041fc:	d04e      	beq.n	800429c <__aeabi_dmul+0x198>
 80041fe:	465b      	mov	r3, fp
 8004200:	2b00      	cmp	r3, #0
 8004202:	d100      	bne.n	8004206 <__aeabi_dmul+0x102>
 8004204:	e185      	b.n	8004512 <__aeabi_dmul+0x40e>
 8004206:	4658      	mov	r0, fp
 8004208:	f000 fe72 	bl	8004ef0 <__clzsi2>
 800420c:	1c02      	adds	r2, r0, #0
 800420e:	2328      	movs	r3, #40	; 0x28
 8004210:	1c29      	adds	r1, r5, #0
 8004212:	1a9b      	subs	r3, r3, r2
 8004214:	1c16      	adds	r6, r2, #0
 8004216:	4658      	mov	r0, fp
 8004218:	40d9      	lsrs	r1, r3
 800421a:	3e08      	subs	r6, #8
 800421c:	40b0      	lsls	r0, r6
 800421e:	1c0b      	adds	r3, r1, #0
 8004220:	40b5      	lsls	r5, r6
 8004222:	4303      	orrs	r3, r0
 8004224:	469b      	mov	fp, r3
 8004226:	1c2e      	adds	r6, r5, #0
 8004228:	2300      	movs	r3, #0
 800422a:	4f30      	ldr	r7, [pc, #192]	; (80042ec <__aeabi_dmul+0x1e8>)
 800422c:	9300      	str	r3, [sp, #0]
 800422e:	1abf      	subs	r7, r7, r2
 8004230:	4698      	mov	r8, r3
 8004232:	e78c      	b.n	800414e <__aeabi_dmul+0x4a>
 8004234:	4651      	mov	r1, sl
 8004236:	4329      	orrs	r1, r5
 8004238:	d12e      	bne.n	8004298 <__aeabi_dmul+0x194>
 800423a:	2500      	movs	r5, #0
 800423c:	2200      	movs	r2, #0
 800423e:	2102      	movs	r1, #2
 8004240:	e79e      	b.n	8004180 <__aeabi_dmul+0x7c>
 8004242:	4651      	mov	r1, sl
 8004244:	4329      	orrs	r1, r5
 8004246:	d023      	beq.n	8004290 <__aeabi_dmul+0x18c>
 8004248:	2d00      	cmp	r5, #0
 800424a:	d100      	bne.n	800424e <__aeabi_dmul+0x14a>
 800424c:	e154      	b.n	80044f8 <__aeabi_dmul+0x3f4>
 800424e:	1c28      	adds	r0, r5, #0
 8004250:	f000 fe4e 	bl	8004ef0 <__clzsi2>
 8004254:	1c03      	adds	r3, r0, #0
 8004256:	2128      	movs	r1, #40	; 0x28
 8004258:	4650      	mov	r0, sl
 800425a:	1ac9      	subs	r1, r1, r3
 800425c:	1c1a      	adds	r2, r3, #0
 800425e:	40c8      	lsrs	r0, r1
 8004260:	4651      	mov	r1, sl
 8004262:	3a08      	subs	r2, #8
 8004264:	4091      	lsls	r1, r2
 8004266:	4095      	lsls	r5, r2
 8004268:	1c0a      	adds	r2, r1, #0
 800426a:	4305      	orrs	r5, r0
 800426c:	481f      	ldr	r0, [pc, #124]	; (80042ec <__aeabi_dmul+0x1e8>)
 800426e:	2100      	movs	r1, #0
 8004270:	1ac3      	subs	r3, r0, r3
 8004272:	e785      	b.n	8004180 <__aeabi_dmul+0x7c>
 8004274:	2b03      	cmp	r3, #3
 8004276:	d100      	bne.n	800427a <__aeabi_dmul+0x176>
 8004278:	e1c2      	b.n	8004600 <__aeabi_dmul+0x4fc>
 800427a:	2b01      	cmp	r3, #1
 800427c:	d000      	beq.n	8004280 <__aeabi_dmul+0x17c>
 800427e:	e16d      	b.n	800455c <__aeabi_dmul+0x458>
 8004280:	4644      	mov	r4, r8
 8004282:	9b01      	ldr	r3, [sp, #4]
 8004284:	2500      	movs	r5, #0
 8004286:	401c      	ands	r4, r3
 8004288:	b2e4      	uxtb	r4, r4
 800428a:	2300      	movs	r3, #0
 800428c:	2600      	movs	r6, #0
 800428e:	e79d      	b.n	80041cc <__aeabi_dmul+0xc8>
 8004290:	2500      	movs	r5, #0
 8004292:	2200      	movs	r2, #0
 8004294:	2101      	movs	r1, #1
 8004296:	e773      	b.n	8004180 <__aeabi_dmul+0x7c>
 8004298:	2103      	movs	r1, #3
 800429a:	e771      	b.n	8004180 <__aeabi_dmul+0x7c>
 800429c:	2304      	movs	r3, #4
 800429e:	9300      	str	r3, [sp, #0]
 80042a0:	2300      	movs	r3, #0
 80042a2:	469b      	mov	fp, r3
 80042a4:	3301      	adds	r3, #1
 80042a6:	2600      	movs	r6, #0
 80042a8:	4698      	mov	r8, r3
 80042aa:	e750      	b.n	800414e <__aeabi_dmul+0x4a>
 80042ac:	230c      	movs	r3, #12
 80042ae:	9300      	str	r3, [sp, #0]
 80042b0:	3b09      	subs	r3, #9
 80042b2:	4698      	mov	r8, r3
 80042b4:	e74b      	b.n	800414e <__aeabi_dmul+0x4a>
 80042b6:	2580      	movs	r5, #128	; 0x80
 80042b8:	2400      	movs	r4, #0
 80042ba:	032d      	lsls	r5, r5, #12
 80042bc:	2600      	movs	r6, #0
 80042be:	4b07      	ldr	r3, [pc, #28]	; (80042dc <__aeabi_dmul+0x1d8>)
 80042c0:	e784      	b.n	80041cc <__aeabi_dmul+0xc8>
 80042c2:	464b      	mov	r3, r9
 80042c4:	46ab      	mov	fp, r5
 80042c6:	1c16      	adds	r6, r2, #0
 80042c8:	9301      	str	r3, [sp, #4]
 80042ca:	4688      	mov	r8, r1
 80042cc:	e775      	b.n	80041ba <__aeabi_dmul+0xb6>
 80042ce:	9b02      	ldr	r3, [sp, #8]
 80042d0:	46ab      	mov	fp, r5
 80042d2:	1c16      	adds	r6, r2, #0
 80042d4:	9301      	str	r3, [sp, #4]
 80042d6:	4688      	mov	r8, r1
 80042d8:	e76f      	b.n	80041ba <__aeabi_dmul+0xb6>
 80042da:	46c0      	nop			; (mov r8, r8)
 80042dc:	000007ff 	.word	0x000007ff
 80042e0:	fffffc01 	.word	0xfffffc01
 80042e4:	0800aa18 	.word	0x0800aa18
 80042e8:	800fffff 	.word	0x800fffff
 80042ec:	fffffc0d 	.word	0xfffffc0d
 80042f0:	0c33      	lsrs	r3, r6, #16
 80042f2:	0436      	lsls	r6, r6, #16
 80042f4:	0c36      	lsrs	r6, r6, #16
 80042f6:	469c      	mov	ip, r3
 80042f8:	1c33      	adds	r3, r6, #0
 80042fa:	0c14      	lsrs	r4, r2, #16
 80042fc:	0412      	lsls	r2, r2, #16
 80042fe:	0c12      	lsrs	r2, r2, #16
 8004300:	4353      	muls	r3, r2
 8004302:	4698      	mov	r8, r3
 8004304:	4663      	mov	r3, ip
 8004306:	4353      	muls	r3, r2
 8004308:	4699      	mov	r9, r3
 800430a:	4663      	mov	r3, ip
 800430c:	4363      	muls	r3, r4
 800430e:	9301      	str	r3, [sp, #4]
 8004310:	1c33      	adds	r3, r6, #0
 8004312:	4641      	mov	r1, r8
 8004314:	4363      	muls	r3, r4
 8004316:	0c09      	lsrs	r1, r1, #16
 8004318:	444b      	add	r3, r9
 800431a:	185b      	adds	r3, r3, r1
 800431c:	4599      	cmp	r9, r3
 800431e:	d905      	bls.n	800432c <__aeabi_dmul+0x228>
 8004320:	2080      	movs	r0, #128	; 0x80
 8004322:	0240      	lsls	r0, r0, #9
 8004324:	4681      	mov	r9, r0
 8004326:	9901      	ldr	r1, [sp, #4]
 8004328:	4449      	add	r1, r9
 800432a:	9101      	str	r1, [sp, #4]
 800432c:	0c19      	lsrs	r1, r3, #16
 800432e:	9103      	str	r1, [sp, #12]
 8004330:	4641      	mov	r1, r8
 8004332:	0409      	lsls	r1, r1, #16
 8004334:	0c09      	lsrs	r1, r1, #16
 8004336:	041b      	lsls	r3, r3, #16
 8004338:	185b      	adds	r3, r3, r1
 800433a:	9304      	str	r3, [sp, #16]
 800433c:	0c2b      	lsrs	r3, r5, #16
 800433e:	4698      	mov	r8, r3
 8004340:	1c33      	adds	r3, r6, #0
 8004342:	042d      	lsls	r5, r5, #16
 8004344:	0c29      	lsrs	r1, r5, #16
 8004346:	434b      	muls	r3, r1
 8004348:	4660      	mov	r0, ip
 800434a:	9300      	str	r3, [sp, #0]
 800434c:	4643      	mov	r3, r8
 800434e:	4665      	mov	r5, ip
 8004350:	4358      	muls	r0, r3
 8004352:	435e      	muls	r6, r3
 8004354:	9b00      	ldr	r3, [sp, #0]
 8004356:	434d      	muls	r5, r1
 8004358:	0c1b      	lsrs	r3, r3, #16
 800435a:	4699      	mov	r9, r3
 800435c:	19ae      	adds	r6, r5, r6
 800435e:	444e      	add	r6, r9
 8004360:	4684      	mov	ip, r0
 8004362:	42b5      	cmp	r5, r6
 8004364:	d903      	bls.n	800436e <__aeabi_dmul+0x26a>
 8004366:	2380      	movs	r3, #128	; 0x80
 8004368:	025b      	lsls	r3, r3, #9
 800436a:	4699      	mov	r9, r3
 800436c:	44cc      	add	ip, r9
 800436e:	0c35      	lsrs	r5, r6, #16
 8004370:	1c2b      	adds	r3, r5, #0
 8004372:	9803      	ldr	r0, [sp, #12]
 8004374:	4463      	add	r3, ip
 8004376:	4684      	mov	ip, r0
 8004378:	9305      	str	r3, [sp, #20]
 800437a:	9b00      	ldr	r3, [sp, #0]
 800437c:	0436      	lsls	r6, r6, #16
 800437e:	041b      	lsls	r3, r3, #16
 8004380:	0c1b      	lsrs	r3, r3, #16
 8004382:	18f3      	adds	r3, r6, r3
 8004384:	449c      	add	ip, r3
 8004386:	4660      	mov	r0, ip
 8004388:	9003      	str	r0, [sp, #12]
 800438a:	4658      	mov	r0, fp
 800438c:	0405      	lsls	r5, r0, #16
 800438e:	0c06      	lsrs	r6, r0, #16
 8004390:	0c28      	lsrs	r0, r5, #16
 8004392:	4684      	mov	ip, r0
 8004394:	4350      	muls	r0, r2
 8004396:	1c35      	adds	r5, r6, #0
 8004398:	4681      	mov	r9, r0
 800439a:	4660      	mov	r0, ip
 800439c:	4365      	muls	r5, r4
 800439e:	4344      	muls	r4, r0
 80043a0:	4648      	mov	r0, r9
 80043a2:	0c00      	lsrs	r0, r0, #16
 80043a4:	4683      	mov	fp, r0
 80043a6:	4372      	muls	r2, r6
 80043a8:	1914      	adds	r4, r2, r4
 80043aa:	445c      	add	r4, fp
 80043ac:	42a2      	cmp	r2, r4
 80043ae:	d903      	bls.n	80043b8 <__aeabi_dmul+0x2b4>
 80043b0:	2280      	movs	r2, #128	; 0x80
 80043b2:	0252      	lsls	r2, r2, #9
 80043b4:	4693      	mov	fp, r2
 80043b6:	445d      	add	r5, fp
 80043b8:	0c22      	lsrs	r2, r4, #16
 80043ba:	18ad      	adds	r5, r5, r2
 80043bc:	464a      	mov	r2, r9
 80043be:	0412      	lsls	r2, r2, #16
 80043c0:	0c12      	lsrs	r2, r2, #16
 80043c2:	0424      	lsls	r4, r4, #16
 80043c4:	4640      	mov	r0, r8
 80043c6:	18a4      	adds	r4, r4, r2
 80043c8:	4662      	mov	r2, ip
 80043ca:	434a      	muls	r2, r1
 80043cc:	4371      	muls	r1, r6
 80043ce:	4346      	muls	r6, r0
 80043d0:	4660      	mov	r0, ip
 80043d2:	9600      	str	r6, [sp, #0]
 80043d4:	4646      	mov	r6, r8
 80043d6:	4370      	muls	r0, r6
 80043d8:	4680      	mov	r8, r0
 80043da:	0c10      	lsrs	r0, r2, #16
 80043dc:	4684      	mov	ip, r0
 80043de:	4488      	add	r8, r1
 80043e0:	44e0      	add	r8, ip
 80043e2:	4541      	cmp	r1, r8
 80043e4:	d905      	bls.n	80043f2 <__aeabi_dmul+0x2ee>
 80043e6:	2180      	movs	r1, #128	; 0x80
 80043e8:	0249      	lsls	r1, r1, #9
 80043ea:	468c      	mov	ip, r1
 80043ec:	9900      	ldr	r1, [sp, #0]
 80043ee:	4461      	add	r1, ip
 80043f0:	9100      	str	r1, [sp, #0]
 80043f2:	9801      	ldr	r0, [sp, #4]
 80043f4:	9903      	ldr	r1, [sp, #12]
 80043f6:	4684      	mov	ip, r0
 80043f8:	4461      	add	r1, ip
 80043fa:	4299      	cmp	r1, r3
 80043fc:	419b      	sbcs	r3, r3
 80043fe:	425b      	negs	r3, r3
 8004400:	4699      	mov	r9, r3
 8004402:	9805      	ldr	r0, [sp, #20]
 8004404:	4643      	mov	r3, r8
 8004406:	4684      	mov	ip, r0
 8004408:	0412      	lsls	r2, r2, #16
 800440a:	0c12      	lsrs	r2, r2, #16
 800440c:	041b      	lsls	r3, r3, #16
 800440e:	189b      	adds	r3, r3, r2
 8004410:	4463      	add	r3, ip
 8004412:	469c      	mov	ip, r3
 8004414:	46ab      	mov	fp, r5
 8004416:	4283      	cmp	r3, r0
 8004418:	419b      	sbcs	r3, r3
 800441a:	4640      	mov	r0, r8
 800441c:	190a      	adds	r2, r1, r4
 800441e:	44cc      	add	ip, r9
 8004420:	42a2      	cmp	r2, r4
 8004422:	4189      	sbcs	r1, r1
 8004424:	44e3      	add	fp, ip
 8004426:	45cc      	cmp	ip, r9
 8004428:	41b6      	sbcs	r6, r6
 800442a:	465c      	mov	r4, fp
 800442c:	0c00      	lsrs	r0, r0, #16
 800442e:	4680      	mov	r8, r0
 8004430:	4249      	negs	r1, r1
 8004432:	4276      	negs	r6, r6
 8004434:	425b      	negs	r3, r3
 8004436:	1864      	adds	r4, r4, r1
 8004438:	4333      	orrs	r3, r6
 800443a:	4498      	add	r8, r3
 800443c:	428c      	cmp	r4, r1
 800443e:	4189      	sbcs	r1, r1
 8004440:	45ab      	cmp	fp, r5
 8004442:	419b      	sbcs	r3, r3
 8004444:	4249      	negs	r1, r1
 8004446:	425b      	negs	r3, r3
 8004448:	4319      	orrs	r1, r3
 800444a:	1c0d      	adds	r5, r1, #0
 800444c:	9b00      	ldr	r3, [sp, #0]
 800444e:	4445      	add	r5, r8
 8004450:	18ee      	adds	r6, r5, r3
 8004452:	0276      	lsls	r6, r6, #9
 8004454:	0de5      	lsrs	r5, r4, #23
 8004456:	432e      	orrs	r6, r5
 8004458:	46b3      	mov	fp, r6
 800445a:	9b04      	ldr	r3, [sp, #16]
 800445c:	0256      	lsls	r6, r2, #9
 800445e:	431e      	orrs	r6, r3
 8004460:	1e73      	subs	r3, r6, #1
 8004462:	419e      	sbcs	r6, r3
 8004464:	465b      	mov	r3, fp
 8004466:	0dd2      	lsrs	r2, r2, #23
 8004468:	4332      	orrs	r2, r6
 800446a:	0266      	lsls	r6, r4, #9
 800446c:	4316      	orrs	r6, r2
 800446e:	01db      	lsls	r3, r3, #7
 8004470:	d50a      	bpl.n	8004488 <__aeabi_dmul+0x384>
 8004472:	2301      	movs	r3, #1
 8004474:	4033      	ands	r3, r6
 8004476:	0876      	lsrs	r6, r6, #1
 8004478:	431e      	orrs	r6, r3
 800447a:	465b      	mov	r3, fp
 800447c:	07db      	lsls	r3, r3, #31
 800447e:	431e      	orrs	r6, r3
 8004480:	465b      	mov	r3, fp
 8004482:	085b      	lsrs	r3, r3, #1
 8004484:	469b      	mov	fp, r3
 8004486:	4657      	mov	r7, sl
 8004488:	4b63      	ldr	r3, [pc, #396]	; (8004618 <__aeabi_dmul+0x514>)
 800448a:	18fb      	adds	r3, r7, r3
 800448c:	2b00      	cmp	r3, #0
 800448e:	dd5a      	ble.n	8004546 <__aeabi_dmul+0x442>
 8004490:	0772      	lsls	r2, r6, #29
 8004492:	d009      	beq.n	80044a8 <__aeabi_dmul+0x3a4>
 8004494:	220f      	movs	r2, #15
 8004496:	4032      	ands	r2, r6
 8004498:	2a04      	cmp	r2, #4
 800449a:	d005      	beq.n	80044a8 <__aeabi_dmul+0x3a4>
 800449c:	1d32      	adds	r2, r6, #4
 800449e:	42b2      	cmp	r2, r6
 80044a0:	41b6      	sbcs	r6, r6
 80044a2:	4276      	negs	r6, r6
 80044a4:	44b3      	add	fp, r6
 80044a6:	1c16      	adds	r6, r2, #0
 80044a8:	465a      	mov	r2, fp
 80044aa:	01d2      	lsls	r2, r2, #7
 80044ac:	d506      	bpl.n	80044bc <__aeabi_dmul+0x3b8>
 80044ae:	465a      	mov	r2, fp
 80044b0:	4b5a      	ldr	r3, [pc, #360]	; (800461c <__aeabi_dmul+0x518>)
 80044b2:	401a      	ands	r2, r3
 80044b4:	2380      	movs	r3, #128	; 0x80
 80044b6:	4693      	mov	fp, r2
 80044b8:	00db      	lsls	r3, r3, #3
 80044ba:	18fb      	adds	r3, r7, r3
 80044bc:	4a58      	ldr	r2, [pc, #352]	; (8004620 <__aeabi_dmul+0x51c>)
 80044be:	4293      	cmp	r3, r2
 80044c0:	dd34      	ble.n	800452c <__aeabi_dmul+0x428>
 80044c2:	2401      	movs	r4, #1
 80044c4:	9b02      	ldr	r3, [sp, #8]
 80044c6:	2500      	movs	r5, #0
 80044c8:	401c      	ands	r4, r3
 80044ca:	2600      	movs	r6, #0
 80044cc:	4b55      	ldr	r3, [pc, #340]	; (8004624 <__aeabi_dmul+0x520>)
 80044ce:	e67d      	b.n	80041cc <__aeabi_dmul+0xc8>
 80044d0:	2080      	movs	r0, #128	; 0x80
 80044d2:	465b      	mov	r3, fp
 80044d4:	0300      	lsls	r0, r0, #12
 80044d6:	4203      	tst	r3, r0
 80044d8:	d008      	beq.n	80044ec <__aeabi_dmul+0x3e8>
 80044da:	4205      	tst	r5, r0
 80044dc:	d106      	bne.n	80044ec <__aeabi_dmul+0x3e8>
 80044de:	4305      	orrs	r5, r0
 80044e0:	032d      	lsls	r5, r5, #12
 80044e2:	0b2d      	lsrs	r5, r5, #12
 80044e4:	464c      	mov	r4, r9
 80044e6:	1c16      	adds	r6, r2, #0
 80044e8:	4b4e      	ldr	r3, [pc, #312]	; (8004624 <__aeabi_dmul+0x520>)
 80044ea:	e66f      	b.n	80041cc <__aeabi_dmul+0xc8>
 80044ec:	465d      	mov	r5, fp
 80044ee:	4305      	orrs	r5, r0
 80044f0:	032d      	lsls	r5, r5, #12
 80044f2:	0b2d      	lsrs	r5, r5, #12
 80044f4:	4b4b      	ldr	r3, [pc, #300]	; (8004624 <__aeabi_dmul+0x520>)
 80044f6:	e669      	b.n	80041cc <__aeabi_dmul+0xc8>
 80044f8:	4650      	mov	r0, sl
 80044fa:	f000 fcf9 	bl	8004ef0 <__clzsi2>
 80044fe:	1c03      	adds	r3, r0, #0
 8004500:	3320      	adds	r3, #32
 8004502:	2b27      	cmp	r3, #39	; 0x27
 8004504:	dc00      	bgt.n	8004508 <__aeabi_dmul+0x404>
 8004506:	e6a6      	b.n	8004256 <__aeabi_dmul+0x152>
 8004508:	4655      	mov	r5, sl
 800450a:	3808      	subs	r0, #8
 800450c:	4085      	lsls	r5, r0
 800450e:	2200      	movs	r2, #0
 8004510:	e6ac      	b.n	800426c <__aeabi_dmul+0x168>
 8004512:	1c28      	adds	r0, r5, #0
 8004514:	f000 fcec 	bl	8004ef0 <__clzsi2>
 8004518:	1c02      	adds	r2, r0, #0
 800451a:	3220      	adds	r2, #32
 800451c:	2a27      	cmp	r2, #39	; 0x27
 800451e:	dc00      	bgt.n	8004522 <__aeabi_dmul+0x41e>
 8004520:	e675      	b.n	800420e <__aeabi_dmul+0x10a>
 8004522:	3808      	subs	r0, #8
 8004524:	4085      	lsls	r5, r0
 8004526:	2600      	movs	r6, #0
 8004528:	46ab      	mov	fp, r5
 800452a:	e67d      	b.n	8004228 <__aeabi_dmul+0x124>
 800452c:	465a      	mov	r2, fp
 800452e:	08f6      	lsrs	r6, r6, #3
 8004530:	0752      	lsls	r2, r2, #29
 8004532:	4316      	orrs	r6, r2
 8004534:	465a      	mov	r2, fp
 8004536:	2401      	movs	r4, #1
 8004538:	0255      	lsls	r5, r2, #9
 800453a:	9a02      	ldr	r2, [sp, #8]
 800453c:	055b      	lsls	r3, r3, #21
 800453e:	0b2d      	lsrs	r5, r5, #12
 8004540:	0d5b      	lsrs	r3, r3, #21
 8004542:	4014      	ands	r4, r2
 8004544:	e642      	b.n	80041cc <__aeabi_dmul+0xc8>
 8004546:	4d38      	ldr	r5, [pc, #224]	; (8004628 <__aeabi_dmul+0x524>)
 8004548:	1bed      	subs	r5, r5, r7
 800454a:	2d38      	cmp	r5, #56	; 0x38
 800454c:	dd0a      	ble.n	8004564 <__aeabi_dmul+0x460>
 800454e:	2401      	movs	r4, #1
 8004550:	9b02      	ldr	r3, [sp, #8]
 8004552:	2500      	movs	r5, #0
 8004554:	401c      	ands	r4, r3
 8004556:	2600      	movs	r6, #0
 8004558:	2300      	movs	r3, #0
 800455a:	e637      	b.n	80041cc <__aeabi_dmul+0xc8>
 800455c:	9b01      	ldr	r3, [sp, #4]
 800455e:	4657      	mov	r7, sl
 8004560:	9302      	str	r3, [sp, #8]
 8004562:	e791      	b.n	8004488 <__aeabi_dmul+0x384>
 8004564:	2d1f      	cmp	r5, #31
 8004566:	dc25      	bgt.n	80045b4 <__aeabi_dmul+0x4b0>
 8004568:	4b30      	ldr	r3, [pc, #192]	; (800462c <__aeabi_dmul+0x528>)
 800456a:	1c32      	adds	r2, r6, #0
 800456c:	469c      	mov	ip, r3
 800456e:	4467      	add	r7, ip
 8004570:	40be      	lsls	r6, r7
 8004572:	465b      	mov	r3, fp
 8004574:	40bb      	lsls	r3, r7
 8004576:	1c37      	adds	r7, r6, #0
 8004578:	40ea      	lsrs	r2, r5
 800457a:	1e7e      	subs	r6, r7, #1
 800457c:	41b7      	sbcs	r7, r6
 800457e:	4313      	orrs	r3, r2
 8004580:	433b      	orrs	r3, r7
 8004582:	1c1e      	adds	r6, r3, #0
 8004584:	465b      	mov	r3, fp
 8004586:	40eb      	lsrs	r3, r5
 8004588:	1c1d      	adds	r5, r3, #0
 800458a:	0773      	lsls	r3, r6, #29
 800458c:	d009      	beq.n	80045a2 <__aeabi_dmul+0x49e>
 800458e:	230f      	movs	r3, #15
 8004590:	4033      	ands	r3, r6
 8004592:	2b04      	cmp	r3, #4
 8004594:	d005      	beq.n	80045a2 <__aeabi_dmul+0x49e>
 8004596:	1d33      	adds	r3, r6, #4
 8004598:	42b3      	cmp	r3, r6
 800459a:	41b6      	sbcs	r6, r6
 800459c:	4276      	negs	r6, r6
 800459e:	19ad      	adds	r5, r5, r6
 80045a0:	1c1e      	adds	r6, r3, #0
 80045a2:	022b      	lsls	r3, r5, #8
 80045a4:	d520      	bpl.n	80045e8 <__aeabi_dmul+0x4e4>
 80045a6:	2401      	movs	r4, #1
 80045a8:	9b02      	ldr	r3, [sp, #8]
 80045aa:	2500      	movs	r5, #0
 80045ac:	401c      	ands	r4, r3
 80045ae:	2600      	movs	r6, #0
 80045b0:	2301      	movs	r3, #1
 80045b2:	e60b      	b.n	80041cc <__aeabi_dmul+0xc8>
 80045b4:	465a      	mov	r2, fp
 80045b6:	4b1e      	ldr	r3, [pc, #120]	; (8004630 <__aeabi_dmul+0x52c>)
 80045b8:	1bdb      	subs	r3, r3, r7
 80045ba:	40da      	lsrs	r2, r3
 80045bc:	1c13      	adds	r3, r2, #0
 80045be:	2d20      	cmp	r5, #32
 80045c0:	d01c      	beq.n	80045fc <__aeabi_dmul+0x4f8>
 80045c2:	4a1c      	ldr	r2, [pc, #112]	; (8004634 <__aeabi_dmul+0x530>)
 80045c4:	4694      	mov	ip, r2
 80045c6:	465a      	mov	r2, fp
 80045c8:	4467      	add	r7, ip
 80045ca:	40ba      	lsls	r2, r7
 80045cc:	1c17      	adds	r7, r2, #0
 80045ce:	433e      	orrs	r6, r7
 80045d0:	1e72      	subs	r2, r6, #1
 80045d2:	4196      	sbcs	r6, r2
 80045d4:	431e      	orrs	r6, r3
 80045d6:	2307      	movs	r3, #7
 80045d8:	2500      	movs	r5, #0
 80045da:	4033      	ands	r3, r6
 80045dc:	d007      	beq.n	80045ee <__aeabi_dmul+0x4ea>
 80045de:	230f      	movs	r3, #15
 80045e0:	2500      	movs	r5, #0
 80045e2:	4033      	ands	r3, r6
 80045e4:	2b04      	cmp	r3, #4
 80045e6:	d1d6      	bne.n	8004596 <__aeabi_dmul+0x492>
 80045e8:	076b      	lsls	r3, r5, #29
 80045ea:	026d      	lsls	r5, r5, #9
 80045ec:	0b2d      	lsrs	r5, r5, #12
 80045ee:	2401      	movs	r4, #1
 80045f0:	08f6      	lsrs	r6, r6, #3
 80045f2:	431e      	orrs	r6, r3
 80045f4:	9b02      	ldr	r3, [sp, #8]
 80045f6:	401c      	ands	r4, r3
 80045f8:	2300      	movs	r3, #0
 80045fa:	e5e7      	b.n	80041cc <__aeabi_dmul+0xc8>
 80045fc:	2700      	movs	r7, #0
 80045fe:	e7e6      	b.n	80045ce <__aeabi_dmul+0x4ca>
 8004600:	2580      	movs	r5, #128	; 0x80
 8004602:	465b      	mov	r3, fp
 8004604:	2401      	movs	r4, #1
 8004606:	032d      	lsls	r5, r5, #12
 8004608:	431d      	orrs	r5, r3
 800460a:	9b01      	ldr	r3, [sp, #4]
 800460c:	032d      	lsls	r5, r5, #12
 800460e:	4023      	ands	r3, r4
 8004610:	1c1c      	adds	r4, r3, #0
 8004612:	0b2d      	lsrs	r5, r5, #12
 8004614:	4b03      	ldr	r3, [pc, #12]	; (8004624 <__aeabi_dmul+0x520>)
 8004616:	e5d9      	b.n	80041cc <__aeabi_dmul+0xc8>
 8004618:	000003ff 	.word	0x000003ff
 800461c:	feffffff 	.word	0xfeffffff
 8004620:	000007fe 	.word	0x000007fe
 8004624:	000007ff 	.word	0x000007ff
 8004628:	fffffc02 	.word	0xfffffc02
 800462c:	0000041e 	.word	0x0000041e
 8004630:	fffffbe2 	.word	0xfffffbe2
 8004634:	0000043e 	.word	0x0000043e

08004638 <__aeabi_dsub>:
 8004638:	b5f0      	push	{r4, r5, r6, r7, lr}
 800463a:	464d      	mov	r5, r9
 800463c:	4644      	mov	r4, r8
 800463e:	465f      	mov	r7, fp
 8004640:	4656      	mov	r6, sl
 8004642:	b4f0      	push	{r4, r5, r6, r7}
 8004644:	1c0e      	adds	r6, r1, #0
 8004646:	1c11      	adds	r1, r2, #0
 8004648:	0332      	lsls	r2, r6, #12
 800464a:	0a52      	lsrs	r2, r2, #9
 800464c:	0f47      	lsrs	r7, r0, #29
 800464e:	4317      	orrs	r7, r2
 8004650:	00c5      	lsls	r5, r0, #3
 8004652:	031a      	lsls	r2, r3, #12
 8004654:	0058      	lsls	r0, r3, #1
 8004656:	0fdb      	lsrs	r3, r3, #31
 8004658:	4699      	mov	r9, r3
 800465a:	0a52      	lsrs	r2, r2, #9
 800465c:	0f4b      	lsrs	r3, r1, #29
 800465e:	b083      	sub	sp, #12
 8004660:	431a      	orrs	r2, r3
 8004662:	00cb      	lsls	r3, r1, #3
 8004664:	9301      	str	r3, [sp, #4]
 8004666:	4bcf      	ldr	r3, [pc, #828]	; (80049a4 <__aeabi_dsub+0x36c>)
 8004668:	0074      	lsls	r4, r6, #1
 800466a:	0ff6      	lsrs	r6, r6, #31
 800466c:	0d64      	lsrs	r4, r4, #21
 800466e:	46b0      	mov	r8, r6
 8004670:	0d40      	lsrs	r0, r0, #21
 8004672:	4298      	cmp	r0, r3
 8004674:	d100      	bne.n	8004678 <__aeabi_dsub+0x40>
 8004676:	e0e8      	b.n	800484a <__aeabi_dsub+0x212>
 8004678:	2301      	movs	r3, #1
 800467a:	4649      	mov	r1, r9
 800467c:	4059      	eors	r1, r3
 800467e:	1c0b      	adds	r3, r1, #0
 8004680:	429e      	cmp	r6, r3
 8004682:	d100      	bne.n	8004686 <__aeabi_dsub+0x4e>
 8004684:	e0b1      	b.n	80047ea <__aeabi_dsub+0x1b2>
 8004686:	1a26      	subs	r6, r4, r0
 8004688:	2e00      	cmp	r6, #0
 800468a:	dc00      	bgt.n	800468e <__aeabi_dsub+0x56>
 800468c:	e11c      	b.n	80048c8 <__aeabi_dsub+0x290>
 800468e:	2800      	cmp	r0, #0
 8004690:	d142      	bne.n	8004718 <__aeabi_dsub+0xe0>
 8004692:	1c13      	adds	r3, r2, #0
 8004694:	9901      	ldr	r1, [sp, #4]
 8004696:	430b      	orrs	r3, r1
 8004698:	d000      	beq.n	800469c <__aeabi_dsub+0x64>
 800469a:	e0e6      	b.n	800486a <__aeabi_dsub+0x232>
 800469c:	076b      	lsls	r3, r5, #29
 800469e:	d100      	bne.n	80046a2 <__aeabi_dsub+0x6a>
 80046a0:	e08e      	b.n	80047c0 <__aeabi_dsub+0x188>
 80046a2:	230f      	movs	r3, #15
 80046a4:	402b      	ands	r3, r5
 80046a6:	2b04      	cmp	r3, #4
 80046a8:	d100      	bne.n	80046ac <__aeabi_dsub+0x74>
 80046aa:	e089      	b.n	80047c0 <__aeabi_dsub+0x188>
 80046ac:	1d2a      	adds	r2, r5, #4
 80046ae:	42aa      	cmp	r2, r5
 80046b0:	41ad      	sbcs	r5, r5
 80046b2:	2380      	movs	r3, #128	; 0x80
 80046b4:	2601      	movs	r6, #1
 80046b6:	4641      	mov	r1, r8
 80046b8:	426d      	negs	r5, r5
 80046ba:	197f      	adds	r7, r7, r5
 80046bc:	041b      	lsls	r3, r3, #16
 80046be:	403b      	ands	r3, r7
 80046c0:	400e      	ands	r6, r1
 80046c2:	1c15      	adds	r5, r2, #0
 80046c4:	2b00      	cmp	r3, #0
 80046c6:	d100      	bne.n	80046ca <__aeabi_dsub+0x92>
 80046c8:	e083      	b.n	80047d2 <__aeabi_dsub+0x19a>
 80046ca:	4bb6      	ldr	r3, [pc, #728]	; (80049a4 <__aeabi_dsub+0x36c>)
 80046cc:	3401      	adds	r4, #1
 80046ce:	429c      	cmp	r4, r3
 80046d0:	d100      	bne.n	80046d4 <__aeabi_dsub+0x9c>
 80046d2:	e116      	b.n	8004902 <__aeabi_dsub+0x2ca>
 80046d4:	1c3a      	adds	r2, r7, #0
 80046d6:	4bb4      	ldr	r3, [pc, #720]	; (80049a8 <__aeabi_dsub+0x370>)
 80046d8:	08ed      	lsrs	r5, r5, #3
 80046da:	401a      	ands	r2, r3
 80046dc:	0750      	lsls	r0, r2, #29
 80046de:	0564      	lsls	r4, r4, #21
 80046e0:	0252      	lsls	r2, r2, #9
 80046e2:	4305      	orrs	r5, r0
 80046e4:	0b12      	lsrs	r2, r2, #12
 80046e6:	0d64      	lsrs	r4, r4, #21
 80046e8:	2100      	movs	r1, #0
 80046ea:	0312      	lsls	r2, r2, #12
 80046ec:	0d0b      	lsrs	r3, r1, #20
 80046ee:	051b      	lsls	r3, r3, #20
 80046f0:	0564      	lsls	r4, r4, #21
 80046f2:	0b12      	lsrs	r2, r2, #12
 80046f4:	431a      	orrs	r2, r3
 80046f6:	0863      	lsrs	r3, r4, #1
 80046f8:	4cac      	ldr	r4, [pc, #688]	; (80049ac <__aeabi_dsub+0x374>)
 80046fa:	07f6      	lsls	r6, r6, #31
 80046fc:	4014      	ands	r4, r2
 80046fe:	431c      	orrs	r4, r3
 8004700:	0064      	lsls	r4, r4, #1
 8004702:	0864      	lsrs	r4, r4, #1
 8004704:	4334      	orrs	r4, r6
 8004706:	1c28      	adds	r0, r5, #0
 8004708:	1c21      	adds	r1, r4, #0
 800470a:	b003      	add	sp, #12
 800470c:	bc3c      	pop	{r2, r3, r4, r5}
 800470e:	4690      	mov	r8, r2
 8004710:	4699      	mov	r9, r3
 8004712:	46a2      	mov	sl, r4
 8004714:	46ab      	mov	fp, r5
 8004716:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004718:	4ba2      	ldr	r3, [pc, #648]	; (80049a4 <__aeabi_dsub+0x36c>)
 800471a:	429c      	cmp	r4, r3
 800471c:	d0be      	beq.n	800469c <__aeabi_dsub+0x64>
 800471e:	2380      	movs	r3, #128	; 0x80
 8004720:	041b      	lsls	r3, r3, #16
 8004722:	431a      	orrs	r2, r3
 8004724:	2e38      	cmp	r6, #56	; 0x38
 8004726:	dd00      	ble.n	800472a <__aeabi_dsub+0xf2>
 8004728:	e103      	b.n	8004932 <__aeabi_dsub+0x2fa>
 800472a:	2e1f      	cmp	r6, #31
 800472c:	dd00      	ble.n	8004730 <__aeabi_dsub+0xf8>
 800472e:	e13f      	b.n	80049b0 <__aeabi_dsub+0x378>
 8004730:	2020      	movs	r0, #32
 8004732:	1b83      	subs	r3, r0, r6
 8004734:	4699      	mov	r9, r3
 8004736:	1c13      	adds	r3, r2, #0
 8004738:	4649      	mov	r1, r9
 800473a:	408b      	lsls	r3, r1
 800473c:	469c      	mov	ip, r3
 800473e:	9b01      	ldr	r3, [sp, #4]
 8004740:	4660      	mov	r0, ip
 8004742:	40f3      	lsrs	r3, r6
 8004744:	4303      	orrs	r3, r0
 8004746:	9801      	ldr	r0, [sp, #4]
 8004748:	40f2      	lsrs	r2, r6
 800474a:	4088      	lsls	r0, r1
 800474c:	1c01      	adds	r1, r0, #0
 800474e:	1e48      	subs	r0, r1, #1
 8004750:	4181      	sbcs	r1, r0
 8004752:	430b      	orrs	r3, r1
 8004754:	1aeb      	subs	r3, r5, r3
 8004756:	429d      	cmp	r5, r3
 8004758:	4180      	sbcs	r0, r0
 800475a:	1c1d      	adds	r5, r3, #0
 800475c:	1aba      	subs	r2, r7, r2
 800475e:	4240      	negs	r0, r0
 8004760:	1a17      	subs	r7, r2, r0
 8004762:	023b      	lsls	r3, r7, #8
 8004764:	d400      	bmi.n	8004768 <__aeabi_dsub+0x130>
 8004766:	e0a8      	b.n	80048ba <__aeabi_dsub+0x282>
 8004768:	027a      	lsls	r2, r7, #9
 800476a:	0a56      	lsrs	r6, r2, #9
 800476c:	2e00      	cmp	r6, #0
 800476e:	d100      	bne.n	8004772 <__aeabi_dsub+0x13a>
 8004770:	e0ca      	b.n	8004908 <__aeabi_dsub+0x2d0>
 8004772:	1c30      	adds	r0, r6, #0
 8004774:	f000 fbbc 	bl	8004ef0 <__clzsi2>
 8004778:	1c03      	adds	r3, r0, #0
 800477a:	3b08      	subs	r3, #8
 800477c:	2b1f      	cmp	r3, #31
 800477e:	dd00      	ble.n	8004782 <__aeabi_dsub+0x14a>
 8004780:	e0cb      	b.n	800491a <__aeabi_dsub+0x2e2>
 8004782:	2228      	movs	r2, #40	; 0x28
 8004784:	1c29      	adds	r1, r5, #0
 8004786:	1a12      	subs	r2, r2, r0
 8004788:	40d1      	lsrs	r1, r2
 800478a:	409e      	lsls	r6, r3
 800478c:	1c0a      	adds	r2, r1, #0
 800478e:	409d      	lsls	r5, r3
 8004790:	4332      	orrs	r2, r6
 8004792:	429c      	cmp	r4, r3
 8004794:	dd00      	ble.n	8004798 <__aeabi_dsub+0x160>
 8004796:	e0c8      	b.n	800492a <__aeabi_dsub+0x2f2>
 8004798:	1b1c      	subs	r4, r3, r4
 800479a:	1c67      	adds	r7, r4, #1
 800479c:	2f1f      	cmp	r7, #31
 800479e:	dd00      	ble.n	80047a2 <__aeabi_dsub+0x16a>
 80047a0:	e0ed      	b.n	800497e <__aeabi_dsub+0x346>
 80047a2:	231f      	movs	r3, #31
 80047a4:	1c29      	adds	r1, r5, #0
 80047a6:	1b1c      	subs	r4, r3, r4
 80047a8:	1c13      	adds	r3, r2, #0
 80047aa:	40a5      	lsls	r5, r4
 80047ac:	40a3      	lsls	r3, r4
 80047ae:	40f9      	lsrs	r1, r7
 80047b0:	1e6c      	subs	r4, r5, #1
 80047b2:	41a5      	sbcs	r5, r4
 80047b4:	40fa      	lsrs	r2, r7
 80047b6:	4319      	orrs	r1, r3
 80047b8:	430d      	orrs	r5, r1
 80047ba:	1c17      	adds	r7, r2, #0
 80047bc:	2400      	movs	r4, #0
 80047be:	e76d      	b.n	800469c <__aeabi_dsub+0x64>
 80047c0:	2380      	movs	r3, #128	; 0x80
 80047c2:	2601      	movs	r6, #1
 80047c4:	4642      	mov	r2, r8
 80047c6:	041b      	lsls	r3, r3, #16
 80047c8:	403b      	ands	r3, r7
 80047ca:	4016      	ands	r6, r2
 80047cc:	2b00      	cmp	r3, #0
 80047ce:	d000      	beq.n	80047d2 <__aeabi_dsub+0x19a>
 80047d0:	e77b      	b.n	80046ca <__aeabi_dsub+0x92>
 80047d2:	4b74      	ldr	r3, [pc, #464]	; (80049a4 <__aeabi_dsub+0x36c>)
 80047d4:	08ed      	lsrs	r5, r5, #3
 80047d6:	0778      	lsls	r0, r7, #29
 80047d8:	4305      	orrs	r5, r0
 80047da:	08fa      	lsrs	r2, r7, #3
 80047dc:	429c      	cmp	r4, r3
 80047de:	d03b      	beq.n	8004858 <__aeabi_dsub+0x220>
 80047e0:	0312      	lsls	r2, r2, #12
 80047e2:	0564      	lsls	r4, r4, #21
 80047e4:	0b12      	lsrs	r2, r2, #12
 80047e6:	0d64      	lsrs	r4, r4, #21
 80047e8:	e77e      	b.n	80046e8 <__aeabi_dsub+0xb0>
 80047ea:	1a23      	subs	r3, r4, r0
 80047ec:	469a      	mov	sl, r3
 80047ee:	2b00      	cmp	r3, #0
 80047f0:	dc00      	bgt.n	80047f4 <__aeabi_dsub+0x1bc>
 80047f2:	e0a5      	b.n	8004940 <__aeabi_dsub+0x308>
 80047f4:	2800      	cmp	r0, #0
 80047f6:	d044      	beq.n	8004882 <__aeabi_dsub+0x24a>
 80047f8:	486a      	ldr	r0, [pc, #424]	; (80049a4 <__aeabi_dsub+0x36c>)
 80047fa:	4284      	cmp	r4, r0
 80047fc:	d100      	bne.n	8004800 <__aeabi_dsub+0x1c8>
 80047fe:	e74d      	b.n	800469c <__aeabi_dsub+0x64>
 8004800:	2080      	movs	r0, #128	; 0x80
 8004802:	0400      	lsls	r0, r0, #16
 8004804:	4302      	orrs	r2, r0
 8004806:	4653      	mov	r3, sl
 8004808:	2b38      	cmp	r3, #56	; 0x38
 800480a:	dc00      	bgt.n	800480e <__aeabi_dsub+0x1d6>
 800480c:	e11c      	b.n	8004a48 <__aeabi_dsub+0x410>
 800480e:	9b01      	ldr	r3, [sp, #4]
 8004810:	431a      	orrs	r2, r3
 8004812:	1e51      	subs	r1, r2, #1
 8004814:	418a      	sbcs	r2, r1
 8004816:	b2d1      	uxtb	r1, r2
 8004818:	2200      	movs	r2, #0
 800481a:	1949      	adds	r1, r1, r5
 800481c:	42a9      	cmp	r1, r5
 800481e:	4180      	sbcs	r0, r0
 8004820:	1c0d      	adds	r5, r1, #0
 8004822:	19d2      	adds	r2, r2, r7
 8004824:	4240      	negs	r0, r0
 8004826:	1817      	adds	r7, r2, r0
 8004828:	023b      	lsls	r3, r7, #8
 800482a:	d546      	bpl.n	80048ba <__aeabi_dsub+0x282>
 800482c:	4b5d      	ldr	r3, [pc, #372]	; (80049a4 <__aeabi_dsub+0x36c>)
 800482e:	3401      	adds	r4, #1
 8004830:	429c      	cmp	r4, r3
 8004832:	d100      	bne.n	8004836 <__aeabi_dsub+0x1fe>
 8004834:	e169      	b.n	8004b0a <__aeabi_dsub+0x4d2>
 8004836:	2001      	movs	r0, #1
 8004838:	4a5b      	ldr	r2, [pc, #364]	; (80049a8 <__aeabi_dsub+0x370>)
 800483a:	086b      	lsrs	r3, r5, #1
 800483c:	403a      	ands	r2, r7
 800483e:	4028      	ands	r0, r5
 8004840:	4318      	orrs	r0, r3
 8004842:	07d5      	lsls	r5, r2, #31
 8004844:	4305      	orrs	r5, r0
 8004846:	0857      	lsrs	r7, r2, #1
 8004848:	e728      	b.n	800469c <__aeabi_dsub+0x64>
 800484a:	1c13      	adds	r3, r2, #0
 800484c:	9901      	ldr	r1, [sp, #4]
 800484e:	430b      	orrs	r3, r1
 8004850:	d100      	bne.n	8004854 <__aeabi_dsub+0x21c>
 8004852:	e711      	b.n	8004678 <__aeabi_dsub+0x40>
 8004854:	464b      	mov	r3, r9
 8004856:	e713      	b.n	8004680 <__aeabi_dsub+0x48>
 8004858:	1c2b      	adds	r3, r5, #0
 800485a:	4313      	orrs	r3, r2
 800485c:	d051      	beq.n	8004902 <__aeabi_dsub+0x2ca>
 800485e:	2380      	movs	r3, #128	; 0x80
 8004860:	031b      	lsls	r3, r3, #12
 8004862:	431a      	orrs	r2, r3
 8004864:	0312      	lsls	r2, r2, #12
 8004866:	0b12      	lsrs	r2, r2, #12
 8004868:	e73e      	b.n	80046e8 <__aeabi_dsub+0xb0>
 800486a:	3e01      	subs	r6, #1
 800486c:	2e00      	cmp	r6, #0
 800486e:	d000      	beq.n	8004872 <__aeabi_dsub+0x23a>
 8004870:	e080      	b.n	8004974 <__aeabi_dsub+0x33c>
 8004872:	1a69      	subs	r1, r5, r1
 8004874:	428d      	cmp	r5, r1
 8004876:	419b      	sbcs	r3, r3
 8004878:	1aba      	subs	r2, r7, r2
 800487a:	425b      	negs	r3, r3
 800487c:	1ad7      	subs	r7, r2, r3
 800487e:	1c0d      	adds	r5, r1, #0
 8004880:	e76f      	b.n	8004762 <__aeabi_dsub+0x12a>
 8004882:	1c10      	adds	r0, r2, #0
 8004884:	9b01      	ldr	r3, [sp, #4]
 8004886:	4318      	orrs	r0, r3
 8004888:	d100      	bne.n	800488c <__aeabi_dsub+0x254>
 800488a:	e707      	b.n	800469c <__aeabi_dsub+0x64>
 800488c:	2301      	movs	r3, #1
 800488e:	425b      	negs	r3, r3
 8004890:	469c      	mov	ip, r3
 8004892:	44e2      	add	sl, ip
 8004894:	4653      	mov	r3, sl
 8004896:	2b00      	cmp	r3, #0
 8004898:	d000      	beq.n	800489c <__aeabi_dsub+0x264>
 800489a:	e102      	b.n	8004aa2 <__aeabi_dsub+0x46a>
 800489c:	9b01      	ldr	r3, [sp, #4]
 800489e:	19d2      	adds	r2, r2, r7
 80048a0:	1959      	adds	r1, r3, r5
 80048a2:	42a9      	cmp	r1, r5
 80048a4:	419b      	sbcs	r3, r3
 80048a6:	425b      	negs	r3, r3
 80048a8:	18d7      	adds	r7, r2, r3
 80048aa:	1c0d      	adds	r5, r1, #0
 80048ac:	e7bc      	b.n	8004828 <__aeabi_dsub+0x1f0>
 80048ae:	4663      	mov	r3, ip
 80048b0:	4303      	orrs	r3, r0
 80048b2:	d100      	bne.n	80048b6 <__aeabi_dsub+0x27e>
 80048b4:	e128      	b.n	8004b08 <__aeabi_dsub+0x4d0>
 80048b6:	1c07      	adds	r7, r0, #0
 80048b8:	4665      	mov	r5, ip
 80048ba:	076b      	lsls	r3, r5, #29
 80048bc:	d000      	beq.n	80048c0 <__aeabi_dsub+0x288>
 80048be:	e6f0      	b.n	80046a2 <__aeabi_dsub+0x6a>
 80048c0:	2601      	movs	r6, #1
 80048c2:	4643      	mov	r3, r8
 80048c4:	401e      	ands	r6, r3
 80048c6:	e784      	b.n	80047d2 <__aeabi_dsub+0x19a>
 80048c8:	2e00      	cmp	r6, #0
 80048ca:	d000      	beq.n	80048ce <__aeabi_dsub+0x296>
 80048cc:	e081      	b.n	80049d2 <__aeabi_dsub+0x39a>
 80048ce:	1c60      	adds	r0, r4, #1
 80048d0:	0540      	lsls	r0, r0, #21
 80048d2:	0d40      	lsrs	r0, r0, #21
 80048d4:	2801      	cmp	r0, #1
 80048d6:	dc00      	bgt.n	80048da <__aeabi_dsub+0x2a2>
 80048d8:	e107      	b.n	8004aea <__aeabi_dsub+0x4b2>
 80048da:	9901      	ldr	r1, [sp, #4]
 80048dc:	1a68      	subs	r0, r5, r1
 80048de:	4684      	mov	ip, r0
 80048e0:	4565      	cmp	r5, ip
 80048e2:	41b6      	sbcs	r6, r6
 80048e4:	1ab8      	subs	r0, r7, r2
 80048e6:	4276      	negs	r6, r6
 80048e8:	1b86      	subs	r6, r0, r6
 80048ea:	0230      	lsls	r0, r6, #8
 80048ec:	d400      	bmi.n	80048f0 <__aeabi_dsub+0x2b8>
 80048ee:	e0a1      	b.n	8004a34 <__aeabi_dsub+0x3fc>
 80048f0:	468c      	mov	ip, r1
 80048f2:	1b4d      	subs	r5, r1, r5
 80048f4:	45ac      	cmp	ip, r5
 80048f6:	4189      	sbcs	r1, r1
 80048f8:	1bd2      	subs	r2, r2, r7
 80048fa:	4249      	negs	r1, r1
 80048fc:	1a56      	subs	r6, r2, r1
 80048fe:	4698      	mov	r8, r3
 8004900:	e734      	b.n	800476c <__aeabi_dsub+0x134>
 8004902:	2200      	movs	r2, #0
 8004904:	2500      	movs	r5, #0
 8004906:	e6ef      	b.n	80046e8 <__aeabi_dsub+0xb0>
 8004908:	1c28      	adds	r0, r5, #0
 800490a:	f000 faf1 	bl	8004ef0 <__clzsi2>
 800490e:	3020      	adds	r0, #32
 8004910:	1c03      	adds	r3, r0, #0
 8004912:	3b08      	subs	r3, #8
 8004914:	2b1f      	cmp	r3, #31
 8004916:	dc00      	bgt.n	800491a <__aeabi_dsub+0x2e2>
 8004918:	e733      	b.n	8004782 <__aeabi_dsub+0x14a>
 800491a:	1c02      	adds	r2, r0, #0
 800491c:	3a28      	subs	r2, #40	; 0x28
 800491e:	4095      	lsls	r5, r2
 8004920:	1c2a      	adds	r2, r5, #0
 8004922:	2500      	movs	r5, #0
 8004924:	429c      	cmp	r4, r3
 8004926:	dc00      	bgt.n	800492a <__aeabi_dsub+0x2f2>
 8004928:	e736      	b.n	8004798 <__aeabi_dsub+0x160>
 800492a:	4f1f      	ldr	r7, [pc, #124]	; (80049a8 <__aeabi_dsub+0x370>)
 800492c:	1ae4      	subs	r4, r4, r3
 800492e:	4017      	ands	r7, r2
 8004930:	e6b4      	b.n	800469c <__aeabi_dsub+0x64>
 8004932:	9b01      	ldr	r3, [sp, #4]
 8004934:	431a      	orrs	r2, r3
 8004936:	1e51      	subs	r1, r2, #1
 8004938:	418a      	sbcs	r2, r1
 800493a:	b2d3      	uxtb	r3, r2
 800493c:	2200      	movs	r2, #0
 800493e:	e709      	b.n	8004754 <__aeabi_dsub+0x11c>
 8004940:	2b00      	cmp	r3, #0
 8004942:	d000      	beq.n	8004946 <__aeabi_dsub+0x30e>
 8004944:	e101      	b.n	8004b4a <__aeabi_dsub+0x512>
 8004946:	1c60      	adds	r0, r4, #1
 8004948:	0543      	lsls	r3, r0, #21
 800494a:	0d5b      	lsrs	r3, r3, #21
 800494c:	2b01      	cmp	r3, #1
 800494e:	dc00      	bgt.n	8004952 <__aeabi_dsub+0x31a>
 8004950:	e0b0      	b.n	8004ab4 <__aeabi_dsub+0x47c>
 8004952:	4b14      	ldr	r3, [pc, #80]	; (80049a4 <__aeabi_dsub+0x36c>)
 8004954:	4298      	cmp	r0, r3
 8004956:	d100      	bne.n	800495a <__aeabi_dsub+0x322>
 8004958:	e11e      	b.n	8004b98 <__aeabi_dsub+0x560>
 800495a:	9b01      	ldr	r3, [sp, #4]
 800495c:	19d2      	adds	r2, r2, r7
 800495e:	1959      	adds	r1, r3, r5
 8004960:	42a9      	cmp	r1, r5
 8004962:	419b      	sbcs	r3, r3
 8004964:	425b      	negs	r3, r3
 8004966:	18d2      	adds	r2, r2, r3
 8004968:	0849      	lsrs	r1, r1, #1
 800496a:	07d5      	lsls	r5, r2, #31
 800496c:	430d      	orrs	r5, r1
 800496e:	0857      	lsrs	r7, r2, #1
 8004970:	1c04      	adds	r4, r0, #0
 8004972:	e693      	b.n	800469c <__aeabi_dsub+0x64>
 8004974:	4b0b      	ldr	r3, [pc, #44]	; (80049a4 <__aeabi_dsub+0x36c>)
 8004976:	429c      	cmp	r4, r3
 8004978:	d000      	beq.n	800497c <__aeabi_dsub+0x344>
 800497a:	e6d3      	b.n	8004724 <__aeabi_dsub+0xec>
 800497c:	e68e      	b.n	800469c <__aeabi_dsub+0x64>
 800497e:	1c21      	adds	r1, r4, #0
 8004980:	1c13      	adds	r3, r2, #0
 8004982:	391f      	subs	r1, #31
 8004984:	40cb      	lsrs	r3, r1
 8004986:	1c19      	adds	r1, r3, #0
 8004988:	2f20      	cmp	r7, #32
 800498a:	d100      	bne.n	800498e <__aeabi_dsub+0x356>
 800498c:	e08e      	b.n	8004aac <__aeabi_dsub+0x474>
 800498e:	233f      	movs	r3, #63	; 0x3f
 8004990:	1b1c      	subs	r4, r3, r4
 8004992:	40a2      	lsls	r2, r4
 8004994:	4315      	orrs	r5, r2
 8004996:	1e6a      	subs	r2, r5, #1
 8004998:	4195      	sbcs	r5, r2
 800499a:	2700      	movs	r7, #0
 800499c:	430d      	orrs	r5, r1
 800499e:	2400      	movs	r4, #0
 80049a0:	e78b      	b.n	80048ba <__aeabi_dsub+0x282>
 80049a2:	46c0      	nop			; (mov r8, r8)
 80049a4:	000007ff 	.word	0x000007ff
 80049a8:	ff7fffff 	.word	0xff7fffff
 80049ac:	800fffff 	.word	0x800fffff
 80049b0:	1c33      	adds	r3, r6, #0
 80049b2:	1c10      	adds	r0, r2, #0
 80049b4:	3b20      	subs	r3, #32
 80049b6:	40d8      	lsrs	r0, r3
 80049b8:	2e20      	cmp	r6, #32
 80049ba:	d079      	beq.n	8004ab0 <__aeabi_dsub+0x478>
 80049bc:	2340      	movs	r3, #64	; 0x40
 80049be:	1b9b      	subs	r3, r3, r6
 80049c0:	409a      	lsls	r2, r3
 80049c2:	1c13      	adds	r3, r2, #0
 80049c4:	9a01      	ldr	r2, [sp, #4]
 80049c6:	4313      	orrs	r3, r2
 80049c8:	1e59      	subs	r1, r3, #1
 80049ca:	418b      	sbcs	r3, r1
 80049cc:	2200      	movs	r2, #0
 80049ce:	4303      	orrs	r3, r0
 80049d0:	e6c0      	b.n	8004754 <__aeabi_dsub+0x11c>
 80049d2:	2c00      	cmp	r4, #0
 80049d4:	d053      	beq.n	8004a7e <__aeabi_dsub+0x446>
 80049d6:	4cc7      	ldr	r4, [pc, #796]	; (8004cf4 <__aeabi_dsub+0x6bc>)
 80049d8:	42a0      	cmp	r0, r4
 80049da:	d100      	bne.n	80049de <__aeabi_dsub+0x3a6>
 80049dc:	e0b0      	b.n	8004b40 <__aeabi_dsub+0x508>
 80049de:	2480      	movs	r4, #128	; 0x80
 80049e0:	4271      	negs	r1, r6
 80049e2:	4689      	mov	r9, r1
 80049e4:	0424      	lsls	r4, r4, #16
 80049e6:	4327      	orrs	r7, r4
 80049e8:	4649      	mov	r1, r9
 80049ea:	2938      	cmp	r1, #56	; 0x38
 80049ec:	dd00      	ble.n	80049f0 <__aeabi_dsub+0x3b8>
 80049ee:	e0cd      	b.n	8004b8c <__aeabi_dsub+0x554>
 80049f0:	291f      	cmp	r1, #31
 80049f2:	dd00      	ble.n	80049f6 <__aeabi_dsub+0x3be>
 80049f4:	e159      	b.n	8004caa <__aeabi_dsub+0x672>
 80049f6:	2420      	movs	r4, #32
 80049f8:	1c3e      	adds	r6, r7, #0
 80049fa:	1a61      	subs	r1, r4, r1
 80049fc:	408e      	lsls	r6, r1
 80049fe:	468a      	mov	sl, r1
 8004a00:	46b0      	mov	r8, r6
 8004a02:	4649      	mov	r1, r9
 8004a04:	1c2e      	adds	r6, r5, #0
 8004a06:	40ce      	lsrs	r6, r1
 8004a08:	4651      	mov	r1, sl
 8004a0a:	46b4      	mov	ip, r6
 8004a0c:	408d      	lsls	r5, r1
 8004a0e:	4664      	mov	r4, ip
 8004a10:	4646      	mov	r6, r8
 8004a12:	4649      	mov	r1, r9
 8004a14:	4326      	orrs	r6, r4
 8004a16:	1e6c      	subs	r4, r5, #1
 8004a18:	41a5      	sbcs	r5, r4
 8004a1a:	40cf      	lsrs	r7, r1
 8004a1c:	4335      	orrs	r5, r6
 8004a1e:	9901      	ldr	r1, [sp, #4]
 8004a20:	1bd7      	subs	r7, r2, r7
 8004a22:	468c      	mov	ip, r1
 8004a24:	1b4d      	subs	r5, r1, r5
 8004a26:	45ac      	cmp	ip, r5
 8004a28:	4192      	sbcs	r2, r2
 8004a2a:	4252      	negs	r2, r2
 8004a2c:	1abf      	subs	r7, r7, r2
 8004a2e:	1c04      	adds	r4, r0, #0
 8004a30:	4698      	mov	r8, r3
 8004a32:	e696      	b.n	8004762 <__aeabi_dsub+0x12a>
 8004a34:	4663      	mov	r3, ip
 8004a36:	4665      	mov	r5, ip
 8004a38:	4333      	orrs	r3, r6
 8004a3a:	d000      	beq.n	8004a3e <__aeabi_dsub+0x406>
 8004a3c:	e696      	b.n	800476c <__aeabi_dsub+0x134>
 8004a3e:	2600      	movs	r6, #0
 8004a40:	2700      	movs	r7, #0
 8004a42:	2400      	movs	r4, #0
 8004a44:	2500      	movs	r5, #0
 8004a46:	e6c4      	b.n	80047d2 <__aeabi_dsub+0x19a>
 8004a48:	2b1f      	cmp	r3, #31
 8004a4a:	dc61      	bgt.n	8004b10 <__aeabi_dsub+0x4d8>
 8004a4c:	2020      	movs	r0, #32
 8004a4e:	1ac3      	subs	r3, r0, r3
 8004a50:	469b      	mov	fp, r3
 8004a52:	1c13      	adds	r3, r2, #0
 8004a54:	4659      	mov	r1, fp
 8004a56:	408b      	lsls	r3, r1
 8004a58:	4651      	mov	r1, sl
 8004a5a:	4699      	mov	r9, r3
 8004a5c:	9b01      	ldr	r3, [sp, #4]
 8004a5e:	40cb      	lsrs	r3, r1
 8004a60:	469c      	mov	ip, r3
 8004a62:	464b      	mov	r3, r9
 8004a64:	4660      	mov	r0, ip
 8004a66:	4303      	orrs	r3, r0
 8004a68:	469c      	mov	ip, r3
 8004a6a:	465b      	mov	r3, fp
 8004a6c:	9901      	ldr	r1, [sp, #4]
 8004a6e:	4099      	lsls	r1, r3
 8004a70:	4663      	mov	r3, ip
 8004a72:	1e48      	subs	r0, r1, #1
 8004a74:	4181      	sbcs	r1, r0
 8004a76:	4319      	orrs	r1, r3
 8004a78:	4653      	mov	r3, sl
 8004a7a:	40da      	lsrs	r2, r3
 8004a7c:	e6cd      	b.n	800481a <__aeabi_dsub+0x1e2>
 8004a7e:	1c3c      	adds	r4, r7, #0
 8004a80:	432c      	orrs	r4, r5
 8004a82:	d05d      	beq.n	8004b40 <__aeabi_dsub+0x508>
 8004a84:	43f1      	mvns	r1, r6
 8004a86:	4689      	mov	r9, r1
 8004a88:	2900      	cmp	r1, #0
 8004a8a:	d155      	bne.n	8004b38 <__aeabi_dsub+0x500>
 8004a8c:	9901      	ldr	r1, [sp, #4]
 8004a8e:	1bd2      	subs	r2, r2, r7
 8004a90:	468c      	mov	ip, r1
 8004a92:	1b4d      	subs	r5, r1, r5
 8004a94:	45ac      	cmp	ip, r5
 8004a96:	4189      	sbcs	r1, r1
 8004a98:	4249      	negs	r1, r1
 8004a9a:	1a57      	subs	r7, r2, r1
 8004a9c:	1c04      	adds	r4, r0, #0
 8004a9e:	4698      	mov	r8, r3
 8004aa0:	e65f      	b.n	8004762 <__aeabi_dsub+0x12a>
 8004aa2:	4894      	ldr	r0, [pc, #592]	; (8004cf4 <__aeabi_dsub+0x6bc>)
 8004aa4:	4284      	cmp	r4, r0
 8004aa6:	d000      	beq.n	8004aaa <__aeabi_dsub+0x472>
 8004aa8:	e6ad      	b.n	8004806 <__aeabi_dsub+0x1ce>
 8004aaa:	e5f7      	b.n	800469c <__aeabi_dsub+0x64>
 8004aac:	2200      	movs	r2, #0
 8004aae:	e771      	b.n	8004994 <__aeabi_dsub+0x35c>
 8004ab0:	2300      	movs	r3, #0
 8004ab2:	e787      	b.n	80049c4 <__aeabi_dsub+0x38c>
 8004ab4:	1c3b      	adds	r3, r7, #0
 8004ab6:	432b      	orrs	r3, r5
 8004ab8:	2c00      	cmp	r4, #0
 8004aba:	d000      	beq.n	8004abe <__aeabi_dsub+0x486>
 8004abc:	e0da      	b.n	8004c74 <__aeabi_dsub+0x63c>
 8004abe:	2b00      	cmp	r3, #0
 8004ac0:	d100      	bne.n	8004ac4 <__aeabi_dsub+0x48c>
 8004ac2:	e113      	b.n	8004cec <__aeabi_dsub+0x6b4>
 8004ac4:	1c13      	adds	r3, r2, #0
 8004ac6:	9901      	ldr	r1, [sp, #4]
 8004ac8:	430b      	orrs	r3, r1
 8004aca:	d100      	bne.n	8004ace <__aeabi_dsub+0x496>
 8004acc:	e5e6      	b.n	800469c <__aeabi_dsub+0x64>
 8004ace:	1949      	adds	r1, r1, r5
 8004ad0:	42a9      	cmp	r1, r5
 8004ad2:	419b      	sbcs	r3, r3
 8004ad4:	19d2      	adds	r2, r2, r7
 8004ad6:	425b      	negs	r3, r3
 8004ad8:	18d7      	adds	r7, r2, r3
 8004ada:	023b      	lsls	r3, r7, #8
 8004adc:	d400      	bmi.n	8004ae0 <__aeabi_dsub+0x4a8>
 8004ade:	e121      	b.n	8004d24 <__aeabi_dsub+0x6ec>
 8004ae0:	4b85      	ldr	r3, [pc, #532]	; (8004cf8 <__aeabi_dsub+0x6c0>)
 8004ae2:	1c0d      	adds	r5, r1, #0
 8004ae4:	401f      	ands	r7, r3
 8004ae6:	1c04      	adds	r4, r0, #0
 8004ae8:	e5d8      	b.n	800469c <__aeabi_dsub+0x64>
 8004aea:	1c38      	adds	r0, r7, #0
 8004aec:	4328      	orrs	r0, r5
 8004aee:	2c00      	cmp	r4, #0
 8004af0:	d140      	bne.n	8004b74 <__aeabi_dsub+0x53c>
 8004af2:	2800      	cmp	r0, #0
 8004af4:	d000      	beq.n	8004af8 <__aeabi_dsub+0x4c0>
 8004af6:	e083      	b.n	8004c00 <__aeabi_dsub+0x5c8>
 8004af8:	1c10      	adds	r0, r2, #0
 8004afa:	9901      	ldr	r1, [sp, #4]
 8004afc:	4308      	orrs	r0, r1
 8004afe:	d003      	beq.n	8004b08 <__aeabi_dsub+0x4d0>
 8004b00:	1c17      	adds	r7, r2, #0
 8004b02:	1c0d      	adds	r5, r1, #0
 8004b04:	4698      	mov	r8, r3
 8004b06:	e5c9      	b.n	800469c <__aeabi_dsub+0x64>
 8004b08:	2600      	movs	r6, #0
 8004b0a:	2700      	movs	r7, #0
 8004b0c:	2500      	movs	r5, #0
 8004b0e:	e660      	b.n	80047d2 <__aeabi_dsub+0x19a>
 8004b10:	4650      	mov	r0, sl
 8004b12:	1c13      	adds	r3, r2, #0
 8004b14:	3820      	subs	r0, #32
 8004b16:	40c3      	lsrs	r3, r0
 8004b18:	1c18      	adds	r0, r3, #0
 8004b1a:	4653      	mov	r3, sl
 8004b1c:	2b20      	cmp	r3, #32
 8004b1e:	d100      	bne.n	8004b22 <__aeabi_dsub+0x4ea>
 8004b20:	e0c1      	b.n	8004ca6 <__aeabi_dsub+0x66e>
 8004b22:	2340      	movs	r3, #64	; 0x40
 8004b24:	4651      	mov	r1, sl
 8004b26:	1a5b      	subs	r3, r3, r1
 8004b28:	409a      	lsls	r2, r3
 8004b2a:	9901      	ldr	r1, [sp, #4]
 8004b2c:	4311      	orrs	r1, r2
 8004b2e:	1e4a      	subs	r2, r1, #1
 8004b30:	4191      	sbcs	r1, r2
 8004b32:	2200      	movs	r2, #0
 8004b34:	4301      	orrs	r1, r0
 8004b36:	e670      	b.n	800481a <__aeabi_dsub+0x1e2>
 8004b38:	4c6e      	ldr	r4, [pc, #440]	; (8004cf4 <__aeabi_dsub+0x6bc>)
 8004b3a:	42a0      	cmp	r0, r4
 8004b3c:	d000      	beq.n	8004b40 <__aeabi_dsub+0x508>
 8004b3e:	e753      	b.n	80049e8 <__aeabi_dsub+0x3b0>
 8004b40:	1c17      	adds	r7, r2, #0
 8004b42:	9d01      	ldr	r5, [sp, #4]
 8004b44:	1c04      	adds	r4, r0, #0
 8004b46:	4698      	mov	r8, r3
 8004b48:	e5a8      	b.n	800469c <__aeabi_dsub+0x64>
 8004b4a:	2c00      	cmp	r4, #0
 8004b4c:	d128      	bne.n	8004ba0 <__aeabi_dsub+0x568>
 8004b4e:	1c3c      	adds	r4, r7, #0
 8004b50:	432c      	orrs	r4, r5
 8004b52:	d100      	bne.n	8004b56 <__aeabi_dsub+0x51e>
 8004b54:	e08a      	b.n	8004c6c <__aeabi_dsub+0x634>
 8004b56:	43db      	mvns	r3, r3
 8004b58:	469a      	mov	sl, r3
 8004b5a:	2b00      	cmp	r3, #0
 8004b5c:	d000      	beq.n	8004b60 <__aeabi_dsub+0x528>
 8004b5e:	e082      	b.n	8004c66 <__aeabi_dsub+0x62e>
 8004b60:	9b01      	ldr	r3, [sp, #4]
 8004b62:	19d2      	adds	r2, r2, r7
 8004b64:	469c      	mov	ip, r3
 8004b66:	4465      	add	r5, ip
 8004b68:	429d      	cmp	r5, r3
 8004b6a:	4189      	sbcs	r1, r1
 8004b6c:	4249      	negs	r1, r1
 8004b6e:	1857      	adds	r7, r2, r1
 8004b70:	1c04      	adds	r4, r0, #0
 8004b72:	e659      	b.n	8004828 <__aeabi_dsub+0x1f0>
 8004b74:	2800      	cmp	r0, #0
 8004b76:	d15b      	bne.n	8004c30 <__aeabi_dsub+0x5f8>
 8004b78:	1c10      	adds	r0, r2, #0
 8004b7a:	9901      	ldr	r1, [sp, #4]
 8004b7c:	4308      	orrs	r0, r1
 8004b7e:	d100      	bne.n	8004b82 <__aeabi_dsub+0x54a>
 8004b80:	e0a4      	b.n	8004ccc <__aeabi_dsub+0x694>
 8004b82:	1c17      	adds	r7, r2, #0
 8004b84:	1c0d      	adds	r5, r1, #0
 8004b86:	4698      	mov	r8, r3
 8004b88:	4c5a      	ldr	r4, [pc, #360]	; (8004cf4 <__aeabi_dsub+0x6bc>)
 8004b8a:	e587      	b.n	800469c <__aeabi_dsub+0x64>
 8004b8c:	433d      	orrs	r5, r7
 8004b8e:	1e6f      	subs	r7, r5, #1
 8004b90:	41bd      	sbcs	r5, r7
 8004b92:	2700      	movs	r7, #0
 8004b94:	b2ed      	uxtb	r5, r5
 8004b96:	e742      	b.n	8004a1e <__aeabi_dsub+0x3e6>
 8004b98:	1c04      	adds	r4, r0, #0
 8004b9a:	2700      	movs	r7, #0
 8004b9c:	2500      	movs	r5, #0
 8004b9e:	e618      	b.n	80047d2 <__aeabi_dsub+0x19a>
 8004ba0:	4c54      	ldr	r4, [pc, #336]	; (8004cf4 <__aeabi_dsub+0x6bc>)
 8004ba2:	42a0      	cmp	r0, r4
 8004ba4:	d062      	beq.n	8004c6c <__aeabi_dsub+0x634>
 8004ba6:	4653      	mov	r3, sl
 8004ba8:	2480      	movs	r4, #128	; 0x80
 8004baa:	425b      	negs	r3, r3
 8004bac:	469a      	mov	sl, r3
 8004bae:	0424      	lsls	r4, r4, #16
 8004bb0:	4327      	orrs	r7, r4
 8004bb2:	4653      	mov	r3, sl
 8004bb4:	2b38      	cmp	r3, #56	; 0x38
 8004bb6:	dd00      	ble.n	8004bba <__aeabi_dsub+0x582>
 8004bb8:	e08e      	b.n	8004cd8 <__aeabi_dsub+0x6a0>
 8004bba:	2b1f      	cmp	r3, #31
 8004bbc:	dd00      	ble.n	8004bc0 <__aeabi_dsub+0x588>
 8004bbe:	e09d      	b.n	8004cfc <__aeabi_dsub+0x6c4>
 8004bc0:	2420      	movs	r4, #32
 8004bc2:	1ae3      	subs	r3, r4, r3
 8004bc4:	469b      	mov	fp, r3
 8004bc6:	1c3b      	adds	r3, r7, #0
 8004bc8:	4659      	mov	r1, fp
 8004bca:	408b      	lsls	r3, r1
 8004bcc:	4651      	mov	r1, sl
 8004bce:	4699      	mov	r9, r3
 8004bd0:	1c2b      	adds	r3, r5, #0
 8004bd2:	40cb      	lsrs	r3, r1
 8004bd4:	469c      	mov	ip, r3
 8004bd6:	464b      	mov	r3, r9
 8004bd8:	4664      	mov	r4, ip
 8004bda:	4323      	orrs	r3, r4
 8004bdc:	469c      	mov	ip, r3
 8004bde:	465b      	mov	r3, fp
 8004be0:	409d      	lsls	r5, r3
 8004be2:	4663      	mov	r3, ip
 8004be4:	1e6c      	subs	r4, r5, #1
 8004be6:	41a5      	sbcs	r5, r4
 8004be8:	40cf      	lsrs	r7, r1
 8004bea:	431d      	orrs	r5, r3
 8004bec:	9b01      	ldr	r3, [sp, #4]
 8004bee:	18bf      	adds	r7, r7, r2
 8004bf0:	469c      	mov	ip, r3
 8004bf2:	4465      	add	r5, ip
 8004bf4:	429d      	cmp	r5, r3
 8004bf6:	4192      	sbcs	r2, r2
 8004bf8:	4252      	negs	r2, r2
 8004bfa:	18bf      	adds	r7, r7, r2
 8004bfc:	1c04      	adds	r4, r0, #0
 8004bfe:	e613      	b.n	8004828 <__aeabi_dsub+0x1f0>
 8004c00:	1c10      	adds	r0, r2, #0
 8004c02:	9901      	ldr	r1, [sp, #4]
 8004c04:	4308      	orrs	r0, r1
 8004c06:	d100      	bne.n	8004c0a <__aeabi_dsub+0x5d2>
 8004c08:	e548      	b.n	800469c <__aeabi_dsub+0x64>
 8004c0a:	1a68      	subs	r0, r5, r1
 8004c0c:	4684      	mov	ip, r0
 8004c0e:	4285      	cmp	r5, r0
 8004c10:	4180      	sbcs	r0, r0
 8004c12:	1abe      	subs	r6, r7, r2
 8004c14:	4240      	negs	r0, r0
 8004c16:	1a30      	subs	r0, r6, r0
 8004c18:	0206      	lsls	r6, r0, #8
 8004c1a:	d400      	bmi.n	8004c1e <__aeabi_dsub+0x5e6>
 8004c1c:	e647      	b.n	80048ae <__aeabi_dsub+0x276>
 8004c1e:	468c      	mov	ip, r1
 8004c20:	1b4d      	subs	r5, r1, r5
 8004c22:	45ac      	cmp	ip, r5
 8004c24:	4189      	sbcs	r1, r1
 8004c26:	1bd2      	subs	r2, r2, r7
 8004c28:	4249      	negs	r1, r1
 8004c2a:	1a57      	subs	r7, r2, r1
 8004c2c:	4698      	mov	r8, r3
 8004c2e:	e535      	b.n	800469c <__aeabi_dsub+0x64>
 8004c30:	1c10      	adds	r0, r2, #0
 8004c32:	9901      	ldr	r1, [sp, #4]
 8004c34:	4308      	orrs	r0, r1
 8004c36:	d034      	beq.n	8004ca2 <__aeabi_dsub+0x66a>
 8004c38:	2480      	movs	r4, #128	; 0x80
 8004c3a:	0778      	lsls	r0, r7, #29
 8004c3c:	08ed      	lsrs	r5, r5, #3
 8004c3e:	08ff      	lsrs	r7, r7, #3
 8004c40:	0324      	lsls	r4, r4, #12
 8004c42:	4328      	orrs	r0, r5
 8004c44:	4227      	tst	r7, r4
 8004c46:	d008      	beq.n	8004c5a <__aeabi_dsub+0x622>
 8004c48:	08d6      	lsrs	r6, r2, #3
 8004c4a:	4226      	tst	r6, r4
 8004c4c:	d105      	bne.n	8004c5a <__aeabi_dsub+0x622>
 8004c4e:	08c9      	lsrs	r1, r1, #3
 8004c50:	0752      	lsls	r2, r2, #29
 8004c52:	430a      	orrs	r2, r1
 8004c54:	1c10      	adds	r0, r2, #0
 8004c56:	1c37      	adds	r7, r6, #0
 8004c58:	4698      	mov	r8, r3
 8004c5a:	00ff      	lsls	r7, r7, #3
 8004c5c:	0f42      	lsrs	r2, r0, #29
 8004c5e:	4317      	orrs	r7, r2
 8004c60:	00c5      	lsls	r5, r0, #3
 8004c62:	4c24      	ldr	r4, [pc, #144]	; (8004cf4 <__aeabi_dsub+0x6bc>)
 8004c64:	e51a      	b.n	800469c <__aeabi_dsub+0x64>
 8004c66:	4c23      	ldr	r4, [pc, #140]	; (8004cf4 <__aeabi_dsub+0x6bc>)
 8004c68:	42a0      	cmp	r0, r4
 8004c6a:	d1a2      	bne.n	8004bb2 <__aeabi_dsub+0x57a>
 8004c6c:	1c17      	adds	r7, r2, #0
 8004c6e:	9d01      	ldr	r5, [sp, #4]
 8004c70:	1c04      	adds	r4, r0, #0
 8004c72:	e513      	b.n	800469c <__aeabi_dsub+0x64>
 8004c74:	2b00      	cmp	r3, #0
 8004c76:	d035      	beq.n	8004ce4 <__aeabi_dsub+0x6ac>
 8004c78:	1c13      	adds	r3, r2, #0
 8004c7a:	9901      	ldr	r1, [sp, #4]
 8004c7c:	430b      	orrs	r3, r1
 8004c7e:	d010      	beq.n	8004ca2 <__aeabi_dsub+0x66a>
 8004c80:	2480      	movs	r4, #128	; 0x80
 8004c82:	0778      	lsls	r0, r7, #29
 8004c84:	08ed      	lsrs	r5, r5, #3
 8004c86:	08ff      	lsrs	r7, r7, #3
 8004c88:	0324      	lsls	r4, r4, #12
 8004c8a:	4328      	orrs	r0, r5
 8004c8c:	4227      	tst	r7, r4
 8004c8e:	d0e4      	beq.n	8004c5a <__aeabi_dsub+0x622>
 8004c90:	08d3      	lsrs	r3, r2, #3
 8004c92:	4223      	tst	r3, r4
 8004c94:	d1e1      	bne.n	8004c5a <__aeabi_dsub+0x622>
 8004c96:	08c9      	lsrs	r1, r1, #3
 8004c98:	0752      	lsls	r2, r2, #29
 8004c9a:	430a      	orrs	r2, r1
 8004c9c:	1c10      	adds	r0, r2, #0
 8004c9e:	1c1f      	adds	r7, r3, #0
 8004ca0:	e7db      	b.n	8004c5a <__aeabi_dsub+0x622>
 8004ca2:	4c14      	ldr	r4, [pc, #80]	; (8004cf4 <__aeabi_dsub+0x6bc>)
 8004ca4:	e4fa      	b.n	800469c <__aeabi_dsub+0x64>
 8004ca6:	2200      	movs	r2, #0
 8004ca8:	e73f      	b.n	8004b2a <__aeabi_dsub+0x4f2>
 8004caa:	464c      	mov	r4, r9
 8004cac:	1c3e      	adds	r6, r7, #0
 8004cae:	3c20      	subs	r4, #32
 8004cb0:	40e6      	lsrs	r6, r4
 8004cb2:	4649      	mov	r1, r9
 8004cb4:	1c34      	adds	r4, r6, #0
 8004cb6:	2920      	cmp	r1, #32
 8004cb8:	d032      	beq.n	8004d20 <__aeabi_dsub+0x6e8>
 8004cba:	2640      	movs	r6, #64	; 0x40
 8004cbc:	1a76      	subs	r6, r6, r1
 8004cbe:	40b7      	lsls	r7, r6
 8004cc0:	433d      	orrs	r5, r7
 8004cc2:	1e6f      	subs	r7, r5, #1
 8004cc4:	41bd      	sbcs	r5, r7
 8004cc6:	2700      	movs	r7, #0
 8004cc8:	4325      	orrs	r5, r4
 8004cca:	e6a8      	b.n	8004a1e <__aeabi_dsub+0x3e6>
 8004ccc:	2780      	movs	r7, #128	; 0x80
 8004cce:	2600      	movs	r6, #0
 8004cd0:	03ff      	lsls	r7, r7, #15
 8004cd2:	4c08      	ldr	r4, [pc, #32]	; (8004cf4 <__aeabi_dsub+0x6bc>)
 8004cd4:	2500      	movs	r5, #0
 8004cd6:	e57c      	b.n	80047d2 <__aeabi_dsub+0x19a>
 8004cd8:	433d      	orrs	r5, r7
 8004cda:	1e6f      	subs	r7, r5, #1
 8004cdc:	41bd      	sbcs	r5, r7
 8004cde:	2700      	movs	r7, #0
 8004ce0:	b2ed      	uxtb	r5, r5
 8004ce2:	e783      	b.n	8004bec <__aeabi_dsub+0x5b4>
 8004ce4:	1c17      	adds	r7, r2, #0
 8004ce6:	9d01      	ldr	r5, [sp, #4]
 8004ce8:	4c02      	ldr	r4, [pc, #8]	; (8004cf4 <__aeabi_dsub+0x6bc>)
 8004cea:	e4d7      	b.n	800469c <__aeabi_dsub+0x64>
 8004cec:	1c17      	adds	r7, r2, #0
 8004cee:	9d01      	ldr	r5, [sp, #4]
 8004cf0:	e4d4      	b.n	800469c <__aeabi_dsub+0x64>
 8004cf2:	46c0      	nop			; (mov r8, r8)
 8004cf4:	000007ff 	.word	0x000007ff
 8004cf8:	ff7fffff 	.word	0xff7fffff
 8004cfc:	4654      	mov	r4, sl
 8004cfe:	1c3b      	adds	r3, r7, #0
 8004d00:	3c20      	subs	r4, #32
 8004d02:	40e3      	lsrs	r3, r4
 8004d04:	1c1c      	adds	r4, r3, #0
 8004d06:	4653      	mov	r3, sl
 8004d08:	2b20      	cmp	r3, #32
 8004d0a:	d00d      	beq.n	8004d28 <__aeabi_dsub+0x6f0>
 8004d0c:	2340      	movs	r3, #64	; 0x40
 8004d0e:	4651      	mov	r1, sl
 8004d10:	1a5b      	subs	r3, r3, r1
 8004d12:	409f      	lsls	r7, r3
 8004d14:	433d      	orrs	r5, r7
 8004d16:	1e6f      	subs	r7, r5, #1
 8004d18:	41bd      	sbcs	r5, r7
 8004d1a:	2700      	movs	r7, #0
 8004d1c:	4325      	orrs	r5, r4
 8004d1e:	e765      	b.n	8004bec <__aeabi_dsub+0x5b4>
 8004d20:	2700      	movs	r7, #0
 8004d22:	e7cd      	b.n	8004cc0 <__aeabi_dsub+0x688>
 8004d24:	1c0d      	adds	r5, r1, #0
 8004d26:	e5c8      	b.n	80048ba <__aeabi_dsub+0x282>
 8004d28:	2700      	movs	r7, #0
 8004d2a:	e7f3      	b.n	8004d14 <__aeabi_dsub+0x6dc>

08004d2c <__aeabi_d2iz>:
 8004d2c:	030b      	lsls	r3, r1, #12
 8004d2e:	b530      	push	{r4, r5, lr}
 8004d30:	4c13      	ldr	r4, [pc, #76]	; (8004d80 <__aeabi_d2iz+0x54>)
 8004d32:	0b1a      	lsrs	r2, r3, #12
 8004d34:	004b      	lsls	r3, r1, #1
 8004d36:	1c05      	adds	r5, r0, #0
 8004d38:	0d5b      	lsrs	r3, r3, #21
 8004d3a:	0fc9      	lsrs	r1, r1, #31
 8004d3c:	2000      	movs	r0, #0
 8004d3e:	42a3      	cmp	r3, r4
 8004d40:	dd10      	ble.n	8004d64 <__aeabi_d2iz+0x38>
 8004d42:	4810      	ldr	r0, [pc, #64]	; (8004d84 <__aeabi_d2iz+0x58>)
 8004d44:	4283      	cmp	r3, r0
 8004d46:	dc0e      	bgt.n	8004d66 <__aeabi_d2iz+0x3a>
 8004d48:	2080      	movs	r0, #128	; 0x80
 8004d4a:	4c0f      	ldr	r4, [pc, #60]	; (8004d88 <__aeabi_d2iz+0x5c>)
 8004d4c:	0340      	lsls	r0, r0, #13
 8004d4e:	4302      	orrs	r2, r0
 8004d50:	1ae4      	subs	r4, r4, r3
 8004d52:	2c1f      	cmp	r4, #31
 8004d54:	dd0a      	ble.n	8004d6c <__aeabi_d2iz+0x40>
 8004d56:	480d      	ldr	r0, [pc, #52]	; (8004d8c <__aeabi_d2iz+0x60>)
 8004d58:	1ac3      	subs	r3, r0, r3
 8004d5a:	40da      	lsrs	r2, r3
 8004d5c:	1c13      	adds	r3, r2, #0
 8004d5e:	4248      	negs	r0, r1
 8004d60:	4043      	eors	r3, r0
 8004d62:	1858      	adds	r0, r3, r1
 8004d64:	bd30      	pop	{r4, r5, pc}
 8004d66:	4b0a      	ldr	r3, [pc, #40]	; (8004d90 <__aeabi_d2iz+0x64>)
 8004d68:	18c8      	adds	r0, r1, r3
 8004d6a:	e7fb      	b.n	8004d64 <__aeabi_d2iz+0x38>
 8004d6c:	1c28      	adds	r0, r5, #0
 8004d6e:	40e0      	lsrs	r0, r4
 8004d70:	4c08      	ldr	r4, [pc, #32]	; (8004d94 <__aeabi_d2iz+0x68>)
 8004d72:	46a4      	mov	ip, r4
 8004d74:	4463      	add	r3, ip
 8004d76:	409a      	lsls	r2, r3
 8004d78:	1c13      	adds	r3, r2, #0
 8004d7a:	4303      	orrs	r3, r0
 8004d7c:	e7ef      	b.n	8004d5e <__aeabi_d2iz+0x32>
 8004d7e:	46c0      	nop			; (mov r8, r8)
 8004d80:	000003fe 	.word	0x000003fe
 8004d84:	0000041d 	.word	0x0000041d
 8004d88:	00000433 	.word	0x00000433
 8004d8c:	00000413 	.word	0x00000413
 8004d90:	7fffffff 	.word	0x7fffffff
 8004d94:	fffffbed 	.word	0xfffffbed

08004d98 <__aeabi_i2d>:
 8004d98:	b538      	push	{r3, r4, r5, lr}
 8004d9a:	1e04      	subs	r4, r0, #0
 8004d9c:	d016      	beq.n	8004dcc <__aeabi_i2d+0x34>
 8004d9e:	0fc5      	lsrs	r5, r0, #31
 8004da0:	d000      	beq.n	8004da4 <__aeabi_i2d+0xc>
 8004da2:	4244      	negs	r4, r0
 8004da4:	1c20      	adds	r0, r4, #0
 8004da6:	f000 f8a3 	bl	8004ef0 <__clzsi2>
 8004daa:	4b17      	ldr	r3, [pc, #92]	; (8004e08 <__aeabi_i2d+0x70>)
 8004dac:	1a1b      	subs	r3, r3, r0
 8004dae:	280a      	cmp	r0, #10
 8004db0:	dc21      	bgt.n	8004df6 <__aeabi_i2d+0x5e>
 8004db2:	1c02      	adds	r2, r0, #0
 8004db4:	1c21      	adds	r1, r4, #0
 8004db6:	3215      	adds	r2, #21
 8004db8:	4091      	lsls	r1, r2
 8004dba:	1c0a      	adds	r2, r1, #0
 8004dbc:	210b      	movs	r1, #11
 8004dbe:	1a08      	subs	r0, r1, r0
 8004dc0:	40c4      	lsrs	r4, r0
 8004dc2:	055b      	lsls	r3, r3, #21
 8004dc4:	0324      	lsls	r4, r4, #12
 8004dc6:	0b24      	lsrs	r4, r4, #12
 8004dc8:	0d5b      	lsrs	r3, r3, #21
 8004dca:	e003      	b.n	8004dd4 <__aeabi_i2d+0x3c>
 8004dcc:	2500      	movs	r5, #0
 8004dce:	2300      	movs	r3, #0
 8004dd0:	2400      	movs	r4, #0
 8004dd2:	2200      	movs	r2, #0
 8004dd4:	2100      	movs	r1, #0
 8004dd6:	1c10      	adds	r0, r2, #0
 8004dd8:	0324      	lsls	r4, r4, #12
 8004dda:	0d0a      	lsrs	r2, r1, #20
 8004ddc:	0512      	lsls	r2, r2, #20
 8004dde:	0b24      	lsrs	r4, r4, #12
 8004de0:	4314      	orrs	r4, r2
 8004de2:	4a0a      	ldr	r2, [pc, #40]	; (8004e0c <__aeabi_i2d+0x74>)
 8004de4:	051b      	lsls	r3, r3, #20
 8004de6:	4014      	ands	r4, r2
 8004de8:	431c      	orrs	r4, r3
 8004dea:	0064      	lsls	r4, r4, #1
 8004dec:	07ed      	lsls	r5, r5, #31
 8004dee:	0864      	lsrs	r4, r4, #1
 8004df0:	432c      	orrs	r4, r5
 8004df2:	1c21      	adds	r1, r4, #0
 8004df4:	bd38      	pop	{r3, r4, r5, pc}
 8004df6:	380b      	subs	r0, #11
 8004df8:	4084      	lsls	r4, r0
 8004dfa:	055b      	lsls	r3, r3, #21
 8004dfc:	0324      	lsls	r4, r4, #12
 8004dfe:	0b24      	lsrs	r4, r4, #12
 8004e00:	0d5b      	lsrs	r3, r3, #21
 8004e02:	2200      	movs	r2, #0
 8004e04:	e7e6      	b.n	8004dd4 <__aeabi_i2d+0x3c>
 8004e06:	46c0      	nop			; (mov r8, r8)
 8004e08:	0000041e 	.word	0x0000041e
 8004e0c:	800fffff 	.word	0x800fffff

08004e10 <__aeabi_ui2d>:
 8004e10:	b510      	push	{r4, lr}
 8004e12:	1e04      	subs	r4, r0, #0
 8004e14:	d010      	beq.n	8004e38 <__aeabi_ui2d+0x28>
 8004e16:	f000 f86b 	bl	8004ef0 <__clzsi2>
 8004e1a:	4a14      	ldr	r2, [pc, #80]	; (8004e6c <__aeabi_ui2d+0x5c>)
 8004e1c:	1a12      	subs	r2, r2, r0
 8004e1e:	280a      	cmp	r0, #10
 8004e20:	dc1a      	bgt.n	8004e58 <__aeabi_ui2d+0x48>
 8004e22:	230b      	movs	r3, #11
 8004e24:	1c21      	adds	r1, r4, #0
 8004e26:	1a1b      	subs	r3, r3, r0
 8004e28:	40d9      	lsrs	r1, r3
 8004e2a:	3015      	adds	r0, #21
 8004e2c:	030b      	lsls	r3, r1, #12
 8004e2e:	0552      	lsls	r2, r2, #21
 8004e30:	4084      	lsls	r4, r0
 8004e32:	0b1b      	lsrs	r3, r3, #12
 8004e34:	0d52      	lsrs	r2, r2, #21
 8004e36:	e001      	b.n	8004e3c <__aeabi_ui2d+0x2c>
 8004e38:	2200      	movs	r2, #0
 8004e3a:	2300      	movs	r3, #0
 8004e3c:	2100      	movs	r1, #0
 8004e3e:	031b      	lsls	r3, r3, #12
 8004e40:	1c20      	adds	r0, r4, #0
 8004e42:	0b1c      	lsrs	r4, r3, #12
 8004e44:	0d0b      	lsrs	r3, r1, #20
 8004e46:	051b      	lsls	r3, r3, #20
 8004e48:	4323      	orrs	r3, r4
 8004e4a:	4c09      	ldr	r4, [pc, #36]	; (8004e70 <__aeabi_ui2d+0x60>)
 8004e4c:	0512      	lsls	r2, r2, #20
 8004e4e:	4023      	ands	r3, r4
 8004e50:	4313      	orrs	r3, r2
 8004e52:	005b      	lsls	r3, r3, #1
 8004e54:	0859      	lsrs	r1, r3, #1
 8004e56:	bd10      	pop	{r4, pc}
 8004e58:	1c03      	adds	r3, r0, #0
 8004e5a:	3b0b      	subs	r3, #11
 8004e5c:	409c      	lsls	r4, r3
 8004e5e:	0552      	lsls	r2, r2, #21
 8004e60:	0323      	lsls	r3, r4, #12
 8004e62:	0b1b      	lsrs	r3, r3, #12
 8004e64:	0d52      	lsrs	r2, r2, #21
 8004e66:	2400      	movs	r4, #0
 8004e68:	e7e8      	b.n	8004e3c <__aeabi_ui2d+0x2c>
 8004e6a:	46c0      	nop			; (mov r8, r8)
 8004e6c:	0000041e 	.word	0x0000041e
 8004e70:	800fffff 	.word	0x800fffff

08004e74 <__aeabi_cdrcmple>:
 8004e74:	4684      	mov	ip, r0
 8004e76:	1c10      	adds	r0, r2, #0
 8004e78:	4662      	mov	r2, ip
 8004e7a:	468c      	mov	ip, r1
 8004e7c:	1c19      	adds	r1, r3, #0
 8004e7e:	4663      	mov	r3, ip
 8004e80:	e000      	b.n	8004e84 <__aeabi_cdcmpeq>
 8004e82:	46c0      	nop			; (mov r8, r8)

08004e84 <__aeabi_cdcmpeq>:
 8004e84:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8004e86:	f000 f905 	bl	8005094 <__ledf2>
 8004e8a:	2800      	cmp	r0, #0
 8004e8c:	d401      	bmi.n	8004e92 <__aeabi_cdcmpeq+0xe>
 8004e8e:	2100      	movs	r1, #0
 8004e90:	42c8      	cmn	r0, r1
 8004e92:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

08004e94 <__aeabi_dcmpeq>:
 8004e94:	b510      	push	{r4, lr}
 8004e96:	f000 f849 	bl	8004f2c <__eqdf2>
 8004e9a:	4240      	negs	r0, r0
 8004e9c:	3001      	adds	r0, #1
 8004e9e:	bd10      	pop	{r4, pc}

08004ea0 <__aeabi_dcmplt>:
 8004ea0:	b510      	push	{r4, lr}
 8004ea2:	f000 f8f7 	bl	8005094 <__ledf2>
 8004ea6:	2800      	cmp	r0, #0
 8004ea8:	db01      	blt.n	8004eae <__aeabi_dcmplt+0xe>
 8004eaa:	2000      	movs	r0, #0
 8004eac:	bd10      	pop	{r4, pc}
 8004eae:	2001      	movs	r0, #1
 8004eb0:	bd10      	pop	{r4, pc}
 8004eb2:	46c0      	nop			; (mov r8, r8)

08004eb4 <__aeabi_dcmple>:
 8004eb4:	b510      	push	{r4, lr}
 8004eb6:	f000 f8ed 	bl	8005094 <__ledf2>
 8004eba:	2800      	cmp	r0, #0
 8004ebc:	dd01      	ble.n	8004ec2 <__aeabi_dcmple+0xe>
 8004ebe:	2000      	movs	r0, #0
 8004ec0:	bd10      	pop	{r4, pc}
 8004ec2:	2001      	movs	r0, #1
 8004ec4:	bd10      	pop	{r4, pc}
 8004ec6:	46c0      	nop			; (mov r8, r8)

08004ec8 <__aeabi_dcmpgt>:
 8004ec8:	b510      	push	{r4, lr}
 8004eca:	f000 f873 	bl	8004fb4 <__gedf2>
 8004ece:	2800      	cmp	r0, #0
 8004ed0:	dc01      	bgt.n	8004ed6 <__aeabi_dcmpgt+0xe>
 8004ed2:	2000      	movs	r0, #0
 8004ed4:	bd10      	pop	{r4, pc}
 8004ed6:	2001      	movs	r0, #1
 8004ed8:	bd10      	pop	{r4, pc}
 8004eda:	46c0      	nop			; (mov r8, r8)

08004edc <__aeabi_dcmpge>:
 8004edc:	b510      	push	{r4, lr}
 8004ede:	f000 f869 	bl	8004fb4 <__gedf2>
 8004ee2:	2800      	cmp	r0, #0
 8004ee4:	da01      	bge.n	8004eea <__aeabi_dcmpge+0xe>
 8004ee6:	2000      	movs	r0, #0
 8004ee8:	bd10      	pop	{r4, pc}
 8004eea:	2001      	movs	r0, #1
 8004eec:	bd10      	pop	{r4, pc}
 8004eee:	46c0      	nop			; (mov r8, r8)

08004ef0 <__clzsi2>:
 8004ef0:	211c      	movs	r1, #28
 8004ef2:	2301      	movs	r3, #1
 8004ef4:	041b      	lsls	r3, r3, #16
 8004ef6:	4298      	cmp	r0, r3
 8004ef8:	d301      	bcc.n	8004efe <__clzsi2+0xe>
 8004efa:	0c00      	lsrs	r0, r0, #16
 8004efc:	3910      	subs	r1, #16
 8004efe:	0a1b      	lsrs	r3, r3, #8
 8004f00:	4298      	cmp	r0, r3
 8004f02:	d301      	bcc.n	8004f08 <__clzsi2+0x18>
 8004f04:	0a00      	lsrs	r0, r0, #8
 8004f06:	3908      	subs	r1, #8
 8004f08:	091b      	lsrs	r3, r3, #4
 8004f0a:	4298      	cmp	r0, r3
 8004f0c:	d301      	bcc.n	8004f12 <__clzsi2+0x22>
 8004f0e:	0900      	lsrs	r0, r0, #4
 8004f10:	3904      	subs	r1, #4
 8004f12:	a202      	add	r2, pc, #8	; (adr r2, 8004f1c <__clzsi2+0x2c>)
 8004f14:	5c10      	ldrb	r0, [r2, r0]
 8004f16:	1840      	adds	r0, r0, r1
 8004f18:	4770      	bx	lr
 8004f1a:	46c0      	nop			; (mov r8, r8)
 8004f1c:	02020304 	.word	0x02020304
 8004f20:	01010101 	.word	0x01010101
	...

08004f2c <__eqdf2>:
 8004f2c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004f2e:	465f      	mov	r7, fp
 8004f30:	464d      	mov	r5, r9
 8004f32:	4644      	mov	r4, r8
 8004f34:	4656      	mov	r6, sl
 8004f36:	b4f0      	push	{r4, r5, r6, r7}
 8004f38:	031f      	lsls	r7, r3, #12
 8004f3a:	005c      	lsls	r4, r3, #1
 8004f3c:	0fdb      	lsrs	r3, r3, #31
 8004f3e:	4699      	mov	r9, r3
 8004f40:	4b1b      	ldr	r3, [pc, #108]	; (8004fb0 <__eqdf2+0x84>)
 8004f42:	030e      	lsls	r6, r1, #12
 8004f44:	004d      	lsls	r5, r1, #1
 8004f46:	0fc9      	lsrs	r1, r1, #31
 8004f48:	4684      	mov	ip, r0
 8004f4a:	0b36      	lsrs	r6, r6, #12
 8004f4c:	0d6d      	lsrs	r5, r5, #21
 8004f4e:	468b      	mov	fp, r1
 8004f50:	4690      	mov	r8, r2
 8004f52:	0b3f      	lsrs	r7, r7, #12
 8004f54:	0d64      	lsrs	r4, r4, #21
 8004f56:	429d      	cmp	r5, r3
 8004f58:	d00c      	beq.n	8004f74 <__eqdf2+0x48>
 8004f5a:	4b15      	ldr	r3, [pc, #84]	; (8004fb0 <__eqdf2+0x84>)
 8004f5c:	429c      	cmp	r4, r3
 8004f5e:	d010      	beq.n	8004f82 <__eqdf2+0x56>
 8004f60:	2301      	movs	r3, #1
 8004f62:	42a5      	cmp	r5, r4
 8004f64:	d014      	beq.n	8004f90 <__eqdf2+0x64>
 8004f66:	1c18      	adds	r0, r3, #0
 8004f68:	bc3c      	pop	{r2, r3, r4, r5}
 8004f6a:	4690      	mov	r8, r2
 8004f6c:	4699      	mov	r9, r3
 8004f6e:	46a2      	mov	sl, r4
 8004f70:	46ab      	mov	fp, r5
 8004f72:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004f74:	1c31      	adds	r1, r6, #0
 8004f76:	2301      	movs	r3, #1
 8004f78:	4301      	orrs	r1, r0
 8004f7a:	d1f4      	bne.n	8004f66 <__eqdf2+0x3a>
 8004f7c:	4b0c      	ldr	r3, [pc, #48]	; (8004fb0 <__eqdf2+0x84>)
 8004f7e:	429c      	cmp	r4, r3
 8004f80:	d1ee      	bne.n	8004f60 <__eqdf2+0x34>
 8004f82:	433a      	orrs	r2, r7
 8004f84:	2301      	movs	r3, #1
 8004f86:	2a00      	cmp	r2, #0
 8004f88:	d1ed      	bne.n	8004f66 <__eqdf2+0x3a>
 8004f8a:	2301      	movs	r3, #1
 8004f8c:	42a5      	cmp	r5, r4
 8004f8e:	d1ea      	bne.n	8004f66 <__eqdf2+0x3a>
 8004f90:	42be      	cmp	r6, r7
 8004f92:	d1e8      	bne.n	8004f66 <__eqdf2+0x3a>
 8004f94:	45c4      	cmp	ip, r8
 8004f96:	d1e6      	bne.n	8004f66 <__eqdf2+0x3a>
 8004f98:	45cb      	cmp	fp, r9
 8004f9a:	d006      	beq.n	8004faa <__eqdf2+0x7e>
 8004f9c:	2d00      	cmp	r5, #0
 8004f9e:	d1e2      	bne.n	8004f66 <__eqdf2+0x3a>
 8004fa0:	4330      	orrs	r0, r6
 8004fa2:	1c03      	adds	r3, r0, #0
 8004fa4:	1e58      	subs	r0, r3, #1
 8004fa6:	4183      	sbcs	r3, r0
 8004fa8:	e7dd      	b.n	8004f66 <__eqdf2+0x3a>
 8004faa:	2300      	movs	r3, #0
 8004fac:	e7db      	b.n	8004f66 <__eqdf2+0x3a>
 8004fae:	46c0      	nop			; (mov r8, r8)
 8004fb0:	000007ff 	.word	0x000007ff

08004fb4 <__gedf2>:
 8004fb4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004fb6:	4657      	mov	r7, sl
 8004fb8:	4645      	mov	r5, r8
 8004fba:	464e      	mov	r6, r9
 8004fbc:	b4e0      	push	{r5, r6, r7}
 8004fbe:	030f      	lsls	r7, r1, #12
 8004fc0:	004e      	lsls	r6, r1, #1
 8004fc2:	0fc9      	lsrs	r1, r1, #31
 8004fc4:	468a      	mov	sl, r1
 8004fc6:	4932      	ldr	r1, [pc, #200]	; (8005090 <__gedf2+0xdc>)
 8004fc8:	031d      	lsls	r5, r3, #12
 8004fca:	005c      	lsls	r4, r3, #1
 8004fcc:	4684      	mov	ip, r0
 8004fce:	0b3f      	lsrs	r7, r7, #12
 8004fd0:	0d76      	lsrs	r6, r6, #21
 8004fd2:	4690      	mov	r8, r2
 8004fd4:	0b2d      	lsrs	r5, r5, #12
 8004fd6:	0d64      	lsrs	r4, r4, #21
 8004fd8:	0fdb      	lsrs	r3, r3, #31
 8004fda:	428e      	cmp	r6, r1
 8004fdc:	d00f      	beq.n	8004ffe <__gedf2+0x4a>
 8004fde:	428c      	cmp	r4, r1
 8004fe0:	d039      	beq.n	8005056 <__gedf2+0xa2>
 8004fe2:	2e00      	cmp	r6, #0
 8004fe4:	d110      	bne.n	8005008 <__gedf2+0x54>
 8004fe6:	4338      	orrs	r0, r7
 8004fe8:	4241      	negs	r1, r0
 8004fea:	4141      	adcs	r1, r0
 8004fec:	4689      	mov	r9, r1
 8004fee:	2c00      	cmp	r4, #0
 8004ff0:	d127      	bne.n	8005042 <__gedf2+0x8e>
 8004ff2:	432a      	orrs	r2, r5
 8004ff4:	d125      	bne.n	8005042 <__gedf2+0x8e>
 8004ff6:	2000      	movs	r0, #0
 8004ff8:	2900      	cmp	r1, #0
 8004ffa:	d10e      	bne.n	800501a <__gedf2+0x66>
 8004ffc:	e008      	b.n	8005010 <__gedf2+0x5c>
 8004ffe:	1c39      	adds	r1, r7, #0
 8005000:	4301      	orrs	r1, r0
 8005002:	d12e      	bne.n	8005062 <__gedf2+0xae>
 8005004:	42b4      	cmp	r4, r6
 8005006:	d026      	beq.n	8005056 <__gedf2+0xa2>
 8005008:	2c00      	cmp	r4, #0
 800500a:	d00b      	beq.n	8005024 <__gedf2+0x70>
 800500c:	459a      	cmp	sl, r3
 800500e:	d00d      	beq.n	800502c <__gedf2+0x78>
 8005010:	4653      	mov	r3, sl
 8005012:	4259      	negs	r1, r3
 8005014:	2301      	movs	r3, #1
 8005016:	4319      	orrs	r1, r3
 8005018:	1c08      	adds	r0, r1, #0
 800501a:	bc1c      	pop	{r2, r3, r4}
 800501c:	4690      	mov	r8, r2
 800501e:	4699      	mov	r9, r3
 8005020:	46a2      	mov	sl, r4
 8005022:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005024:	432a      	orrs	r2, r5
 8005026:	d0f3      	beq.n	8005010 <__gedf2+0x5c>
 8005028:	459a      	cmp	sl, r3
 800502a:	d1f1      	bne.n	8005010 <__gedf2+0x5c>
 800502c:	42a6      	cmp	r6, r4
 800502e:	dcef      	bgt.n	8005010 <__gedf2+0x5c>
 8005030:	da1a      	bge.n	8005068 <__gedf2+0xb4>
 8005032:	4650      	mov	r0, sl
 8005034:	4241      	negs	r1, r0
 8005036:	4148      	adcs	r0, r1
 8005038:	2301      	movs	r3, #1
 800503a:	4241      	negs	r1, r0
 800503c:	4319      	orrs	r1, r3
 800503e:	1c08      	adds	r0, r1, #0
 8005040:	e7eb      	b.n	800501a <__gedf2+0x66>
 8005042:	464a      	mov	r2, r9
 8005044:	2a00      	cmp	r2, #0
 8005046:	d0e1      	beq.n	800500c <__gedf2+0x58>
 8005048:	4258      	negs	r0, r3
 800504a:	4158      	adcs	r0, r3
 800504c:	2201      	movs	r2, #1
 800504e:	4241      	negs	r1, r0
 8005050:	4311      	orrs	r1, r2
 8005052:	1c08      	adds	r0, r1, #0
 8005054:	e7e1      	b.n	800501a <__gedf2+0x66>
 8005056:	1c29      	adds	r1, r5, #0
 8005058:	4311      	orrs	r1, r2
 800505a:	d102      	bne.n	8005062 <__gedf2+0xae>
 800505c:	2e00      	cmp	r6, #0
 800505e:	d0c2      	beq.n	8004fe6 <__gedf2+0x32>
 8005060:	e7d4      	b.n	800500c <__gedf2+0x58>
 8005062:	2002      	movs	r0, #2
 8005064:	4240      	negs	r0, r0
 8005066:	e7d8      	b.n	800501a <__gedf2+0x66>
 8005068:	42af      	cmp	r7, r5
 800506a:	d8d1      	bhi.n	8005010 <__gedf2+0x5c>
 800506c:	d009      	beq.n	8005082 <__gedf2+0xce>
 800506e:	2000      	movs	r0, #0
 8005070:	42af      	cmp	r7, r5
 8005072:	d2d2      	bcs.n	800501a <__gedf2+0x66>
 8005074:	4650      	mov	r0, sl
 8005076:	4241      	negs	r1, r0
 8005078:	4148      	adcs	r0, r1
 800507a:	2301      	movs	r3, #1
 800507c:	4240      	negs	r0, r0
 800507e:	4318      	orrs	r0, r3
 8005080:	e7cb      	b.n	800501a <__gedf2+0x66>
 8005082:	45c4      	cmp	ip, r8
 8005084:	d8c4      	bhi.n	8005010 <__gedf2+0x5c>
 8005086:	2000      	movs	r0, #0
 8005088:	45c4      	cmp	ip, r8
 800508a:	d3f3      	bcc.n	8005074 <__gedf2+0xc0>
 800508c:	e7c5      	b.n	800501a <__gedf2+0x66>
 800508e:	46c0      	nop			; (mov r8, r8)
 8005090:	000007ff 	.word	0x000007ff

08005094 <__ledf2>:
 8005094:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005096:	465f      	mov	r7, fp
 8005098:	464d      	mov	r5, r9
 800509a:	4644      	mov	r4, r8
 800509c:	4656      	mov	r6, sl
 800509e:	4680      	mov	r8, r0
 80050a0:	b4f0      	push	{r4, r5, r6, r7}
 80050a2:	1c06      	adds	r6, r0, #0
 80050a4:	0308      	lsls	r0, r1, #12
 80050a6:	0b00      	lsrs	r0, r0, #12
 80050a8:	4684      	mov	ip, r0
 80050aa:	482c      	ldr	r0, [pc, #176]	; (800515c <__ledf2+0xc8>)
 80050ac:	004c      	lsls	r4, r1, #1
 80050ae:	031f      	lsls	r7, r3, #12
 80050b0:	005d      	lsls	r5, r3, #1
 80050b2:	0fc9      	lsrs	r1, r1, #31
 80050b4:	0d64      	lsrs	r4, r4, #21
 80050b6:	468b      	mov	fp, r1
 80050b8:	4691      	mov	r9, r2
 80050ba:	0b3f      	lsrs	r7, r7, #12
 80050bc:	0d6d      	lsrs	r5, r5, #21
 80050be:	0fdb      	lsrs	r3, r3, #31
 80050c0:	4284      	cmp	r4, r0
 80050c2:	d012      	beq.n	80050ea <__ledf2+0x56>
 80050c4:	4285      	cmp	r5, r0
 80050c6:	d025      	beq.n	8005114 <__ledf2+0x80>
 80050c8:	2c00      	cmp	r4, #0
 80050ca:	d114      	bne.n	80050f6 <__ledf2+0x62>
 80050cc:	4661      	mov	r1, ip
 80050ce:	430e      	orrs	r6, r1
 80050d0:	4270      	negs	r0, r6
 80050d2:	4146      	adcs	r6, r0
 80050d4:	2d00      	cmp	r5, #0
 80050d6:	d035      	beq.n	8005144 <__ledf2+0xb0>
 80050d8:	2e00      	cmp	r6, #0
 80050da:	d021      	beq.n	8005120 <__ledf2+0x8c>
 80050dc:	4258      	negs	r0, r3
 80050de:	4158      	adcs	r0, r3
 80050e0:	2101      	movs	r1, #1
 80050e2:	4243      	negs	r3, r0
 80050e4:	430b      	orrs	r3, r1
 80050e6:	1c18      	adds	r0, r3, #0
 80050e8:	e00e      	b.n	8005108 <__ledf2+0x74>
 80050ea:	4661      	mov	r1, ip
 80050ec:	2002      	movs	r0, #2
 80050ee:	4331      	orrs	r1, r6
 80050f0:	d10a      	bne.n	8005108 <__ledf2+0x74>
 80050f2:	42a5      	cmp	r5, r4
 80050f4:	d00e      	beq.n	8005114 <__ledf2+0x80>
 80050f6:	2d00      	cmp	r5, #0
 80050f8:	d112      	bne.n	8005120 <__ledf2+0x8c>
 80050fa:	433a      	orrs	r2, r7
 80050fc:	d110      	bne.n	8005120 <__ledf2+0x8c>
 80050fe:	465b      	mov	r3, fp
 8005100:	4259      	negs	r1, r3
 8005102:	2301      	movs	r3, #1
 8005104:	4319      	orrs	r1, r3
 8005106:	1c08      	adds	r0, r1, #0
 8005108:	bc3c      	pop	{r2, r3, r4, r5}
 800510a:	4690      	mov	r8, r2
 800510c:	4699      	mov	r9, r3
 800510e:	46a2      	mov	sl, r4
 8005110:	46ab      	mov	fp, r5
 8005112:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005114:	1c39      	adds	r1, r7, #0
 8005116:	2002      	movs	r0, #2
 8005118:	4311      	orrs	r1, r2
 800511a:	d1f5      	bne.n	8005108 <__ledf2+0x74>
 800511c:	2c00      	cmp	r4, #0
 800511e:	d0d5      	beq.n	80050cc <__ledf2+0x38>
 8005120:	459b      	cmp	fp, r3
 8005122:	d1ec      	bne.n	80050fe <__ledf2+0x6a>
 8005124:	42ac      	cmp	r4, r5
 8005126:	dcea      	bgt.n	80050fe <__ledf2+0x6a>
 8005128:	db05      	blt.n	8005136 <__ledf2+0xa2>
 800512a:	45bc      	cmp	ip, r7
 800512c:	d8e7      	bhi.n	80050fe <__ledf2+0x6a>
 800512e:	d00f      	beq.n	8005150 <__ledf2+0xbc>
 8005130:	2000      	movs	r0, #0
 8005132:	45bc      	cmp	ip, r7
 8005134:	d2e8      	bcs.n	8005108 <__ledf2+0x74>
 8005136:	4658      	mov	r0, fp
 8005138:	4241      	negs	r1, r0
 800513a:	4148      	adcs	r0, r1
 800513c:	4241      	negs	r1, r0
 800513e:	2001      	movs	r0, #1
 8005140:	4308      	orrs	r0, r1
 8005142:	e7e1      	b.n	8005108 <__ledf2+0x74>
 8005144:	433a      	orrs	r2, r7
 8005146:	d1c7      	bne.n	80050d8 <__ledf2+0x44>
 8005148:	2000      	movs	r0, #0
 800514a:	2e00      	cmp	r6, #0
 800514c:	d1dc      	bne.n	8005108 <__ledf2+0x74>
 800514e:	e7d6      	b.n	80050fe <__ledf2+0x6a>
 8005150:	45c8      	cmp	r8, r9
 8005152:	d8d4      	bhi.n	80050fe <__ledf2+0x6a>
 8005154:	2000      	movs	r0, #0
 8005156:	45c8      	cmp	r8, r9
 8005158:	d3ed      	bcc.n	8005136 <__ledf2+0xa2>
 800515a:	e7d5      	b.n	8005108 <__ledf2+0x74>
 800515c:	000007ff 	.word	0x000007ff

08005160 <ADC_DeInit>:
  * @brief  Deinitializes ADC1 peripheral registers to their default reset values.
  * @param  ADCx: where x can be 1 to select the ADC peripheral.
  * @retval None
  */
void ADC_DeInit(ADC_TypeDef* ADCx)
{
 8005160:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  if(ADCx == ADC1)
 8005162:	4b07      	ldr	r3, [pc, #28]	; (8005180 <ADC_DeInit+0x20>)
 8005164:	4298      	cmp	r0, r3
 8005166:	d000      	beq.n	800516a <ADC_DeInit+0xa>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);

    /* Release ADC1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
  }
}
 8005168:	bd08      	pop	{r3, pc}
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  if(ADCx == ADC1)
  {
    /* Enable ADC1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
 800516a:	2080      	movs	r0, #128	; 0x80
 800516c:	2101      	movs	r1, #1
 800516e:	0080      	lsls	r0, r0, #2
 8005170:	f001 faa6 	bl	80066c0 <RCC_APB2PeriphResetCmd>

    /* Release ADC1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
 8005174:	2080      	movs	r0, #128	; 0x80
 8005176:	2100      	movs	r1, #0
 8005178:	0080      	lsls	r0, r0, #2
 800517a:	f001 faa1 	bl	80066c0 <RCC_APB2PeriphResetCmd>
 800517e:	e7f3      	b.n	8005168 <ADC_DeInit+0x8>
 8005180:	40012400 	.word	0x40012400

08005184 <ADC_Init>:
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains 
  *         the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
 8005184:	680a      	ldr	r2, [r1, #0]
 8005186:	b510      	push	{r4, lr}
 8005188:	688c      	ldr	r4, [r1, #8]
  assert_param(IS_ADC_EXTERNAL_TRIG_CONV(ADC_InitStruct->ADC_ExternalTrigConv));
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign));
  assert_param(IS_ADC_SCAN_DIRECTION(ADC_InitStruct->ADC_ScanDirection)); 

  /* Get the ADCx CFGR value */
  tmpreg = ADCx->CFGR1;
 800518a:	68c3      	ldr	r3, [r0, #12]
 800518c:	4314      	orrs	r4, r2
 800518e:	68ca      	ldr	r2, [r1, #12]
             ADC_InitStruct->ADC_ExternalTrigConvEdge | ADC_InitStruct->ADC_ExternalTrigConv |
             ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ScanDirection);

  /* Write to ADCx CFGR */
  ADCx->CFGR1 = tmpreg;
}
 8005190:	4314      	orrs	r4, r2
 8005192:	690a      	ldr	r2, [r1, #16]
 8005194:	4314      	orrs	r4, r2
 8005196:	694a      	ldr	r2, [r1, #20]
 8005198:	4314      	orrs	r4, r2

  /* Get the ADCx CFGR value */
  tmpreg = ADCx->CFGR1;

  /* Clear SCANDIR, RES[1:0], ALIGN, EXTSEL[2:0], EXTEN[1:0] and CONT bits */
  tmpreg &= CFGR1_CLEAR_MASK;
 800519a:	4a04      	ldr	r2, [pc, #16]	; (80051ac <ADC_Init+0x28>)
 800519c:	4013      	ands	r3, r2
  /* Set EXTEN[1:0] bits according to ADC_ExternalTrigConvEdge value */
  /* Set EXTSEL[2:0] bits according to ADC_ExternalTrigConv value */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set SCANDIR bit according to ADC_ScanDirection value */
 
  tmpreg  |= (uint32_t)(ADC_InitStruct->ADC_Resolution | ((uint32_t)(ADC_InitStruct->ADC_ContinuousConvMode) << 13) |
 800519e:	790a      	ldrb	r2, [r1, #4]
 80051a0:	4323      	orrs	r3, r4
 80051a2:	0352      	lsls	r2, r2, #13
 80051a4:	4313      	orrs	r3, r2
             ADC_InitStruct->ADC_ExternalTrigConvEdge | ADC_InitStruct->ADC_ExternalTrigConv |
             ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ScanDirection);

  /* Write to ADCx CFGR */
  ADCx->CFGR1 = tmpreg;
 80051a6:	60c3      	str	r3, [r0, #12]
}
 80051a8:	bd10      	pop	{r4, pc}
 80051aa:	46c0      	nop			; (mov r8, r8)
 80051ac:	ffffd203 	.word	0xffffd203

080051b0 <ADC_StructInit>:
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Reset ADC init structure parameters values */
  /* Initialize the ADC_Resolution member */
  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
 80051b0:	2300      	movs	r3, #0
 80051b2:	6003      	str	r3, [r0, #0]

   /* Initialize the ADC_ContinuousConvMode member */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 80051b4:	7103      	strb	r3, [r0, #4]

  /* Initialize the ADC_ExternalTrigConvEdge member */
  ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 80051b6:	6083      	str	r3, [r0, #8]

  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_TRGO;
 80051b8:	60c3      	str	r3, [r0, #12]

  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
 80051ba:	6103      	str	r3, [r0, #16]

  /* Initialize the ADC_ScanDirection member */
  ADC_InitStruct->ADC_ScanDirection = ADC_ScanDirection_Upward;
 80051bc:	6143      	str	r3, [r0, #20]
}
 80051be:	4770      	bx	lr

080051c0 <ADC_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the ADEN bit to Enable the ADC peripheral */
    ADCx->CR |= (uint32_t)ADC_CR_ADEN;
 80051c0:	6882      	ldr	r2, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80051c2:	2900      	cmp	r1, #0
 80051c4:	d103      	bne.n	80051ce <ADC_Cmd+0xe>
    ADCx->CR |= (uint32_t)ADC_CR_ADEN;
  }
  else
  {
    /* Set the ADDIS to Disable the ADC peripheral */
    ADCx->CR |= (uint32_t)ADC_CR_ADDIS;
 80051c6:	2302      	movs	r3, #2
 80051c8:	4313      	orrs	r3, r2
 80051ca:	6083      	str	r3, [r0, #8]
  }
}
 80051cc:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the ADEN bit to Enable the ADC peripheral */
    ADCx->CR |= (uint32_t)ADC_CR_ADEN;
 80051ce:	2301      	movs	r3, #1
 80051d0:	4313      	orrs	r3, r2
 80051d2:	6083      	str	r3, [r0, #8]
 80051d4:	e7fa      	b.n	80051cc <ADC_Cmd+0xc>
 80051d6:	46c0      	nop			; (mov r8, r8)

080051d8 <ADC_ClockModeConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLOCKMODE(ADC_ClockMode));

    /* Configure the ADC Clock mode according to ADC_ClockMode */
    ADCx->CFGR2 = (uint32_t)ADC_ClockMode;
 80051d8:	6101      	str	r1, [r0, #16]

}
 80051da:	4770      	bx	lr

080051dc <ADC_JitterCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Disable Jitter */
    ADCx->CFGR2 |= (uint32_t)ADC_JitterOff;
 80051dc:	6903      	ldr	r3, [r0, #16]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_JITTEROFF(ADC_JitterOff));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80051de:	2a00      	cmp	r2, #0
 80051e0:	d102      	bne.n	80051e8 <ADC_JitterCmd+0xc>
    ADCx->CFGR2 |= (uint32_t)ADC_JitterOff;
  }
  else
  {
    /* Enable Jitter */
    ADCx->CFGR2 &= (uint32_t)(~ADC_JitterOff);
 80051e2:	438b      	bics	r3, r1
 80051e4:	6103      	str	r3, [r0, #16]
  }
}
 80051e6:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Disable Jitter */
    ADCx->CFGR2 |= (uint32_t)ADC_JitterOff;
 80051e8:	4319      	orrs	r1, r3
 80051ea:	6101      	str	r1, [r0, #16]
 80051ec:	e7fb      	b.n	80051e6 <ADC_JitterCmd+0xa>
 80051ee:	46c0      	nop			; (mov r8, r8)

080051f0 <ADC_AutoPowerOffCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80051f0:	2900      	cmp	r1, #0
 80051f2:	d104      	bne.n	80051fe <ADC_AutoPowerOffCmd+0xe>
    ADCx->CFGR1 |= ADC_CFGR1_AUTOFF;
  }
  else
  {
    /* Disable the ADC Automatic Power-Off */
    ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_AUTOFF;
 80051f4:	68c2      	ldr	r2, [r0, #12]
 80051f6:	4b05      	ldr	r3, [pc, #20]	; (800520c <ADC_AutoPowerOffCmd+0x1c>)
 80051f8:	4013      	ands	r3, r2
 80051fa:	60c3      	str	r3, [r0, #12]
  }
}
 80051fc:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the ADC Automatic Power-Off */
    ADCx->CFGR1 |= ADC_CFGR1_AUTOFF;
 80051fe:	2280      	movs	r2, #128	; 0x80
 8005200:	68c3      	ldr	r3, [r0, #12]
 8005202:	0212      	lsls	r2, r2, #8
 8005204:	4313      	orrs	r3, r2
 8005206:	60c3      	str	r3, [r0, #12]
 8005208:	e7f8      	b.n	80051fc <ADC_AutoPowerOffCmd+0xc>
 800520a:	46c0      	nop			; (mov r8, r8)
 800520c:	ffff7fff 	.word	0xffff7fff

08005210 <ADC_WaitModeCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005210:	2900      	cmp	r1, #0
 8005212:	d104      	bne.n	800521e <ADC_WaitModeCmd+0xe>
    ADCx->CFGR1 |= ADC_CFGR1_WAIT;
  }
  else
  {
    /* Disable the ADC Automatic Delayed conversion */
    ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_WAIT;
 8005214:	68c2      	ldr	r2, [r0, #12]
 8005216:	4b05      	ldr	r3, [pc, #20]	; (800522c <ADC_WaitModeCmd+0x1c>)
 8005218:	4013      	ands	r3, r2
 800521a:	60c3      	str	r3, [r0, #12]
  }
}
 800521c:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the ADC Automatic Delayed conversion */
    ADCx->CFGR1 |= ADC_CFGR1_WAIT;
 800521e:	2280      	movs	r2, #128	; 0x80
 8005220:	68c3      	ldr	r3, [r0, #12]
 8005222:	01d2      	lsls	r2, r2, #7
 8005224:	4313      	orrs	r3, r2
 8005226:	60c3      	str	r3, [r0, #12]
 8005228:	e7f8      	b.n	800521c <ADC_WaitModeCmd+0xc>
 800522a:	46c0      	nop			; (mov r8, r8)
 800522c:	ffffbfff 	.word	0xffffbfff

08005230 <ADC_AnalogWatchdogCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005230:	2900      	cmp	r1, #0
 8005232:	d104      	bne.n	800523e <ADC_AnalogWatchdogCmd+0xe>
    ADCx->CFGR1 |= ADC_CFGR1_AWDEN;
  }
  else
  {
    /* Disable the ADC Analog Watchdog */
    ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_AWDEN;
 8005234:	68c2      	ldr	r2, [r0, #12]
 8005236:	4b05      	ldr	r3, [pc, #20]	; (800524c <ADC_AnalogWatchdogCmd+0x1c>)
 8005238:	4013      	ands	r3, r2
 800523a:	60c3      	str	r3, [r0, #12]
  }
}
 800523c:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the ADC Analog Watchdog */
    ADCx->CFGR1 |= ADC_CFGR1_AWDEN;
 800523e:	2280      	movs	r2, #128	; 0x80
 8005240:	68c3      	ldr	r3, [r0, #12]
 8005242:	0412      	lsls	r2, r2, #16
 8005244:	4313      	orrs	r3, r2
 8005246:	60c3      	str	r3, [r0, #12]
 8005248:	e7f8      	b.n	800523c <ADC_AnalogWatchdogCmd+0xc>
 800524a:	46c0      	nop			; (mov r8, r8)
 800524c:	ff7fffff 	.word	0xff7fffff

08005250 <ADC_AnalogWatchdogThresholdsConfig>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_THRESHOLD(HighThreshold));
  assert_param(IS_ADC_THRESHOLD(LowThreshold));

  /* Set the ADCx high and low threshold */
  ADCx->TR = LowThreshold | ((uint32_t)HighThreshold << 16);
 8005250:	0409      	lsls	r1, r1, #16
 8005252:	430a      	orrs	r2, r1
 8005254:	6202      	str	r2, [r0, #32]

}
 8005256:	4770      	bx	lr

08005258 <ADC_AnalogWatchdogSingleChannelConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_ANALOG_WATCHDOG_CHANNEL(ADC_AnalogWatchdog_Channel));

  /* Get the old register value */
  tmpreg = ADCx->CFGR1;
 8005258:	68c2      	ldr	r2, [r0, #12]

  /* Clear the Analog watchdog channel select bits */
  tmpreg &= ~ADC_CFGR1_AWDCH;
 800525a:	4b02      	ldr	r3, [pc, #8]	; (8005264 <ADC_AnalogWatchdogSingleChannelConfig+0xc>)
 800525c:	4013      	ands	r3, r2

  /* Set the Analog watchdog channel */
  tmpreg |= ADC_AnalogWatchdog_Channel;
 800525e:	4319      	orrs	r1, r3

  /* Store the new register value */
  ADCx->CFGR1 = tmpreg;
 8005260:	60c1      	str	r1, [r0, #12]
}
 8005262:	4770      	bx	lr
 8005264:	83ffffff 	.word	0x83ffffff

08005268 <ADC_AnalogWatchdogSingleChannelCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005268:	2900      	cmp	r1, #0
 800526a:	d104      	bne.n	8005276 <ADC_AnalogWatchdogSingleChannelCmd+0xe>
    ADCx->CFGR1 |= ADC_CFGR1_AWDSGL;
  }
  else
  {
    /* Disable the ADC Analog Watchdog Single Channel */
    ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_AWDSGL;
 800526c:	68c2      	ldr	r2, [r0, #12]
 800526e:	4b05      	ldr	r3, [pc, #20]	; (8005284 <ADC_AnalogWatchdogSingleChannelCmd+0x1c>)
 8005270:	4013      	ands	r3, r2
 8005272:	60c3      	str	r3, [r0, #12]
  }
}
 8005274:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the ADC Analog Watchdog Single Channel */
    ADCx->CFGR1 |= ADC_CFGR1_AWDSGL;
 8005276:	2280      	movs	r2, #128	; 0x80
 8005278:	68c3      	ldr	r3, [r0, #12]
 800527a:	03d2      	lsls	r2, r2, #15
 800527c:	4313      	orrs	r3, r2
 800527e:	60c3      	str	r3, [r0, #12]
 8005280:	e7f8      	b.n	8005274 <ADC_AnalogWatchdogSingleChannelCmd+0xc>
 8005282:	46c0      	nop			; (mov r8, r8)
 8005284:	ffbfffff 	.word	0xffbfffff

08005288 <ADC_TempSensorCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the temperature sensor channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_TSEN;
 8005288:	4a06      	ldr	r2, [pc, #24]	; (80052a4 <ADC_TempSensorCmd+0x1c>)
void ADC_TempSensorCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800528a:	2800      	cmp	r0, #0
 800528c:	d104      	bne.n	8005298 <ADC_TempSensorCmd+0x10>
    ADC->CCR |= (uint32_t)ADC_CCR_TSEN;
  }
  else
  {
    /* Disable the temperature sensor channel*/
    ADC->CCR &= (uint32_t)(~ADC_CCR_TSEN);
 800528e:	6811      	ldr	r1, [r2, #0]
 8005290:	4b05      	ldr	r3, [pc, #20]	; (80052a8 <ADC_TempSensorCmd+0x20>)
 8005292:	400b      	ands	r3, r1
 8005294:	6013      	str	r3, [r2, #0]
  }
}
 8005296:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the temperature sensor channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_TSEN;
 8005298:	2180      	movs	r1, #128	; 0x80
 800529a:	6813      	ldr	r3, [r2, #0]
 800529c:	0409      	lsls	r1, r1, #16
 800529e:	430b      	orrs	r3, r1
 80052a0:	6013      	str	r3, [r2, #0]
 80052a2:	e7f8      	b.n	8005296 <ADC_TempSensorCmd+0xe>
 80052a4:	40012708 	.word	0x40012708
 80052a8:	ff7fffff 	.word	0xff7fffff

080052ac <ADC_VrefintCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the Vrefint channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_VREFEN;
 80052ac:	4a06      	ldr	r2, [pc, #24]	; (80052c8 <ADC_VrefintCmd+0x1c>)
void ADC_VrefintCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80052ae:	2800      	cmp	r0, #0
 80052b0:	d104      	bne.n	80052bc <ADC_VrefintCmd+0x10>
    ADC->CCR |= (uint32_t)ADC_CCR_VREFEN;
  }
  else
  {
    /* Disable the Vrefint channel*/
    ADC->CCR &= (uint32_t)(~ADC_CCR_VREFEN);
 80052b2:	6811      	ldr	r1, [r2, #0]
 80052b4:	4b05      	ldr	r3, [pc, #20]	; (80052cc <ADC_VrefintCmd+0x20>)
 80052b6:	400b      	ands	r3, r1
 80052b8:	6013      	str	r3, [r2, #0]
  }
}
 80052ba:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the Vrefint channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_VREFEN;
 80052bc:	2180      	movs	r1, #128	; 0x80
 80052be:	6813      	ldr	r3, [r2, #0]
 80052c0:	03c9      	lsls	r1, r1, #15
 80052c2:	430b      	orrs	r3, r1
 80052c4:	6013      	str	r3, [r2, #0]
 80052c6:	e7f8      	b.n	80052ba <ADC_VrefintCmd+0xe>
 80052c8:	40012708 	.word	0x40012708
 80052cc:	ffbfffff 	.word	0xffbfffff

080052d0 <ADC_VbatCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the Vbat channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_VBATEN;
 80052d0:	4a06      	ldr	r2, [pc, #24]	; (80052ec <ADC_VbatCmd+0x1c>)
void ADC_VbatCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80052d2:	2800      	cmp	r0, #0
 80052d4:	d104      	bne.n	80052e0 <ADC_VbatCmd+0x10>
    ADC->CCR |= (uint32_t)ADC_CCR_VBATEN;
  }
  else
  {
    /* Disable the Vbat channel*/
    ADC->CCR &= (uint32_t)(~ADC_CCR_VBATEN);
 80052d6:	6811      	ldr	r1, [r2, #0]
 80052d8:	4b05      	ldr	r3, [pc, #20]	; (80052f0 <ADC_VbatCmd+0x20>)
 80052da:	400b      	ands	r3, r1
 80052dc:	6013      	str	r3, [r2, #0]
  }
}
 80052de:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the Vbat channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_VBATEN;
 80052e0:	2180      	movs	r1, #128	; 0x80
 80052e2:	6813      	ldr	r3, [r2, #0]
 80052e4:	0449      	lsls	r1, r1, #17
 80052e6:	430b      	orrs	r3, r1
 80052e8:	6013      	str	r3, [r2, #0]
 80052ea:	e7f8      	b.n	80052de <ADC_VbatCmd+0xe>
 80052ec:	40012708 	.word	0x40012708
 80052f0:	feffffff 	.word	0xfeffffff

080052f4 <ADC_ChannelConfig>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* Configure the ADC Channel */
  ADCx->CHSELR |= (uint32_t)ADC_Channel;
 80052f4:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80052f6:	4319      	orrs	r1, r3
 80052f8:	6281      	str	r1, [r0, #40]	; 0x28

  /* Set the ADC Sampling Time register */
  tmpreg |= (uint32_t)ADC_SampleTime;

  /* Configure the ADC Sample time register */
  ADCx->SMPR = tmpreg ;
 80052fa:	6142      	str	r2, [r0, #20]
}
 80052fc:	4770      	bx	lr
 80052fe:	46c0      	nop			; (mov r8, r8)

08005300 <ADC_ContinuousModeCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

    if (NewState != DISABLE)
 8005300:	2900      	cmp	r1, #0
 8005302:	d104      	bne.n	800530e <ADC_ContinuousModeCmd+0xe>
    ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_CONT;
  }
  else
  {
    /* Disable the Continuous mode */
    ADCx->CFGR1 &= (uint32_t)(~ADC_CFGR1_CONT);
 8005304:	68c2      	ldr	r2, [r0, #12]
 8005306:	4b05      	ldr	r3, [pc, #20]	; (800531c <ADC_ContinuousModeCmd+0x1c>)
 8005308:	4013      	ands	r3, r2
 800530a:	60c3      	str	r3, [r0, #12]
  }
}
 800530c:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

    if (NewState != DISABLE)
  {
    /* Enable the Continuous mode*/
    ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_CONT;
 800530e:	2280      	movs	r2, #128	; 0x80
 8005310:	68c3      	ldr	r3, [r0, #12]
 8005312:	0192      	lsls	r2, r2, #6
 8005314:	4313      	orrs	r3, r2
 8005316:	60c3      	str	r3, [r0, #12]
 8005318:	e7f8      	b.n	800530c <ADC_ContinuousModeCmd+0xc>
 800531a:	46c0      	nop			; (mov r8, r8)
 800531c:	ffffdfff 	.word	0xffffdfff

08005320 <ADC_DiscModeCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

    if (NewState != DISABLE)
 8005320:	2900      	cmp	r1, #0
 8005322:	d104      	bne.n	800532e <ADC_DiscModeCmd+0xe>
    ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_DISCEN;
  }
  else
  {
    /* Disable the Discontinuous mode */
    ADCx->CFGR1 &= (uint32_t)(~ADC_CFGR1_DISCEN);
 8005324:	68c2      	ldr	r2, [r0, #12]
 8005326:	4b05      	ldr	r3, [pc, #20]	; (800533c <ADC_DiscModeCmd+0x1c>)
 8005328:	4013      	ands	r3, r2
 800532a:	60c3      	str	r3, [r0, #12]
  }
}
 800532c:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

    if (NewState != DISABLE)
  {
    /* Enable the Discontinuous mode */
    ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_DISCEN;
 800532e:	2280      	movs	r2, #128	; 0x80
 8005330:	68c3      	ldr	r3, [r0, #12]
 8005332:	0252      	lsls	r2, r2, #9
 8005334:	4313      	orrs	r3, r2
 8005336:	60c3      	str	r3, [r0, #12]
 8005338:	e7f8      	b.n	800532c <ADC_DiscModeCmd+0xc>
 800533a:	46c0      	nop			; (mov r8, r8)
 800533c:	fffeffff 	.word	0xfffeffff

08005340 <ADC_OverrunModeCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

    if (NewState != DISABLE)
 8005340:	2900      	cmp	r1, #0
 8005342:	d104      	bne.n	800534e <ADC_OverrunModeCmd+0xe>
    ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_OVRMOD;
  }
  else
  {
    /* Disable the Overrun mode */
    ADCx->CFGR1 &= (uint32_t)(~ADC_CFGR1_OVRMOD);
 8005344:	68c2      	ldr	r2, [r0, #12]
 8005346:	4b05      	ldr	r3, [pc, #20]	; (800535c <ADC_OverrunModeCmd+0x1c>)
 8005348:	4013      	ands	r3, r2
 800534a:	60c3      	str	r3, [r0, #12]
  }
}
 800534c:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

    if (NewState != DISABLE)
  {
    /* Enable the Overrun mode */
    ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_OVRMOD;
 800534e:	2280      	movs	r2, #128	; 0x80
 8005350:	68c3      	ldr	r3, [r0, #12]
 8005352:	0152      	lsls	r2, r2, #5
 8005354:	4313      	orrs	r3, r2
 8005356:	60c3      	str	r3, [r0, #12]
 8005358:	e7f8      	b.n	800534c <ADC_OverrunModeCmd+0xc>
 800535a:	46c0      	nop			; (mov r8, r8)
 800535c:	ffffefff 	.word	0xffffefff

08005360 <ADC_GetCalibrationFactor>:

  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Set the ADC calibartion */
  ADCx->CR |= (uint32_t)ADC_CR_ADCAL;
 8005360:	2280      	movs	r2, #128	; 0x80
 8005362:	6883      	ldr	r3, [r0, #8]
 8005364:	0612      	lsls	r2, r2, #24
 8005366:	4313      	orrs	r3, r2
 8005368:	6083      	str	r3, [r0, #8]
  
  /* Wait until no ADC calibration is completed */
  do
  {
    calibrationstatus = ADCx->CR & ADC_CR_ADCAL;
 800536a:	6883      	ldr	r3, [r0, #8]
 800536c:	4a09      	ldr	r2, [pc, #36]	; (8005394 <ADC_GetCalibrationFactor+0x34>)
 800536e:	0fdb      	lsrs	r3, r3, #31
 8005370:	07db      	lsls	r3, r3, #31
 8005372:	e005      	b.n	8005380 <ADC_GetCalibrationFactor+0x20>
 8005374:	6883      	ldr	r3, [r0, #8]
 8005376:	3a01      	subs	r2, #1
 8005378:	0fdb      	lsrs	r3, r3, #31
 800537a:	07db      	lsls	r3, r3, #31
    calibrationcounter++;  
  } while((calibrationcounter != CALIBRATION_TIMEOUT) && (calibrationstatus != 0x00));
 800537c:	2a00      	cmp	r2, #0
 800537e:	d001      	beq.n	8005384 <ADC_GetCalibrationFactor+0x24>
 8005380:	2b00      	cmp	r3, #0
 8005382:	d1f7      	bne.n	8005374 <ADC_GetCalibrationFactor+0x14>
    
  if((uint32_t)(ADCx->CR & ADC_CR_ADCAL) == RESET)
 8005384:	6883      	ldr	r3, [r0, #8]
 8005386:	2b00      	cmp	r3, #0
 8005388:	db01      	blt.n	800538e <ADC_GetCalibrationFactor+0x2e>
  {
    /*Get the calibration factor from the ADC data register */
    tmpreg = ADCx->DR;
 800538a:	6c00      	ldr	r0, [r0, #64]	; 0x40
  {
    /* Error factor */
    tmpreg = 0x00000000;
  }
  return tmpreg;
}
 800538c:	4770      	bx	lr
    tmpreg = ADCx->DR;
  }
  else
  {
    /* Error factor */
    tmpreg = 0x00000000;
 800538e:	2000      	movs	r0, #0
 8005390:	e7fc      	b.n	800538c <ADC_GetCalibrationFactor+0x2c>
 8005392:	46c0      	nop			; (mov r8, r8)
 8005394:	0000efff 	.word	0x0000efff

08005398 <ADC_StopOfConversion>:
void ADC_StopOfConversion(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  ADCx->CR |= (uint32_t)ADC_CR_ADSTP;
 8005398:	2310      	movs	r3, #16
 800539a:	6882      	ldr	r2, [r0, #8]
 800539c:	4313      	orrs	r3, r2
 800539e:	6083      	str	r3, [r0, #8]
}
 80053a0:	4770      	bx	lr
 80053a2:	46c0      	nop			; (mov r8, r8)

080053a4 <ADC_StartOfConversion>:
void ADC_StartOfConversion(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  ADCx->CR |= (uint32_t)ADC_CR_ADSTART;
 80053a4:	2304      	movs	r3, #4
 80053a6:	6882      	ldr	r2, [r0, #8]
 80053a8:	4313      	orrs	r3, r2
 80053aa:	6083      	str	r3, [r0, #8]
}
 80053ac:	4770      	bx	lr
 80053ae:	46c0      	nop			; (mov r8, r8)

080053b0 <ADC_GetConversionValue>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Return the selected ADC conversion value */
  return (uint16_t) ADCx->DR;
 80053b0:	6c00      	ldr	r0, [r0, #64]	; 0x40
 80053b2:	b280      	uxth	r0, r0
}
 80053b4:	4770      	bx	lr
 80053b6:	46c0      	nop			; (mov r8, r8)

080053b8 <ADC_DMACmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80053b8:	2900      	cmp	r1, #0
 80053ba:	d104      	bne.n	80053c6 <ADC_DMACmd+0xe>
    ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_DMAEN;
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CFGR1 &= (uint32_t)(~ADC_CFGR1_DMAEN);
 80053bc:	2201      	movs	r2, #1
 80053be:	68c3      	ldr	r3, [r0, #12]
 80053c0:	4393      	bics	r3, r2
 80053c2:	60c3      	str	r3, [r0, #12]
  }
}
 80053c4:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected ADC DMA request */
    ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_DMAEN;
 80053c6:	2301      	movs	r3, #1
 80053c8:	68c2      	ldr	r2, [r0, #12]
 80053ca:	4313      	orrs	r3, r2
 80053cc:	60c3      	str	r3, [r0, #12]
 80053ce:	e7f9      	b.n	80053c4 <ADC_DMACmd+0xc>

080053d0 <ADC_DMARequestModeConfig>:
void ADC_DMARequestModeConfig(ADC_TypeDef* ADCx, uint32_t ADC_DMARequestMode)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_DMACFG;
 80053d0:	2202      	movs	r2, #2
 80053d2:	68c3      	ldr	r3, [r0, #12]
 80053d4:	4393      	bics	r3, r2
 80053d6:	60c3      	str	r3, [r0, #12]
  ADCx->CFGR1 |= (uint32_t)ADC_DMARequestMode;
 80053d8:	68c3      	ldr	r3, [r0, #12]
 80053da:	4319      	orrs	r1, r3
 80053dc:	60c1      	str	r1, [r0, #12]
}
 80053de:	4770      	bx	lr

080053e0 <ADC_ITConfig>:
  assert_param(IS_ADC_CONFIG_IT(ADC_IT)); 

  if (NewState != DISABLE)
  {
    /* Enable the selected ADC interrupts */
    ADCx->IER |= ADC_IT;
 80053e0:	6843      	ldr	r3, [r0, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_ADC_CONFIG_IT(ADC_IT)); 

  if (NewState != DISABLE)
 80053e2:	2a00      	cmp	r2, #0
 80053e4:	d102      	bne.n	80053ec <ADC_ITConfig+0xc>
    ADCx->IER |= ADC_IT;
  }
  else
  {
    /* Disable the selected ADC interrupts */
    ADCx->IER &= (~(uint32_t)ADC_IT);
 80053e6:	438b      	bics	r3, r1
 80053e8:	6043      	str	r3, [r0, #4]
  }
}
 80053ea:	4770      	bx	lr
  assert_param(IS_ADC_CONFIG_IT(ADC_IT)); 

  if (NewState != DISABLE)
  {
    /* Enable the selected ADC interrupts */
    ADCx->IER |= ADC_IT;
 80053ec:	4319      	orrs	r1, r3
 80053ee:	6041      	str	r1, [r0, #4]
 80053f0:	e7fb      	b.n	80053ea <ADC_ITConfig+0xa>
 80053f2:	46c0      	nop			; (mov r8, r8)

080053f4 <ADC_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));

  if((uint32_t)(ADC_FLAG & 0x01000000))
 80053f4:	01cb      	lsls	r3, r1, #7
 80053f6:	d507      	bpl.n	8005408 <ADC_GetFlagStatus+0x14>
  {
    tmpreg = ADCx->CR & 0xFEFFFFFF;
 80053f8:	6880      	ldr	r0, [r0, #8]
 80053fa:	4b04      	ldr	r3, [pc, #16]	; (800540c <ADC_GetFlagStatus+0x18>)
 80053fc:	4018      	ands	r0, r3
  {
    tmpreg = ADCx->ISR;
  }
  
  /* Check the status of the specified ADC flag */
  if ((tmpreg & ADC_FLAG) != (uint32_t)RESET)
 80053fe:	4008      	ands	r0, r1
 8005400:	1e41      	subs	r1, r0, #1
 8005402:	4188      	sbcs	r0, r1
  {
    /* ADC_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the ADC_FLAG status */
  return  bitstatus;
 8005404:	b2c0      	uxtb	r0, r0
}
 8005406:	4770      	bx	lr
  {
    tmpreg = ADCx->CR & 0xFEFFFFFF;
  }
  else
  {
    tmpreg = ADCx->ISR;
 8005408:	6800      	ldr	r0, [r0, #0]
 800540a:	e7f8      	b.n	80053fe <ADC_GetFlagStatus+0xa>
 800540c:	feffffff 	.word	0xfeffffff

08005410 <ADC_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));

  /* Clear the selected ADC flags */
  ADCx->ISR = (uint32_t)ADC_FLAG;
 8005410:	6001      	str	r1, [r0, #0]
}
 8005412:	4770      	bx	lr

08005414 <ADC_GetITStatus>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_IT(ADC_IT));

  /* Get the ADC_IT enable bit status */
  enablestatus = (uint32_t)(ADCx->IER & ADC_IT); 
 8005414:	6842      	ldr	r2, [r0, #4]

  /* Check the status of the specified ADC interrupt */
  if (((uint32_t)(ADCx->ISR & ADC_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8005416:	6803      	ldr	r3, [r0, #0]
    bitstatus = SET;
  }
  else
  {
    /* ADC_IT is reset */
    bitstatus = RESET;
 8005418:	2000      	movs	r0, #0

  /* Get the ADC_IT enable bit status */
  enablestatus = (uint32_t)(ADCx->IER & ADC_IT); 

  /* Check the status of the specified ADC interrupt */
  if (((uint32_t)(ADCx->ISR & ADC_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 800541a:	420b      	tst	r3, r1
 800541c:	d003      	beq.n	8005426 <ADC_GetITStatus+0x12>
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_IT(ADC_IT));

  /* Get the ADC_IT enable bit status */
  enablestatus = (uint32_t)(ADCx->IER & ADC_IT); 
 800541e:	4011      	ands	r1, r2

  /* Check the status of the specified ADC interrupt */
  if (((uint32_t)(ADCx->ISR & ADC_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8005420:	1e48      	subs	r0, r1, #1
 8005422:	4181      	sbcs	r1, r0
  {
    /* ADC_IT is set */
    bitstatus = SET;
 8005424:	b2c8      	uxtb	r0, r1
    /* ADC_IT is reset */
    bitstatus = RESET;
  }
  /* Return the ADC_IT status */
  return  bitstatus;
}
 8005426:	4770      	bx	lr

08005428 <ADC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_IT(ADC_IT));

  /* Clear the selected ADC interrupt pending bits */
  ADCx->ISR = (uint32_t)ADC_IT; 
 8005428:	6001      	str	r1, [r0, #0]
}
 800542a:	4770      	bx	lr

0800542c <DMA_DeInit>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));

  /* Disable the selected DMAy Channelx */
  DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR_EN);
 800542c:	6802      	ldr	r2, [r0, #0]
 800542e:	4b37      	ldr	r3, [pc, #220]	; (800550c <DMA_DeInit+0xe0>)
 8005430:	4013      	ands	r3, r2
 8005432:	6003      	str	r3, [r0, #0]

  /* Reset DMAy Channelx control register */
  DMAy_Channelx->CCR  = 0;
 8005434:	2300      	movs	r3, #0
 8005436:	6003      	str	r3, [r0, #0]

  /* Reset DMAy Channelx remaining bytes register */
  DMAy_Channelx->CNDTR = 0;
 8005438:	6043      	str	r3, [r0, #4]

  /* Reset DMAy Channelx peripheral address register */
  DMAy_Channelx->CPAR  = 0;
 800543a:	6083      	str	r3, [r0, #8]

  /* Reset DMAy Channelx memory address register */
  DMAy_Channelx->CMAR = 0;
 800543c:	60c3      	str	r3, [r0, #12]

  if (DMAy_Channelx == DMA1_Channel1)
 800543e:	4b34      	ldr	r3, [pc, #208]	; (8005510 <DMA_DeInit+0xe4>)
 8005440:	4298      	cmp	r0, r3
 8005442:	d028      	beq.n	8005496 <DMA_DeInit+0x6a>
  {
    /* Reset interrupt pending bits for DMA1 Channel1 */
    DMA1->IFCR |= DMA1_CHANNEL1_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel2)
 8005444:	4b33      	ldr	r3, [pc, #204]	; (8005514 <DMA_DeInit+0xe8>)
 8005446:	4298      	cmp	r0, r3
 8005448:	d02b      	beq.n	80054a2 <DMA_DeInit+0x76>
  {
    /* Reset interrupt pending bits for DMA1 Channel2 */
    DMA1->IFCR |= DMA1_CHANNEL2_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel3)
 800544a:	4b33      	ldr	r3, [pc, #204]	; (8005518 <DMA_DeInit+0xec>)
 800544c:	4298      	cmp	r0, r3
 800544e:	d02e      	beq.n	80054ae <DMA_DeInit+0x82>
  {
    /* Reset interrupt pending bits for DMA1 Channel3 */
    DMA1->IFCR |= DMA1_CHANNEL3_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel4)
 8005450:	4b32      	ldr	r3, [pc, #200]	; (800551c <DMA_DeInit+0xf0>)
 8005452:	4298      	cmp	r0, r3
 8005454:	d032      	beq.n	80054bc <DMA_DeInit+0x90>
  {
    /* Reset interrupt pending bits for DMA1 Channel4 */
    DMA1->IFCR |= DMA1_CHANNEL4_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel5)
 8005456:	4b32      	ldr	r3, [pc, #200]	; (8005520 <DMA_DeInit+0xf4>)
 8005458:	4298      	cmp	r0, r3
 800545a:	d03d      	beq.n	80054d8 <DMA_DeInit+0xac>
  {
    /* Reset interrupt pending bits for DMA1 Channel5 */
    DMA1->IFCR |= DMA1_CHANNEL5_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel6)
 800545c:	4b31      	ldr	r3, [pc, #196]	; (8005524 <DMA_DeInit+0xf8>)
 800545e:	4298      	cmp	r0, r3
 8005460:	d03c      	beq.n	80054dc <DMA_DeInit+0xb0>
  {
    /* Reset interrupt pending bits for DMA1 Channel6 */
    DMA1->IFCR |= DMA1_CHANNEL6_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel7)
 8005462:	4b31      	ldr	r3, [pc, #196]	; (8005528 <DMA_DeInit+0xfc>)
 8005464:	4298      	cmp	r0, r3
 8005466:	d00f      	beq.n	8005488 <DMA_DeInit+0x5c>
  {
    /* Reset interrupt pending bits for DMA1 Channel7 */
    DMA1->IFCR |= DMA1_CHANNEL7_IT_MASK;
  }
  else if (DMAy_Channelx == DMA2_Channel1)
 8005468:	4b30      	ldr	r3, [pc, #192]	; (800552c <DMA_DeInit+0x100>)
 800546a:	4298      	cmp	r0, r3
 800546c:	d03d      	beq.n	80054ea <DMA_DeInit+0xbe>
  {
    /* Reset interrupt pending bits for DMA2 Channel1 */
    DMA2->IFCR |= DMA2_CHANNEL1_IT_MASK;
  }
  else if (DMAy_Channelx == DMA2_Channel2)
 800546e:	4b30      	ldr	r3, [pc, #192]	; (8005530 <DMA_DeInit+0x104>)
 8005470:	4298      	cmp	r0, r3
 8005472:	d040      	beq.n	80054f6 <DMA_DeInit+0xca>
  {
    /* Reset interrupt pending bits for DMA2 Channel2 */
    DMA2->IFCR |= DMA2_CHANNEL2_IT_MASK;
  }
  else if (DMAy_Channelx == DMA2_Channel3)
 8005474:	4b2f      	ldr	r3, [pc, #188]	; (8005534 <DMA_DeInit+0x108>)
 8005476:	4298      	cmp	r0, r3
 8005478:	d043      	beq.n	8005502 <DMA_DeInit+0xd6>
  {
    /* Reset interrupt pending bits for DMA2 Channel3 */
    DMA2->IFCR |= DMA2_CHANNEL3_IT_MASK;
  }
  else if (DMAy_Channelx == DMA2_Channel4)
 800547a:	4b2f      	ldr	r3, [pc, #188]	; (8005538 <DMA_DeInit+0x10c>)
 800547c:	4298      	cmp	r0, r3
 800547e:	d042      	beq.n	8005506 <DMA_DeInit+0xda>
    /* Reset interrupt pending bits for DMA2 Channel4 */
    DMA2->IFCR |= DMA2_CHANNEL4_IT_MASK;
  }
  else
  { 
    if (DMAy_Channelx == DMA2_Channel5)
 8005480:	4b2e      	ldr	r3, [pc, #184]	; (800553c <DMA_DeInit+0x110>)
 8005482:	4298      	cmp	r0, r3
 8005484:	d021      	beq.n	80054ca <DMA_DeInit+0x9e>
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_CHANNEL5_IT_MASK;
    }
  }
}
 8005486:	4770      	bx	lr
    DMA1->IFCR |= DMA1_CHANNEL6_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel7)
  {
    /* Reset interrupt pending bits for DMA1 Channel7 */
    DMA1->IFCR |= DMA1_CHANNEL7_IT_MASK;
 8005488:	21f0      	movs	r1, #240	; 0xf0
 800548a:	4a2d      	ldr	r2, [pc, #180]	; (8005540 <DMA_DeInit+0x114>)
 800548c:	0509      	lsls	r1, r1, #20
 800548e:	6853      	ldr	r3, [r2, #4]
 8005490:	430b      	orrs	r3, r1
 8005492:	6053      	str	r3, [r2, #4]
 8005494:	e7f7      	b.n	8005486 <DMA_DeInit+0x5a>
  DMAy_Channelx->CMAR = 0;

  if (DMAy_Channelx == DMA1_Channel1)
  {
    /* Reset interrupt pending bits for DMA1 Channel1 */
    DMA1->IFCR |= DMA1_CHANNEL1_IT_MASK;
 8005496:	230f      	movs	r3, #15
 8005498:	4a29      	ldr	r2, [pc, #164]	; (8005540 <DMA_DeInit+0x114>)
 800549a:	6851      	ldr	r1, [r2, #4]
 800549c:	430b      	orrs	r3, r1
 800549e:	6053      	str	r3, [r2, #4]
 80054a0:	e7f1      	b.n	8005486 <DMA_DeInit+0x5a>
  }
  else if (DMAy_Channelx == DMA1_Channel2)
  {
    /* Reset interrupt pending bits for DMA1 Channel2 */
    DMA1->IFCR |= DMA1_CHANNEL2_IT_MASK;
 80054a2:	23f0      	movs	r3, #240	; 0xf0
 80054a4:	4a26      	ldr	r2, [pc, #152]	; (8005540 <DMA_DeInit+0x114>)
 80054a6:	6851      	ldr	r1, [r2, #4]
 80054a8:	430b      	orrs	r3, r1
 80054aa:	6053      	str	r3, [r2, #4]
 80054ac:	e7eb      	b.n	8005486 <DMA_DeInit+0x5a>
  }
  else if (DMAy_Channelx == DMA1_Channel3)
  {
    /* Reset interrupt pending bits for DMA1 Channel3 */
    DMA1->IFCR |= DMA1_CHANNEL3_IT_MASK;
 80054ae:	4a24      	ldr	r2, [pc, #144]	; (8005540 <DMA_DeInit+0x114>)
    DMA2->IFCR |= DMA2_CHANNEL2_IT_MASK;
  }
  else if (DMAy_Channelx == DMA2_Channel3)
  {
    /* Reset interrupt pending bits for DMA2 Channel3 */
    DMA2->IFCR |= DMA2_CHANNEL3_IT_MASK;
 80054b0:	21f0      	movs	r1, #240	; 0xf0
 80054b2:	6853      	ldr	r3, [r2, #4]
 80054b4:	0109      	lsls	r1, r1, #4
 80054b6:	430b      	orrs	r3, r1
 80054b8:	6053      	str	r3, [r2, #4]
 80054ba:	e7e4      	b.n	8005486 <DMA_DeInit+0x5a>
    DMA1->IFCR |= DMA1_CHANNEL3_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel4)
  {
    /* Reset interrupt pending bits for DMA1 Channel4 */
    DMA1->IFCR |= DMA1_CHANNEL4_IT_MASK;
 80054bc:	4a20      	ldr	r2, [pc, #128]	; (8005540 <DMA_DeInit+0x114>)
    DMA2->IFCR |= DMA2_CHANNEL3_IT_MASK;
  }
  else if (DMAy_Channelx == DMA2_Channel4)
  {
    /* Reset interrupt pending bits for DMA2 Channel4 */
    DMA2->IFCR |= DMA2_CHANNEL4_IT_MASK;
 80054be:	21f0      	movs	r1, #240	; 0xf0
 80054c0:	6853      	ldr	r3, [r2, #4]
 80054c2:	0209      	lsls	r1, r1, #8
 80054c4:	430b      	orrs	r3, r1
 80054c6:	6053      	str	r3, [r2, #4]
 80054c8:	e7dd      	b.n	8005486 <DMA_DeInit+0x5a>
  else
  { 
    if (DMAy_Channelx == DMA2_Channel5)
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_CHANNEL5_IT_MASK;
 80054ca:	4a1e      	ldr	r2, [pc, #120]	; (8005544 <DMA_DeInit+0x118>)
 80054cc:	21f0      	movs	r1, #240	; 0xf0
 80054ce:	6853      	ldr	r3, [r2, #4]
 80054d0:	0309      	lsls	r1, r1, #12
 80054d2:	430b      	orrs	r3, r1
 80054d4:	6053      	str	r3, [r2, #4]
 80054d6:	e7d6      	b.n	8005486 <DMA_DeInit+0x5a>
    DMA1->IFCR |= DMA1_CHANNEL4_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel5)
  {
    /* Reset interrupt pending bits for DMA1 Channel5 */
    DMA1->IFCR |= DMA1_CHANNEL5_IT_MASK;
 80054d8:	4a19      	ldr	r2, [pc, #100]	; (8005540 <DMA_DeInit+0x114>)
 80054da:	e7f7      	b.n	80054cc <DMA_DeInit+0xa0>
  }
  else if (DMAy_Channelx == DMA1_Channel6)
  {
    /* Reset interrupt pending bits for DMA1 Channel6 */
    DMA1->IFCR |= DMA1_CHANNEL6_IT_MASK;
 80054dc:	21f0      	movs	r1, #240	; 0xf0
 80054de:	4a18      	ldr	r2, [pc, #96]	; (8005540 <DMA_DeInit+0x114>)
 80054e0:	0409      	lsls	r1, r1, #16
 80054e2:	6853      	ldr	r3, [r2, #4]
 80054e4:	430b      	orrs	r3, r1
 80054e6:	6053      	str	r3, [r2, #4]
 80054e8:	e7cd      	b.n	8005486 <DMA_DeInit+0x5a>
    DMA1->IFCR |= DMA1_CHANNEL7_IT_MASK;
  }
  else if (DMAy_Channelx == DMA2_Channel1)
  {
    /* Reset interrupt pending bits for DMA2 Channel1 */
    DMA2->IFCR |= DMA2_CHANNEL1_IT_MASK;
 80054ea:	230f      	movs	r3, #15
 80054ec:	4a15      	ldr	r2, [pc, #84]	; (8005544 <DMA_DeInit+0x118>)
 80054ee:	6851      	ldr	r1, [r2, #4]
 80054f0:	430b      	orrs	r3, r1
 80054f2:	6053      	str	r3, [r2, #4]
 80054f4:	e7c7      	b.n	8005486 <DMA_DeInit+0x5a>
  }
  else if (DMAy_Channelx == DMA2_Channel2)
  {
    /* Reset interrupt pending bits for DMA2 Channel2 */
    DMA2->IFCR |= DMA2_CHANNEL2_IT_MASK;
 80054f6:	23f0      	movs	r3, #240	; 0xf0
 80054f8:	4a12      	ldr	r2, [pc, #72]	; (8005544 <DMA_DeInit+0x118>)
 80054fa:	6851      	ldr	r1, [r2, #4]
 80054fc:	430b      	orrs	r3, r1
 80054fe:	6053      	str	r3, [r2, #4]
 8005500:	e7c1      	b.n	8005486 <DMA_DeInit+0x5a>
  }
  else if (DMAy_Channelx == DMA2_Channel3)
  {
    /* Reset interrupt pending bits for DMA2 Channel3 */
    DMA2->IFCR |= DMA2_CHANNEL3_IT_MASK;
 8005502:	4a10      	ldr	r2, [pc, #64]	; (8005544 <DMA_DeInit+0x118>)
 8005504:	e7d4      	b.n	80054b0 <DMA_DeInit+0x84>
  }
  else if (DMAy_Channelx == DMA2_Channel4)
  {
    /* Reset interrupt pending bits for DMA2 Channel4 */
    DMA2->IFCR |= DMA2_CHANNEL4_IT_MASK;
 8005506:	4a0f      	ldr	r2, [pc, #60]	; (8005544 <DMA_DeInit+0x118>)
 8005508:	e7d9      	b.n	80054be <DMA_DeInit+0x92>
 800550a:	46c0      	nop			; (mov r8, r8)
 800550c:	0000fffe 	.word	0x0000fffe
 8005510:	40020008 	.word	0x40020008
 8005514:	4002001c 	.word	0x4002001c
 8005518:	40020030 	.word	0x40020030
 800551c:	40020044 	.word	0x40020044
 8005520:	40020058 	.word	0x40020058
 8005524:	4002006c 	.word	0x4002006c
 8005528:	40020080 	.word	0x40020080
 800552c:	40020408 	.word	0x40020408
 8005530:	4002041c 	.word	0x4002041c
 8005534:	40020430 	.word	0x40020430
 8005538:	40020444 	.word	0x40020444
 800553c:	40020458 	.word	0x40020458
 8005540:	40020000 	.word	0x40020000
 8005544:	40020400 	.word	0x40020400

08005548 <DMA_Init>:
  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));

/*--------------------------- DMAy Channelx CCR Configuration ----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
 8005548:	6802      	ldr	r2, [r0, #0]

  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_MASK;
 800554a:	4b0d      	ldr	r3, [pc, #52]	; (8005580 <DMA_Init+0x38>)
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
  *         the configuration information for the specified DMA Channel.
  * @retval None
  */
void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
{
 800554c:	b510      	push	{r4, lr}
/*--------------------------- DMAy Channelx CCR Configuration ----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;

  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_MASK;
 800554e:	401a      	ands	r2, r3
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8005550:	688c      	ldr	r4, [r1, #8]
 8005552:	6a0b      	ldr	r3, [r1, #32]
 8005554:	4323      	orrs	r3, r4
 8005556:	690c      	ldr	r4, [r1, #16]
 8005558:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 800555a:	694c      	ldr	r4, [r1, #20]
 800555c:	4323      	orrs	r3, r4
 800555e:	698c      	ldr	r4, [r1, #24]
 8005560:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8005562:	69cc      	ldr	r4, [r1, #28]
 8005564:	4323      	orrs	r3, r4
 8005566:	6a4c      	ldr	r4, [r1, #36]	; 0x24
 8005568:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 800556a:	6a8c      	ldr	r4, [r1, #40]	; 0x28
 800556c:	4323      	orrs	r3, r4
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 800556e:	4313      	orrs	r3, r2
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;

  /* Write to DMAy Channelx CCR */
  DMAy_Channelx->CCR = tmpreg;
 8005570:	6003      	str	r3, [r0, #0]

/*--------------------------- DMAy Channelx CNDTR Configuration --------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
 8005572:	68cb      	ldr	r3, [r1, #12]
 8005574:	6043      	str	r3, [r0, #4]

/*--------------------------- DMAy Channelx CPAR Configuration ---------------*/
  /* Write to DMAy Channelx CPAR */
  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 8005576:	680b      	ldr	r3, [r1, #0]
 8005578:	6083      	str	r3, [r0, #8]

/*--------------------------- DMAy Channelx CMAR Configuration ---------------*/
  /* Write to DMAy Channelx CMAR */
  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
 800557a:	684b      	ldr	r3, [r1, #4]
 800557c:	60c3      	str	r3, [r0, #12]
}
 800557e:	bd10      	pop	{r4, pc}
 8005580:	ffff800f 	.word	0xffff800f

08005584 <DMA_StructInit>:
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
/*-------------- Reset DMA init structure parameters values ------------------*/
  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 8005584:	2300      	movs	r3, #0
 8005586:	6003      	str	r3, [r0, #0]
  /* Initialize the DMA_MemoryBaseAddr member */
  DMA_InitStruct->DMA_MemoryBaseAddr = 0;
 8005588:	6043      	str	r3, [r0, #4]
  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralSRC;
 800558a:	6083      	str	r3, [r0, #8]
  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;
 800558c:	60c3      	str	r3, [r0, #12]
  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 800558e:	6103      	str	r3, [r0, #16]
  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
 8005590:	6143      	str	r3, [r0, #20]
  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8005592:	6183      	str	r3, [r0, #24]
  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8005594:	61c3      	str	r3, [r0, #28]
  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 8005596:	6203      	str	r3, [r0, #32]
  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
 8005598:	6243      	str	r3, [r0, #36]	; 0x24
  /* Initialize the DMA_M2M member */
  DMA_InitStruct->DMA_M2M = DMA_M2M_Disable;
 800559a:	6283      	str	r3, [r0, #40]	; 0x28
}
 800559c:	4770      	bx	lr
 800559e:	46c0      	nop			; (mov r8, r8)

080055a0 <DMA_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected DMAy Channelx */
    DMAy_Channelx->CCR |= DMA_CCR_EN;
 80055a0:	6802      	ldr	r2, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80055a2:	2900      	cmp	r1, #0
 80055a4:	d103      	bne.n	80055ae <DMA_Cmd+0xe>
    DMAy_Channelx->CCR |= DMA_CCR_EN;
  }
  else
  {
    /* Disable the selected DMAy Channelx */
    DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR_EN);
 80055a6:	4b04      	ldr	r3, [pc, #16]	; (80055b8 <DMA_Cmd+0x18>)
 80055a8:	4013      	ands	r3, r2
 80055aa:	6003      	str	r3, [r0, #0]
  }
}
 80055ac:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected DMAy Channelx */
    DMAy_Channelx->CCR |= DMA_CCR_EN;
 80055ae:	2301      	movs	r3, #1
 80055b0:	4313      	orrs	r3, r2
 80055b2:	6003      	str	r3, [r0, #0]
 80055b4:	e7fa      	b.n	80055ac <DMA_Cmd+0xc>
 80055b6:	46c0      	nop			; (mov r8, r8)
 80055b8:	0000fffe 	.word	0x0000fffe

080055bc <DMA_RemapConfig>:
  *         for DMA1 to select the DMA1 Channel and can be 1 to 5 for DMA2 to select the DMA2 Channel.
  * @note   This function is available only for STM32F091 devices. 
  * @retval None
  */
void DMA_RemapConfig(DMA_TypeDef* DMAy, uint32_t DMAx_CHy_RemapRequest)
{
 80055bc:	b530      	push	{r4, r5, lr}
  else
  {
    assert_param(IS_DMA2_REMAP(DMAx_CHy_RemapRequest)); 
  }

  DMAy->RMPCR &= ~((uint32_t)0x0F << (uint32_t)((DMAx_CHy_RemapRequest >> 28) * 4)); 
 80055be:	250f      	movs	r5, #15
 80055c0:	23a8      	movs	r3, #168	; 0xa8
 80055c2:	0f0c      	lsrs	r4, r1, #28
 80055c4:	00a4      	lsls	r4, r4, #2
 80055c6:	40a5      	lsls	r5, r4
 80055c8:	58c2      	ldr	r2, [r0, r3]
  DMAy->RMPCR |= (uint32_t)(DMAx_CHy_RemapRequest & 0x0FFFFFFF);  
 80055ca:	0109      	lsls	r1, r1, #4
  else
  {
    assert_param(IS_DMA2_REMAP(DMAx_CHy_RemapRequest)); 
  }

  DMAy->RMPCR &= ~((uint32_t)0x0F << (uint32_t)((DMAx_CHy_RemapRequest >> 28) * 4)); 
 80055cc:	43aa      	bics	r2, r5
 80055ce:	50c2      	str	r2, [r0, r3]
  DMAy->RMPCR |= (uint32_t)(DMAx_CHy_RemapRequest & 0x0FFFFFFF);  
 80055d0:	58c2      	ldr	r2, [r0, r3]
 80055d2:	0909      	lsrs	r1, r1, #4
 80055d4:	4311      	orrs	r1, r2
 80055d6:	50c1      	str	r1, [r0, r3]
}
 80055d8:	bd30      	pop	{r4, r5, pc}
 80055da:	46c0      	nop			; (mov r8, r8)

080055dc <DMA_SetCurrDataCounter>:
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));

/*--------------------------- DMAy Channelx CNDTR Configuration --------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DataNumber;
 80055dc:	6041      	str	r1, [r0, #4]
}
 80055de:	4770      	bx	lr

080055e0 <DMA_GetCurrDataCounter>:
uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  /* Return the number of remaining data units for DMAy Channelx */
  return ((uint16_t)(DMAy_Channelx->CNDTR));
 80055e0:	6840      	ldr	r0, [r0, #4]
 80055e2:	b280      	uxth	r0, r0
}
 80055e4:	4770      	bx	lr
 80055e6:	46c0      	nop			; (mov r8, r8)

080055e8 <DMA_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 80055e8:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80055ea:	2a00      	cmp	r2, #0
 80055ec:	d102      	bne.n	80055f4 <DMA_ITConfig+0xc>
    DMAy_Channelx->CCR |= DMA_IT;
  }
  else
  {
    /* Disable the selected DMA interrupts */
    DMAy_Channelx->CCR &= ~DMA_IT;
 80055ee:	438b      	bics	r3, r1
 80055f0:	6003      	str	r3, [r0, #0]
  }
}
 80055f2:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 80055f4:	4319      	orrs	r1, r3
 80055f6:	6001      	str	r1, [r0, #0]
 80055f8:	e7fb      	b.n	80055f2 <DMA_ITConfig+0xa>
 80055fa:	46c0      	nop			; (mov r8, r8)

080055fc <DMA_GetFlagStatus>:
  
  /* Check the parameters */
  assert_param(IS_DMA_GET_FLAG(DMAy_FLAG));

  /* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
 80055fc:	00c3      	lsls	r3, r0, #3
 80055fe:	d506      	bpl.n	800560e <DMA_GetFlagStatus+0x12>
  {
    /* Get DMA2 ISR register value */
    tmpreg = DMA2->ISR ;
 8005600:	4b04      	ldr	r3, [pc, #16]	; (8005614 <DMA_GetFlagStatus+0x18>)
 8005602:	681b      	ldr	r3, [r3, #0]
    /* Get DMA1 ISR register value */
    tmpreg = DMA1->ISR ;
  }

  /* Check the status of the specified DMAy flag */
  if ((tmpreg & DMAy_FLAG) != (uint32_t)RESET)
 8005604:	4018      	ands	r0, r3
 8005606:	1e43      	subs	r3, r0, #1
 8005608:	4198      	sbcs	r0, r3
    /* DMAy_FLAG is reset */
    bitstatus = RESET;
  }
  
  /* Return the DMAy_FLAG status */
  return  bitstatus;
 800560a:	b2c0      	uxtb	r0, r0
}
 800560c:	4770      	bx	lr
    tmpreg = DMA2->ISR ;
  }
  else
  {
    /* Get DMA1 ISR register value */
    tmpreg = DMA1->ISR ;
 800560e:	4b02      	ldr	r3, [pc, #8]	; (8005618 <DMA_GetFlagStatus+0x1c>)
 8005610:	681b      	ldr	r3, [r3, #0]
 8005612:	e7f7      	b.n	8005604 <DMA_GetFlagStatus+0x8>
 8005614:	40020400 	.word	0x40020400
 8005618:	40020000 	.word	0x40020000

0800561c <DMA_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_FLAG(DMAy_FLAG));

/* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
 800561c:	00c3      	lsls	r3, r0, #3
 800561e:	d402      	bmi.n	8005626 <DMA_ClearFlag+0xa>
    DMA2->IFCR = DMAy_FLAG;
  }
  else
  {
    /* Clear the selected DMAy flags */
    DMA1->IFCR = DMAy_FLAG;
 8005620:	4b02      	ldr	r3, [pc, #8]	; (800562c <DMA_ClearFlag+0x10>)
 8005622:	6058      	str	r0, [r3, #4]
  }
}
 8005624:	4770      	bx	lr

/* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
  {
    /* Clear the selected DMAy flags */
    DMA2->IFCR = DMAy_FLAG;
 8005626:	4b02      	ldr	r3, [pc, #8]	; (8005630 <DMA_ClearFlag+0x14>)
 8005628:	6058      	str	r0, [r3, #4]
 800562a:	e7fb      	b.n	8005624 <DMA_ClearFlag+0x8>
 800562c:	40020000 	.word	0x40020000
 8005630:	40020400 	.word	0x40020400

08005634 <DMA_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_DMA_GET_IT(DMAy_IT));

  /* Calculate the used DMA */
  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)
 8005634:	00c3      	lsls	r3, r0, #3
 8005636:	d506      	bpl.n	8005646 <DMA_GetITStatus+0x12>
  {
    /* Get DMA2 ISR register value */
    tmpreg = DMA2->ISR;
 8005638:	4b04      	ldr	r3, [pc, #16]	; (800564c <DMA_GetITStatus+0x18>)
 800563a:	681b      	ldr	r3, [r3, #0]
    /* Get DMA1 ISR register value */
    tmpreg = DMA1->ISR;
  }

  /* Check the status of the specified DMAy interrupt */
  if ((tmpreg & DMAy_IT) != (uint32_t)RESET)
 800563c:	4018      	ands	r0, r3
 800563e:	1e43      	subs	r3, r0, #1
 8005640:	4198      	sbcs	r0, r3
  {
    /* DMAy_IT is reset */
    bitstatus = RESET;
  }
  /* Return the DMAy_IT status */
  return  bitstatus;
 8005642:	b2c0      	uxtb	r0, r0
}
 8005644:	4770      	bx	lr
    tmpreg = DMA2->ISR;
  }
  else
  {
    /* Get DMA1 ISR register value */
    tmpreg = DMA1->ISR;
 8005646:	4b02      	ldr	r3, [pc, #8]	; (8005650 <DMA_GetITStatus+0x1c>)
 8005648:	681b      	ldr	r3, [r3, #0]
 800564a:	e7f7      	b.n	800563c <DMA_GetITStatus+0x8>
 800564c:	40020400 	.word	0x40020400
 8005650:	40020000 	.word	0x40020000

08005654 <DMA_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_IT(DMAy_IT));
  
  /* Calculate the used DMAy */
  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)
 8005654:	00c3      	lsls	r3, r0, #3
 8005656:	d402      	bmi.n	800565e <DMA_ClearITPendingBit+0xa>
    DMA2->IFCR = DMAy_IT;
  }
  else
  {
    /* Clear the selected DMAy interrupt pending bits */
    DMA1->IFCR = DMAy_IT;
 8005658:	4b02      	ldr	r3, [pc, #8]	; (8005664 <DMA_ClearITPendingBit+0x10>)
 800565a:	6058      	str	r0, [r3, #4]
  }
}
 800565c:	4770      	bx	lr
  
  /* Calculate the used DMAy */
  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)
  {
    /* Clear the selected DMAy interrupt pending bits */
    DMA2->IFCR = DMAy_IT;
 800565e:	4b02      	ldr	r3, [pc, #8]	; (8005668 <DMA_ClearITPendingBit+0x14>)
 8005660:	6058      	str	r0, [r3, #4]
 8005662:	e7fb      	b.n	800565c <DMA_ClearITPendingBit+0x8>
 8005664:	40020000 	.word	0x40020000
 8005668:	40020400 	.word	0x40020400

0800566c <EXTI_DeInit>:
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR = 0x0F940000;
 800566c:	4b04      	ldr	r3, [pc, #16]	; (8005680 <EXTI_DeInit+0x14>)
 800566e:	4a05      	ldr	r2, [pc, #20]	; (8005684 <EXTI_DeInit+0x18>)
 8005670:	601a      	str	r2, [r3, #0]
  EXTI->EMR = 0x00000000;
 8005672:	2200      	movs	r2, #0
 8005674:	605a      	str	r2, [r3, #4]
  EXTI->RTSR = 0x00000000;
 8005676:	609a      	str	r2, [r3, #8]
  EXTI->FTSR = 0x00000000;
 8005678:	60da      	str	r2, [r3, #12]
  EXTI->PR = 0x006BFFFF;
 800567a:	4a03      	ldr	r2, [pc, #12]	; (8005688 <EXTI_DeInit+0x1c>)
 800567c:	615a      	str	r2, [r3, #20]
}
 800567e:	4770      	bx	lr
 8005680:	40010400 	.word	0x40010400
 8005684:	0f940000 	.word	0x0f940000
 8005688:	006bffff 	.word	0x006bffff

0800568c <EXTI_Init>:
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;

  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 800568c:	7983      	ldrb	r3, [r0, #6]
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure that 
  *         contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 800568e:	b510      	push	{r4, lr}
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;

  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8005690:	2b00      	cmp	r3, #0
 8005692:	d020      	beq.n	80056d6 <EXTI_Init+0x4a>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 8005694:	6801      	ldr	r1, [r0, #0]
 8005696:	4b18      	ldr	r3, [pc, #96]	; (80056f8 <EXTI_Init+0x6c>)
 8005698:	43ca      	mvns	r2, r1
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;

    tmp += EXTI_InitStruct->EXTI_Mode;
 800569a:	469c      	mov	ip, r3
  tmp = (uint32_t)EXTI_BASE;

  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 800569c:	681c      	ldr	r4, [r3, #0]
 800569e:	4014      	ands	r4, r2
 80056a0:	601c      	str	r4, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 80056a2:	685c      	ldr	r4, [r3, #4]
 80056a4:	4022      	ands	r2, r4
 80056a6:	605a      	str	r2, [r3, #4]

    tmp += EXTI_InitStruct->EXTI_Mode;
 80056a8:	7902      	ldrb	r2, [r0, #4]
 80056aa:	4462      	add	r2, ip

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80056ac:	6814      	ldr	r4, [r2, #0]
 80056ae:	4321      	orrs	r1, r4
 80056b0:	6011      	str	r1, [r2, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 80056b2:	6801      	ldr	r1, [r0, #0]
 80056b4:	689c      	ldr	r4, [r3, #8]
 80056b6:	43ca      	mvns	r2, r1
 80056b8:	4014      	ands	r4, r2
 80056ba:	609c      	str	r4, [r3, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 80056bc:	68dc      	ldr	r4, [r3, #12]
 80056be:	4022      	ands	r2, r4
 80056c0:	60da      	str	r2, [r3, #12]

    /* Select the trigger for the selected interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80056c2:	7942      	ldrb	r2, [r0, #5]
 80056c4:	2a10      	cmp	r2, #16
 80056c6:	d00f      	beq.n	80056e8 <EXTI_Init+0x5c>
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
    }
    else
    {
      tmp = (uint32_t)EXTI_BASE;
      tmp += EXTI_InitStruct->EXTI_Trigger;
 80056c8:	4b0b      	ldr	r3, [pc, #44]	; (80056f8 <EXTI_Init+0x6c>)
 80056ca:	469c      	mov	ip, r3
 80056cc:	4462      	add	r2, ip

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80056ce:	6813      	ldr	r3, [r2, #0]
 80056d0:	4319      	orrs	r1, r3
 80056d2:	6011      	str	r1, [r2, #0]
 80056d4:	e007      	b.n	80056e6 <EXTI_Init+0x5a>
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 80056d6:	4a08      	ldr	r2, [pc, #32]	; (80056f8 <EXTI_Init+0x6c>)
 80056d8:	7903      	ldrb	r3, [r0, #4]
 80056da:	4694      	mov	ip, r2
 80056dc:	4463      	add	r3, ip

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 80056de:	681a      	ldr	r2, [r3, #0]
 80056e0:	6801      	ldr	r1, [r0, #0]
 80056e2:	438a      	bics	r2, r1
 80056e4:	601a      	str	r2, [r3, #0]
  }
}
 80056e6:	bd10      	pop	{r4, pc}

    /* Select the trigger for the selected interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 80056e8:	689a      	ldr	r2, [r3, #8]
 80056ea:	430a      	orrs	r2, r1
 80056ec:	609a      	str	r2, [r3, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 80056ee:	68da      	ldr	r2, [r3, #12]
 80056f0:	4311      	orrs	r1, r2
 80056f2:	60d9      	str	r1, [r3, #12]
 80056f4:	e7f7      	b.n	80056e6 <EXTI_Init+0x5a>
 80056f6:	46c0      	nop			; (mov r8, r8)
 80056f8:	40010400 	.word	0x40010400

080056fc <EXTI_StructInit>:
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 80056fc:	2300      	movs	r3, #0
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 80056fe:	220c      	movs	r2, #12
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8005700:	6003      	str	r3, [r0, #0]
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
 8005702:	7103      	strb	r3, [r0, #4]
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 8005704:	7142      	strb	r2, [r0, #5]
  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
 8005706:	7183      	strb	r3, [r0, #6]
}
 8005708:	4770      	bx	lr
 800570a:	46c0      	nop			; (mov r8, r8)

0800570c <EXTI_GenerateSWInterrupt>:
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));

  EXTI->SWIER |= EXTI_Line;
 800570c:	4a02      	ldr	r2, [pc, #8]	; (8005718 <EXTI_GenerateSWInterrupt+0xc>)
 800570e:	6913      	ldr	r3, [r2, #16]
 8005710:	4318      	orrs	r0, r3
 8005712:	6110      	str	r0, [r2, #16]
}
 8005714:	4770      	bx	lr
 8005716:	46c0      	nop			; (mov r8, r8)
 8005718:	40010400 	.word	0x40010400

0800571c <EXTI_GetFlagStatus>:
{
   FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));

  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 800571c:	4b03      	ldr	r3, [pc, #12]	; (800572c <EXTI_GetFlagStatus+0x10>)
 800571e:	695b      	ldr	r3, [r3, #20]
 8005720:	4018      	ands	r0, r3
 8005722:	1e43      	subs	r3, r0, #1
 8005724:	4198      	sbcs	r0, r3
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 8005726:	b2c0      	uxtb	r0, r0
}
 8005728:	4770      	bx	lr
 800572a:	46c0      	nop			; (mov r8, r8)
 800572c:	40010400 	.word	0x40010400

08005730 <EXTI_ClearFlag>:
void EXTI_ClearFlag(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));

  EXTI->PR = EXTI_Line;
 8005730:	4b01      	ldr	r3, [pc, #4]	; (8005738 <EXTI_ClearFlag+0x8>)
 8005732:	6158      	str	r0, [r3, #20]
}
 8005734:	4770      	bx	lr
 8005736:	46c0      	nop			; (mov r8, r8)
 8005738:	40010400 	.word	0x40010400

0800573c <EXTI_GetITStatus>:
  ITStatus bitstatus = RESET;

  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));

  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 800573c:	4b03      	ldr	r3, [pc, #12]	; (800574c <EXTI_GetITStatus+0x10>)
 800573e:	695b      	ldr	r3, [r3, #20]
 8005740:	4018      	ands	r0, r3
 8005742:	1e43      	subs	r3, r0, #1
 8005744:	4198      	sbcs	r0, r3
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 8005746:	b2c0      	uxtb	r0, r0
}
 8005748:	4770      	bx	lr
 800574a:	46c0      	nop			; (mov r8, r8)
 800574c:	40010400 	.word	0x40010400

08005750 <EXTI_ClearITPendingBit>:
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));

  EXTI->PR = EXTI_Line;
 8005750:	4b01      	ldr	r3, [pc, #4]	; (8005758 <EXTI_ClearITPendingBit+0x8>)
 8005752:	6158      	str	r0, [r3, #20]
}
 8005754:	4770      	bx	lr
 8005756:	46c0      	nop			; (mov r8, r8)
 8005758:	40010400 	.word	0x40010400

0800575c <FLASH_SetLatency>:

  /* Read the ACR register */
  tmpreg = FLASH->ACR;  

  /* Sets the Latency value */
  tmpreg &= (uint32_t) (~((uint32_t)FLASH_ACR_LATENCY));
 800575c:	2101      	movs	r1, #1

  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));

  /* Read the ACR register */
  tmpreg = FLASH->ACR;  
 800575e:	4a03      	ldr	r2, [pc, #12]	; (800576c <FLASH_SetLatency+0x10>)
 8005760:	6813      	ldr	r3, [r2, #0]

  /* Sets the Latency value */
  tmpreg &= (uint32_t) (~((uint32_t)FLASH_ACR_LATENCY));
 8005762:	438b      	bics	r3, r1
  tmpreg |= FLASH_Latency;
 8005764:	4318      	orrs	r0, r3

  /* Write the ACR register */
  FLASH->ACR = tmpreg;
 8005766:	6010      	str	r0, [r2, #0]
}
 8005768:	4770      	bx	lr
 800576a:	46c0      	nop			; (mov r8, r8)
 800576c:	40022000 	.word	0x40022000

08005770 <FLASH_PrefetchBufferCmd>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if(NewState != DISABLE)
  {
    FLASH->ACR |= FLASH_ACR_PRFTBE;
 8005770:	4a06      	ldr	r2, [pc, #24]	; (800578c <FLASH_PrefetchBufferCmd+0x1c>)
void FLASH_PrefetchBufferCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if(NewState != DISABLE)
 8005772:	2800      	cmp	r0, #0
 8005774:	d104      	bne.n	8005780 <FLASH_PrefetchBufferCmd+0x10>
  {
    FLASH->ACR |= FLASH_ACR_PRFTBE;
  }
  else
  {
    FLASH->ACR &= (uint32_t)(~((uint32_t)FLASH_ACR_PRFTBE));
 8005776:	2110      	movs	r1, #16
 8005778:	6813      	ldr	r3, [r2, #0]
 800577a:	438b      	bics	r3, r1
 800577c:	6013      	str	r3, [r2, #0]
  }
}
 800577e:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if(NewState != DISABLE)
  {
    FLASH->ACR |= FLASH_ACR_PRFTBE;
 8005780:	2310      	movs	r3, #16
 8005782:	6811      	ldr	r1, [r2, #0]
 8005784:	430b      	orrs	r3, r1
 8005786:	6013      	str	r3, [r2, #0]
 8005788:	e7f9      	b.n	800577e <FLASH_PrefetchBufferCmd+0xe>
 800578a:	46c0      	nop			; (mov r8, r8)
 800578c:	40022000 	.word	0x40022000

08005790 <FLASH_GetPrefetchBufferStatus>:
  */
FlagStatus FLASH_GetPrefetchBufferStatus(void)
{
  FlagStatus bitstatus = RESET;

  if ((FLASH->ACR & FLASH_ACR_PRFTBS) != (uint32_t)RESET)
 8005790:	4b02      	ldr	r3, [pc, #8]	; (800579c <FLASH_GetPrefetchBufferStatus+0xc>)
 8005792:	6818      	ldr	r0, [r3, #0]
 8005794:	0680      	lsls	r0, r0, #26
  else
  {
    bitstatus = RESET;
  }
  /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
  return bitstatus; 
 8005796:	0fc0      	lsrs	r0, r0, #31
}
 8005798:	4770      	bx	lr
 800579a:	46c0      	nop			; (mov r8, r8)
 800579c:	40022000 	.word	0x40022000

080057a0 <FLASH_Unlock>:
  * @param  None
  * @retval None
  */
void FLASH_Unlock(void)
{
  if((FLASH->CR & FLASH_CR_LOCK) != RESET)
 80057a0:	4b04      	ldr	r3, [pc, #16]	; (80057b4 <FLASH_Unlock+0x14>)
 80057a2:	691a      	ldr	r2, [r3, #16]
 80057a4:	0612      	lsls	r2, r2, #24
 80057a6:	d503      	bpl.n	80057b0 <FLASH_Unlock+0x10>
  {
    /* Unlocking the program memory access */
    FLASH->KEYR = FLASH_FKEY1;
 80057a8:	4a03      	ldr	r2, [pc, #12]	; (80057b8 <FLASH_Unlock+0x18>)
 80057aa:	605a      	str	r2, [r3, #4]
    FLASH->KEYR = FLASH_FKEY2;
 80057ac:	4a03      	ldr	r2, [pc, #12]	; (80057bc <FLASH_Unlock+0x1c>)
 80057ae:	605a      	str	r2, [r3, #4]
  }
}
 80057b0:	4770      	bx	lr
 80057b2:	46c0      	nop			; (mov r8, r8)
 80057b4:	40022000 	.word	0x40022000
 80057b8:	45670123 	.word	0x45670123
 80057bc:	cdef89ab 	.word	0xcdef89ab

080057c0 <FLASH_Lock>:
  * @retval None
  */
void FLASH_Lock(void)
{
  /* Set the LOCK Bit to lock the FLASH control register and program memory access */
  FLASH->CR |= FLASH_CR_LOCK;
 80057c0:	2380      	movs	r3, #128	; 0x80
 80057c2:	4a02      	ldr	r2, [pc, #8]	; (80057cc <FLASH_Lock+0xc>)
 80057c4:	6911      	ldr	r1, [r2, #16]
 80057c6:	430b      	orrs	r3, r1
 80057c8:	6113      	str	r3, [r2, #16]
}
 80057ca:	4770      	bx	lr
 80057cc:	40022000 	.word	0x40022000

080057d0 <FLASH_OB_Unlock>:
  * @param  None
  * @retval None
  */
void FLASH_OB_Unlock(void)
{
  if((FLASH->CR & FLASH_CR_OPTWRE) == RESET)
 80057d0:	4b04      	ldr	r3, [pc, #16]	; (80057e4 <FLASH_OB_Unlock+0x14>)
 80057d2:	691a      	ldr	r2, [r3, #16]
 80057d4:	0592      	lsls	r2, r2, #22
 80057d6:	d403      	bmi.n	80057e0 <FLASH_OB_Unlock+0x10>
  { 
    /* Unlocking the option bytes block access */
    FLASH->OPTKEYR = FLASH_OPTKEY1;
 80057d8:	4a03      	ldr	r2, [pc, #12]	; (80057e8 <FLASH_OB_Unlock+0x18>)
 80057da:	609a      	str	r2, [r3, #8]
    FLASH->OPTKEYR = FLASH_OPTKEY2;
 80057dc:	4a03      	ldr	r2, [pc, #12]	; (80057ec <FLASH_OB_Unlock+0x1c>)
 80057de:	609a      	str	r2, [r3, #8]
  }
}
 80057e0:	4770      	bx	lr
 80057e2:	46c0      	nop			; (mov r8, r8)
 80057e4:	40022000 	.word	0x40022000
 80057e8:	45670123 	.word	0x45670123
 80057ec:	cdef89ab 	.word	0xcdef89ab

080057f0 <FLASH_OB_Lock>:
  * @retval None
  */
void FLASH_OB_Lock(void)
{
  /* Set the OPTWREN Bit to lock the option bytes block access */
  FLASH->CR &= ~FLASH_CR_OPTWRE;
 80057f0:	4a02      	ldr	r2, [pc, #8]	; (80057fc <FLASH_OB_Lock+0xc>)
 80057f2:	4b03      	ldr	r3, [pc, #12]	; (8005800 <FLASH_OB_Lock+0x10>)
 80057f4:	6911      	ldr	r1, [r2, #16]
 80057f6:	400b      	ands	r3, r1
 80057f8:	6113      	str	r3, [r2, #16]
}
 80057fa:	4770      	bx	lr
 80057fc:	40022000 	.word	0x40022000
 8005800:	fffffdff 	.word	0xfffffdff

08005804 <FLASH_OB_Launch>:
  * @retval None
  */
void FLASH_OB_Launch(void)
{
  /* Set the OBL_Launch bit to launch the option byte loading */
  FLASH->CR |= FLASH_CR_OBL_LAUNCH;
 8005804:	2180      	movs	r1, #128	; 0x80
 8005806:	4a03      	ldr	r2, [pc, #12]	; (8005814 <FLASH_OB_Launch+0x10>)
 8005808:	0189      	lsls	r1, r1, #6
 800580a:	6913      	ldr	r3, [r2, #16]
 800580c:	430b      	orrs	r3, r1
 800580e:	6113      	str	r3, [r2, #16]
}
 8005810:	4770      	bx	lr
 8005812:	46c0      	nop			; (mov r8, r8)
 8005814:	40022000 	.word	0x40022000

08005818 <FLASH_OB_GetUser>:
  * @retval The FLASH User Option Bytes .
  */
uint8_t FLASH_OB_GetUser(void)
{
  /* Return the User Option Byte */
  return (uint8_t)(FLASH->OBR >> 8);
 8005818:	4b02      	ldr	r3, [pc, #8]	; (8005824 <FLASH_OB_GetUser+0xc>)
 800581a:	69d8      	ldr	r0, [r3, #28]
 800581c:	0a00      	lsrs	r0, r0, #8
 800581e:	b2c0      	uxtb	r0, r0
}
 8005820:	4770      	bx	lr
 8005822:	46c0      	nop			; (mov r8, r8)
 8005824:	40022000 	.word	0x40022000

08005828 <FLASH_OB_GetWRP>:
  * @retval The FLASH Write Protection Option Bytes value
  */
uint32_t FLASH_OB_GetWRP(void)
{
  /* Return the FLASH write protection Register value */
  return (uint32_t)(FLASH->WRPR);
 8005828:	4b01      	ldr	r3, [pc, #4]	; (8005830 <FLASH_OB_GetWRP+0x8>)
 800582a:	6a18      	ldr	r0, [r3, #32]
}
 800582c:	4770      	bx	lr
 800582e:	46c0      	nop			; (mov r8, r8)
 8005830:	40022000 	.word	0x40022000

08005834 <FLASH_OB_GetRDP>:
  */
FlagStatus FLASH_OB_GetRDP(void)
{
  FlagStatus readstatus = RESET;
  
  if ((uint8_t)(FLASH->OBR & (FLASH_OBR_RDPRT1 | FLASH_OBR_RDPRT2)) != RESET)
 8005834:	4b03      	ldr	r3, [pc, #12]	; (8005844 <FLASH_OB_GetRDP+0x10>)
 8005836:	69d8      	ldr	r0, [r3, #28]
 8005838:	2306      	movs	r3, #6
 800583a:	4018      	ands	r0, r3
 800583c:	1e43      	subs	r3, r0, #1
 800583e:	4198      	sbcs	r0, r3
  }
  else
  {
    readstatus = RESET;
  }
  return readstatus;
 8005840:	b2c0      	uxtb	r0, r0
}
 8005842:	4770      	bx	lr
 8005844:	40022000 	.word	0x40022000

08005848 <FLASH_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
  {
    /* Enable the interrupt sources */
    FLASH->CR |= FLASH_IT;
 8005848:	4a04      	ldr	r2, [pc, #16]	; (800585c <FLASH_ITConfig+0x14>)
 800584a:	6913      	ldr	r3, [r2, #16]
{
  /* Check the parameters */
  assert_param(IS_FLASH_IT(FLASH_IT)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
 800584c:	2900      	cmp	r1, #0
 800584e:	d102      	bne.n	8005856 <FLASH_ITConfig+0xe>
    FLASH->CR |= FLASH_IT;
  }
  else
  {
    /* Disable the interrupt sources */
    FLASH->CR &= ~(uint32_t)FLASH_IT;
 8005850:	4383      	bics	r3, r0
 8005852:	6113      	str	r3, [r2, #16]
  }
}
 8005854:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
  {
    /* Enable the interrupt sources */
    FLASH->CR |= FLASH_IT;
 8005856:	4318      	orrs	r0, r3
 8005858:	6110      	str	r0, [r2, #16]
 800585a:	e7fb      	b.n	8005854 <FLASH_ITConfig+0xc>
 800585c:	40022000 	.word	0x40022000

08005860 <FLASH_GetFlagStatus>:
  FlagStatus bitstatus = RESET;

  /* Check the parameters */
  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));

  if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
 8005860:	4b03      	ldr	r3, [pc, #12]	; (8005870 <FLASH_GetFlagStatus+0x10>)
 8005862:	68db      	ldr	r3, [r3, #12]
 8005864:	4018      	ands	r0, r3
 8005866:	1e43      	subs	r3, r0, #1
 8005868:	4198      	sbcs	r0, r3
  else
  {
    bitstatus = RESET;
  }
  /* Return the new state of FLASH_FLAG (SET or RESET) */
  return bitstatus; 
 800586a:	b2c0      	uxtb	r0, r0
}
 800586c:	4770      	bx	lr
 800586e:	46c0      	nop			; (mov r8, r8)
 8005870:	40022000 	.word	0x40022000

08005874 <FLASH_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
  
  /* Clear the flags */
  FLASH->SR = FLASH_FLAG;
 8005874:	4b01      	ldr	r3, [pc, #4]	; (800587c <FLASH_ClearFlag+0x8>)
 8005876:	60d8      	str	r0, [r3, #12]
}
 8005878:	4770      	bx	lr
 800587a:	46c0      	nop			; (mov r8, r8)
 800587c:	40022000 	.word	0x40022000

08005880 <FLASH_GetStatus>:
  */
FLASH_Status FLASH_GetStatus(void)
{
  FLASH_Status FLASHstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 8005880:	4b08      	ldr	r3, [pc, #32]	; (80058a4 <FLASH_GetStatus+0x24>)
  {
    FLASHstatus = FLASH_BUSY;
 8005882:	2001      	movs	r0, #1
  */
FLASH_Status FLASH_GetStatus(void)
{
  FLASH_Status FLASHstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 8005884:	68da      	ldr	r2, [r3, #12]
 8005886:	07d2      	lsls	r2, r2, #31
 8005888:	d403      	bmi.n	8005892 <FLASH_GetStatus+0x12>
  {
    FLASHstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & (uint32_t)FLASH_FLAG_WRPERR)!= (uint32_t)0x00)
 800588a:	68da      	ldr	r2, [r3, #12]
    { 
      FLASHstatus = FLASH_ERROR_WRP;
 800588c:	3001      	adds	r0, #1
  {
    FLASHstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & (uint32_t)FLASH_FLAG_WRPERR)!= (uint32_t)0x00)
 800588e:	06d2      	lsls	r2, r2, #27
 8005890:	d500      	bpl.n	8005894 <FLASH_GetStatus+0x14>
      }
    }
  }
  /* Return the FLASH Status */
  return FLASHstatus;
}
 8005892:	4770      	bx	lr
    { 
      FLASHstatus = FLASH_ERROR_WRP;
    }
    else 
    {
      if((FLASH->SR & (uint32_t)(FLASH_SR_PGERR)) != (uint32_t)0x00)
 8005894:	68d8      	ldr	r0, [r3, #12]
 8005896:	2304      	movs	r3, #4
 8005898:	4018      	ands	r0, r3
      {
        FLASHstatus = FLASH_ERROR_PROGRAM; 
      }
      else
      {
        FLASHstatus = FLASH_COMPLETE;
 800589a:	1e42      	subs	r2, r0, #1
 800589c:	4190      	sbcs	r0, r2
 800589e:	1a18      	subs	r0, r3, r0
 80058a0:	e7f7      	b.n	8005892 <FLASH_GetStatus+0x12>
 80058a2:	46c0      	nop			; (mov r8, r8)
 80058a4:	40022000 	.word	0x40022000

080058a8 <FLASH_WaitForLastOperation>:
  * @param  Timeout: FLASH programming Timeout
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, 
  *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
{ 
 80058a8:	b510      	push	{r4, lr}
 80058aa:	1c04      	adds	r4, r0, #0
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the FLASH Status */
  status = FLASH_GetStatus();
 80058ac:	f7ff ffe8 	bl	8005880 <FLASH_GetStatus>
  
  /* Wait for a FLASH operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 80058b0:	2801      	cmp	r0, #1
 80058b2:	d005      	beq.n	80058c0 <FLASH_WaitForLastOperation+0x18>
 80058b4:	e008      	b.n	80058c8 <FLASH_WaitForLastOperation+0x20>
  {
    status = FLASH_GetStatus();
 80058b6:	f7ff ffe3 	bl	8005880 <FLASH_GetStatus>
    Timeout--;
 80058ba:	3c01      	subs	r4, #1
   
  /* Check for the FLASH Status */
  status = FLASH_GetStatus();
  
  /* Wait for a FLASH operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 80058bc:	2801      	cmp	r0, #1
 80058be:	d103      	bne.n	80058c8 <FLASH_WaitForLastOperation+0x20>
 80058c0:	2c00      	cmp	r4, #0
 80058c2:	d1f8      	bne.n	80058b6 <FLASH_WaitForLastOperation+0xe>
    Timeout--;
  }
  
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 80058c4:	2005      	movs	r0, #5
  }
  /* Return the operation status */
  return status;
}
 80058c6:	bd10      	pop	{r4, pc}
  {
    status = FLASH_GetStatus();
    Timeout--;
  }
  
  if(Timeout == 0x00 )
 80058c8:	2c00      	cmp	r4, #0
 80058ca:	d0fb      	beq.n	80058c4 <FLASH_WaitForLastOperation+0x1c>
 80058cc:	e7fb      	b.n	80058c6 <FLASH_WaitForLastOperation+0x1e>
 80058ce:	46c0      	nop			; (mov r8, r8)

080058d0 <FLASH_ErasePage>:
  *         is the start address of a page (multiple of 1024 bytes).
  * @retval FLASH Status: The returned value can be: 
  *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
{
 80058d0:	b570      	push	{r4, r5, r6, lr}
 80058d2:	1c05      	adds	r5, r0, #0

  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Page_Address));
 
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 80058d4:	20b0      	movs	r0, #176	; 0xb0
 80058d6:	0300      	lsls	r0, r0, #12
 80058d8:	f7ff ffe6 	bl	80058a8 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 80058dc:	2804      	cmp	r0, #4
 80058de:	d000      	beq.n	80058e2 <FLASH_ErasePage+0x12>
    FLASH->CR &= ~FLASH_CR_PER;
  }
    
  /* Return the Erase Status */
  return status;
}
 80058e0:	bd70      	pop	{r4, r5, r6, pc}
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  { 
    /* If the previous operation is completed, proceed to erase the page */
    FLASH->CR |= FLASH_CR_PER;
 80058e2:	2602      	movs	r6, #2
 80058e4:	4c08      	ldr	r4, [pc, #32]	; (8005908 <FLASH_ErasePage+0x38>)
    FLASH->AR  = Page_Address;
    FLASH->CR |= FLASH_CR_STRT;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 80058e6:	20b0      	movs	r0, #176	; 0xb0
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  { 
    /* If the previous operation is completed, proceed to erase the page */
    FLASH->CR |= FLASH_CR_PER;
 80058e8:	6923      	ldr	r3, [r4, #16]
    FLASH->AR  = Page_Address;
    FLASH->CR |= FLASH_CR_STRT;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 80058ea:	0300      	lsls	r0, r0, #12
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  { 
    /* If the previous operation is completed, proceed to erase the page */
    FLASH->CR |= FLASH_CR_PER;
 80058ec:	4333      	orrs	r3, r6
 80058ee:	6123      	str	r3, [r4, #16]
    FLASH->AR  = Page_Address;
    FLASH->CR |= FLASH_CR_STRT;
 80058f0:	2340      	movs	r3, #64	; 0x40
  
  if(status == FLASH_COMPLETE)
  { 
    /* If the previous operation is completed, proceed to erase the page */
    FLASH->CR |= FLASH_CR_PER;
    FLASH->AR  = Page_Address;
 80058f2:	6165      	str	r5, [r4, #20]
    FLASH->CR |= FLASH_CR_STRT;
 80058f4:	6922      	ldr	r2, [r4, #16]
 80058f6:	4313      	orrs	r3, r2
 80058f8:	6123      	str	r3, [r4, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 80058fa:	f7ff ffd5 	bl	80058a8 <FLASH_WaitForLastOperation>
    
    /* Disable the PER Bit */
    FLASH->CR &= ~FLASH_CR_PER;
 80058fe:	6923      	ldr	r3, [r4, #16]
 8005900:	43b3      	bics	r3, r6
 8005902:	6123      	str	r3, [r4, #16]
 8005904:	e7ec      	b.n	80058e0 <FLASH_ErasePage+0x10>
 8005906:	46c0      	nop			; (mov r8, r8)
 8005908:	40022000 	.word	0x40022000

0800590c <FLASH_EraseAllPages>:
FLASH_Status FLASH_EraseAllPages(void)
{
  FLASH_Status status = FLASH_COMPLETE;

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 800590c:	20b0      	movs	r0, #176	; 0xb0
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_EraseAllPages(void)
{
 800590e:	b538      	push	{r3, r4, r5, lr}
  FLASH_Status status = FLASH_COMPLETE;

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005910:	0300      	lsls	r0, r0, #12
 8005912:	f7ff ffc9 	bl	80058a8 <FLASH_WaitForLastOperation>
 8005916:	1e05      	subs	r5, r0, #0
  
  if(status == FLASH_COMPLETE)
 8005918:	2d04      	cmp	r5, #4
 800591a:	d000      	beq.n	800591e <FLASH_EraseAllPages+0x12>
    FLASH->CR &= ~FLASH_CR_MER;
  }

  /* Return the Erase Status */
  return status;
}
 800591c:	bd38      	pop	{r3, r4, r5, pc}
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to erase all pages */
     FLASH->CR |= FLASH_CR_MER;
 800591e:	4c08      	ldr	r4, [pc, #32]	; (8005940 <FLASH_EraseAllPages+0x34>)
 8005920:	6923      	ldr	r3, [r4, #16]
 8005922:	4318      	orrs	r0, r3
     FLASH->CR |= FLASH_CR_STRT;
 8005924:	2340      	movs	r3, #64	; 0x40
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to erase all pages */
     FLASH->CR |= FLASH_CR_MER;
 8005926:	6120      	str	r0, [r4, #16]
     FLASH->CR |= FLASH_CR_STRT;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005928:	20b0      	movs	r0, #176	; 0xb0
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to erase all pages */
     FLASH->CR |= FLASH_CR_MER;
     FLASH->CR |= FLASH_CR_STRT;
 800592a:	6922      	ldr	r2, [r4, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 800592c:	0300      	lsls	r0, r0, #12
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to erase all pages */
     FLASH->CR |= FLASH_CR_MER;
     FLASH->CR |= FLASH_CR_STRT;
 800592e:	4313      	orrs	r3, r2
 8005930:	6123      	str	r3, [r4, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005932:	f7ff ffb9 	bl	80058a8 <FLASH_WaitForLastOperation>

    /* Disable the MER Bit */
    FLASH->CR &= ~FLASH_CR_MER;
 8005936:	6923      	ldr	r3, [r4, #16]
 8005938:	43ab      	bics	r3, r5
 800593a:	6123      	str	r3, [r4, #16]
 800593c:	e7ee      	b.n	800591c <FLASH_EraseAllPages+0x10>
 800593e:	46c0      	nop			; (mov r8, r8)
 8005940:	40022000 	.word	0x40022000

08005944 <FLASH_ProgramWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
 8005944:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005946:	1c05      	adds	r5, r0, #0

  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005948:	20b0      	movs	r0, #176	; 0xb0
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
  FLASH_Status status = FLASH_COMPLETE;
  __IO uint32_t tmp = 0;
 800594a:	2300      	movs	r3, #0
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
 800594c:	b083      	sub	sp, #12

  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 800594e:	0300      	lsls	r0, r0, #12
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
 8005950:	1c0c      	adds	r4, r1, #0
  FLASH_Status status = FLASH_COMPLETE;
  __IO uint32_t tmp = 0;
 8005952:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005954:	f7ff ffa8 	bl	80058a8 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8005958:	2804      	cmp	r0, #4
 800595a:	d001      	beq.n	8005960 <FLASH_ProgramWord+0x1c>
    }
  }
   
  /* Return the Program Status */
  return status;
}
 800595c:	b003      	add	sp, #12
 800595e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  
  if(status == FLASH_COMPLETE)
  {
    /* If the previous operation is completed, proceed to program the new first 
    half word */
    FLASH->CR |= FLASH_CR_PG;
 8005960:	2701      	movs	r7, #1
  
    *(__IO uint16_t*)Address = (uint16_t)Data;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005962:	20b0      	movs	r0, #176	; 0xb0
  
  if(status == FLASH_COMPLETE)
  {
    /* If the previous operation is completed, proceed to program the new first 
    half word */
    FLASH->CR |= FLASH_CR_PG;
 8005964:	4e0d      	ldr	r6, [pc, #52]	; (800599c <FLASH_ProgramWord+0x58>)
  
    *(__IO uint16_t*)Address = (uint16_t)Data;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005966:	0300      	lsls	r0, r0, #12
  
  if(status == FLASH_COMPLETE)
  {
    /* If the previous operation is completed, proceed to program the new first 
    half word */
    FLASH->CR |= FLASH_CR_PG;
 8005968:	6933      	ldr	r3, [r6, #16]
 800596a:	433b      	orrs	r3, r7
 800596c:	6133      	str	r3, [r6, #16]
  
    *(__IO uint16_t*)Address = (uint16_t)Data;
 800596e:	b2a3      	uxth	r3, r4
 8005970:	802b      	strh	r3, [r5, #0]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005972:	f7ff ff99 	bl	80058a8 <FLASH_WaitForLastOperation>
 
    if(status == FLASH_COMPLETE)
 8005976:	2804      	cmp	r0, #4
 8005978:	d003      	beq.n	8005982 <FLASH_ProgramWord+0x3e>
      FLASH->CR &= ~FLASH_CR_PG;
    }
    else
    {
      /* Disable the PG Bit */
      FLASH->CR &= ~FLASH_CR_PG;
 800597a:	6933      	ldr	r3, [r6, #16]
 800597c:	43bb      	bics	r3, r7
 800597e:	6133      	str	r3, [r6, #16]
 8005980:	e7ec      	b.n	800595c <FLASH_ProgramWord+0x18>
      tmp = Address + 2;

      *(__IO uint16_t*) tmp = Data >> 16;
    
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005982:	20b0      	movs	r0, #176	; 0xb0
 
    if(status == FLASH_COMPLETE)
    {
      /* If the previous operation is completed, proceed to program the new second 
      half word */
      tmp = Address + 2;
 8005984:	3502      	adds	r5, #2
 8005986:	9501      	str	r5, [sp, #4]

      *(__IO uint16_t*) tmp = Data >> 16;
 8005988:	9b01      	ldr	r3, [sp, #4]
 800598a:	0c24      	lsrs	r4, r4, #16
 800598c:	801c      	strh	r4, [r3, #0]
    
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 800598e:	0300      	lsls	r0, r0, #12
 8005990:	f7ff ff8a 	bl	80058a8 <FLASH_WaitForLastOperation>
        
      /* Disable the PG Bit */
      FLASH->CR &= ~FLASH_CR_PG;
 8005994:	6933      	ldr	r3, [r6, #16]
 8005996:	43bb      	bics	r3, r7
 8005998:	6133      	str	r3, [r6, #16]
 800599a:	e7df      	b.n	800595c <FLASH_ProgramWord+0x18>
 800599c:	40022000 	.word	0x40022000

080059a0 <FLASH_ProgramHalfWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
{
 80059a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80059a2:	1c04      	adds	r4, r0, #0

  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 80059a4:	20b0      	movs	r0, #176	; 0xb0
 80059a6:	0300      	lsls	r0, r0, #12
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
{
 80059a8:	1c0d      	adds	r5, r1, #0

  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 80059aa:	f7ff ff7d 	bl	80058a8 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 80059ae:	2804      	cmp	r0, #4
 80059b0:	d000      	beq.n	80059b4 <FLASH_ProgramHalfWord+0x14>
    FLASH->CR &= ~FLASH_CR_PG;
  } 
  
  /* Return the Program Status */
  return status;
}
 80059b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {
    /* If the previous operation is completed, proceed to program the new data */
    FLASH->CR |= FLASH_CR_PG;
 80059b4:	2701      	movs	r7, #1
  
    *(__IO uint16_t*)Address = Data;

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 80059b6:	20b0      	movs	r0, #176	; 0xb0
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {
    /* If the previous operation is completed, proceed to program the new data */
    FLASH->CR |= FLASH_CR_PG;
 80059b8:	4e05      	ldr	r6, [pc, #20]	; (80059d0 <FLASH_ProgramHalfWord+0x30>)
  
    *(__IO uint16_t*)Address = Data;

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 80059ba:	0300      	lsls	r0, r0, #12
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {
    /* If the previous operation is completed, proceed to program the new data */
    FLASH->CR |= FLASH_CR_PG;
 80059bc:	6933      	ldr	r3, [r6, #16]
 80059be:	433b      	orrs	r3, r7
 80059c0:	6133      	str	r3, [r6, #16]
  
    *(__IO uint16_t*)Address = Data;
 80059c2:	8025      	strh	r5, [r4, #0]

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 80059c4:	f7ff ff70 	bl	80058a8 <FLASH_WaitForLastOperation>
    
    /* Disable the PG Bit */
    FLASH->CR &= ~FLASH_CR_PG;
 80059c8:	6933      	ldr	r3, [r6, #16]
 80059ca:	43bb      	bics	r3, r7
 80059cc:	6133      	str	r3, [r6, #16]
 80059ce:	e7f0      	b.n	80059b2 <FLASH_ProgramHalfWord+0x12>
 80059d0:	40022000 	.word	0x40022000

080059d4 <FLASH_OB_Erase>:
  */
FlagStatus FLASH_OB_GetRDP(void)
{
  FlagStatus readstatus = RESET;
  
  if ((uint8_t)(FLASH->OBR & (FLASH_OBR_RDPRT1 | FLASH_OBR_RDPRT2)) != RESET)
 80059d4:	2306      	movs	r3, #6
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_OB_Erase(void)
{
 80059d6:	b570      	push	{r4, r5, r6, lr}
  */
FlagStatus FLASH_OB_GetRDP(void)
{
  FlagStatus readstatus = RESET;
  
  if ((uint8_t)(FLASH->OBR & (FLASH_OBR_RDPRT1 | FLASH_OBR_RDPRT2)) != RESET)
 80059d8:	4c1b      	ldr	r4, [pc, #108]	; (8005a48 <FLASH_OB_Erase+0x74>)
  {
    rdptmp = 0x00;  
  }

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 80059da:	20b0      	movs	r0, #176	; 0xb0
  */
FlagStatus FLASH_OB_GetRDP(void)
{
  FlagStatus readstatus = RESET;
  
  if ((uint8_t)(FLASH->OBR & (FLASH_OBR_RDPRT1 | FLASH_OBR_RDPRT2)) != RESET)
 80059dc:	69e2      	ldr	r2, [r4, #28]
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_OB_Erase(void)
{
  uint16_t rdptmp = OB_RDP_Level_0;
 80059de:	25aa      	movs	r5, #170	; 0xaa
  */
FlagStatus FLASH_OB_GetRDP(void)
{
  FlagStatus readstatus = RESET;
  
  if ((uint8_t)(FLASH->OBR & (FLASH_OBR_RDPRT1 | FLASH_OBR_RDPRT2)) != RESET)
 80059e0:	4013      	ands	r3, r2
  FLASH_Status status = FLASH_COMPLETE;

  /* Get the actual read protection Option Byte value */ 
  if(FLASH_OB_GetRDP() != RESET)
  {
    rdptmp = 0x00;  
 80059e2:	425a      	negs	r2, r3
 80059e4:	4153      	adcs	r3, r2
  }

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 80059e6:	0300      	lsls	r0, r0, #12
  FLASH_Status status = FLASH_COMPLETE;

  /* Get the actual read protection Option Byte value */ 
  if(FLASH_OB_GetRDP() != RESET)
  {
    rdptmp = 0x00;  
 80059e8:	425b      	negs	r3, r3
 80059ea:	401d      	ands	r5, r3
  }

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 80059ec:	f7ff ff5c 	bl	80058a8 <FLASH_WaitForLastOperation>

  if(status == FLASH_COMPLETE)
 80059f0:	2804      	cmp	r0, #4
 80059f2:	d000      	beq.n	80059f6 <FLASH_OB_Erase+0x22>
      }
    }  
  }
  /* Return the erase status */
  return status;
}
 80059f4:	bd70      	pop	{r4, r5, r6, pc}
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);

  if(status == FLASH_COMPLETE)
  {   
    /* If the previous operation is completed, proceed to erase the option bytes */
    FLASH->CR |= FLASH_CR_OPTER;
 80059f6:	2620      	movs	r6, #32
 80059f8:	6923      	ldr	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_STRT;

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 80059fa:	20b0      	movs	r0, #176	; 0xb0
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);

  if(status == FLASH_COMPLETE)
  {   
    /* If the previous operation is completed, proceed to erase the option bytes */
    FLASH->CR |= FLASH_CR_OPTER;
 80059fc:	4333      	orrs	r3, r6
 80059fe:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_STRT;
 8005a00:	2340      	movs	r3, #64	; 0x40
 8005a02:	6922      	ldr	r2, [r4, #16]

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005a04:	0300      	lsls	r0, r0, #12

  if(status == FLASH_COMPLETE)
  {   
    /* If the previous operation is completed, proceed to erase the option bytes */
    FLASH->CR |= FLASH_CR_OPTER;
    FLASH->CR |= FLASH_CR_STRT;
 8005a06:	4313      	orrs	r3, r2
 8005a08:	6123      	str	r3, [r4, #16]

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005a0a:	f7ff ff4d 	bl	80058a8 <FLASH_WaitForLastOperation>
    
    if(status == FLASH_COMPLETE)
 8005a0e:	2804      	cmp	r0, #4
 8005a10:	d006      	beq.n	8005a20 <FLASH_OB_Erase+0x4c>
        FLASH->CR &= ~FLASH_CR_OPTPG;
      }
    }
    else
    {
      if (status != FLASH_TIMEOUT)
 8005a12:	2805      	cmp	r0, #5
 8005a14:	d0ee      	beq.n	80059f4 <FLASH_OB_Erase+0x20>
      {
        /* Disable the OPTPG Bit */
        FLASH->CR &= ~FLASH_CR_OPTPG;
 8005a16:	2210      	movs	r2, #16
 8005a18:	6923      	ldr	r3, [r4, #16]
 8005a1a:	4393      	bics	r3, r2
 8005a1c:	6123      	str	r3, [r4, #16]
 8005a1e:	e7e9      	b.n	80059f4 <FLASH_OB_Erase+0x20>

      /* Restore the last read protection Option Byte value */
      OB->RDP = (uint16_t)rdptmp; 

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005a20:	20b0      	movs	r0, #176	; 0xb0
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    
    if(status == FLASH_COMPLETE)
    {
      /* If the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= ~FLASH_CR_OPTER;
 8005a22:	6923      	ldr	r3, [r4, #16]

      /* Restore the last read protection Option Byte value */
      OB->RDP = (uint16_t)rdptmp; 

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005a24:	0300      	lsls	r0, r0, #12
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    
    if(status == FLASH_COMPLETE)
    {
      /* If the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= ~FLASH_CR_OPTER;
 8005a26:	43b3      	bics	r3, r6
 8005a28:	6123      	str	r3, [r4, #16]
       
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= FLASH_CR_OPTPG;
 8005a2a:	6923      	ldr	r3, [r4, #16]
 8005a2c:	3e10      	subs	r6, #16
 8005a2e:	4333      	orrs	r3, r6
 8005a30:	6123      	str	r3, [r4, #16]

      /* Restore the last read protection Option Byte value */
      OB->RDP = (uint16_t)rdptmp; 
 8005a32:	4b06      	ldr	r3, [pc, #24]	; (8005a4c <FLASH_OB_Erase+0x78>)
 8005a34:	801d      	strh	r5, [r3, #0]

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005a36:	f7ff ff37 	bl	80058a8 <FLASH_WaitForLastOperation>
 
      if(status != FLASH_TIMEOUT)
 8005a3a:	2805      	cmp	r0, #5
 8005a3c:	d0da      	beq.n	80059f4 <FLASH_OB_Erase+0x20>
      {
        /* if the program operation is completed, disable the OPTPG Bit */
        FLASH->CR &= ~FLASH_CR_OPTPG;
 8005a3e:	6923      	ldr	r3, [r4, #16]
 8005a40:	43b3      	bics	r3, r6
 8005a42:	6123      	str	r3, [r4, #16]
 8005a44:	e7d6      	b.n	80059f4 <FLASH_OB_Erase+0x20>
 8005a46:	46c0      	nop			; (mov r8, r8)
 8005a48:	40022000 	.word	0x40022000
 8005a4c:	1ffff800 	.word	0x1ffff800

08005a50 <FLASH_OB_EnableWRP>:
  *             @arg OB_WRP_AllPages
  * @retval FLASH Status: The returned value can be: 
  *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_OB_EnableWRP(uint32_t OB_WRP)
{
 8005a50:	b538      	push	{r3, r4, r5, lr}
 8005a52:	1c05      	adds	r5, r0, #0
  WRP1_Data = (uint16_t)((OB_WRP >> 8) & OB_WRP0_WRP0);
  WRP2_Data = (uint16_t)((OB_WRP >> 16) & OB_WRP0_WRP0) ;
  WRP3_Data = (uint16_t)((OB_WRP >> 24) & OB_WRP0_WRP0) ;
    
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005a54:	20b0      	movs	r0, #176	; 0xb0
 8005a56:	0300      	lsls	r0, r0, #12
 8005a58:	f7ff ff26 	bl	80058a8 <FLASH_WaitForLastOperation>
 8005a5c:	1e04      	subs	r4, r0, #0

  if(status == FLASH_COMPLETE)
 8005a5e:	2c04      	cmp	r4, #4
 8005a60:	d001      	beq.n	8005a66 <FLASH_OB_EnableWRP+0x16>
      FLASH->CR &= ~FLASH_CR_OPTPG;
    }
  } 
  /* Return the write protection operation Status */
  return status;
}
 8005a62:	1c20      	adds	r0, r4, #0
 8005a64:	bd38      	pop	{r3, r4, r5, pc}
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);

  if(status == FLASH_COMPLETE)
  {
    FLASH->CR |= FLASH_CR_OPTPG;
 8005a66:	2210      	movs	r2, #16
  FLASH_Status status = FLASH_COMPLETE;

  /* Check the parameters */
  assert_param(IS_OB_WRP(OB_WRP));

  OB_WRP = (uint32_t)(~OB_WRP);
 8005a68:	43ed      	mvns	r5, r5
  WRP0_Data = (uint16_t)(OB_WRP & OB_WRP0_WRP0);
 8005a6a:	23ff      	movs	r3, #255	; 0xff
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);

  if(status == FLASH_COMPLETE)
  {
    FLASH->CR |= FLASH_CR_OPTPG;
 8005a6c:	491d      	ldr	r1, [pc, #116]	; (8005ae4 <FLASH_OB_EnableWRP+0x94>)

  /* Check the parameters */
  assert_param(IS_OB_WRP(OB_WRP));

  OB_WRP = (uint32_t)(~OB_WRP);
  WRP0_Data = (uint16_t)(OB_WRP & OB_WRP0_WRP0);
 8005a6e:	402b      	ands	r3, r5
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);

  if(status == FLASH_COMPLETE)
  {
    FLASH->CR |= FLASH_CR_OPTPG;
 8005a70:	6908      	ldr	r0, [r1, #16]
 8005a72:	4302      	orrs	r2, r0
 8005a74:	610a      	str	r2, [r1, #16]

    if(WRP0_Data != 0xFF)
 8005a76:	2bff      	cmp	r3, #255	; 0xff
 8005a78:	d010      	beq.n	8005a9c <FLASH_OB_EnableWRP+0x4c>
    {
      OB->WRP0 = WRP0_Data;
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005a7a:	20b0      	movs	r0, #176	; 0xb0
  {
    FLASH->CR |= FLASH_CR_OPTPG;

    if(WRP0_Data != 0xFF)
    {
      OB->WRP0 = WRP0_Data;
 8005a7c:	4a1a      	ldr	r2, [pc, #104]	; (8005ae8 <FLASH_OB_EnableWRP+0x98>)
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005a7e:	0300      	lsls	r0, r0, #12
  {
    FLASH->CR |= FLASH_CR_OPTPG;

    if(WRP0_Data != 0xFF)
    {
      OB->WRP0 = WRP0_Data;
 8005a80:	8113      	strh	r3, [r2, #8]
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005a82:	f7ff ff11 	bl	80058a8 <FLASH_WaitForLastOperation>
    }
    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
 8005a86:	2804      	cmp	r0, #4
 8005a88:	d008      	beq.n	8005a9c <FLASH_OB_EnableWRP+0x4c>
    if((status == FLASH_COMPLETE) && (WRP3_Data != 0xFF))
    {
      OB->WRP3 = WRP3_Data;
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005a8a:	1e04      	subs	r4, r0, #0
    }  
    if(status != FLASH_TIMEOUT)
 8005a8c:	2c05      	cmp	r4, #5
 8005a8e:	d0e8      	beq.n	8005a62 <FLASH_OB_EnableWRP+0x12>
    {
      /* if the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= ~FLASH_CR_OPTPG;
 8005a90:	2110      	movs	r1, #16
 8005a92:	4a14      	ldr	r2, [pc, #80]	; (8005ae4 <FLASH_OB_EnableWRP+0x94>)
 8005a94:	6913      	ldr	r3, [r2, #16]
 8005a96:	438b      	bics	r3, r1
 8005a98:	6113      	str	r3, [r2, #16]
 8005a9a:	e7e2      	b.n	8005a62 <FLASH_OB_EnableWRP+0x12>
  /* Check the parameters */
  assert_param(IS_OB_WRP(OB_WRP));

  OB_WRP = (uint32_t)(~OB_WRP);
  WRP0_Data = (uint16_t)(OB_WRP & OB_WRP0_WRP0);
  WRP1_Data = (uint16_t)((OB_WRP >> 8) & OB_WRP0_WRP0);
 8005a9c:	042b      	lsls	r3, r5, #16
 8005a9e:	0e1b      	lsrs	r3, r3, #24
      OB->WRP0 = WRP0_Data;
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    }
    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
 8005aa0:	2bff      	cmp	r3, #255	; 0xff
 8005aa2:	d007      	beq.n	8005ab4 <FLASH_OB_EnableWRP+0x64>
    {
      OB->WRP1 = WRP1_Data;
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005aa4:	20b0      	movs	r0, #176	; 0xb0
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    }
    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
    {
      OB->WRP1 = WRP1_Data;
 8005aa6:	4a10      	ldr	r2, [pc, #64]	; (8005ae8 <FLASH_OB_EnableWRP+0x98>)
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005aa8:	0300      	lsls	r0, r0, #12
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    }
    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
    {
      OB->WRP1 = WRP1_Data;
 8005aaa:	8153      	strh	r3, [r2, #10]
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005aac:	f7ff fefc 	bl	80058a8 <FLASH_WaitForLastOperation>
    }
    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
 8005ab0:	2804      	cmp	r0, #4
 8005ab2:	d1ea      	bne.n	8005a8a <FLASH_OB_EnableWRP+0x3a>
  assert_param(IS_OB_WRP(OB_WRP));

  OB_WRP = (uint32_t)(~OB_WRP);
  WRP0_Data = (uint16_t)(OB_WRP & OB_WRP0_WRP0);
  WRP1_Data = (uint16_t)((OB_WRP >> 8) & OB_WRP0_WRP0);
  WRP2_Data = (uint16_t)((OB_WRP >> 16) & OB_WRP0_WRP0) ;
 8005ab4:	022b      	lsls	r3, r5, #8
 8005ab6:	0e1b      	lsrs	r3, r3, #24
      OB->WRP1 = WRP1_Data;
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    }
    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
 8005ab8:	2bff      	cmp	r3, #255	; 0xff
 8005aba:	d007      	beq.n	8005acc <FLASH_OB_EnableWRP+0x7c>
    {
      OB->WRP2 = WRP2_Data;
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005abc:	20b0      	movs	r0, #176	; 0xb0
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    }
    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
    {
      OB->WRP2 = WRP2_Data;
 8005abe:	4a0a      	ldr	r2, [pc, #40]	; (8005ae8 <FLASH_OB_EnableWRP+0x98>)
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005ac0:	0300      	lsls	r0, r0, #12
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    }
    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
    {
      OB->WRP2 = WRP2_Data;
 8005ac2:	8193      	strh	r3, [r2, #12]
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005ac4:	f7ff fef0 	bl	80058a8 <FLASH_WaitForLastOperation>
    }    
    if((status == FLASH_COMPLETE) && (WRP3_Data != 0xFF))
 8005ac8:	2804      	cmp	r0, #4
 8005aca:	d1de      	bne.n	8005a8a <FLASH_OB_EnableWRP+0x3a>

  OB_WRP = (uint32_t)(~OB_WRP);
  WRP0_Data = (uint16_t)(OB_WRP & OB_WRP0_WRP0);
  WRP1_Data = (uint16_t)((OB_WRP >> 8) & OB_WRP0_WRP0);
  WRP2_Data = (uint16_t)((OB_WRP >> 16) & OB_WRP0_WRP0) ;
  WRP3_Data = (uint16_t)((OB_WRP >> 24) & OB_WRP0_WRP0) ;
 8005acc:	0e2d      	lsrs	r5, r5, #24
 8005ace:	b2ab      	uxth	r3, r5
      OB->WRP2 = WRP2_Data;
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    }    
    if((status == FLASH_COMPLETE) && (WRP3_Data != 0xFF))
 8005ad0:	2dff      	cmp	r5, #255	; 0xff
 8005ad2:	d0dd      	beq.n	8005a90 <FLASH_OB_EnableWRP+0x40>
    {
      OB->WRP3 = WRP3_Data;
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005ad4:	20b0      	movs	r0, #176	; 0xb0
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    }    
    if((status == FLASH_COMPLETE) && (WRP3_Data != 0xFF))
    {
      OB->WRP3 = WRP3_Data;
 8005ad6:	4a04      	ldr	r2, [pc, #16]	; (8005ae8 <FLASH_OB_EnableWRP+0x98>)
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005ad8:	0300      	lsls	r0, r0, #12
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    }    
    if((status == FLASH_COMPLETE) && (WRP3_Data != 0xFF))
    {
      OB->WRP3 = WRP3_Data;
 8005ada:	81d3      	strh	r3, [r2, #14]
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005adc:	f7ff fee4 	bl	80058a8 <FLASH_WaitForLastOperation>
 8005ae0:	e7d3      	b.n	8005a8a <FLASH_OB_EnableWRP+0x3a>
 8005ae2:	46c0      	nop			; (mov r8, r8)
 8005ae4:	40022000 	.word	0x40022000
 8005ae8:	1ffff800 	.word	0x1ffff800

08005aec <FLASH_OB_RDPConfig>:
  * @note   When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
  * @retval FLASH Status: The returned value can be: 
  *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_OB_RDPConfig(uint8_t OB_RDP)
{
 8005aec:	b570      	push	{r4, r5, r6, lr}
 8005aee:	1c05      	adds	r5, r0, #0
  FLASH_Status status = FLASH_COMPLETE;
  
  /* Check the parameters */
  assert_param(IS_OB_RDP(OB_RDP));
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005af0:	20b0      	movs	r0, #176	; 0xb0
 8005af2:	0300      	lsls	r0, r0, #12
 8005af4:	f7ff fed8 	bl	80058a8 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8005af8:	2804      	cmp	r0, #4
 8005afa:	d000      	beq.n	8005afe <FLASH_OB_RDPConfig+0x12>
      }
    }
  }
  /* Return the protection operation Status */
  return status;
}
 8005afc:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_OB_RDP(OB_RDP));
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {
    FLASH->CR |= FLASH_CR_OPTER;
 8005afe:	2620      	movs	r6, #32
 8005b00:	4c12      	ldr	r4, [pc, #72]	; (8005b4c <FLASH_OB_RDPConfig+0x60>)
    FLASH->CR |= FLASH_CR_STRT;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005b02:	20b0      	movs	r0, #176	; 0xb0
  assert_param(IS_OB_RDP(OB_RDP));
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {
    FLASH->CR |= FLASH_CR_OPTER;
 8005b04:	6923      	ldr	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_STRT;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005b06:	0300      	lsls	r0, r0, #12
  assert_param(IS_OB_RDP(OB_RDP));
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {
    FLASH->CR |= FLASH_CR_OPTER;
 8005b08:	4333      	orrs	r3, r6
 8005b0a:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_STRT;
 8005b0c:	2340      	movs	r3, #64	; 0x40
 8005b0e:	6922      	ldr	r2, [r4, #16]
 8005b10:	4313      	orrs	r3, r2
 8005b12:	6123      	str	r3, [r4, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005b14:	f7ff fec8 	bl	80058a8 <FLASH_WaitForLastOperation>
    
    if(status == FLASH_COMPLETE)
 8005b18:	2804      	cmp	r0, #4
 8005b1a:	d005      	beq.n	8005b28 <FLASH_OB_RDPConfig+0x3c>
        FLASH->CR &= ~FLASH_CR_OPTPG;
      }
    }
    else 
    {
      if(status != FLASH_TIMEOUT)
 8005b1c:	2805      	cmp	r0, #5
 8005b1e:	d0ed      	beq.n	8005afc <FLASH_OB_RDPConfig+0x10>
      {
        /* Disable the OPTER Bit */
        FLASH->CR &= ~FLASH_CR_OPTER;
 8005b20:	6923      	ldr	r3, [r4, #16]
 8005b22:	43b3      	bics	r3, r6
 8005b24:	6123      	str	r3, [r4, #16]
 8005b26:	e7e9      	b.n	8005afc <FLASH_OB_RDPConfig+0x10>
      FLASH->CR |= FLASH_CR_OPTPG;
       
      OB->RDP = OB_RDP;

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT); 
 8005b28:	20b0      	movs	r0, #176	; 0xb0
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    
    if(status == FLASH_COMPLETE)
    {
      /* If the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= ~FLASH_CR_OPTER;
 8005b2a:	6923      	ldr	r3, [r4, #16]
      
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= FLASH_CR_OPTPG;
       
      OB->RDP = OB_RDP;
 8005b2c:	b2ad      	uxth	r5, r5
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    
    if(status == FLASH_COMPLETE)
    {
      /* If the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= ~FLASH_CR_OPTER;
 8005b2e:	43b3      	bics	r3, r6
 8005b30:	6123      	str	r3, [r4, #16]
      
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= FLASH_CR_OPTPG;
 8005b32:	6923      	ldr	r3, [r4, #16]
 8005b34:	3e10      	subs	r6, #16
 8005b36:	4333      	orrs	r3, r6
 8005b38:	6123      	str	r3, [r4, #16]
       
      OB->RDP = OB_RDP;
 8005b3a:	4b05      	ldr	r3, [pc, #20]	; (8005b50 <FLASH_OB_RDPConfig+0x64>)

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT); 
 8005b3c:	0300      	lsls	r0, r0, #12
      FLASH->CR &= ~FLASH_CR_OPTER;
      
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= FLASH_CR_OPTPG;
       
      OB->RDP = OB_RDP;
 8005b3e:	801d      	strh	r5, [r3, #0]

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT); 
 8005b40:	f7ff feb2 	bl	80058a8 <FLASH_WaitForLastOperation>
    
      if(status != FLASH_TIMEOUT)
 8005b44:	2805      	cmp	r0, #5
 8005b46:	d1eb      	bne.n	8005b20 <FLASH_OB_RDPConfig+0x34>
 8005b48:	e7d8      	b.n	8005afc <FLASH_OB_RDPConfig+0x10>
 8005b4a:	46c0      	nop			; (mov r8, r8)
 8005b4c:	40022000 	.word	0x40022000
 8005b50:	1ffff800 	.word	0x1ffff800

08005b54 <FLASH_OB_UserConfig>:
  *             @arg OB_STDBY_RST: Reset generated when entering in STANDBY
  * @retval FLASH Status: The returned value can be: 
  *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
{
 8005b54:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005b56:	4647      	mov	r7, r8
 8005b58:	b480      	push	{r7}
 8005b5a:	1c07      	adds	r7, r0, #0
  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005b5c:	20b0      	movs	r0, #176	; 0xb0
 8005b5e:	0300      	lsls	r0, r0, #12
  *             @arg OB_STDBY_RST: Reset generated when entering in STANDBY
  * @retval FLASH Status: The returned value can be: 
  *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
{
 8005b60:	1c0e      	adds	r6, r1, #0
 8005b62:	1c14      	adds	r4, r2, #0
  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005b64:	f7ff fea0 	bl	80058a8 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8005b68:	2804      	cmp	r0, #4
 8005b6a:	d002      	beq.n	8005b72 <FLASH_OB_UserConfig+0x1e>
      FLASH->CR &= ~FLASH_CR_OPTPG;
    }
  }    
  /* Return the Option Byte program Status */
  return status;
}
 8005b6c:	bc04      	pop	{r2}
 8005b6e:	4690      	mov	r8, r2
 8005b70:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005b72:	380c      	subs	r0, #12
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005b74:	2210      	movs	r2, #16
 8005b76:	4320      	orrs	r0, r4
 8005b78:	4330      	orrs	r0, r6

    OB->USER = (uint16_t)((uint16_t)(OB_IWDG | OB_STOP) | (uint16_t)(OB_STDBY | 0xF8));
 8005b7a:	4338      	orrs	r0, r7
 8005b7c:	b2c4      	uxtb	r4, r0
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005b7e:	20b0      	movs	r0, #176	; 0xb0
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005b80:	4d08      	ldr	r5, [pc, #32]	; (8005ba4 <FLASH_OB_UserConfig+0x50>)

    OB->USER = (uint16_t)((uint16_t)(OB_IWDG | OB_STOP) | (uint16_t)(OB_STDBY | 0xF8));
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005b82:	0300      	lsls	r0, r0, #12
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005b84:	692b      	ldr	r3, [r5, #16]
 8005b86:	4690      	mov	r8, r2
 8005b88:	4313      	orrs	r3, r2
 8005b8a:	612b      	str	r3, [r5, #16]

    OB->USER = (uint16_t)((uint16_t)(OB_IWDG | OB_STOP) | (uint16_t)(OB_STDBY | 0xF8));
 8005b8c:	4b06      	ldr	r3, [pc, #24]	; (8005ba8 <FLASH_OB_UserConfig+0x54>)
 8005b8e:	805c      	strh	r4, [r3, #2]
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005b90:	f7ff fe8a 	bl	80058a8 <FLASH_WaitForLastOperation>

    if(status != FLASH_TIMEOUT)
 8005b94:	2805      	cmp	r0, #5
 8005b96:	d0e9      	beq.n	8005b6c <FLASH_OB_UserConfig+0x18>
    {
      /* If the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= ~FLASH_CR_OPTPG;
 8005b98:	4642      	mov	r2, r8
 8005b9a:	692b      	ldr	r3, [r5, #16]
 8005b9c:	4393      	bics	r3, r2
 8005b9e:	612b      	str	r3, [r5, #16]
 8005ba0:	e7e4      	b.n	8005b6c <FLASH_OB_UserConfig+0x18>
 8005ba2:	46c0      	nop			; (mov r8, r8)
 8005ba4:	40022000 	.word	0x40022000
 8005ba8:	1ffff800 	.word	0x1ffff800

08005bac <FLASH_OB_BOOTConfig>:
  *             @arg OB_BOOT1_RESET: BOOT1 option bit reset
  *             @arg OB_BOOT1_SET: BOOT1 option bit set
  * @retval None
  */
FLASH_Status FLASH_OB_BOOTConfig(uint8_t OB_BOOT1)
{
 8005bac:	b570      	push	{r4, r5, r6, lr}
 8005bae:	1c04      	adds	r4, r0, #0

  /* Check the parameters */
  assert_param(IS_OB_BOOT1(OB_BOOT1));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005bb0:	20b0      	movs	r0, #176	; 0xb0
 8005bb2:	0300      	lsls	r0, r0, #12
 8005bb4:	f7ff fe78 	bl	80058a8 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8005bb8:	2804      	cmp	r0, #4
 8005bba:	d000      	beq.n	8005bbe <FLASH_OB_BOOTConfig+0x12>
      FLASH->CR &= ~FLASH_CR_OPTPG;
    }
  }
  /* Return the Option Byte program Status */
  return status;
}
 8005bbc:	bd70      	pop	{r4, r5, r6, pc}
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG;
 8005bbe:	2610      	movs	r6, #16
 8005bc0:	4d08      	ldr	r5, [pc, #32]	; (8005be4 <FLASH_OB_BOOTConfig+0x38>)

    OB->USER = OB_BOOT1 | 0xEF;
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005bc2:	20b0      	movs	r0, #176	; 0xb0
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG;
 8005bc4:	692b      	ldr	r3, [r5, #16]

    OB->USER = OB_BOOT1 | 0xEF;
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005bc6:	0300      	lsls	r0, r0, #12
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG;
 8005bc8:	4333      	orrs	r3, r6
 8005bca:	612b      	str	r3, [r5, #16]

    OB->USER = OB_BOOT1 | 0xEF;
 8005bcc:	23ef      	movs	r3, #239	; 0xef
 8005bce:	431c      	orrs	r4, r3
 8005bd0:	4b05      	ldr	r3, [pc, #20]	; (8005be8 <FLASH_OB_BOOTConfig+0x3c>)
 8005bd2:	805c      	strh	r4, [r3, #2]
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005bd4:	f7ff fe68 	bl	80058a8 <FLASH_WaitForLastOperation>

    if(status != FLASH_TIMEOUT)
 8005bd8:	2805      	cmp	r0, #5
 8005bda:	d0ef      	beq.n	8005bbc <FLASH_OB_BOOTConfig+0x10>
    {
      /* If the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= ~FLASH_CR_OPTPG;
 8005bdc:	692b      	ldr	r3, [r5, #16]
 8005bde:	43b3      	bics	r3, r6
 8005be0:	612b      	str	r3, [r5, #16]
 8005be2:	e7eb      	b.n	8005bbc <FLASH_OB_BOOTConfig+0x10>
 8005be4:	40022000 	.word	0x40022000
 8005be8:	1ffff800 	.word	0x1ffff800

08005bec <FLASH_OB_BOOT0Config>:
  *             @arg OB_BOOT0_RESET: BOOT0 option bit reset
  *             @arg OB_BOOT0_SET: BOOT0 option bit set
  * @retval None
  */
FLASH_Status FLASH_OB_BOOT0Config(uint8_t OB_BOOT0)
{
 8005bec:	b570      	push	{r4, r5, r6, lr}
 8005bee:	1c04      	adds	r4, r0, #0

  /* Check the parameters */
  assert_param(IS_OB_BOOT0(OB_BOOT0));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005bf0:	20b0      	movs	r0, #176	; 0xb0
 8005bf2:	0300      	lsls	r0, r0, #12
 8005bf4:	f7ff fe58 	bl	80058a8 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8005bf8:	2804      	cmp	r0, #4
 8005bfa:	d000      	beq.n	8005bfe <FLASH_OB_BOOT0Config+0x12>
      FLASH->CR &= ~FLASH_CR_OPTPG;
    }
  }
  /* Return the Option Byte program Status */
  return status;
}
 8005bfc:	bd70      	pop	{r4, r5, r6, pc}
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG;
 8005bfe:	2610      	movs	r6, #16
 8005c00:	4d08      	ldr	r5, [pc, #32]	; (8005c24 <FLASH_OB_BOOT0Config+0x38>)

    OB->USER = OB_BOOT0 | 0xF7;
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005c02:	20b0      	movs	r0, #176	; 0xb0
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG;
 8005c04:	692b      	ldr	r3, [r5, #16]

    OB->USER = OB_BOOT0 | 0xF7;
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005c06:	0300      	lsls	r0, r0, #12
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG;
 8005c08:	4333      	orrs	r3, r6
 8005c0a:	612b      	str	r3, [r5, #16]

    OB->USER = OB_BOOT0 | 0xF7;
 8005c0c:	23f7      	movs	r3, #247	; 0xf7
 8005c0e:	431c      	orrs	r4, r3
 8005c10:	4b05      	ldr	r3, [pc, #20]	; (8005c28 <FLASH_OB_BOOT0Config+0x3c>)
 8005c12:	805c      	strh	r4, [r3, #2]
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005c14:	f7ff fe48 	bl	80058a8 <FLASH_WaitForLastOperation>

    if(status != FLASH_TIMEOUT)
 8005c18:	2805      	cmp	r0, #5
 8005c1a:	d0ef      	beq.n	8005bfc <FLASH_OB_BOOT0Config+0x10>
    {
      /* If the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= ~FLASH_CR_OPTPG;
 8005c1c:	692b      	ldr	r3, [r5, #16]
 8005c1e:	43b3      	bics	r3, r6
 8005c20:	612b      	str	r3, [r5, #16]
 8005c22:	e7eb      	b.n	8005bfc <FLASH_OB_BOOT0Config+0x10>
 8005c24:	40022000 	.word	0x40022000
 8005c28:	1ffff800 	.word	0x1ffff800

08005c2c <FLASH_OB_BOOT0SWConfig>:
  *             @arg OB_BOOT0_SW: BOOT0_SW option bit reset
  *             @arg OB_BOOT0_HW: BOOT0_SW option bit set
  * @retval None
  */
FLASH_Status FLASH_OB_BOOT0SWConfig(uint8_t OB_BOOT0SW)
{
 8005c2c:	b570      	push	{r4, r5, r6, lr}
 8005c2e:	1c04      	adds	r4, r0, #0

  /* Check the parameters */
  assert_param(IS_OB_BOOT0SW(OB_BOOT0SW));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005c30:	20b0      	movs	r0, #176	; 0xb0
 8005c32:	0300      	lsls	r0, r0, #12
 8005c34:	f7ff fe38 	bl	80058a8 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8005c38:	2804      	cmp	r0, #4
 8005c3a:	d000      	beq.n	8005c3e <FLASH_OB_BOOT0SWConfig+0x12>
      FLASH->CR &= ~FLASH_CR_OPTPG;
    }
  }
  /* Return the Option Byte program Status */
  return status;
}
 8005c3c:	bd70      	pop	{r4, r5, r6, pc}
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG;
 8005c3e:	2610      	movs	r6, #16
 8005c40:	4d08      	ldr	r5, [pc, #32]	; (8005c64 <FLASH_OB_BOOT0SWConfig+0x38>)

    OB->USER = OB_BOOT0SW | 0x7F;
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005c42:	20b0      	movs	r0, #176	; 0xb0
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG;
 8005c44:	692b      	ldr	r3, [r5, #16]

    OB->USER = OB_BOOT0SW | 0x7F;
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005c46:	0300      	lsls	r0, r0, #12
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG;
 8005c48:	4333      	orrs	r3, r6
 8005c4a:	612b      	str	r3, [r5, #16]

    OB->USER = OB_BOOT0SW | 0x7F;
 8005c4c:	237f      	movs	r3, #127	; 0x7f
 8005c4e:	431c      	orrs	r4, r3
 8005c50:	4b05      	ldr	r3, [pc, #20]	; (8005c68 <FLASH_OB_BOOT0SWConfig+0x3c>)
 8005c52:	805c      	strh	r4, [r3, #2]
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005c54:	f7ff fe28 	bl	80058a8 <FLASH_WaitForLastOperation>

    if(status != FLASH_TIMEOUT)
 8005c58:	2805      	cmp	r0, #5
 8005c5a:	d0ef      	beq.n	8005c3c <FLASH_OB_BOOT0SWConfig+0x10>
    {
      /* If the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= ~FLASH_CR_OPTPG;
 8005c5c:	692b      	ldr	r3, [r5, #16]
 8005c5e:	43b3      	bics	r3, r6
 8005c60:	612b      	str	r3, [r5, #16]
 8005c62:	e7eb      	b.n	8005c3c <FLASH_OB_BOOT0SWConfig+0x10>
 8005c64:	40022000 	.word	0x40022000
 8005c68:	1ffff800 	.word	0x1ffff800

08005c6c <FLASH_OB_VDDAConfig>:
  *             @arg OB_VDDA_ANALOG_ON: Analog monitoring on VDDA Power source ON
  *             @arg OB_VDDA_ANALOG_OFF: Analog monitoring on VDDA Power source OFF
  * @retval None
  */
FLASH_Status FLASH_OB_VDDAConfig(uint8_t OB_VDDA_ANALOG)
{
 8005c6c:	b570      	push	{r4, r5, r6, lr}
 8005c6e:	1c04      	adds	r4, r0, #0

  /* Check the parameters */
  assert_param(IS_OB_VDDA_ANALOG(OB_VDDA_ANALOG));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005c70:	20b0      	movs	r0, #176	; 0xb0
 8005c72:	0300      	lsls	r0, r0, #12
 8005c74:	f7ff fe18 	bl	80058a8 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8005c78:	2804      	cmp	r0, #4
 8005c7a:	d000      	beq.n	8005c7e <FLASH_OB_VDDAConfig+0x12>
      FLASH->CR &= ~FLASH_CR_OPTPG;
    }
  }
  /* Return the Option Byte program Status */
  return status;
}
 8005c7c:	bd70      	pop	{r4, r5, r6, pc}
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005c7e:	2610      	movs	r6, #16
 8005c80:	4d08      	ldr	r5, [pc, #32]	; (8005ca4 <FLASH_OB_VDDAConfig+0x38>)

    OB->USER = OB_VDDA_ANALOG | 0xDF;
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005c82:	20b0      	movs	r0, #176	; 0xb0
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005c84:	692b      	ldr	r3, [r5, #16]

    OB->USER = OB_VDDA_ANALOG | 0xDF;
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005c86:	0300      	lsls	r0, r0, #12
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005c88:	4333      	orrs	r3, r6
 8005c8a:	612b      	str	r3, [r5, #16]

    OB->USER = OB_VDDA_ANALOG | 0xDF;
 8005c8c:	23df      	movs	r3, #223	; 0xdf
 8005c8e:	431c      	orrs	r4, r3
 8005c90:	4b05      	ldr	r3, [pc, #20]	; (8005ca8 <FLASH_OB_VDDAConfig+0x3c>)
 8005c92:	805c      	strh	r4, [r3, #2]
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005c94:	f7ff fe08 	bl	80058a8 <FLASH_WaitForLastOperation>

    if(status != FLASH_TIMEOUT)
 8005c98:	2805      	cmp	r0, #5
 8005c9a:	d0ef      	beq.n	8005c7c <FLASH_OB_VDDAConfig+0x10>
    {
      /* if the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= ~FLASH_CR_OPTPG;
 8005c9c:	692b      	ldr	r3, [r5, #16]
 8005c9e:	43b3      	bics	r3, r6
 8005ca0:	612b      	str	r3, [r5, #16]
 8005ca2:	e7eb      	b.n	8005c7c <FLASH_OB_VDDAConfig+0x10>
 8005ca4:	40022000 	.word	0x40022000
 8005ca8:	1ffff800 	.word	0x1ffff800

08005cac <FLASH_OB_SRAMParityConfig>:
  *             @arg OB_SRAM_PARITY_SET: Set SRAM parity.
  *             @arg OB_SRAM_PARITY_RESET: Reset SRAM parity.
  * @retval None
  */
FLASH_Status FLASH_OB_SRAMParityConfig(uint8_t OB_SRAM_Parity)
{
 8005cac:	b570      	push	{r4, r5, r6, lr}
 8005cae:	1c04      	adds	r4, r0, #0

  /* Check the parameters */
  assert_param(IS_OB_SRAM_PARITY(OB_SRAM_Parity));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005cb0:	20b0      	movs	r0, #176	; 0xb0
 8005cb2:	0300      	lsls	r0, r0, #12
 8005cb4:	f7ff fdf8 	bl	80058a8 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8005cb8:	2804      	cmp	r0, #4
 8005cba:	d000      	beq.n	8005cbe <FLASH_OB_SRAMParityConfig+0x12>
      FLASH->CR &= ~FLASH_CR_OPTPG;
    }
  }
  /* Return the Option Byte program Status */
  return status;
}
 8005cbc:	bd70      	pop	{r4, r5, r6, pc}
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005cbe:	2610      	movs	r6, #16
 8005cc0:	4d08      	ldr	r5, [pc, #32]	; (8005ce4 <FLASH_OB_SRAMParityConfig+0x38>)

    OB->USER = OB_SRAM_Parity | 0xBF;
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005cc2:	20b0      	movs	r0, #176	; 0xb0
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005cc4:	692b      	ldr	r3, [r5, #16]

    OB->USER = OB_SRAM_Parity | 0xBF;
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005cc6:	0300      	lsls	r0, r0, #12
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005cc8:	4333      	orrs	r3, r6
 8005cca:	612b      	str	r3, [r5, #16]

    OB->USER = OB_SRAM_Parity | 0xBF;
 8005ccc:	23bf      	movs	r3, #191	; 0xbf
 8005cce:	431c      	orrs	r4, r3
 8005cd0:	4b05      	ldr	r3, [pc, #20]	; (8005ce8 <FLASH_OB_SRAMParityConfig+0x3c>)
 8005cd2:	805c      	strh	r4, [r3, #2]
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005cd4:	f7ff fde8 	bl	80058a8 <FLASH_WaitForLastOperation>

    if(status != FLASH_TIMEOUT)
 8005cd8:	2805      	cmp	r0, #5
 8005cda:	d0ef      	beq.n	8005cbc <FLASH_OB_SRAMParityConfig+0x10>
    {
      /* if the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= ~FLASH_CR_OPTPG;
 8005cdc:	692b      	ldr	r3, [r5, #16]
 8005cde:	43b3      	bics	r3, r6
 8005ce0:	612b      	str	r3, [r5, #16]
 8005ce2:	e7eb      	b.n	8005cbc <FLASH_OB_SRAMParityConfig+0x10>
 8005ce4:	40022000 	.word	0x40022000
 8005ce8:	1ffff800 	.word	0x1ffff800

08005cec <FLASH_OB_WriteUser>:
  *             @arg OB_BOOT0_SW / OB_BOOT0_SW: BOOT0 pin disabled / BOOT0 pin bonded with GPIO      
  * @retval FLASH Status: The returned value can be: 
  *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_OB_WriteUser(uint8_t OB_USER)
{
 8005cec:	b570      	push	{r4, r5, r6, lr}
 8005cee:	1c04      	adds	r4, r0, #0
  FLASH_Status status = FLASH_COMPLETE; 

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005cf0:	20b0      	movs	r0, #176	; 0xb0
 8005cf2:	0300      	lsls	r0, r0, #12
 8005cf4:	f7ff fdd8 	bl	80058a8 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8005cf8:	2804      	cmp	r0, #4
 8005cfa:	d000      	beq.n	8005cfe <FLASH_OB_WriteUser+0x12>
    }
  }    
  /* Return the Option Byte program Status */
  return status;

}
 8005cfc:	bd70      	pop	{r4, r5, r6, pc}
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005cfe:	2610      	movs	r6, #16

    OB->USER = OB_USER;
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005d00:	20b0      	movs	r0, #176	; 0xb0
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005d02:	4d08      	ldr	r5, [pc, #32]	; (8005d24 <FLASH_OB_WriteUser+0x38>)

    OB->USER = OB_USER;
 8005d04:	b2a4      	uxth	r4, r4
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005d06:	692b      	ldr	r3, [r5, #16]

    OB->USER = OB_USER;
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005d08:	0300      	lsls	r0, r0, #12
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
  
  if(status == FLASH_COMPLETE)
  {
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005d0a:	4333      	orrs	r3, r6
 8005d0c:	612b      	str	r3, [r5, #16]

    OB->USER = OB_USER;
 8005d0e:	4b06      	ldr	r3, [pc, #24]	; (8005d28 <FLASH_OB_WriteUser+0x3c>)
 8005d10:	805c      	strh	r4, [r3, #2]
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005d12:	f7ff fdc9 	bl	80058a8 <FLASH_WaitForLastOperation>

    if(status != FLASH_TIMEOUT)
 8005d16:	2805      	cmp	r0, #5
 8005d18:	d0f0      	beq.n	8005cfc <FLASH_OB_WriteUser+0x10>
    {
      /* If the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= ~FLASH_CR_OPTPG;
 8005d1a:	692b      	ldr	r3, [r5, #16]
 8005d1c:	43b3      	bics	r3, r6
 8005d1e:	612b      	str	r3, [r5, #16]
 8005d20:	e7ec      	b.n	8005cfc <FLASH_OB_WriteUser+0x10>
 8005d22:	46c0      	nop			; (mov r8, r8)
 8005d24:	40022000 	.word	0x40022000
 8005d28:	1ffff800 	.word	0x1ffff800

08005d2c <FLASH_OB_ProgramData>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_OB_ProgramData(uint32_t Address, uint8_t Data)
{
 8005d2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005d2e:	1c05      	adds	r5, r0, #0
  FLASH_Status status = FLASH_COMPLETE;
  /* Check the parameters */
  assert_param(IS_OB_DATA_ADDRESS(Address));
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005d30:	20b0      	movs	r0, #176	; 0xb0
 8005d32:	0300      	lsls	r0, r0, #12
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_OB_ProgramData(uint32_t Address, uint8_t Data)
{
 8005d34:	1c0c      	adds	r4, r1, #0
  FLASH_Status status = FLASH_COMPLETE;
  /* Check the parameters */
  assert_param(IS_OB_DATA_ADDRESS(Address));
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005d36:	f7ff fdb7 	bl	80058a8 <FLASH_WaitForLastOperation>

  if(status == FLASH_COMPLETE)
 8005d3a:	2804      	cmp	r0, #4
 8005d3c:	d000      	beq.n	8005d40 <FLASH_OB_ProgramData+0x14>
      FLASH->CR &= ~FLASH_CR_OPTPG;
    }
  }
  /* Return the Option Byte Data Program Status */
  return status;
}
 8005d3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);

  if(status == FLASH_COMPLETE)
  {
    /* Enables the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005d40:	2710      	movs	r7, #16
    *(__IO uint16_t*)Address = Data;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005d42:	20b0      	movs	r0, #176	; 0xb0
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);

  if(status == FLASH_COMPLETE)
  {
    /* Enables the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005d44:	4e07      	ldr	r6, [pc, #28]	; (8005d64 <FLASH_OB_ProgramData+0x38>)
    *(__IO uint16_t*)Address = Data;
 8005d46:	b2a4      	uxth	r4, r4
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);

  if(status == FLASH_COMPLETE)
  {
    /* Enables the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005d48:	6933      	ldr	r3, [r6, #16]
    *(__IO uint16_t*)Address = Data;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005d4a:	0300      	lsls	r0, r0, #12
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);

  if(status == FLASH_COMPLETE)
  {
    /* Enables the Option Bytes Programming operation */
    FLASH->CR |= FLASH_CR_OPTPG; 
 8005d4c:	433b      	orrs	r3, r7
 8005d4e:	6133      	str	r3, [r6, #16]
    *(__IO uint16_t*)Address = Data;
 8005d50:	802c      	strh	r4, [r5, #0]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8005d52:	f7ff fda9 	bl	80058a8 <FLASH_WaitForLastOperation>
    
    if(status != FLASH_TIMEOUT)
 8005d56:	2805      	cmp	r0, #5
 8005d58:	d0f1      	beq.n	8005d3e <FLASH_OB_ProgramData+0x12>
    {
      /* If the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= ~FLASH_CR_OPTPG;
 8005d5a:	6933      	ldr	r3, [r6, #16]
 8005d5c:	43bb      	bics	r3, r7
 8005d5e:	6133      	str	r3, [r6, #16]
 8005d60:	e7ed      	b.n	8005d3e <FLASH_OB_ProgramData+0x12>
 8005d62:	46c0      	nop			; (mov r8, r8)
 8005d64:	40022000 	.word	0x40022000

08005d68 <GPIO_DeInit>:
  * @note   GPIOE is available only for STM32F072.
  * @note   GPIOD is not available for STM32F031.    
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 8005d68:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if(GPIOx == GPIOA)
 8005d6a:	2390      	movs	r3, #144	; 0x90
 8005d6c:	05db      	lsls	r3, r3, #23
 8005d6e:	4298      	cmp	r0, r3
 8005d70:	d01a      	beq.n	8005da8 <GPIO_DeInit+0x40>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOA, ENABLE);
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOA, DISABLE);
  }
  else if(GPIOx == GPIOB)
 8005d72:	4b29      	ldr	r3, [pc, #164]	; (8005e18 <GPIO_DeInit+0xb0>)
 8005d74:	4298      	cmp	r0, r3
 8005d76:	d022      	beq.n	8005dbe <GPIO_DeInit+0x56>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOB, ENABLE);
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOB, DISABLE);
  }
  else if(GPIOx == GPIOC)
 8005d78:	4b28      	ldr	r3, [pc, #160]	; (8005e1c <GPIO_DeInit+0xb4>)
 8005d7a:	4298      	cmp	r0, r3
 8005d7c:	d02a      	beq.n	8005dd4 <GPIO_DeInit+0x6c>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOC, ENABLE);
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOC, DISABLE);
  }
  else if(GPIOx == GPIOD)
 8005d7e:	4b28      	ldr	r3, [pc, #160]	; (8005e20 <GPIO_DeInit+0xb8>)
 8005d80:	4298      	cmp	r0, r3
 8005d82:	d032      	beq.n	8005dea <GPIO_DeInit+0x82>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOD, ENABLE);
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOD, DISABLE);
  }
  else if(GPIOx == GPIOE)
 8005d84:	4b27      	ldr	r3, [pc, #156]	; (8005e24 <GPIO_DeInit+0xbc>)
 8005d86:	4298      	cmp	r0, r3
 8005d88:	d03a      	beq.n	8005e00 <GPIO_DeInit+0x98>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOE, ENABLE);
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOE, DISABLE);
  }
  else
  {
    if(GPIOx == GPIOF)
 8005d8a:	4b27      	ldr	r3, [pc, #156]	; (8005e28 <GPIO_DeInit+0xc0>)
 8005d8c:	4298      	cmp	r0, r3
 8005d8e:	d000      	beq.n	8005d92 <GPIO_DeInit+0x2a>
    {
      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, ENABLE);
      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, DISABLE);
    }
  }
}
 8005d90:	bd08      	pop	{r3, pc}
  }
  else
  {
    if(GPIOx == GPIOF)
    {
      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, ENABLE);
 8005d92:	2080      	movs	r0, #128	; 0x80
 8005d94:	2101      	movs	r1, #1
 8005d96:	03c0      	lsls	r0, r0, #15
 8005d98:	f000 fc86 	bl	80066a8 <RCC_AHBPeriphResetCmd>
      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, DISABLE);
 8005d9c:	2080      	movs	r0, #128	; 0x80
 8005d9e:	2100      	movs	r1, #0
 8005da0:	03c0      	lsls	r0, r0, #15
 8005da2:	f000 fc81 	bl	80066a8 <RCC_AHBPeriphResetCmd>
 8005da6:	e7f3      	b.n	8005d90 <GPIO_DeInit+0x28>
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if(GPIOx == GPIOA)
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8005da8:	2080      	movs	r0, #128	; 0x80
 8005daa:	2101      	movs	r1, #1
 8005dac:	0280      	lsls	r0, r0, #10
 8005dae:	f000 fc7b 	bl	80066a8 <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOA, DISABLE);
 8005db2:	2080      	movs	r0, #128	; 0x80
 8005db4:	2100      	movs	r1, #0
 8005db6:	0280      	lsls	r0, r0, #10
 8005db8:	f000 fc76 	bl	80066a8 <RCC_AHBPeriphResetCmd>
 8005dbc:	e7e8      	b.n	8005d90 <GPIO_DeInit+0x28>
  }
  else if(GPIOx == GPIOB)
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 8005dbe:	2080      	movs	r0, #128	; 0x80
 8005dc0:	2101      	movs	r1, #1
 8005dc2:	02c0      	lsls	r0, r0, #11
 8005dc4:	f000 fc70 	bl	80066a8 <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOB, DISABLE);
 8005dc8:	2080      	movs	r0, #128	; 0x80
 8005dca:	2100      	movs	r1, #0
 8005dcc:	02c0      	lsls	r0, r0, #11
 8005dce:	f000 fc6b 	bl	80066a8 <RCC_AHBPeriphResetCmd>
 8005dd2:	e7dd      	b.n	8005d90 <GPIO_DeInit+0x28>
  }
  else if(GPIOx == GPIOC)
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOC, ENABLE);
 8005dd4:	2080      	movs	r0, #128	; 0x80
 8005dd6:	2101      	movs	r1, #1
 8005dd8:	0300      	lsls	r0, r0, #12
 8005dda:	f000 fc65 	bl	80066a8 <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOC, DISABLE);
 8005dde:	2080      	movs	r0, #128	; 0x80
 8005de0:	2100      	movs	r1, #0
 8005de2:	0300      	lsls	r0, r0, #12
 8005de4:	f000 fc60 	bl	80066a8 <RCC_AHBPeriphResetCmd>
 8005de8:	e7d2      	b.n	8005d90 <GPIO_DeInit+0x28>
  }
  else if(GPIOx == GPIOD)
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOD, ENABLE);
 8005dea:	2080      	movs	r0, #128	; 0x80
 8005dec:	2101      	movs	r1, #1
 8005dee:	0340      	lsls	r0, r0, #13
 8005df0:	f000 fc5a 	bl	80066a8 <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOD, DISABLE);
 8005df4:	2080      	movs	r0, #128	; 0x80
 8005df6:	2100      	movs	r1, #0
 8005df8:	0340      	lsls	r0, r0, #13
 8005dfa:	f000 fc55 	bl	80066a8 <RCC_AHBPeriphResetCmd>
 8005dfe:	e7c7      	b.n	8005d90 <GPIO_DeInit+0x28>
  }
  else if(GPIOx == GPIOE)
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOE, ENABLE);
 8005e00:	2080      	movs	r0, #128	; 0x80
 8005e02:	2101      	movs	r1, #1
 8005e04:	0380      	lsls	r0, r0, #14
 8005e06:	f000 fc4f 	bl	80066a8 <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOE, DISABLE);
 8005e0a:	2080      	movs	r0, #128	; 0x80
 8005e0c:	2100      	movs	r1, #0
 8005e0e:	0380      	lsls	r0, r0, #14
 8005e10:	f000 fc4a 	bl	80066a8 <RCC_AHBPeriphResetCmd>
 8005e14:	e7bc      	b.n	8005d90 <GPIO_DeInit+0x28>
 8005e16:	46c0      	nop			; (mov r8, r8)
 8005e18:	48000400 	.word	0x48000400
 8005e1c:	48000800 	.word	0x48000800
 8005e20:	48000c00 	.word	0x48000c00
 8005e24:	48001000 	.word	0x48001000
 8005e28:	48001400 	.word	0x48001400

08005e2c <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8005e2c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005e2e:	4644      	mov	r4, r8
 8005e30:	465f      	mov	r7, fp
 8005e32:	4656      	mov	r6, sl
 8005e34:	464d      	mov	r5, r9
 8005e36:	b4f0      	push	{r4, r5, r6, r7}
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));

      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));

      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8005e38:	2403      	movs	r4, #3
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8005e3a:	468c      	mov	ip, r1
 8005e3c:	b083      	sub	sp, #12
 8005e3e:	6809      	ldr	r1, [r1, #0]
 8005e40:	2200      	movs	r2, #0
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /*-------------------------- Configure the port pins -----------------------*/
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8005e42:	2300      	movs	r3, #0
  {
    pos = ((uint32_t)0x01) << pinpos;
 8005e44:	2701      	movs	r7, #1
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));

      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));

      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8005e46:	46a0      	mov	r8, r4
 8005e48:	e003      	b.n	8005e52 <GPIO_Init+0x26>
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /*-------------------------- Configure the port pins -----------------------*/
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8005e4a:	3301      	adds	r3, #1
 8005e4c:	3202      	adds	r2, #2
 8005e4e:	2b10      	cmp	r3, #16
 8005e50:	d027      	beq.n	8005ea2 <GPIO_Init+0x76>
  {
    pos = ((uint32_t)0x01) << pinpos;
 8005e52:	1c3c      	adds	r4, r7, #0

    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8005e54:	1c0d      	adds	r5, r1, #0

  /*-------------------------- Configure the port pins -----------------------*/
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
  {
    pos = ((uint32_t)0x01) << pinpos;
 8005e56:	409c      	lsls	r4, r3

    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8005e58:	4025      	ands	r5, r4

    if (currentpin == pos)
 8005e5a:	42a5      	cmp	r5, r4
 8005e5c:	d1f5      	bne.n	8005e4a <GPIO_Init+0x1e>
    {
      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8005e5e:	4664      	mov	r4, ip
 8005e60:	7924      	ldrb	r4, [r4, #4]
 8005e62:	46a3      	mov	fp, r4
 8005e64:	3c01      	subs	r4, #1
 8005e66:	2c01      	cmp	r4, #1
 8005e68:	d922      	bls.n	8005eb0 <GPIO_Init+0x84>
 8005e6a:	4644      	mov	r4, r8
 8005e6c:	4094      	lsls	r4, r2
 8005e6e:	43e4      	mvns	r4, r4
 8005e70:	9401      	str	r4, [sp, #4]
        /* Output mode configuration */
        GPIOx->OTYPER &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos));
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8005e72:	6805      	ldr	r5, [r0, #0]
 8005e74:	9c01      	ldr	r4, [sp, #4]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /*-------------------------- Configure the port pins -----------------------*/
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8005e76:	3301      	adds	r3, #1
        /* Output mode configuration */
        GPIOx->OTYPER &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos));
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8005e78:	402c      	ands	r4, r5
 8005e7a:	6004      	str	r4, [r0, #0]

      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8005e7c:	465c      	mov	r4, fp
 8005e7e:	4094      	lsls	r4, r2
 8005e80:	6805      	ldr	r5, [r0, #0]
 8005e82:	432c      	orrs	r4, r5

      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8005e84:	4645      	mov	r5, r8
 8005e86:	4095      	lsls	r5, r2
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));

      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8005e88:	6004      	str	r4, [r0, #0]

      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8005e8a:	68c4      	ldr	r4, [r0, #12]
 8005e8c:	43ac      	bics	r4, r5
 8005e8e:	60c4      	str	r4, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8005e90:	4664      	mov	r4, ip
 8005e92:	79e4      	ldrb	r4, [r4, #7]
 8005e94:	68c5      	ldr	r5, [r0, #12]
 8005e96:	4094      	lsls	r4, r2
 8005e98:	432c      	orrs	r4, r5
 8005e9a:	60c4      	str	r4, [r0, #12]
 8005e9c:	3202      	adds	r2, #2
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /*-------------------------- Configure the port pins -----------------------*/
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8005e9e:	2b10      	cmp	r3, #16
 8005ea0:	d1d7      	bne.n	8005e52 <GPIO_Init+0x26>
      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 8005ea2:	b003      	add	sp, #12
 8005ea4:	bc3c      	pop	{r2, r3, r4, r5}
 8005ea6:	4690      	mov	r8, r2
 8005ea8:	4699      	mov	r9, r3
 8005eaa:	46a2      	mov	sl, r4
 8005eac:	46ab      	mov	fp, r5
 8005eae:	bdf0      	pop	{r4, r5, r6, r7, pc}
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8005eb0:	6884      	ldr	r4, [r0, #8]
 8005eb2:	46a1      	mov	r9, r4
 8005eb4:	4644      	mov	r4, r8
 8005eb6:	4094      	lsls	r4, r2
 8005eb8:	464e      	mov	r6, r9
 8005eba:	43e4      	mvns	r4, r4
 8005ebc:	4026      	ands	r6, r4
 8005ebe:	6086      	str	r6, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8005ec0:	6886      	ldr	r6, [r0, #8]
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8005ec2:	9401      	str	r4, [sp, #4]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8005ec4:	46b2      	mov	sl, r6
 8005ec6:	4666      	mov	r6, ip
 8005ec8:	7976      	ldrb	r6, [r6, #5]
 8005eca:	4096      	lsls	r6, r2
 8005ecc:	46b1      	mov	r9, r6
 8005ece:	4656      	mov	r6, sl
 8005ed0:	464c      	mov	r4, r9
 8005ed2:	4326      	orrs	r6, r4
 8005ed4:	6086      	str	r6, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration */
        GPIOx->OTYPER &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos));
 8005ed6:	8884      	ldrh	r4, [r0, #4]
 8005ed8:	1c26      	adds	r6, r4, #0
 8005eda:	43ae      	bics	r6, r5
 8005edc:	8086      	strh	r6, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8005ede:	8884      	ldrh	r4, [r0, #4]
 8005ee0:	46a1      	mov	r9, r4
 8005ee2:	4664      	mov	r4, ip
 8005ee4:	79a5      	ldrb	r5, [r4, #6]
 8005ee6:	464c      	mov	r4, r9
 8005ee8:	409d      	lsls	r5, r3
 8005eea:	4325      	orrs	r5, r4
 8005eec:	b2ad      	uxth	r5, r5
 8005eee:	8085      	strh	r5, [r0, #4]
 8005ef0:	e7bf      	b.n	8005e72 <GPIO_Init+0x46>
 8005ef2:	46c0      	nop			; (mov r8, r8)

08005ef4 <GPIO_StructInit>:
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 8005ef4:	4b04      	ldr	r3, [pc, #16]	; (8005f08 <GPIO_StructInit+0x14>)
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_Level_2;
 8005ef6:	2201      	movs	r2, #1
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 8005ef8:	6003      	str	r3, [r0, #0]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 8005efa:	2300      	movs	r3, #0
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_Level_2;
 8005efc:	7142      	strb	r2, [r0, #5]
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 8005efe:	7103      	strb	r3, [r0, #4]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_Level_2;
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
 8005f00:	7183      	strb	r3, [r0, #6]
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
 8005f02:	71c3      	strb	r3, [r0, #7]
}
 8005f04:	4770      	bx	lr
 8005f06:	46c0      	nop			; (mov r8, r8)
 8005f08:	0000ffff 	.word	0x0000ffff

08005f0c <GPIO_PinLockConfig>:
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  __IO uint32_t tmp = 0x00010000;
 8005f0c:	2380      	movs	r3, #128	; 0x80
  * @param  GPIO_Pin: specifies the port bit to be written.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8005f0e:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0x00010000;
 8005f10:	025b      	lsls	r3, r3, #9
 8005f12:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_GPIO_LIST_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  tmp |= GPIO_Pin;
 8005f14:	9b01      	ldr	r3, [sp, #4]
 8005f16:	430b      	orrs	r3, r1
 8005f18:	9301      	str	r3, [sp, #4]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8005f1a:	9b01      	ldr	r3, [sp, #4]
 8005f1c:	61c3      	str	r3, [r0, #28]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 8005f1e:	61c1      	str	r1, [r0, #28]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8005f20:	9b01      	ldr	r3, [sp, #4]
 8005f22:	61c3      	str	r3, [r0, #28]
  /* Read LCKK bit */
  tmp = GPIOx->LCKR;
 8005f24:	69c3      	ldr	r3, [r0, #28]
 8005f26:	9301      	str	r3, [sp, #4]
  /* Read LCKK bit */
  tmp = GPIOx->LCKR;
 8005f28:	69c3      	ldr	r3, [r0, #28]
 8005f2a:	9301      	str	r3, [sp, #4]
}
 8005f2c:	b002      	add	sp, #8
 8005f2e:	4770      	bx	lr

08005f30 <GPIO_ReadInputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8005f30:	8a00      	ldrh	r0, [r0, #16]
 8005f32:	4008      	ands	r0, r1
 8005f34:	1e41      	subs	r1, r0, #1
 8005f36:	4188      	sbcs	r0, r1
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
 8005f38:	b2c0      	uxtb	r0, r0
}
 8005f3a:	4770      	bx	lr

08005f3c <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 8005f3c:	8a00      	ldrh	r0, [r0, #16]
 8005f3e:	b280      	uxth	r0, r0
}
 8005f40:	4770      	bx	lr
 8005f42:	46c0      	nop			; (mov r8, r8)

08005f44 <GPIO_ReadOutputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8005f44:	8a80      	ldrh	r0, [r0, #20]
 8005f46:	4008      	ands	r0, r1
 8005f48:	1e41      	subs	r1, r0, #1
 8005f4a:	4188      	sbcs	r0, r1
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
 8005f4c:	b2c0      	uxtb	r0, r0
}
 8005f4e:	4770      	bx	lr

08005f50 <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->ODR);
 8005f50:	8a80      	ldrh	r0, [r0, #20]
 8005f52:	b280      	uxth	r0, r0
}
 8005f54:	4770      	bx	lr
 8005f56:	46c0      	nop			; (mov r8, r8)

08005f58 <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRR = GPIO_Pin;
 8005f58:	6181      	str	r1, [r0, #24]
}
 8005f5a:	4770      	bx	lr

08005f5c <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BRR = GPIO_Pin;
 8005f5c:	8501      	strh	r1, [r0, #40]	; 0x28
}
 8005f5e:	4770      	bx	lr

08005f60 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 8005f60:	2a00      	cmp	r2, #0
 8005f62:	d101      	bne.n	8005f68 <GPIO_WriteBit+0x8>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BRR = GPIO_Pin ;
 8005f64:	8501      	strh	r1, [r0, #40]	; 0x28
  }
}
 8005f66:	4770      	bx	lr
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
  {
    GPIOx->BSRR = GPIO_Pin;
 8005f68:	6181      	str	r1, [r0, #24]
 8005f6a:	e7fc      	b.n	8005f66 <GPIO_WriteBit+0x6>

08005f6c <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR = PortVal;
 8005f6c:	8281      	strh	r1, [r0, #20]
}
 8005f6e:	4770      	bx	lr

08005f70 <GPIO_PinAFConfig>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));

  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 8005f70:	2307      	movs	r3, #7
  *         for the detailed mapping of the system and peripherals'alternate 
  *         function I/O pins.
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8005f72:	b510      	push	{r4, lr}
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));

  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 8005f74:	240f      	movs	r4, #15
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));

  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 8005f76:	400b      	ands	r3, r1
 8005f78:	009b      	lsls	r3, r3, #2
 8005f7a:	409a      	lsls	r2, r3
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 8005f7c:	409c      	lsls	r4, r3
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));

  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 8005f7e:	1c13      	adds	r3, r2, #0
 8005f80:	08c9      	lsrs	r1, r1, #3
 8005f82:	0089      	lsls	r1, r1, #2
 8005f84:	1840      	adds	r0, r0, r1
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 8005f86:	6a01      	ldr	r1, [r0, #32]
 8005f88:	43a1      	bics	r1, r4
 8005f8a:	6201      	str	r1, [r0, #32]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8005f8c:	6a01      	ldr	r1, [r0, #32]
 8005f8e:	430b      	orrs	r3, r1
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 8005f90:	6203      	str	r3, [r0, #32]
}
 8005f92:	bd10      	pop	{r4, pc}

08005f94 <NVIC_Init>:
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPriority));  
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8005f94:	7883      	ldrb	r3, [r0, #2]
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8005f96:	b570      	push	{r4, r5, r6, lr}
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPriority));  
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8005f98:	2b00      	cmp	r3, #0
 8005f9a:	d109      	bne.n	8005fb0 <NVIC_Init+0x1c>
    NVIC->ISER[0] = (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[0] = (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8005f9c:	221f      	movs	r2, #31
 8005f9e:	7803      	ldrb	r3, [r0, #0]
 8005fa0:	4913      	ldr	r1, [pc, #76]	; (8005ff0 <NVIC_Init+0x5c>)
 8005fa2:	4013      	ands	r3, r2
 8005fa4:	3a1e      	subs	r2, #30
 8005fa6:	409a      	lsls	r2, r3
 8005fa8:	1c13      	adds	r3, r2, #0
 8005faa:	2280      	movs	r2, #128	; 0x80
 8005fac:	508b      	str	r3, [r1, r2]
  }
}
 8005fae:	bd70      	pop	{r4, r5, r6, pc}
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel >> 0x02];
    tmppriority &= (uint32_t)(~(((uint32_t)0xFF) << ((NVIC_InitStruct->NVIC_IRQChannel & 0x03) * 8)));
 8005fb0:	2403      	movs	r4, #3
  assert_param(IS_NVIC_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPriority));  
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel >> 0x02];
 8005fb2:	7802      	ldrb	r2, [r0, #0]
 8005fb4:	4b0e      	ldr	r3, [pc, #56]	; (8005ff0 <NVIC_Init+0x5c>)
 8005fb6:	0895      	lsrs	r5, r2, #2
    tmppriority &= (uint32_t)(~(((uint32_t)0xFF) << ((NVIC_InitStruct->NVIC_IRQChannel & 0x03) * 8)));
 8005fb8:	4022      	ands	r2, r4
 8005fba:	00d4      	lsls	r4, r2, #3
 8005fbc:	22ff      	movs	r2, #255	; 0xff
 8005fbe:	1c11      	adds	r1, r2, #0
 8005fc0:	469c      	mov	ip, r3
  assert_param(IS_NVIC_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPriority));  
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel >> 0x02];
 8005fc2:	26c0      	movs	r6, #192	; 0xc0
    tmppriority &= (uint32_t)(~(((uint32_t)0xFF) << ((NVIC_InitStruct->NVIC_IRQChannel & 0x03) * 8)));
 8005fc4:	40a1      	lsls	r1, r4
 8005fc6:	00ad      	lsls	r5, r5, #2
 8005fc8:	4465      	add	r5, ip
  assert_param(IS_NVIC_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPriority));  
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel >> 0x02];
 8005fca:	00b6      	lsls	r6, r6, #2
 8005fcc:	59ab      	ldr	r3, [r5, r6]
    tmppriority &= (uint32_t)(~(((uint32_t)0xFF) << ((NVIC_InitStruct->NVIC_IRQChannel & 0x03) * 8)));
 8005fce:	438b      	bics	r3, r1
    tmppriority |= (uint32_t)((((uint32_t)NVIC_InitStruct->NVIC_IRQChannelPriority << 6) & 0xFF) << ((NVIC_InitStruct->NVIC_IRQChannel & 0x03) * 8));    
 8005fd0:	7841      	ldrb	r1, [r0, #1]
 8005fd2:	0189      	lsls	r1, r1, #6
 8005fd4:	400a      	ands	r2, r1
 8005fd6:	40a2      	lsls	r2, r4
 8005fd8:	4313      	orrs	r3, r2
    
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel >> 0x02] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[0] = (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8005fda:	221f      	movs	r2, #31
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel >> 0x02];
    tmppriority &= (uint32_t)(~(((uint32_t)0xFF) << ((NVIC_InitStruct->NVIC_IRQChannel & 0x03) * 8)));
    tmppriority |= (uint32_t)((((uint32_t)NVIC_InitStruct->NVIC_IRQChannelPriority << 6) & 0xFF) << ((NVIC_InitStruct->NVIC_IRQChannel & 0x03) * 8));    
    
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel >> 0x02] = tmppriority;
 8005fdc:	51ab      	str	r3, [r5, r6]
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[0] = (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8005fde:	7803      	ldrb	r3, [r0, #0]
 8005fe0:	4013      	ands	r3, r2
 8005fe2:	3a1e      	subs	r2, #30
 8005fe4:	409a      	lsls	r2, r3
 8005fe6:	1c13      	adds	r3, r2, #0
 8005fe8:	4662      	mov	r2, ip
 8005fea:	6013      	str	r3, [r2, #0]
 8005fec:	e7df      	b.n	8005fae <NVIC_Init+0x1a>
 8005fee:	46c0      	nop			; (mov r8, r8)
 8005ff0:	e000e100 	.word	0xe000e100

08005ff4 <NVIC_SystemLPConfig>:
  
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    SCB->SCR |= LowPowerMode;
 8005ff4:	4a04      	ldr	r2, [pc, #16]	; (8006008 <NVIC_SystemLPConfig+0x14>)
 8005ff6:	6913      	ldr	r3, [r2, #16]
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 8005ff8:	2900      	cmp	r1, #0
 8005ffa:	d102      	bne.n	8006002 <NVIC_SystemLPConfig+0xe>
  {
    SCB->SCR |= LowPowerMode;
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 8005ffc:	4383      	bics	r3, r0
 8005ffe:	6113      	str	r3, [r2, #16]
  }
}
 8006000:	4770      	bx	lr
  
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    SCB->SCR |= LowPowerMode;
 8006002:	4318      	orrs	r0, r3
 8006004:	6110      	str	r0, [r2, #16]
 8006006:	e7fb      	b.n	8006000 <NVIC_SystemLPConfig+0xc>
 8006008:	e000ed00 	.word	0xe000ed00

0800600c <SysTick_CLKSourceConfig>:
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 800600c:	2804      	cmp	r0, #4
 800600e:	d005      	beq.n	800601c <SysTick_CLKSourceConfig+0x10>
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8006010:	2104      	movs	r1, #4
 8006012:	4a05      	ldr	r2, [pc, #20]	; (8006028 <SysTick_CLKSourceConfig+0x1c>)
 8006014:	6813      	ldr	r3, [r2, #0]
 8006016:	438b      	bics	r3, r1
 8006018:	6013      	str	r3, [r2, #0]
  }
}
 800601a:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 800601c:	4b02      	ldr	r3, [pc, #8]	; (8006028 <SysTick_CLKSourceConfig+0x1c>)
 800601e:	681a      	ldr	r2, [r3, #0]
 8006020:	4310      	orrs	r0, r2
 8006022:	6018      	str	r0, [r3, #0]
 8006024:	e7f9      	b.n	800601a <SysTick_CLKSourceConfig+0xe>
 8006026:	46c0      	nop			; (mov r8, r8)
 8006028:	e000e010 	.word	0xe000e010

0800602c <PWR_DeInit>:
  * @brief  Deinitializes the PWR peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void PWR_DeInit(void)
{
 800602c:	b510      	push	{r4, lr}
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
 800602e:	2480      	movs	r4, #128	; 0x80
 8006030:	0564      	lsls	r4, r4, #21
 8006032:	1c20      	adds	r0, r4, #0
 8006034:	2101      	movs	r1, #1
 8006036:	f000 fb4f 	bl	80066d8 <RCC_APB1PeriphResetCmd>
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
 800603a:	1c20      	adds	r0, r4, #0
 800603c:	2100      	movs	r1, #0
 800603e:	f000 fb4b 	bl	80066d8 <RCC_APB1PeriphResetCmd>
}
 8006042:	bd10      	pop	{r4, pc}

08006044 <PWR_BackupAccessCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Backup Domain Access */
    PWR->CR |= PWR_CR_DBP;
 8006044:	4a06      	ldr	r2, [pc, #24]	; (8006060 <PWR_BackupAccessCmd+0x1c>)
void PWR_BackupAccessCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8006046:	2800      	cmp	r0, #0
 8006048:	d104      	bne.n	8006054 <PWR_BackupAccessCmd+0x10>
    PWR->CR |= PWR_CR_DBP;
  }
  else
  {
    /* Disable the Backup Domain Access */
    PWR->CR &= (uint32_t)~((uint32_t)PWR_CR_DBP);
 800604a:	6811      	ldr	r1, [r2, #0]
 800604c:	4b05      	ldr	r3, [pc, #20]	; (8006064 <PWR_BackupAccessCmd+0x20>)
 800604e:	400b      	ands	r3, r1
 8006050:	6013      	str	r3, [r2, #0]
  } 
}
 8006052:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Backup Domain Access */
    PWR->CR |= PWR_CR_DBP;
 8006054:	2180      	movs	r1, #128	; 0x80
 8006056:	6813      	ldr	r3, [r2, #0]
 8006058:	0049      	lsls	r1, r1, #1
 800605a:	430b      	orrs	r3, r1
 800605c:	6013      	str	r3, [r2, #0]
 800605e:	e7f8      	b.n	8006052 <PWR_BackupAccessCmd+0xe>
 8006060:	40007000 	.word	0x40007000
 8006064:	fffffeff 	.word	0xfffffeff

08006068 <PWR_PVDLevelConfig>:
  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
  
  tmpreg = PWR->CR;
  
  /* Clear PLS[7:5] bits */
  tmpreg &= CR_PLS_MASK;
 8006068:	21e0      	movs	r1, #224	; 0xe0
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
  
  tmpreg = PWR->CR;
 800606a:	4a03      	ldr	r2, [pc, #12]	; (8006078 <PWR_PVDLevelConfig+0x10>)
 800606c:	6813      	ldr	r3, [r2, #0]
  
  /* Clear PLS[7:5] bits */
  tmpreg &= CR_PLS_MASK;
 800606e:	438b      	bics	r3, r1
  
  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
  tmpreg |= PWR_PVDLevel;
 8006070:	4318      	orrs	r0, r3
  
  /* Store the new value */
  PWR->CR = tmpreg;
 8006072:	6010      	str	r0, [r2, #0]
}
 8006074:	4770      	bx	lr
 8006076:	46c0      	nop			; (mov r8, r8)
 8006078:	40007000 	.word	0x40007000

0800607c <PWR_PVDCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the PVD */
    PWR->CR |= PWR_CR_PVDE;
 800607c:	4a06      	ldr	r2, [pc, #24]	; (8006098 <PWR_PVDCmd+0x1c>)
void PWR_PVDCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800607e:	2800      	cmp	r0, #0
 8006080:	d104      	bne.n	800608c <PWR_PVDCmd+0x10>
    PWR->CR |= PWR_CR_PVDE;
  }
  else
  {
    /* Disable the PVD */
    PWR->CR &= (uint32_t)~((uint32_t)PWR_CR_PVDE);
 8006082:	2110      	movs	r1, #16
 8006084:	6813      	ldr	r3, [r2, #0]
 8006086:	438b      	bics	r3, r1
 8006088:	6013      	str	r3, [r2, #0]
  } 
}
 800608a:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the PVD */
    PWR->CR |= PWR_CR_PVDE;
 800608c:	2310      	movs	r3, #16
 800608e:	6811      	ldr	r1, [r2, #0]
 8006090:	430b      	orrs	r3, r1
 8006092:	6013      	str	r3, [r2, #0]
 8006094:	e7f9      	b.n	800608a <PWR_PVDCmd+0xe>
 8006096:	46c0      	nop			; (mov r8, r8)
 8006098:	40007000 	.word	0x40007000

0800609c <PWR_WakeUpPinCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the EWUPx pin */
    PWR->CSR |= PWR_WakeUpPin;
 800609c:	4a04      	ldr	r2, [pc, #16]	; (80060b0 <PWR_WakeUpPinCmd+0x14>)
 800609e:	6853      	ldr	r3, [r2, #4]
{
  /* Check the parameters */
  assert_param(IS_PWR_WAKEUP_PIN(PWR_WakeUpPin));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80060a0:	2900      	cmp	r1, #0
 80060a2:	d102      	bne.n	80060aa <PWR_WakeUpPinCmd+0xe>
    PWR->CSR |= PWR_WakeUpPin;
  }
  else
  {
    /* Disable the EWUPx pin */
    PWR->CSR &= ~PWR_WakeUpPin;
 80060a4:	4383      	bics	r3, r0
 80060a6:	6053      	str	r3, [r2, #4]
  }
}
 80060a8:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the EWUPx pin */
    PWR->CSR |= PWR_WakeUpPin;
 80060aa:	4318      	orrs	r0, r3
 80060ac:	6050      	str	r0, [r2, #4]
 80060ae:	e7fb      	b.n	80060a8 <PWR_WakeUpPinCmd+0xc>
 80060b0:	40007000 	.word	0x40007000

080060b4 <PWR_EnterSleepMode>:
{
  /* Check the parameters */
  assert_param(IS_PWR_SLEEP_ENTRY(PWR_SLEEPEntry));

  /* Clear SLEEPDEEP bit of Cortex-M0 System Control Register */
  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
 80060b4:	2104      	movs	r1, #4
 80060b6:	4a06      	ldr	r2, [pc, #24]	; (80060d0 <PWR_EnterSleepMode+0x1c>)
 80060b8:	6913      	ldr	r3, [r2, #16]
 80060ba:	438b      	bics	r3, r1
 80060bc:	6113      	str	r3, [r2, #16]
  
  /* Select SLEEP mode entry -------------------------------------------------*/
  if(PWR_SLEEPEntry == PWR_SLEEPEntry_WFI)
 80060be:	2801      	cmp	r0, #1
 80060c0:	d003      	beq.n	80060ca <PWR_EnterSleepMode+0x16>

    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
{
  __ASM volatile ("sev");
 80060c2:	bf40      	sev
    Wait For Event is a hint instruction that permits the processor to enter
    a low-power state until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
{
  __ASM volatile ("wfe");
 80060c4:	bf20      	wfe
 80060c6:	bf20      	wfe
    /* Request Wait For Event */
    __SEV();
    __WFE(); 
    __WFE();
  }
}
 80060c8:	4770      	bx	lr
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 80060ca:	bf30      	wfi
 80060cc:	e7fc      	b.n	80060c8 <PWR_EnterSleepMode+0x14>
 80060ce:	46c0      	nop			; (mov r8, r8)
 80060d0:	e000ed00 	.word	0xe000ed00

080060d4 <PWR_EnterSTOPMode>:
  *             @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
                @arg PWR_STOPEntry_SLEEPONEXIT: enter STOP mode with SLEEPONEXIT instruction
  * @retval None
  */
void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
{
 80060d4:	b510      	push	{r4, lr}
  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
  
  /* Select the regulator state in STOP mode ---------------------------------*/
  tmpreg = PWR->CR;
  /* Clear PDDS and LPDSR bits */
  tmpreg &= CR_DS_MASK;
 80060d6:	2403      	movs	r4, #3
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
  
  /* Select the regulator state in STOP mode ---------------------------------*/
  tmpreg = PWR->CR;
 80060d8:	4a0e      	ldr	r2, [pc, #56]	; (8006114 <PWR_EnterSTOPMode+0x40>)
 80060da:	6813      	ldr	r3, [r2, #0]
  /* Clear PDDS and LPDSR bits */
  tmpreg &= CR_DS_MASK;
 80060dc:	43a3      	bics	r3, r4
  
  /* Set LPDSR bit according to PWR_Regulator value */
  tmpreg |= PWR_Regulator;
 80060de:	4318      	orrs	r0, r3
  
  /* Store the new value */
  PWR->CR = tmpreg;
 80060e0:	6010      	str	r0, [r2, #0]
  
  /* Set SLEEPDEEP bit of Cortex-M0 System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 80060e2:	2004      	movs	r0, #4
 80060e4:	4b0c      	ldr	r3, [pc, #48]	; (8006118 <PWR_EnterSTOPMode+0x44>)
 80060e6:	691a      	ldr	r2, [r3, #16]
 80060e8:	4302      	orrs	r2, r0
 80060ea:	611a      	str	r2, [r3, #16]
  
  /* Select STOP mode entry --------------------------------------------------*/
  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 80060ec:	2901      	cmp	r1, #1
 80060ee:	d006      	beq.n	80060fe <PWR_EnterSTOPMode+0x2a>
    /* Request Wait For Interrupt */
    __WFI();
    /* Reset SLEEPDEEP bit of Cortex System Control Register */
    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk); 
  }
  else if (PWR_STOPEntry == PWR_STOPEntry_WFE)
 80060f0:	2902      	cmp	r1, #2
 80060f2:	d009      	beq.n	8006108 <PWR_EnterSTOPMode+0x34>
    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);   
  }
  else
  {
    /* Set SLEEP on exit bit of Cortex-M0 System Control Register */
    SCB->SCR |= SCB_SCR_SLEEPONEXIT_Msk;
 80060f4:	2202      	movs	r2, #2
 80060f6:	6919      	ldr	r1, [r3, #16]
 80060f8:	430a      	orrs	r2, r1
 80060fa:	611a      	str	r2, [r3, #16]
  }
}
 80060fc:	bd10      	pop	{r4, pc}
 80060fe:	bf30      	wfi
  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
  {
    /* Request Wait For Interrupt */
    __WFI();
    /* Reset SLEEPDEEP bit of Cortex System Control Register */
    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk); 
 8006100:	691a      	ldr	r2, [r3, #16]
 8006102:	4382      	bics	r2, r0
 8006104:	611a      	str	r2, [r3, #16]
 8006106:	e7f9      	b.n	80060fc <PWR_EnterSTOPMode+0x28>
    Wait For Event is a hint instruction that permits the processor to enter
    a low-power state until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
{
  __ASM volatile ("wfe");
 8006108:	bf20      	wfe
  else if (PWR_STOPEntry == PWR_STOPEntry_WFE)
  {
    /* Request Wait For Event */
    __WFE();
    /* Reset SLEEPDEEP bit of Cortex System Control Register */
    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);   
 800610a:	691a      	ldr	r2, [r3, #16]
 800610c:	4382      	bics	r2, r0
 800610e:	611a      	str	r2, [r3, #16]
 8006110:	e7f4      	b.n	80060fc <PWR_EnterSTOPMode+0x28>
 8006112:	46c0      	nop			; (mov r8, r8)
 8006114:	40007000 	.word	0x40007000
 8006118:	e000ed00 	.word	0xe000ed00

0800611c <PWR_EnterSTANDBYMode>:
  * @retval None
  */
void PWR_EnterSTANDBYMode(void)
{
  /* Select STANDBY mode */
  PWR->CR |= PWR_CR_PDDS;
 800611c:	2302      	movs	r3, #2
 800611e:	4a05      	ldr	r2, [pc, #20]	; (8006134 <PWR_EnterSTANDBYMode+0x18>)
 8006120:	6811      	ldr	r1, [r2, #0]
 8006122:	430b      	orrs	r3, r1
 8006124:	6013      	str	r3, [r2, #0]

  /* Set SLEEPDEEP bit of Cortex-M0 System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 8006126:	2304      	movs	r3, #4
 8006128:	4a03      	ldr	r2, [pc, #12]	; (8006138 <PWR_EnterSTANDBYMode+0x1c>)
 800612a:	6911      	ldr	r1, [r2, #16]
 800612c:	430b      	orrs	r3, r1
 800612e:	6113      	str	r3, [r2, #16]
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 8006130:	bf30      	wfi

  /* Request Wait For Interrupt */
  __WFI();
}
 8006132:	4770      	bx	lr
 8006134:	40007000 	.word	0x40007000
 8006138:	e000ed00 	.word	0xe000ed00

0800613c <PWR_GetFlagStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));

  if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
 800613c:	4b03      	ldr	r3, [pc, #12]	; (800614c <PWR_GetFlagStatus+0x10>)
 800613e:	685b      	ldr	r3, [r3, #4]
 8006140:	4018      	ands	r0, r3
 8006142:	1e43      	subs	r3, r0, #1
 8006144:	4198      	sbcs	r0, r3
  else
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
 8006146:	b2c0      	uxtb	r0, r0
}
 8006148:	4770      	bx	lr
 800614a:	46c0      	nop			; (mov r8, r8)
 800614c:	40007000 	.word	0x40007000

08006150 <PWR_ClearFlag>:
void PWR_ClearFlag(uint32_t PWR_FLAG)
{
  /* Check the parameters */
  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));

  PWR->CR |=  PWR_FLAG << 2;
 8006150:	4a02      	ldr	r2, [pc, #8]	; (800615c <PWR_ClearFlag+0xc>)
 8006152:	0080      	lsls	r0, r0, #2
 8006154:	6813      	ldr	r3, [r2, #0]
 8006156:	4318      	orrs	r0, r3
 8006158:	6010      	str	r0, [r2, #0]
}
 800615a:	4770      	bx	lr
 800615c:	40007000 	.word	0x40007000

08006160 <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8006160:	2101      	movs	r1, #1
 8006162:	4b11      	ldr	r3, [pc, #68]	; (80061a8 <RCC_DeInit+0x48>)
 8006164:	681a      	ldr	r2, [r3, #0]
 8006166:	430a      	orrs	r2, r1
 8006168:	601a      	str	r2, [r3, #0]
#if defined (STM32F051)
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0] and MCOSEL[2:0] bits */
  RCC->CFGR &= (uint32_t)0xF8FFB80C;
#else
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, MCOSEL[2:0], MCOPRE[2:0] and PLLNODIV bits */
  RCC->CFGR &= (uint32_t)0x08FFB80C;
 800616a:	6858      	ldr	r0, [r3, #4]
 800616c:	4a0f      	ldr	r2, [pc, #60]	; (80061ac <RCC_DeInit+0x4c>)
 800616e:	4002      	ands	r2, r0
 8006170:	605a      	str	r2, [r3, #4]
#endif /* STM32F051 */
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8006172:	6818      	ldr	r0, [r3, #0]
 8006174:	4a0e      	ldr	r2, [pc, #56]	; (80061b0 <RCC_DeInit+0x50>)
 8006176:	4002      	ands	r2, r0
 8006178:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800617a:	6818      	ldr	r0, [r3, #0]
 800617c:	4a0d      	ldr	r2, [pc, #52]	; (80061b4 <RCC_DeInit+0x54>)
 800617e:	4002      	ands	r2, r0
 8006180:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  RCC->CFGR &= (uint32_t)0xFFC0FFFF;
 8006182:	6858      	ldr	r0, [r3, #4]
 8006184:	4a0c      	ldr	r2, [pc, #48]	; (80061b8 <RCC_DeInit+0x58>)
 8006186:	4002      	ands	r2, r0

  /* Reset PREDIV1[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
 8006188:	200f      	movs	r0, #15

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;

  /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  RCC->CFGR &= (uint32_t)0xFFC0FFFF;
 800618a:	605a      	str	r2, [r3, #4]

  /* Reset PREDIV1[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
 800618c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800618e:	4382      	bics	r2, r0
 8006190:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Reset USARTSW[1:0], I2CSW, CECSW and ADCSW bits */
  RCC->CFGR3 &= (uint32_t)0xFFF0FEAC;
 8006192:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8006194:	4a09      	ldr	r2, [pc, #36]	; (80061bc <RCC_DeInit+0x5c>)
 8006196:	4002      	ands	r2, r0
 8006198:	631a      	str	r2, [r3, #48]	; 0x30
  
  /* Reset HSI14 bit */
  RCC->CR2 &= (uint32_t)0xFFFFFFFE;
 800619a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800619c:	438a      	bics	r2, r1
 800619e:	635a      	str	r2, [r3, #52]	; 0x34

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80061a0:	2200      	movs	r2, #0
 80061a2:	609a      	str	r2, [r3, #8]
}
 80061a4:	4770      	bx	lr
 80061a6:	46c0      	nop			; (mov r8, r8)
 80061a8:	40021000 	.word	0x40021000
 80061ac:	08ffb80c 	.word	0x08ffb80c
 80061b0:	fef6ffff 	.word	0xfef6ffff
 80061b4:	fffbffff 	.word	0xfffbffff
 80061b8:	ffc0ffff 	.word	0xffc0ffff
 80061bc:	fff0feac 	.word	0xfff0feac

080061c0 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE_OFF;
 80061c0:	2200      	movs	r2, #0
 80061c2:	4b02      	ldr	r3, [pc, #8]	; (80061cc <RCC_HSEConfig+0xc>)
 80061c4:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE;
 80061c6:	7018      	strb	r0, [r3, #0]

}
 80061c8:	4770      	bx	lr
 80061ca:	46c0      	nop			; (mov r8, r8)
 80061cc:	40021002 	.word	0x40021002

080061d0 <RCC_AdjustHSICalibrationValue>:
  assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
  
  tmpreg = RCC->CR;
  
  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
 80061d0:	21f8      	movs	r1, #248	; 0xf8
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
  
  tmpreg = RCC->CR;
 80061d2:	4a03      	ldr	r2, [pc, #12]	; (80061e0 <RCC_AdjustHSICalibrationValue+0x10>)
  
  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
  
  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 80061d4:	00c0      	lsls	r0, r0, #3
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
  
  tmpreg = RCC->CR;
 80061d6:	6813      	ldr	r3, [r2, #0]
  
  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
 80061d8:	438b      	bics	r3, r1
  
  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 80061da:	4318      	orrs	r0, r3

  /* Store the new value */
  RCC->CR = tmpreg;
 80061dc:	6010      	str	r0, [r2, #0]
}
 80061de:	4770      	bx	lr
 80061e0:	40021000 	.word	0x40021000

080061e4 <RCC_HSICmd>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->CR |= RCC_CR_HSION;
 80061e4:	4a06      	ldr	r2, [pc, #24]	; (8006200 <RCC_HSICmd+0x1c>)
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80061e6:	2800      	cmp	r0, #0
 80061e8:	d104      	bne.n	80061f4 <RCC_HSICmd+0x10>
  {
    RCC->CR |= RCC_CR_HSION;
  }
  else
  {
    RCC->CR &= ~RCC_CR_HSION;
 80061ea:	2101      	movs	r1, #1
 80061ec:	6813      	ldr	r3, [r2, #0]
 80061ee:	438b      	bics	r3, r1
 80061f0:	6013      	str	r3, [r2, #0]
  }
}
 80061f2:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->CR |= RCC_CR_HSION;
 80061f4:	2301      	movs	r3, #1
 80061f6:	6811      	ldr	r1, [r2, #0]
 80061f8:	430b      	orrs	r3, r1
 80061fa:	6013      	str	r3, [r2, #0]
 80061fc:	e7f9      	b.n	80061f2 <RCC_HSICmd+0xe>
 80061fe:	46c0      	nop			; (mov r8, r8)
 8006200:	40021000 	.word	0x40021000

08006204 <RCC_AdjustHSI14CalibrationValue>:
  assert_param(IS_RCC_HSI14_CALIBRATION_VALUE(HSI14CalibrationValue));
  
  tmpreg = RCC->CR2;
  
  /* Clear HSI14TRIM[4:0] bits */
  tmpreg &= ~RCC_CR2_HSI14TRIM;
 8006204:	21f8      	movs	r1, #248	; 0xf8
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HSI14_CALIBRATION_VALUE(HSI14CalibrationValue));
  
  tmpreg = RCC->CR2;
 8006206:	4a03      	ldr	r2, [pc, #12]	; (8006214 <RCC_AdjustHSI14CalibrationValue+0x10>)
  
  /* Clear HSI14TRIM[4:0] bits */
  tmpreg &= ~RCC_CR2_HSI14TRIM;
  
  /* Set the HSITRIM14[4:0] bits according to HSI14CalibrationValue value */
  tmpreg |= (uint32_t)HSI14CalibrationValue << 3;
 8006208:	00c0      	lsls	r0, r0, #3
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HSI14_CALIBRATION_VALUE(HSI14CalibrationValue));
  
  tmpreg = RCC->CR2;
 800620a:	6b53      	ldr	r3, [r2, #52]	; 0x34
  
  /* Clear HSI14TRIM[4:0] bits */
  tmpreg &= ~RCC_CR2_HSI14TRIM;
 800620c:	438b      	bics	r3, r1
  
  /* Set the HSITRIM14[4:0] bits according to HSI14CalibrationValue value */
  tmpreg |= (uint32_t)HSI14CalibrationValue << 3;
 800620e:	4318      	orrs	r0, r3

  /* Store the new value */
  RCC->CR2 = tmpreg;
 8006210:	6350      	str	r0, [r2, #52]	; 0x34
}
 8006212:	4770      	bx	lr
 8006214:	40021000 	.word	0x40021000

08006218 <RCC_HSI14Cmd>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->CR2 |= RCC_CR2_HSI14ON;
 8006218:	4a06      	ldr	r2, [pc, #24]	; (8006234 <RCC_HSI14Cmd+0x1c>)
void RCC_HSI14Cmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800621a:	2800      	cmp	r0, #0
 800621c:	d104      	bne.n	8006228 <RCC_HSI14Cmd+0x10>
  {
    RCC->CR2 |= RCC_CR2_HSI14ON;
  }
  else
  {
    RCC->CR2 &= ~RCC_CR2_HSI14ON;
 800621e:	2101      	movs	r1, #1
 8006220:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8006222:	438b      	bics	r3, r1
 8006224:	6353      	str	r3, [r2, #52]	; 0x34
  }
}
 8006226:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->CR2 |= RCC_CR2_HSI14ON;
 8006228:	2301      	movs	r3, #1
 800622a:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800622c:	430b      	orrs	r3, r1
 800622e:	6353      	str	r3, [r2, #52]	; 0x34
 8006230:	e7f9      	b.n	8006226 <RCC_HSI14Cmd+0xe>
 8006232:	46c0      	nop			; (mov r8, r8)
 8006234:	40021000 	.word	0x40021000

08006238 <RCC_HSI14ADCRequestCmd>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->CR2 &= ~RCC_CR2_HSI14DIS;
 8006238:	4a06      	ldr	r2, [pc, #24]	; (8006254 <RCC_HSI14ADCRequestCmd+0x1c>)
void RCC_HSI14ADCRequestCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800623a:	2800      	cmp	r0, #0
 800623c:	d104      	bne.n	8006248 <RCC_HSI14ADCRequestCmd+0x10>
  {
    RCC->CR2 &= ~RCC_CR2_HSI14DIS;
  }
  else
  {
    RCC->CR2 |= RCC_CR2_HSI14DIS;
 800623e:	2304      	movs	r3, #4
 8006240:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8006242:	430b      	orrs	r3, r1
 8006244:	6353      	str	r3, [r2, #52]	; 0x34
  }
}
 8006246:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->CR2 &= ~RCC_CR2_HSI14DIS;
 8006248:	2104      	movs	r1, #4
 800624a:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800624c:	438b      	bics	r3, r1
 800624e:	6353      	str	r3, [r2, #52]	; 0x34
 8006250:	e7f9      	b.n	8006246 <RCC_HSI14ADCRequestCmd+0xe>
 8006252:	46c0      	nop			; (mov r8, r8)
 8006254:	40021000 	.word	0x40021000

08006258 <RCC_LSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  RCC->BDCR &= ~(RCC_BDCR_LSEON);
 8006258:	2101      	movs	r1, #1
 800625a:	4b06      	ldr	r3, [pc, #24]	; (8006274 <RCC_LSEConfig+0x1c>)
 800625c:	6a1a      	ldr	r2, [r3, #32]
 800625e:	438a      	bics	r2, r1
 8006260:	621a      	str	r2, [r3, #32]

  /* Reset LSEBYP bit */
  RCC->BDCR &= ~(RCC_BDCR_LSEBYP);
 8006262:	6a1a      	ldr	r2, [r3, #32]
 8006264:	3103      	adds	r1, #3
 8006266:	438a      	bics	r2, r1
 8006268:	621a      	str	r2, [r3, #32]

  /* Configure LSE */
  RCC->BDCR |= RCC_LSE;
 800626a:	6a1a      	ldr	r2, [r3, #32]
 800626c:	4310      	orrs	r0, r2
 800626e:	6218      	str	r0, [r3, #32]
}
 8006270:	4770      	bx	lr
 8006272:	46c0      	nop			; (mov r8, r8)
 8006274:	40021000 	.word	0x40021000

08006278 <RCC_LSEDriveConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_LSE_DRIVE(RCC_LSEDrive));
  
  /* Clear LSEDRV[1:0] bits */
  RCC->BDCR &= ~(RCC_BDCR_LSEDRV);
 8006278:	2118      	movs	r1, #24
 800627a:	4b04      	ldr	r3, [pc, #16]	; (800628c <RCC_LSEDriveConfig+0x14>)
 800627c:	6a1a      	ldr	r2, [r3, #32]
 800627e:	438a      	bics	r2, r1
 8006280:	621a      	str	r2, [r3, #32]

  /* Set the LSE Drive */
  RCC->BDCR |= RCC_LSEDrive;
 8006282:	6a1a      	ldr	r2, [r3, #32]
 8006284:	4310      	orrs	r0, r2
 8006286:	6218      	str	r0, [r3, #32]
}
 8006288:	4770      	bx	lr
 800628a:	46c0      	nop			; (mov r8, r8)
 800628c:	40021000 	.word	0x40021000

08006290 <RCC_LSICmd>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->CSR |= RCC_CSR_LSION;
 8006290:	4a06      	ldr	r2, [pc, #24]	; (80062ac <RCC_LSICmd+0x1c>)
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8006292:	2800      	cmp	r0, #0
 8006294:	d104      	bne.n	80062a0 <RCC_LSICmd+0x10>
  {
    RCC->CSR |= RCC_CSR_LSION;
  }
  else
  {
    RCC->CSR &= ~RCC_CSR_LSION;
 8006296:	2101      	movs	r1, #1
 8006298:	6a53      	ldr	r3, [r2, #36]	; 0x24
 800629a:	438b      	bics	r3, r1
 800629c:	6253      	str	r3, [r2, #36]	; 0x24
  }
}
 800629e:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->CSR |= RCC_CSR_LSION;
 80062a0:	2301      	movs	r3, #1
 80062a2:	6a51      	ldr	r1, [r2, #36]	; 0x24
 80062a4:	430b      	orrs	r3, r1
 80062a6:	6253      	str	r3, [r2, #36]	; 0x24
 80062a8:	e7f9      	b.n	800629e <RCC_LSICmd+0xe>
 80062aa:	46c0      	nop			; (mov r8, r8)
 80062ac:	40021000 	.word	0x40021000

080062b0 <RCC_PLLConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  /* Clear PLL Source [16] and Multiplier [21:18] bits */
  RCC->CFGR &= ~(RCC_CFGR_PLLMULL | RCC_CFGR_PLLSRC);
 80062b0:	4b05      	ldr	r3, [pc, #20]	; (80062c8 <RCC_PLLConfig+0x18>)
  *          This parameter can be RCC_PLLMul_x where x:[2,16] 
  *
  * @retval None
  */
void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
{
 80062b2:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  /* Clear PLL Source [16] and Multiplier [21:18] bits */
  RCC->CFGR &= ~(RCC_CFGR_PLLMULL | RCC_CFGR_PLLSRC);
 80062b4:	4a05      	ldr	r2, [pc, #20]	; (80062cc <RCC_PLLConfig+0x1c>)
 80062b6:	685c      	ldr	r4, [r3, #4]
 80062b8:	4022      	ands	r2, r4
 80062ba:	605a      	str	r2, [r3, #4]

  /* Set the PLL Source and Multiplier */
  RCC->CFGR |= (uint32_t)(RCC_PLLSource | RCC_PLLMul);
 80062bc:	685a      	ldr	r2, [r3, #4]
 80062be:	4311      	orrs	r1, r2
 80062c0:	4308      	orrs	r0, r1
 80062c2:	6058      	str	r0, [r3, #4]
}
 80062c4:	bd10      	pop	{r4, pc}
 80062c6:	46c0      	nop			; (mov r8, r8)
 80062c8:	40021000 	.word	0x40021000
 80062cc:	ffc27fff 	.word	0xffc27fff

080062d0 <RCC_PLLCmd>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->CR |= RCC_CR_PLLON;
 80062d0:	4a06      	ldr	r2, [pc, #24]	; (80062ec <RCC_PLLCmd+0x1c>)
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80062d2:	2800      	cmp	r0, #0
 80062d4:	d104      	bne.n	80062e0 <RCC_PLLCmd+0x10>
  {
    RCC->CR |= RCC_CR_PLLON;
  }
  else
  {
    RCC->CR &= ~RCC_CR_PLLON;
 80062d6:	6811      	ldr	r1, [r2, #0]
 80062d8:	4b05      	ldr	r3, [pc, #20]	; (80062f0 <RCC_PLLCmd+0x20>)
 80062da:	400b      	ands	r3, r1
 80062dc:	6013      	str	r3, [r2, #0]
  }
}
 80062de:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->CR |= RCC_CR_PLLON;
 80062e0:	2180      	movs	r1, #128	; 0x80
 80062e2:	6813      	ldr	r3, [r2, #0]
 80062e4:	0449      	lsls	r1, r1, #17
 80062e6:	430b      	orrs	r3, r1
 80062e8:	6013      	str	r3, [r2, #0]
 80062ea:	e7f8      	b.n	80062de <RCC_PLLCmd+0xe>
 80062ec:	40021000 	.word	0x40021000
 80062f0:	feffffff 	.word	0xfeffffff

080062f4 <RCC_HSI48Cmd>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->CR2 |= RCC_CR2_HSI48ON;
 80062f4:	4a06      	ldr	r2, [pc, #24]	; (8006310 <RCC_HSI48Cmd+0x1c>)
void RCC_HSI48Cmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80062f6:	2800      	cmp	r0, #0
 80062f8:	d104      	bne.n	8006304 <RCC_HSI48Cmd+0x10>
  {
    RCC->CR2 |= RCC_CR2_HSI48ON;
  }
  else
  {
    RCC->CR2 &= ~RCC_CR2_HSI48ON;
 80062fa:	6b51      	ldr	r1, [r2, #52]	; 0x34
 80062fc:	4b05      	ldr	r3, [pc, #20]	; (8006314 <RCC_HSI48Cmd+0x20>)
 80062fe:	400b      	ands	r3, r1
 8006300:	6353      	str	r3, [r2, #52]	; 0x34
  }
}
 8006302:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->CR2 |= RCC_CR2_HSI48ON;
 8006304:	2180      	movs	r1, #128	; 0x80
 8006306:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8006308:	0249      	lsls	r1, r1, #9
 800630a:	430b      	orrs	r3, r1
 800630c:	6353      	str	r3, [r2, #52]	; 0x34
 800630e:	e7f8      	b.n	8006302 <RCC_HSI48Cmd+0xe>
 8006310:	40021000 	.word	0x40021000
 8006314:	fffeffff 	.word	0xfffeffff

08006318 <RCC_PREDIV1Config>:
  /* Check the parameters */
  assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));

  tmpreg = RCC->CFGR2;
  /* Clear PREDIV1[3:0] bits */
  tmpreg &= ~(RCC_CFGR2_PREDIV1);
 8006318:	210f      	movs	r1, #15
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));

  tmpreg = RCC->CFGR2;
 800631a:	4a03      	ldr	r2, [pc, #12]	; (8006328 <RCC_PREDIV1Config+0x10>)
 800631c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
  /* Clear PREDIV1[3:0] bits */
  tmpreg &= ~(RCC_CFGR2_PREDIV1);
 800631e:	438b      	bics	r3, r1
  /* Set the PREDIV1 division factor */
  tmpreg |= RCC_PREDIV1_Div;
 8006320:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR2 = tmpreg;
 8006322:	62d0      	str	r0, [r2, #44]	; 0x2c
}
 8006324:	4770      	bx	lr
 8006326:	46c0      	nop			; (mov r8, r8)
 8006328:	40021000 	.word	0x40021000

0800632c <RCC_ClockSecuritySystemCmd>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->CR |= RCC_CR_CSSON;
 800632c:	4a06      	ldr	r2, [pc, #24]	; (8006348 <RCC_ClockSecuritySystemCmd+0x1c>)
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800632e:	2800      	cmp	r0, #0
 8006330:	d104      	bne.n	800633c <RCC_ClockSecuritySystemCmd+0x10>
  {
    RCC->CR |= RCC_CR_CSSON;
  }
  else
  {
    RCC->CR &= ~RCC_CR_CSSON;
 8006332:	6811      	ldr	r1, [r2, #0]
 8006334:	4b05      	ldr	r3, [pc, #20]	; (800634c <RCC_ClockSecuritySystemCmd+0x20>)
 8006336:	400b      	ands	r3, r1
 8006338:	6013      	str	r3, [r2, #0]
  }
}
 800633a:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->CR |= RCC_CR_CSSON;
 800633c:	2180      	movs	r1, #128	; 0x80
 800633e:	6813      	ldr	r3, [r2, #0]
 8006340:	0309      	lsls	r1, r1, #12
 8006342:	430b      	orrs	r3, r1
 8006344:	6013      	str	r3, [r2, #0]
 8006346:	e7f8      	b.n	800633a <RCC_ClockSecuritySystemCmd+0xe>
 8006348:	40021000 	.word	0x40021000
 800634c:	fff7ffff 	.word	0xfff7ffff

08006350 <RCC_MCOConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
  assert_param(IS_RCC_MCO_PRESCALER(RCC_MCOPrescaler));
    
  /* Get CFGR value */  
  tmpreg = RCC->CFGR;
 8006350:	4a04      	ldr	r2, [pc, #16]	; (8006364 <RCC_MCOConfig+0x14>)
  /* Clear MCOPRE[2:0] bits */
  tmpreg &= ~(RCC_CFGR_MCO_PRE | RCC_CFGR_MCO | RCC_CFGR_PLLNODIV);
  /* Set the RCC_MCOSource and RCC_MCOPrescaler */
  tmpreg |= (RCC_MCOPrescaler | ((uint32_t)RCC_MCOSource<<24));
 8006352:	0600      	lsls	r0, r0, #24
  /* Check the parameters */
  assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
  assert_param(IS_RCC_MCO_PRESCALER(RCC_MCOPrescaler));
    
  /* Get CFGR value */  
  tmpreg = RCC->CFGR;
 8006354:	6853      	ldr	r3, [r2, #4]
  /* Clear MCOPRE[2:0] bits */
  tmpreg &= ~(RCC_CFGR_MCO_PRE | RCC_CFGR_MCO | RCC_CFGR_PLLNODIV);
 8006356:	021b      	lsls	r3, r3, #8
 8006358:	0a1b      	lsrs	r3, r3, #8
 800635a:	4319      	orrs	r1, r3
  /* Set the RCC_MCOSource and RCC_MCOPrescaler */
  tmpreg |= (RCC_MCOPrescaler | ((uint32_t)RCC_MCOSource<<24));
 800635c:	4301      	orrs	r1, r0
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800635e:	6051      	str	r1, [r2, #4]
}
 8006360:	4770      	bx	lr
 8006362:	46c0      	nop			; (mov r8, r8)
 8006364:	40021000 	.word	0x40021000

08006368 <RCC_SYSCLKConfig>:
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  
  tmpreg = RCC->CFGR;
  
  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 8006368:	2103      	movs	r1, #3
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  
  tmpreg = RCC->CFGR;
 800636a:	4a03      	ldr	r2, [pc, #12]	; (8006378 <RCC_SYSCLKConfig+0x10>)
 800636c:	6853      	ldr	r3, [r2, #4]
  
  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 800636e:	438b      	bics	r3, r1
  
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8006370:	4318      	orrs	r0, r3
  
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8006372:	6050      	str	r0, [r2, #4]
}
 8006374:	4770      	bx	lr
 8006376:	46c0      	nop			; (mov r8, r8)
 8006378:	40021000 	.word	0x40021000

0800637c <RCC_GetSYSCLKSource>:
  *           - 0x08: PLL used as system clock
  *           - 0x0C: HSI48 used as system clock, applicable only for STM32F072 devices  
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 800637c:	200c      	movs	r0, #12
 800637e:	4b02      	ldr	r3, [pc, #8]	; (8006388 <RCC_GetSYSCLKSource+0xc>)
 8006380:	685b      	ldr	r3, [r3, #4]
 8006382:	4018      	ands	r0, r3
}
 8006384:	4770      	bx	lr
 8006386:	46c0      	nop			; (mov r8, r8)
 8006388:	40021000 	.word	0x40021000

0800638c <RCC_HCLKConfig>:
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  
  tmpreg = RCC->CFGR;
  
  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 800638c:	21f0      	movs	r1, #240	; 0xf0
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  
  tmpreg = RCC->CFGR;
 800638e:	4a03      	ldr	r2, [pc, #12]	; (800639c <RCC_HCLKConfig+0x10>)
 8006390:	6853      	ldr	r3, [r2, #4]
  
  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 8006392:	438b      	bics	r3, r1
  
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8006394:	4318      	orrs	r0, r3
  
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8006396:	6050      	str	r0, [r2, #4]
}
 8006398:	4770      	bx	lr
 800639a:	46c0      	nop			; (mov r8, r8)
 800639c:	40021000 	.word	0x40021000

080063a0 <RCC_PCLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  
  tmpreg = RCC->CFGR;
 80063a0:	4a03      	ldr	r2, [pc, #12]	; (80063b0 <RCC_PCLKConfig+0x10>)
  
  /* Clear PPRE[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE;
 80063a2:	4b04      	ldr	r3, [pc, #16]	; (80063b4 <RCC_PCLKConfig+0x14>)
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  
  tmpreg = RCC->CFGR;
 80063a4:	6851      	ldr	r1, [r2, #4]
  
  /* Clear PPRE[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE;
 80063a6:	400b      	ands	r3, r1
  
  /* Set PPRE[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 80063a8:	4318      	orrs	r0, r3
  
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80063aa:	6050      	str	r0, [r2, #4]
}
 80063ac:	4770      	bx	lr
 80063ae:	46c0      	nop			; (mov r8, r8)
 80063b0:	40021000 	.word	0x40021000
 80063b4:	fffff8ff 	.word	0xfffff8ff

080063b8 <RCC_ADCCLKConfig>:
{ 
  /* Check the parameters */
  assert_param(IS_RCC_ADCCLK(RCC_ADCCLK));

  /* Clear ADCPRE bit */
  RCC->CFGR &= ~RCC_CFGR_ADCPRE;
 80063b8:	4b09      	ldr	r3, [pc, #36]	; (80063e0 <RCC_ADCCLKConfig+0x28>)
 80063ba:	4a0a      	ldr	r2, [pc, #40]	; (80063e4 <RCC_ADCCLKConfig+0x2c>)
 80063bc:	6859      	ldr	r1, [r3, #4]
 80063be:	400a      	ands	r2, r1
 80063c0:	605a      	str	r2, [r3, #4]
  /* Set ADCPRE bits according to RCC_PCLK value */
  RCC->CFGR |= RCC_ADCCLK & 0xFFFF;
 80063c2:	6859      	ldr	r1, [r3, #4]
 80063c4:	0402      	lsls	r2, r0, #16
 80063c6:	0c12      	lsrs	r2, r2, #16
 80063c8:	430a      	orrs	r2, r1
 80063ca:	605a      	str	r2, [r3, #4]

  /* Clear ADCSW bit */
  RCC->CFGR3 &= ~RCC_CFGR3_ADCSW; 
 80063cc:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80063ce:	4a06      	ldr	r2, [pc, #24]	; (80063e8 <RCC_ADCCLKConfig+0x30>)
  /* Set ADCSW bits according to RCC_ADCCLK value */
  RCC->CFGR3 |= RCC_ADCCLK >> 16;  
 80063d0:	0c00      	lsrs	r0, r0, #16
  RCC->CFGR &= ~RCC_CFGR_ADCPRE;
  /* Set ADCPRE bits according to RCC_PCLK value */
  RCC->CFGR |= RCC_ADCCLK & 0xFFFF;

  /* Clear ADCSW bit */
  RCC->CFGR3 &= ~RCC_CFGR3_ADCSW; 
 80063d2:	400a      	ands	r2, r1
 80063d4:	631a      	str	r2, [r3, #48]	; 0x30
  /* Set ADCSW bits according to RCC_ADCCLK value */
  RCC->CFGR3 |= RCC_ADCCLK >> 16;  
 80063d6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80063d8:	4310      	orrs	r0, r2
 80063da:	6318      	str	r0, [r3, #48]	; 0x30
}
 80063dc:	4770      	bx	lr
 80063de:	46c0      	nop			; (mov r8, r8)
 80063e0:	40021000 	.word	0x40021000
 80063e4:	ffffbfff 	.word	0xffffbfff
 80063e8:	fffffeff 	.word	0xfffffeff

080063ec <RCC_CECCLKConfig>:
{ 
  /* Check the parameters */
  assert_param(IS_RCC_CECCLK(RCC_CECCLK));

  /* Clear CECSW bit */
  RCC->CFGR3 &= ~RCC_CFGR3_CECSW;
 80063ec:	2140      	movs	r1, #64	; 0x40
 80063ee:	4b04      	ldr	r3, [pc, #16]	; (8006400 <RCC_CECCLKConfig+0x14>)
 80063f0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80063f2:	438a      	bics	r2, r1
 80063f4:	631a      	str	r2, [r3, #48]	; 0x30
  /* Set CECSW bits according to RCC_CECCLK value */
  RCC->CFGR3 |= RCC_CECCLK;
 80063f6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80063f8:	4310      	orrs	r0, r2
 80063fa:	6318      	str	r0, [r3, #48]	; 0x30
}
 80063fc:	4770      	bx	lr
 80063fe:	46c0      	nop			; (mov r8, r8)
 8006400:	40021000 	.word	0x40021000

08006404 <RCC_I2CCLKConfig>:
{ 
  /* Check the parameters */
  assert_param(IS_RCC_I2CCLK(RCC_I2CCLK));

  /* Clear I2CSW bit */
  RCC->CFGR3 &= ~RCC_CFGR3_I2C1SW;
 8006404:	2110      	movs	r1, #16
 8006406:	4b04      	ldr	r3, [pc, #16]	; (8006418 <RCC_I2CCLKConfig+0x14>)
 8006408:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800640a:	438a      	bics	r2, r1
 800640c:	631a      	str	r2, [r3, #48]	; 0x30
  /* Set I2CSW bits according to RCC_I2CCLK value */
  RCC->CFGR3 |= RCC_I2CCLK;
 800640e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006410:	4310      	orrs	r0, r2
 8006412:	6318      	str	r0, [r3, #48]	; 0x30
}
 8006414:	4770      	bx	lr
 8006416:	46c0      	nop			; (mov r8, r8)
 8006418:	40021000 	.word	0x40021000

0800641c <RCC_USARTCLKConfig>:
  
  /* Check the parameters */
  assert_param(IS_RCC_USARTCLK(RCC_USARTCLK));

  /* Get USART index */
  tmp = (RCC_USARTCLK >> 28);
 800641c:	0f03      	lsrs	r3, r0, #28

  /* Clear USARTSW[1:0] bit */
  if (tmp == (uint32_t)0x00000001)
  {
    /* Clear USART1SW[1:0] bit */  
    RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
 800641e:	4a0b      	ldr	r2, [pc, #44]	; (800644c <RCC_USARTCLKConfig+0x30>)

  /* Get USART index */
  tmp = (RCC_USARTCLK >> 28);

  /* Clear USARTSW[1:0] bit */
  if (tmp == (uint32_t)0x00000001)
 8006420:	2b01      	cmp	r3, #1
 8006422:	d00a      	beq.n	800643a <RCC_USARTCLKConfig+0x1e>
    RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
  }
  else if (tmp == (uint32_t)0x00000002)
  {
    /* Clear USART2SW[1:0] bit */
    RCC->CFGR3 &= ~RCC_CFGR3_USART2SW;
 8006424:	6b11      	ldr	r1, [r2, #48]	; 0x30
  if (tmp == (uint32_t)0x00000001)
  {
    /* Clear USART1SW[1:0] bit */  
    RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
  }
  else if (tmp == (uint32_t)0x00000002)
 8006426:	2b02      	cmp	r3, #2
 8006428:	d00c      	beq.n	8006444 <RCC_USARTCLKConfig+0x28>
    RCC->CFGR3 &= ~RCC_CFGR3_USART2SW;
  }
  else 
  {
    /* Clear USART3SW[1:0] bit */
    RCC->CFGR3 &= ~RCC_CFGR3_USART3SW;
 800642a:	4b09      	ldr	r3, [pc, #36]	; (8006450 <RCC_USARTCLKConfig+0x34>)
 800642c:	400b      	ands	r3, r1
 800642e:	6313      	str	r3, [r2, #48]	; 0x30
  }

  /* Set USARTxSW bits according to RCC_USARTCLK value */
  RCC->CFGR3 |= RCC_USARTCLK;
 8006430:	4a06      	ldr	r2, [pc, #24]	; (800644c <RCC_USARTCLKConfig+0x30>)
 8006432:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8006434:	4318      	orrs	r0, r3
 8006436:	6310      	str	r0, [r2, #48]	; 0x30
}
 8006438:	4770      	bx	lr

  /* Clear USARTSW[1:0] bit */
  if (tmp == (uint32_t)0x00000001)
  {
    /* Clear USART1SW[1:0] bit */  
    RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
 800643a:	2103      	movs	r1, #3
 800643c:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800643e:	438b      	bics	r3, r1
 8006440:	6313      	str	r3, [r2, #48]	; 0x30
 8006442:	e7f5      	b.n	8006430 <RCC_USARTCLKConfig+0x14>
  }
  else if (tmp == (uint32_t)0x00000002)
  {
    /* Clear USART2SW[1:0] bit */
    RCC->CFGR3 &= ~RCC_CFGR3_USART2SW;
 8006444:	4b03      	ldr	r3, [pc, #12]	; (8006454 <RCC_USARTCLKConfig+0x38>)
 8006446:	400b      	ands	r3, r1
 8006448:	6313      	str	r3, [r2, #48]	; 0x30
 800644a:	e7f1      	b.n	8006430 <RCC_USARTCLKConfig+0x14>
 800644c:	40021000 	.word	0x40021000
 8006450:	fff3ffff 	.word	0xfff3ffff
 8006454:	fffcffff 	.word	0xfffcffff

08006458 <RCC_USBCLKConfig>:
{ 
  /* Check the parameters */
  assert_param(IS_RCC_USBCLK(RCC_USBCLK));

  /* Clear USBSW bit */
  RCC->CFGR3 &= ~RCC_CFGR3_USBSW;
 8006458:	2180      	movs	r1, #128	; 0x80
 800645a:	4b04      	ldr	r3, [pc, #16]	; (800646c <RCC_USBCLKConfig+0x14>)
 800645c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800645e:	438a      	bics	r2, r1
 8006460:	631a      	str	r2, [r3, #48]	; 0x30
  /* Set USBSW bits according to RCC_USBCLK value */
  RCC->CFGR3 |= RCC_USBCLK;
 8006462:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006464:	4310      	orrs	r0, r2
 8006466:	6318      	str	r0, [r3, #48]	; 0x30
}
 8006468:	4770      	bx	lr
 800646a:	46c0      	nop			; (mov r8, r8)
 800646c:	40021000 	.word	0x40021000

08006470 <RCC_GetClocksFreq>:
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8006470:	210c      	movs	r1, #12
 8006472:	4a5e      	ldr	r2, [pc, #376]	; (80065ec <RCC_GetClocksFreq+0x17c>)
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8006474:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8006476:	6853      	ldr	r3, [r2, #4]
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8006478:	1c04      	adds	r4, r0, #0
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 800647a:	400b      	ands	r3, r1
  
  switch (tmp)
 800647c:	2b04      	cmp	r3, #4
 800647e:	d009      	beq.n	8006494 <RCC_GetClocksFreq+0x24>
 8006480:	d908      	bls.n	8006494 <RCC_GetClocksFreq+0x24>
 8006482:	2b08      	cmp	r3, #8
 8006484:	d100      	bne.n	8006488 <RCC_GetClocksFreq+0x18>
 8006486:	e085      	b.n	8006594 <RCC_GetClocksFreq+0x124>
 8006488:	2b0c      	cmp	r3, #12
 800648a:	d103      	bne.n	8006494 <RCC_GetClocksFreq+0x24>
        pllclk = (HSE_VALUE / prediv1factor) * pllmull; 
      }
      RCC_Clocks->SYSCLK_Frequency = pllclk;      
      break;
    case 0x0C:  /* HSI48 used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI48_VALUE;
 800648c:	4958      	ldr	r1, [pc, #352]	; (80065f0 <RCC_GetClocksFreq+0x180>)
 800648e:	6001      	str	r1, [r0, #0]
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
 8006490:	2000      	movs	r0, #0
      }
      RCC_Clocks->SYSCLK_Frequency = pllclk;      
      break;
    case 0x0C:  /* HSI48 used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI48_VALUE;
      break;
 8006492:	e002      	b.n	800649a <RCC_GetClocksFreq+0x2a>
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
 8006494:	2000      	movs	r0, #0
      break;
    case 0x0C:  /* HSI48 used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI48_VALUE;
      break;
    default: /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8006496:	4957      	ldr	r1, [pc, #348]	; (80065f4 <RCC_GetClocksFreq+0x184>)
 8006498:	6021      	str	r1, [r4, #0]
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp]; 
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 800649a:	1c0a      	adds	r2, r1, #0
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
  }
  /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 800649c:	4d53      	ldr	r5, [pc, #332]	; (80065ec <RCC_GetClocksFreq+0x17c>)
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp]; 
 800649e:	4e56      	ldr	r6, [pc, #344]	; (80065f8 <RCC_GetClocksFreq+0x188>)
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
  }
  /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 80064a0:	686b      	ldr	r3, [r5, #4]
 80064a2:	061b      	lsls	r3, r3, #24
  tmp = tmp >> 4;
 80064a4:	0f1b      	lsrs	r3, r3, #28
  presc = APBAHBPrescTable[tmp]; 
 80064a6:	5cf3      	ldrb	r3, [r6, r3]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 80064a8:	40da      	lsrs	r2, r3
 80064aa:	1c13      	adds	r3, r2, #0
 80064ac:	6062      	str	r2, [r4, #4]

  /* Get PCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE;
 80064ae:	686a      	ldr	r2, [r5, #4]
 80064b0:	0552      	lsls	r2, r2, #21
  tmp = tmp >> 8;
 80064b2:	0f52      	lsrs	r2, r2, #29
  presc = APBAHBPrescTable[tmp];
 80064b4:	5cb2      	ldrb	r2, [r6, r2]
  /* PCLK clock frequency */
  RCC_Clocks->PCLK_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 80064b6:	40d3      	lsrs	r3, r2
 80064b8:	60a3      	str	r3, [r4, #8]

  /* ADCCLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_ADCSW) != RCC_CFGR3_ADCSW)
 80064ba:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 80064bc:	05d2      	lsls	r2, r2, #23
 80064be:	d460      	bmi.n	8006582 <RCC_GetClocksFreq+0x112>
  {
    /* ADC Clock is HSI14 Osc. */
    RCC_Clocks->ADCCLK_Frequency = HSI14_VALUE;
 80064c0:	4a4e      	ldr	r2, [pc, #312]	; (80065fc <RCC_GetClocksFreq+0x18c>)
 80064c2:	60e2      	str	r2, [r4, #12]
    }
    
  }

  /* CECCLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_CECSW) != RCC_CFGR3_CECSW)
 80064c4:	4a49      	ldr	r2, [pc, #292]	; (80065ec <RCC_GetClocksFreq+0x17c>)
 80064c6:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80064c8:	0652      	lsls	r2, r2, #25
 80064ca:	d456      	bmi.n	800657a <RCC_GetClocksFreq+0x10a>
  {
    /* CEC Clock is HSI/244 */
    RCC_Clocks->CECCLK_Frequency = HSI_VALUE / 244;
 80064cc:	4a4c      	ldr	r2, [pc, #304]	; (8006600 <RCC_GetClocksFreq+0x190>)
 80064ce:	6122      	str	r2, [r4, #16]
    /* CECC Clock is LSE Osc. */
    RCC_Clocks->CECCLK_Frequency = LSE_VALUE;
  }

  /* I2C1CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
 80064d0:	4a46      	ldr	r2, [pc, #280]	; (80065ec <RCC_GetClocksFreq+0x17c>)
 80064d2:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80064d4:	06d2      	lsls	r2, r2, #27
 80064d6:	d44e      	bmi.n	8006576 <RCC_GetClocksFreq+0x106>
  {
    /* I2C1 Clock is HSI Osc. */
    RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
 80064d8:	4a46      	ldr	r2, [pc, #280]	; (80065f4 <RCC_GetClocksFreq+0x184>)
 80064da:	6162      	str	r2, [r4, #20]
    /* I2C1 Clock is System Clock */
    RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
  }

  /* USART1CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == 0x0)
 80064dc:	2203      	movs	r2, #3
 80064de:	4d43      	ldr	r5, [pc, #268]	; (80065ec <RCC_GetClocksFreq+0x17c>)
 80064e0:	6b2e      	ldr	r6, [r5, #48]	; 0x30
 80064e2:	4232      	tst	r2, r6
 80064e4:	d138      	bne.n	8006558 <RCC_GetClocksFreq+0xe8>
  {
    /* USART1 Clock is PCLK */
    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK_Frequency;
 80064e6:	61a3      	str	r3, [r4, #24]
    /* USART1 Clock is HSI Osc. */
    RCC_Clocks->USART1CLK_Frequency = HSI_VALUE;
  }
  
  /* USART2CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == 0x0)
 80064e8:	22c0      	movs	r2, #192	; 0xc0
 80064ea:	4d40      	ldr	r5, [pc, #256]	; (80065ec <RCC_GetClocksFreq+0x17c>)
 80064ec:	0292      	lsls	r2, r2, #10
 80064ee:	6b2e      	ldr	r6, [r5, #48]	; 0x30
 80064f0:	4216      	tst	r6, r2
 80064f2:	d11e      	bne.n	8006532 <RCC_GetClocksFreq+0xc2>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->PCLK_Frequency;
 80064f4:	61e3      	str	r3, [r4, #28]
    /* USART Clock is HSI Osc. */
    RCC_Clocks->USART2CLK_Frequency = HSI_VALUE;
  }
  
  /* USART3CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == 0x0)
 80064f6:	22c0      	movs	r2, #192	; 0xc0
 80064f8:	4d3c      	ldr	r5, [pc, #240]	; (80065ec <RCC_GetClocksFreq+0x17c>)
 80064fa:	0312      	lsls	r2, r2, #12
 80064fc:	6b2e      	ldr	r6, [r5, #48]	; 0x30
 80064fe:	4216      	tst	r6, r2
 8006500:	d010      	beq.n	8006524 <RCC_GetClocksFreq+0xb4>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->PCLK_Frequency;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_0)
 8006502:	2680      	movs	r6, #128	; 0x80
 8006504:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8006506:	02f6      	lsls	r6, r6, #11
 8006508:	4013      	ands	r3, r2
 800650a:	42b3      	cmp	r3, r6
 800650c:	d05d      	beq.n	80065ca <RCC_GetClocksFreq+0x15a>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_1)
 800650e:	2180      	movs	r1, #128	; 0x80
 8006510:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8006512:	0309      	lsls	r1, r1, #12
 8006514:	4013      	ands	r3, r2
 8006516:	428b      	cmp	r3, r1
 8006518:	d064      	beq.n	80065e4 <RCC_GetClocksFreq+0x174>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART3CLK_Frequency = LSE_VALUE;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW)
 800651a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800651c:	4013      	ands	r3, r2
 800651e:	4293      	cmp	r3, r2
 8006520:	d101      	bne.n	8006526 <RCC_GetClocksFreq+0xb6>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->USART3CLK_Frequency = HSI_VALUE;
 8006522:	4b34      	ldr	r3, [pc, #208]	; (80065f4 <RCC_GetClocksFreq+0x184>)
 8006524:	6223      	str	r3, [r4, #32]
  }
  
  /* USBCLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USBSW) != RCC_CFGR3_USBSW)
 8006526:	4b31      	ldr	r3, [pc, #196]	; (80065ec <RCC_GetClocksFreq+0x17c>)
 8006528:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800652a:	061b      	lsls	r3, r3, #24
 800652c:	d546      	bpl.n	80065bc <RCC_GetClocksFreq+0x14c>
    RCC_Clocks->USBCLK_Frequency = HSI48_VALUE;
  }
  else
  {
    /* USB Clock is PLL clock */
    RCC_Clocks->USBCLK_Frequency = pllclk;
 800652e:	6260      	str	r0, [r4, #36]	; 0x24
  }   
}
 8006530:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == 0x0)
  {
    /* USART Clock is PCLK */
    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->PCLK_Frequency;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_0)
 8006532:	2780      	movs	r7, #128	; 0x80
 8006534:	6b2e      	ldr	r6, [r5, #48]	; 0x30
 8006536:	027f      	lsls	r7, r7, #9
 8006538:	4016      	ands	r6, r2
 800653a:	42be      	cmp	r6, r7
 800653c:	d043      	beq.n	80065c6 <RCC_GetClocksFreq+0x156>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_1)
 800653e:	2780      	movs	r7, #128	; 0x80
 8006540:	6b2e      	ldr	r6, [r5, #48]	; 0x30
 8006542:	02bf      	lsls	r7, r7, #10
 8006544:	4016      	ands	r6, r2
 8006546:	42be      	cmp	r6, r7
 8006548:	d044      	beq.n	80065d4 <RCC_GetClocksFreq+0x164>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART2CLK_Frequency = LSE_VALUE;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW)
 800654a:	6b2d      	ldr	r5, [r5, #48]	; 0x30
 800654c:	4015      	ands	r5, r2
 800654e:	4295      	cmp	r5, r2
 8006550:	d1d1      	bne.n	80064f6 <RCC_GetClocksFreq+0x86>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->USART2CLK_Frequency = HSI_VALUE;
 8006552:	4a28      	ldr	r2, [pc, #160]	; (80065f4 <RCC_GetClocksFreq+0x184>)
 8006554:	61e2      	str	r2, [r4, #28]
 8006556:	e7ce      	b.n	80064f6 <RCC_GetClocksFreq+0x86>
  if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == 0x0)
  {
    /* USART1 Clock is PCLK */
    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK_Frequency;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_0)
 8006558:	6b2e      	ldr	r6, [r5, #48]	; 0x30
 800655a:	4016      	ands	r6, r2
 800655c:	2e01      	cmp	r6, #1
 800655e:	d030      	beq.n	80065c2 <RCC_GetClocksFreq+0x152>
  {
    /* USART1 Clock is System Clock */
    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_1)
 8006560:	6b2e      	ldr	r6, [r5, #48]	; 0x30
 8006562:	4016      	ands	r6, r2
 8006564:	2e02      	cmp	r6, #2
 8006566:	d039      	beq.n	80065dc <RCC_GetClocksFreq+0x16c>
  {
    /* USART1 Clock is LSE Osc. */
    RCC_Clocks->USART1CLK_Frequency = LSE_VALUE;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW)
 8006568:	6b2d      	ldr	r5, [r5, #48]	; 0x30
 800656a:	402a      	ands	r2, r5
 800656c:	2a03      	cmp	r2, #3
 800656e:	d1bb      	bne.n	80064e8 <RCC_GetClocksFreq+0x78>
  {
    /* USART1 Clock is HSI Osc. */
    RCC_Clocks->USART1CLK_Frequency = HSI_VALUE;
 8006570:	4a20      	ldr	r2, [pc, #128]	; (80065f4 <RCC_GetClocksFreq+0x184>)
 8006572:	61a2      	str	r2, [r4, #24]
 8006574:	e7b8      	b.n	80064e8 <RCC_GetClocksFreq+0x78>
    RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
  }
  else
  {
    /* I2C1 Clock is System Clock */
    RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8006576:	6161      	str	r1, [r4, #20]
 8006578:	e7b0      	b.n	80064dc <RCC_GetClocksFreq+0x6c>
    RCC_Clocks->CECCLK_Frequency = HSI_VALUE / 244;
  }
  else
  {
    /* CECC Clock is LSE Osc. */
    RCC_Clocks->CECCLK_Frequency = LSE_VALUE;
 800657a:	2280      	movs	r2, #128	; 0x80
 800657c:	0212      	lsls	r2, r2, #8
 800657e:	6122      	str	r2, [r4, #16]
 8006580:	e7a6      	b.n	80064d0 <RCC_GetClocksFreq+0x60>
    /* ADC Clock is HSI14 Osc. */
    RCC_Clocks->ADCCLK_Frequency = HSI14_VALUE;
  }
  else
  {
    if((RCC->CFGR & RCC_CFGR_ADCPRE) != RCC_CFGR_ADCPRE)
 8006582:	686a      	ldr	r2, [r5, #4]
 8006584:	0452      	lsls	r2, r2, #17
 8006586:	d402      	bmi.n	800658e <RCC_GetClocksFreq+0x11e>
    {
      /* ADC Clock is derived from PCLK/2 */
      RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK_Frequency >> 1;
 8006588:	085a      	lsrs	r2, r3, #1
 800658a:	60e2      	str	r2, [r4, #12]
 800658c:	e79a      	b.n	80064c4 <RCC_GetClocksFreq+0x54>
    }
    else
    {
      /* ADC Clock is derived from PCLK/4 */
      RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK_Frequency >> 2;
 800658e:	089a      	lsrs	r2, r3, #2
 8006590:	60e2      	str	r2, [r4, #12]
 8006592:	e797      	b.n	80064c4 <RCC_GetClocksFreq+0x54>
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
      pllmull = ( pllmull >> 18) + 2;
      
      if (pllsource == 0x00)
 8006594:	23c0      	movs	r3, #192	; 0xc0
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
      break;
    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 8006596:	6850      	ldr	r0, [r2, #4]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 8006598:	6851      	ldr	r1, [r2, #4]
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
      break;
    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 800659a:	0280      	lsls	r0, r0, #10
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
      pllmull = ( pllmull >> 18) + 2;
 800659c:	0f00      	lsrs	r0, r0, #28
      
      if (pllsource == 0x00)
 800659e:	025b      	lsls	r3, r3, #9
      break;
    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
      pllmull = ( pllmull >> 18) + 2;
 80065a0:	1c85      	adds	r5, r0, #2
      
      if (pllsource == 0x00)
 80065a2:	4219      	tst	r1, r3
 80065a4:	d013      	beq.n	80065ce <RCC_GetClocksFreq+0x15e>
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        pllclk = (HSI_VALUE >> 1) * pllmull;
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 80065a6:	210f      	movs	r1, #15
 80065a8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        pllclk = (HSE_VALUE / prediv1factor) * pllmull; 
 80065aa:	4812      	ldr	r0, [pc, #72]	; (80065f4 <RCC_GetClocksFreq+0x184>)
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        pllclk = (HSI_VALUE >> 1) * pllmull;
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 80065ac:	4019      	ands	r1, r3
 80065ae:	3101      	adds	r1, #1
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        pllclk = (HSE_VALUE / prediv1factor) * pllmull; 
 80065b0:	f7fd f8e0 	bl	8003774 <__aeabi_uidiv>
 80065b4:	4368      	muls	r0, r5
      }
      RCC_Clocks->SYSCLK_Frequency = pllclk;      
 80065b6:	6020      	str	r0, [r4, #0]
      break;
 80065b8:	1c01      	adds	r1, r0, #0
 80065ba:	e76e      	b.n	800649a <RCC_GetClocksFreq+0x2a>
  
  /* USBCLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USBSW) != RCC_CFGR3_USBSW)
  {
    /* USB Clock is HSI48 */
    RCC_Clocks->USBCLK_Frequency = HSI48_VALUE;
 80065bc:	4b0c      	ldr	r3, [pc, #48]	; (80065f0 <RCC_GetClocksFreq+0x180>)
 80065be:	6263      	str	r3, [r4, #36]	; 0x24
 80065c0:	e7b6      	b.n	8006530 <RCC_GetClocksFreq+0xc0>
    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK_Frequency;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_0)
  {
    /* USART1 Clock is System Clock */
    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 80065c2:	61a1      	str	r1, [r4, #24]
 80065c4:	e790      	b.n	80064e8 <RCC_GetClocksFreq+0x78>
    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->PCLK_Frequency;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_0)
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 80065c6:	61e1      	str	r1, [r4, #28]
 80065c8:	e795      	b.n	80064f6 <RCC_GetClocksFreq+0x86>
    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->PCLK_Frequency;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_0)
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 80065ca:	6221      	str	r1, [r4, #32]
 80065cc:	e7ab      	b.n	8006526 <RCC_GetClocksFreq+0xb6>
      pllmull = ( pllmull >> 18) + 2;
      
      if (pllsource == 0x00)
      {
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        pllclk = (HSI_VALUE >> 1) * pllmull;
 80065ce:	480d      	ldr	r0, [pc, #52]	; (8006604 <RCC_GetClocksFreq+0x194>)
 80065d0:	4368      	muls	r0, r5
 80065d2:	e7f0      	b.n	80065b6 <RCC_GetClocksFreq+0x146>
    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_1)
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART2CLK_Frequency = LSE_VALUE;
 80065d4:	2280      	movs	r2, #128	; 0x80
 80065d6:	0212      	lsls	r2, r2, #8
 80065d8:	61e2      	str	r2, [r4, #28]
 80065da:	e78c      	b.n	80064f6 <RCC_GetClocksFreq+0x86>
    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_1)
  {
    /* USART1 Clock is LSE Osc. */
    RCC_Clocks->USART1CLK_Frequency = LSE_VALUE;
 80065dc:	2280      	movs	r2, #128	; 0x80
 80065de:	0212      	lsls	r2, r2, #8
 80065e0:	61a2      	str	r2, [r4, #24]
 80065e2:	e781      	b.n	80064e8 <RCC_GetClocksFreq+0x78>
    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_1)
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART3CLK_Frequency = LSE_VALUE;
 80065e4:	2380      	movs	r3, #128	; 0x80
 80065e6:	021b      	lsls	r3, r3, #8
 80065e8:	6223      	str	r3, [r4, #32]
 80065ea:	e79c      	b.n	8006526 <RCC_GetClocksFreq+0xb6>
 80065ec:	40021000 	.word	0x40021000
 80065f0:	02dc6c00 	.word	0x02dc6c00
 80065f4:	007a1200 	.word	0x007a1200
 80065f8:	2000003c 	.word	0x2000003c
 80065fc:	00d59f80 	.word	0x00d59f80
 8006600:	00008012 	.word	0x00008012
 8006604:	003d0900 	.word	0x003d0900

08006608 <RCC_RTCCLKConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 8006608:	4a02      	ldr	r2, [pc, #8]	; (8006614 <RCC_RTCCLKConfig+0xc>)
 800660a:	6a13      	ldr	r3, [r2, #32]
 800660c:	4318      	orrs	r0, r3
 800660e:	6210      	str	r0, [r2, #32]
}
 8006610:	4770      	bx	lr
 8006612:	46c0      	nop			; (mov r8, r8)
 8006614:	40021000 	.word	0x40021000

08006618 <RCC_RTCCLKCmd>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8006618:	4a06      	ldr	r2, [pc, #24]	; (8006634 <RCC_RTCCLKCmd+0x1c>)
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800661a:	2800      	cmp	r0, #0
 800661c:	d104      	bne.n	8006628 <RCC_RTCCLKCmd+0x10>
  {
    RCC->BDCR |= RCC_BDCR_RTCEN;
  }
  else
  {
    RCC->BDCR &= ~RCC_BDCR_RTCEN;
 800661e:	6a11      	ldr	r1, [r2, #32]
 8006620:	4b05      	ldr	r3, [pc, #20]	; (8006638 <RCC_RTCCLKCmd+0x20>)
 8006622:	400b      	ands	r3, r1
 8006624:	6213      	str	r3, [r2, #32]
  }
}
 8006626:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8006628:	2180      	movs	r1, #128	; 0x80
 800662a:	6a13      	ldr	r3, [r2, #32]
 800662c:	0209      	lsls	r1, r1, #8
 800662e:	430b      	orrs	r3, r1
 8006630:	6213      	str	r3, [r2, #32]
 8006632:	e7f8      	b.n	8006626 <RCC_RTCCLKCmd+0xe>
 8006634:	40021000 	.word	0x40021000
 8006638:	ffff7fff 	.word	0xffff7fff

0800663c <RCC_BackupResetCmd>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->BDCR |= RCC_BDCR_BDRST;
 800663c:	4a06      	ldr	r2, [pc, #24]	; (8006658 <RCC_BackupResetCmd+0x1c>)
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800663e:	2800      	cmp	r0, #0
 8006640:	d104      	bne.n	800664c <RCC_BackupResetCmd+0x10>
  {
    RCC->BDCR |= RCC_BDCR_BDRST;
  }
  else
  {
    RCC->BDCR &= ~RCC_BDCR_BDRST;
 8006642:	6a11      	ldr	r1, [r2, #32]
 8006644:	4b05      	ldr	r3, [pc, #20]	; (800665c <RCC_BackupResetCmd+0x20>)
 8006646:	400b      	ands	r3, r1
 8006648:	6213      	str	r3, [r2, #32]
  }
}
 800664a:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->BDCR |= RCC_BDCR_BDRST;
 800664c:	2180      	movs	r1, #128	; 0x80
 800664e:	6a13      	ldr	r3, [r2, #32]
 8006650:	0249      	lsls	r1, r1, #9
 8006652:	430b      	orrs	r3, r1
 8006654:	6213      	str	r3, [r2, #32]
 8006656:	e7f8      	b.n	800664a <RCC_BackupResetCmd+0xe>
 8006658:	40021000 	.word	0x40021000
 800665c:	fffeffff 	.word	0xfffeffff

08006660 <RCC_AHBPeriphClockCmd>:
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 8006660:	4a04      	ldr	r2, [pc, #16]	; (8006674 <RCC_AHBPeriphClockCmd+0x14>)
 8006662:	6953      	ldr	r3, [r2, #20]
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8006664:	2900      	cmp	r1, #0
 8006666:	d102      	bne.n	800666e <RCC_AHBPeriphClockCmd+0xe>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 8006668:	4383      	bics	r3, r0
 800666a:	6153      	str	r3, [r2, #20]
  }
}
 800666c:	4770      	bx	lr
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 800666e:	4318      	orrs	r0, r3
 8006670:	6150      	str	r0, [r2, #20]
 8006672:	e7fb      	b.n	800666c <RCC_AHBPeriphClockCmd+0xc>
 8006674:	40021000 	.word	0x40021000

08006678 <RCC_APB2PeriphClockCmd>:
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8006678:	4a04      	ldr	r2, [pc, #16]	; (800668c <RCC_APB2PeriphClockCmd+0x14>)
 800667a:	6993      	ldr	r3, [r2, #24]
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800667c:	2900      	cmp	r1, #0
 800667e:	d102      	bne.n	8006686 <RCC_APB2PeriphClockCmd+0xe>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8006680:	4383      	bics	r3, r0
 8006682:	6193      	str	r3, [r2, #24]
  }
}
 8006684:	4770      	bx	lr
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8006686:	4318      	orrs	r0, r3
 8006688:	6190      	str	r0, [r2, #24]
 800668a:	e7fb      	b.n	8006684 <RCC_APB2PeriphClockCmd+0xc>
 800668c:	40021000 	.word	0x40021000

08006690 <RCC_APB1PeriphClockCmd>:
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8006690:	4a04      	ldr	r2, [pc, #16]	; (80066a4 <RCC_APB1PeriphClockCmd+0x14>)
 8006692:	69d3      	ldr	r3, [r2, #28]
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8006694:	2900      	cmp	r1, #0
 8006696:	d102      	bne.n	800669e <RCC_APB1PeriphClockCmd+0xe>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8006698:	4383      	bics	r3, r0
 800669a:	61d3      	str	r3, [r2, #28]
  }
}
 800669c:	4770      	bx	lr
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 800669e:	4318      	orrs	r0, r3
 80066a0:	61d0      	str	r0, [r2, #28]
 80066a2:	e7fb      	b.n	800669c <RCC_APB1PeriphClockCmd+0xc>
 80066a4:	40021000 	.word	0x40021000

080066a8 <RCC_AHBPeriphResetCmd>:
  assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHBRSTR |= RCC_AHBPeriph;
 80066a8:	4a04      	ldr	r2, [pc, #16]	; (80066bc <RCC_AHBPeriphResetCmd+0x14>)
 80066aa:	6a93      	ldr	r3, [r2, #40]	; 0x28
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80066ac:	2900      	cmp	r1, #0
 80066ae:	d102      	bne.n	80066b6 <RCC_AHBPeriphResetCmd+0xe>
  {
    RCC->AHBRSTR |= RCC_AHBPeriph;
  }
  else
  {
    RCC->AHBRSTR &= ~RCC_AHBPeriph;
 80066b0:	4383      	bics	r3, r0
 80066b2:	6293      	str	r3, [r2, #40]	; 0x28
  }
}
 80066b4:	4770      	bx	lr
  assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHBRSTR |= RCC_AHBPeriph;
 80066b6:	4318      	orrs	r0, r3
 80066b8:	6290      	str	r0, [r2, #40]	; 0x28
 80066ba:	e7fb      	b.n	80066b4 <RCC_AHBPeriphResetCmd+0xc>
 80066bc:	40021000 	.word	0x40021000

080066c0 <RCC_APB2PeriphResetCmd>:
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 80066c0:	4a04      	ldr	r2, [pc, #16]	; (80066d4 <RCC_APB2PeriphResetCmd+0x14>)
 80066c2:	68d3      	ldr	r3, [r2, #12]
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80066c4:	2900      	cmp	r1, #0
 80066c6:	d102      	bne.n	80066ce <RCC_APB2PeriphResetCmd+0xe>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 80066c8:	4383      	bics	r3, r0
 80066ca:	60d3      	str	r3, [r2, #12]
  }
}
 80066cc:	4770      	bx	lr
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 80066ce:	4318      	orrs	r0, r3
 80066d0:	60d0      	str	r0, [r2, #12]
 80066d2:	e7fb      	b.n	80066cc <RCC_APB2PeriphResetCmd+0xc>
 80066d4:	40021000 	.word	0x40021000

080066d8 <RCC_APB1PeriphResetCmd>:
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 80066d8:	4a04      	ldr	r2, [pc, #16]	; (80066ec <RCC_APB1PeriphResetCmd+0x14>)
 80066da:	6913      	ldr	r3, [r2, #16]
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80066dc:	2900      	cmp	r1, #0
 80066de:	d102      	bne.n	80066e6 <RCC_APB1PeriphResetCmd+0xe>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 80066e0:	4383      	bics	r3, r0
 80066e2:	6113      	str	r3, [r2, #16]
  }
}
 80066e4:	4770      	bx	lr
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 80066e6:	4318      	orrs	r0, r3
 80066e8:	6110      	str	r0, [r2, #16]
 80066ea:	e7fb      	b.n	80066e4 <RCC_APB1PeriphResetCmd+0xc>
 80066ec:	40021000 	.word	0x40021000

080066f0 <RCC_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE1_ADDRESS |= RCC_IT;
 80066f0:	4a04      	ldr	r2, [pc, #16]	; (8006704 <RCC_ITConfig+0x14>)
 80066f2:	7813      	ldrb	r3, [r2, #0]
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80066f4:	2900      	cmp	r1, #0
 80066f6:	d102      	bne.n	80066fe <RCC_ITConfig+0xe>
    *(__IO uint8_t *) CIR_BYTE1_ADDRESS |= RCC_IT;
  }
  else
  {
    /* Perform Byte access to RCC_CIR[13:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE1_ADDRESS &= (uint8_t)~RCC_IT;
 80066f8:	4383      	bics	r3, r0
 80066fa:	7013      	strb	r3, [r2, #0]
  }
}
 80066fc:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE1_ADDRESS |= RCC_IT;
 80066fe:	4318      	orrs	r0, r3
 8006700:	7010      	strb	r0, [r2, #0]
 8006702:	e7fb      	b.n	80066fc <RCC_ITConfig+0xc>
 8006704:	40021009 	.word	0x40021009

08006708 <RCC_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8006708:	0943      	lsrs	r3, r0, #5

  if (tmp == 0)               /* The flag to check is in CR register */
 800670a:	d108      	bne.n	800671e <RCC_GetFlagStatus+0x16>
  {
    statusreg = RCC->CR;
 800670c:	4b0a      	ldr	r3, [pc, #40]	; (8006738 <RCC_GetFlagStatus+0x30>)
 800670e:	681b      	ldr	r3, [r3, #0]
  }    

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;

  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8006710:	221f      	movs	r2, #31
 8006712:	4010      	ands	r0, r2
 8006714:	40c3      	lsrs	r3, r0
 8006716:	1c18      	adds	r0, r3, #0
  else
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
 8006718:	2301      	movs	r3, #1
 800671a:	4018      	ands	r0, r3
}
 800671c:	4770      	bx	lr

  if (tmp == 0)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 1)          /* The flag to check is in BDCR register */
 800671e:	2b01      	cmp	r3, #1
 8006720:	d004      	beq.n	800672c <RCC_GetFlagStatus+0x24>
  {
    statusreg = RCC->BDCR;
  }
  else if (tmp == 2)          /* The flag to check is in CSR register */
 8006722:	2b02      	cmp	r3, #2
 8006724:	d005      	beq.n	8006732 <RCC_GetFlagStatus+0x2a>
  {
    statusreg = RCC->CSR;
  }
  else                        /* The flag to check is in CR2 register */
  {
    statusreg = RCC->CR2;
 8006726:	4b04      	ldr	r3, [pc, #16]	; (8006738 <RCC_GetFlagStatus+0x30>)
 8006728:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800672a:	e7f1      	b.n	8006710 <RCC_GetFlagStatus+0x8>
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 1)          /* The flag to check is in BDCR register */
  {
    statusreg = RCC->BDCR;
 800672c:	4b02      	ldr	r3, [pc, #8]	; (8006738 <RCC_GetFlagStatus+0x30>)
 800672e:	6a1b      	ldr	r3, [r3, #32]
 8006730:	e7ee      	b.n	8006710 <RCC_GetFlagStatus+0x8>
  }
  else if (tmp == 2)          /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8006732:	4b01      	ldr	r3, [pc, #4]	; (8006738 <RCC_GetFlagStatus+0x30>)
 8006734:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006736:	e7eb      	b.n	8006710 <RCC_GetFlagStatus+0x8>
 8006738:	40021000 	.word	0x40021000

0800673c <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 800673c:	b510      	push	{r4, lr}
  __IO uint32_t StartUpCounter = 0;
 800673e:	2300      	movs	r3, #0
  /* Wait till HSE is ready and if timeout is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    StartUpCounter++;  
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 8006740:	24a0      	movs	r4, #160	; 0xa0
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 8006742:	b082      	sub	sp, #8
  __IO uint32_t StartUpCounter = 0;
 8006744:	9301      	str	r3, [sp, #4]
  /* Wait till HSE is ready and if timeout is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    StartUpCounter++;  
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 8006746:	01e4      	lsls	r4, r4, #7
 8006748:	e001      	b.n	800674e <RCC_WaitForHSEStartUp+0x12>
 800674a:	2800      	cmp	r0, #0
 800674c:	d108      	bne.n	8006760 <RCC_WaitForHSEStartUp+0x24>
  FlagStatus HSEStatus = RESET;
  
  /* Wait till HSE is ready and if timeout is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 800674e:	2011      	movs	r0, #17
 8006750:	f7ff ffda 	bl	8006708 <RCC_GetFlagStatus>
    StartUpCounter++;  
 8006754:	9b01      	ldr	r3, [sp, #4]
 8006756:	3301      	adds	r3, #1
 8006758:	9301      	str	r3, [sp, #4]
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 800675a:	9b01      	ldr	r3, [sp, #4]
 800675c:	42a3      	cmp	r3, r4
 800675e:	d1f4      	bne.n	800674a <RCC_WaitForHSEStartUp+0xe>
  
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 8006760:	2011      	movs	r0, #17
 8006762:	f7ff ffd1 	bl	8006708 <RCC_GetFlagStatus>
 8006766:	1e43      	subs	r3, r0, #1
 8006768:	4198      	sbcs	r0, r3
  }
  else
  {
    status = ERROR;
  }  
  return (status);
 800676a:	b2c0      	uxtb	r0, r0
}
 800676c:	b002      	add	sp, #8
 800676e:	bd10      	pop	{r4, pc}

08006770 <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
 8006770:	2180      	movs	r1, #128	; 0x80
 8006772:	4a03      	ldr	r2, [pc, #12]	; (8006780 <RCC_ClearFlag+0x10>)
 8006774:	0449      	lsls	r1, r1, #17
 8006776:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8006778:	430b      	orrs	r3, r1
 800677a:	6253      	str	r3, [r2, #36]	; 0x24
}
 800677c:	4770      	bx	lr
 800677e:	46c0      	nop			; (mov r8, r8)
 8006780:	40021000 	.word	0x40021000

08006784 <RCC_GetITStatus>:
  
  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));
  
  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 8006784:	4b03      	ldr	r3, [pc, #12]	; (8006794 <RCC_GetITStatus+0x10>)
 8006786:	689b      	ldr	r3, [r3, #8]
 8006788:	4018      	ands	r0, r3
 800678a:	1e43      	subs	r3, r0, #1
 800678c:	4198      	sbcs	r0, r3
  else
  {
    bitstatus = RESET;
  }
  /* Return the RCC_IT status */
  return  bitstatus;
 800678e:	b2c0      	uxtb	r0, r0
}
 8006790:	4770      	bx	lr
 8006792:	46c0      	nop			; (mov r8, r8)
 8006794:	40021000 	.word	0x40021000

08006798 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));
  
  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE2_ADDRESS = RCC_IT;
 8006798:	4b01      	ldr	r3, [pc, #4]	; (80067a0 <RCC_ClearITPendingBit+0x8>)
 800679a:	7018      	strb	r0, [r3, #0]
}
 800679c:	4770      	bx	lr
 800679e:	46c0      	nop			; (mov r8, r8)
 80067a0:	4002100a 	.word	0x4002100a

080067a4 <RTC_StructInit>:
  * @retval None
  */
void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
{
  /* Initialize the RTC_HourFormat member */
  RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
 80067a4:	2300      	movs	r3, #0
 80067a6:	6003      	str	r3, [r0, #0]

  /* Initialize the RTC_AsynchPrediv member */
  RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
 80067a8:	337f      	adds	r3, #127	; 0x7f
 80067aa:	6043      	str	r3, [r0, #4]

  /* Initialize the RTC_SynchPrediv member */
  RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
 80067ac:	3380      	adds	r3, #128	; 0x80
 80067ae:	6083      	str	r3, [r0, #8]
}
 80067b0:	4770      	bx	lr
 80067b2:	46c0      	nop			; (mov r8, r8)

080067b4 <RTC_WriteProtectionCmd>:
void RTC_WriteProtectionCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80067b4:	2800      	cmp	r0, #0
 80067b6:	d105      	bne.n	80067c4 <RTC_WriteProtectionCmd+0x10>
    RTC->WPR = 0xFF;
  }
  else
  {
    /* Disable the write protection for RTC registers */
    RTC->WPR = 0xCA;
 80067b8:	22ca      	movs	r2, #202	; 0xca
 80067ba:	4b04      	ldr	r3, [pc, #16]	; (80067cc <RTC_WriteProtectionCmd+0x18>)
 80067bc:	625a      	str	r2, [r3, #36]	; 0x24
    RTC->WPR = 0x53;
 80067be:	3a77      	subs	r2, #119	; 0x77
 80067c0:	625a      	str	r2, [r3, #36]	; 0x24
  }
}
 80067c2:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the write protection for RTC registers */
    RTC->WPR = 0xFF;
 80067c4:	22ff      	movs	r2, #255	; 0xff
 80067c6:	4b01      	ldr	r3, [pc, #4]	; (80067cc <RTC_WriteProtectionCmd+0x18>)
 80067c8:	625a      	str	r2, [r3, #36]	; 0x24
 80067ca:	e7fa      	b.n	80067c2 <RTC_WriteProtectionCmd+0xe>
 80067cc:	40002800 	.word	0x40002800

080067d0 <RTC_EnterInitMode>:
  *          - SUCCESS: RTC is in Init mode
  *          - ERROR: RTC is not in Init mode
  */
ErrorStatus RTC_EnterInitMode(void)
{
  __IO uint32_t initcounter = 0x00;
 80067d0:	2300      	movs	r3, #0
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC is in Init mode
  *          - ERROR: RTC is not in Init mode
  */
ErrorStatus RTC_EnterInitMode(void)
{
 80067d2:	b510      	push	{r4, lr}
  __IO uint32_t initcounter = 0x00;
  ErrorStatus status = ERROR;
  uint32_t initstatus = 0x00;

  /* Check if the Initialization mode is set */
  if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 80067d4:	490f      	ldr	r1, [pc, #60]	; (8006814 <RTC_EnterInitMode+0x44>)
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC is in Init mode
  *          - ERROR: RTC is not in Init mode
  */
ErrorStatus RTC_EnterInitMode(void)
{
 80067d6:	b082      	sub	sp, #8
  __IO uint32_t initcounter = 0x00;
 80067d8:	9301      	str	r3, [sp, #4]
  ErrorStatus status = ERROR;
  uint32_t initstatus = 0x00;

  /* Check if the Initialization mode is set */
  if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 80067da:	68cb      	ldr	r3, [r1, #12]
      status = ERROR;
    }
  }
  else
  {
    status = SUCCESS;
 80067dc:	2001      	movs	r0, #1
  __IO uint32_t initcounter = 0x00;
  ErrorStatus status = ERROR;
  uint32_t initstatus = 0x00;

  /* Check if the Initialization mode is set */
  if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 80067de:	065b      	lsls	r3, r3, #25
 80067e0:	d415      	bmi.n	800680e <RTC_EnterInitMode+0x3e>
  {
    /* Set the Initialization mode */
    RTC->ISR = (uint32_t)RTC_INIT_MASK;
 80067e2:	2301      	movs	r3, #1
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    do
    {
      initstatus = RTC->ISR & RTC_ISR_INITF;
      initcounter++;  
    } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
 80067e4:	2080      	movs	r0, #128	; 0x80

  /* Check if the Initialization mode is set */
  if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
  {
    /* Set the Initialization mode */
    RTC->ISR = (uint32_t)RTC_INIT_MASK;
 80067e6:	425b      	negs	r3, r3
 80067e8:	60cb      	str	r3, [r1, #12]
    
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    do
    {
      initstatus = RTC->ISR & RTC_ISR_INITF;
 80067ea:	2440      	movs	r4, #64	; 0x40
      initcounter++;  
    } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
 80067ec:	01c0      	lsls	r0, r0, #7
 80067ee:	e001      	b.n	80067f4 <RTC_EnterInitMode+0x24>
 80067f0:	2a00      	cmp	r2, #0
 80067f2:	d108      	bne.n	8006806 <RTC_EnterInitMode+0x36>
    RTC->ISR = (uint32_t)RTC_INIT_MASK;
    
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    do
    {
      initstatus = RTC->ISR & RTC_ISR_INITF;
 80067f4:	68cb      	ldr	r3, [r1, #12]
 80067f6:	4023      	ands	r3, r4
 80067f8:	1c1a      	adds	r2, r3, #0
      initcounter++;  
 80067fa:	9b01      	ldr	r3, [sp, #4]
 80067fc:	3301      	adds	r3, #1
 80067fe:	9301      	str	r3, [sp, #4]
    } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
 8006800:	9b01      	ldr	r3, [sp, #4]
 8006802:	4283      	cmp	r3, r0
 8006804:	d1f4      	bne.n	80067f0 <RTC_EnterInitMode+0x20>
    
    if ((RTC->ISR & RTC_ISR_INITF) != RESET)
 8006806:	4b03      	ldr	r3, [pc, #12]	; (8006814 <RTC_EnterInitMode+0x44>)
 8006808:	68d8      	ldr	r0, [r3, #12]
 800680a:	0640      	lsls	r0, r0, #25
    {
      status = SUCCESS;
    }
    else
    {
      status = ERROR;
 800680c:	0fc0      	lsrs	r0, r0, #31
  {
    status = SUCCESS;
  }

  return (status);
}
 800680e:	b002      	add	sp, #8
 8006810:	bd10      	pop	{r4, pc}
 8006812:	46c0      	nop			; (mov r8, r8)
 8006814:	40002800 	.word	0x40002800

08006818 <RTC_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are initialized
  *          - ERROR: RTC registers are not initialized  
  */
ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
{
 8006818:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
  assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
  assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800681a:	23ca      	movs	r3, #202	; 0xca
 800681c:	4c11      	ldr	r4, [pc, #68]	; (8006864 <RTC_Init+0x4c>)
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are initialized
  *          - ERROR: RTC registers are not initialized  
  */
ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
{
 800681e:	1c05      	adds	r5, r0, #0
  assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
  assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
  assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006820:	6263      	str	r3, [r4, #36]	; 0x24
  RTC->WPR = 0x53;
 8006822:	3b77      	subs	r3, #119	; 0x77
 8006824:	6263      	str	r3, [r4, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8006826:	f7ff ffd3 	bl	80067d0 <RTC_EnterInitMode>
  {
    status = ERROR;
 800682a:	2300      	movs	r3, #0
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 800682c:	2800      	cmp	r0, #0
 800682e:	d013      	beq.n	8006858 <RTC_Init+0x40>
    status = ERROR;
  }
  else
  {
    /* Clear RTC CR FMT Bit */
    RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
 8006830:	2240      	movs	r2, #64	; 0x40
 8006832:	68a3      	ldr	r3, [r4, #8]
 8006834:	4393      	bics	r3, r2
 8006836:	60a3      	str	r3, [r4, #8]
    /* Set RTC_CR register */
    RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
 8006838:	68a3      	ldr	r3, [r4, #8]
 800683a:	682a      	ldr	r2, [r5, #0]
 800683c:	4313      	orrs	r3, r2
 800683e:	60a3      	str	r3, [r4, #8]
  
    /* Configure the RTC PRER */
    RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
 8006840:	68ab      	ldr	r3, [r5, #8]
 8006842:	6123      	str	r3, [r4, #16]
    RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
 8006844:	686b      	ldr	r3, [r5, #4]
 8006846:	6922      	ldr	r2, [r4, #16]
 8006848:	041b      	lsls	r3, r3, #16
 800684a:	4313      	orrs	r3, r2
  * @retval None
  */
void RTC_ExitInitMode(void)
{
  /* Exit Initialization mode */
  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;
 800684c:	2280      	movs	r2, #128	; 0x80
    /* Set RTC_CR register */
    RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
  
    /* Configure the RTC PRER */
    RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
    RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
 800684e:	6123      	str	r3, [r4, #16]
  * @retval None
  */
void RTC_ExitInitMode(void)
{
  /* Exit Initialization mode */
  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;
 8006850:	68e3      	ldr	r3, [r4, #12]
 8006852:	4393      	bics	r3, r2
 8006854:	60e3      	str	r3, [r4, #12]
    RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);

    /* Exit Initialization mode */
    RTC_ExitInitMode();

    status = SUCCESS;
 8006856:	2301      	movs	r3, #1
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006858:	21ff      	movs	r1, #255	; 0xff
 800685a:	4a02      	ldr	r2, [pc, #8]	; (8006864 <RTC_Init+0x4c>)

  return status;
}
 800685c:	1c18      	adds	r0, r3, #0
    RTC_ExitInitMode();

    status = SUCCESS;
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 800685e:	6251      	str	r1, [r2, #36]	; 0x24

  return status;
}
 8006860:	bd38      	pop	{r3, r4, r5, pc}
 8006862:	46c0      	nop			; (mov r8, r8)
 8006864:	40002800 	.word	0x40002800

08006868 <RTC_ExitInitMode>:
  * @retval None
  */
void RTC_ExitInitMode(void)
{
  /* Exit Initialization mode */
  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;
 8006868:	2180      	movs	r1, #128	; 0x80
 800686a:	4a02      	ldr	r2, [pc, #8]	; (8006874 <RTC_ExitInitMode+0xc>)
 800686c:	68d3      	ldr	r3, [r2, #12]
 800686e:	438b      	bics	r3, r1
 8006870:	60d3      	str	r3, [r2, #12]
}
 8006872:	4770      	bx	lr
 8006874:	40002800 	.word	0x40002800

08006878 <RTC_WaitForSynchro>:
  *          - SUCCESS: RTC registers are synchronised
  *          - ERROR: RTC registers are not synchronised
  */
ErrorStatus RTC_WaitForSynchro(void)
{
  __IO uint32_t synchrocounter = 0;
 8006878:	2300      	movs	r3, #0
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are synchronised
  *          - ERROR: RTC registers are not synchronised
  */
ErrorStatus RTC_WaitForSynchro(void)
{
 800687a:	b510      	push	{r4, lr}
  __IO uint32_t synchrocounter = 0;
  ErrorStatus status = ERROR;
  uint32_t synchrostatus = 0x00;

  if ((RTC->CR & RTC_CR_BYPSHAD) != RESET)
 800687c:	4912      	ldr	r1, [pc, #72]	; (80068c8 <RTC_WaitForSynchro+0x50>)
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are synchronised
  *          - ERROR: RTC registers are not synchronised
  */
ErrorStatus RTC_WaitForSynchro(void)
{
 800687e:	b082      	sub	sp, #8
  __IO uint32_t synchrocounter = 0;
 8006880:	9301      	str	r3, [sp, #4]
  ErrorStatus status = ERROR;
  uint32_t synchrostatus = 0x00;

  if ((RTC->CR & RTC_CR_BYPSHAD) != RESET)
 8006882:	688b      	ldr	r3, [r1, #8]
  {
    /* Bypass shadow mode */
    status = SUCCESS;
 8006884:	2001      	movs	r0, #1
{
  __IO uint32_t synchrocounter = 0;
  ErrorStatus status = ERROR;
  uint32_t synchrostatus = 0x00;

  if ((RTC->CR & RTC_CR_BYPSHAD) != RESET)
 8006886:	069b      	lsls	r3, r3, #26
 8006888:	d41c      	bmi.n	80068c4 <RTC_WaitForSynchro+0x4c>
    status = SUCCESS;
  }
  else
  {
    /* Disable the write protection for RTC registers */
    RTC->WPR = 0xCA;
 800688a:	23ca      	movs	r3, #202	; 0xca
    RTC->WPR = 0x53;

    /* Clear RSF flag */
    RTC->ISR &= (uint32_t)RTC_RSF_MASK;
 800688c:	22a0      	movs	r2, #160	; 0xa0
    /* Wait the registers to be synchronised */
    do
    {
      synchrostatus = RTC->ISR & RTC_ISR_RSF;
      synchrocounter++;  
    } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
 800688e:	2080      	movs	r0, #128	; 0x80
    status = SUCCESS;
  }
  else
  {
    /* Disable the write protection for RTC registers */
    RTC->WPR = 0xCA;
 8006890:	624b      	str	r3, [r1, #36]	; 0x24
    RTC->WPR = 0x53;
 8006892:	3b77      	subs	r3, #119	; 0x77
 8006894:	624b      	str	r3, [r1, #36]	; 0x24

    /* Clear RSF flag */
    RTC->ISR &= (uint32_t)RTC_RSF_MASK;
 8006896:	68cb      	ldr	r3, [r1, #12]

    /* Wait the registers to be synchronised */
    do
    {
      synchrostatus = RTC->ISR & RTC_ISR_RSF;
 8006898:	2420      	movs	r4, #32
    /* Disable the write protection for RTC registers */
    RTC->WPR = 0xCA;
    RTC->WPR = 0x53;

    /* Clear RSF flag */
    RTC->ISR &= (uint32_t)RTC_RSF_MASK;
 800689a:	4393      	bics	r3, r2
 800689c:	60cb      	str	r3, [r1, #12]
    /* Wait the registers to be synchronised */
    do
    {
      synchrostatus = RTC->ISR & RTC_ISR_RSF;
      synchrocounter++;  
    } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
 800689e:	0200      	lsls	r0, r0, #8
 80068a0:	e001      	b.n	80068a6 <RTC_WaitForSynchro+0x2e>
 80068a2:	2a00      	cmp	r2, #0
 80068a4:	d108      	bne.n	80068b8 <RTC_WaitForSynchro+0x40>
    RTC->ISR &= (uint32_t)RTC_RSF_MASK;

    /* Wait the registers to be synchronised */
    do
    {
      synchrostatus = RTC->ISR & RTC_ISR_RSF;
 80068a6:	68cb      	ldr	r3, [r1, #12]
 80068a8:	4023      	ands	r3, r4
 80068aa:	1c1a      	adds	r2, r3, #0
      synchrocounter++;  
 80068ac:	9b01      	ldr	r3, [sp, #4]
 80068ae:	3301      	adds	r3, #1
 80068b0:	9301      	str	r3, [sp, #4]
    } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
 80068b2:	9b01      	ldr	r3, [sp, #4]
 80068b4:	4283      	cmp	r3, r0
 80068b6:	d1f4      	bne.n	80068a2 <RTC_WaitForSynchro+0x2a>
    {
      status = ERROR;
    }

    /* Enable the write protection for RTC registers */
    RTC->WPR = 0xFF;
 80068b8:	22ff      	movs	r2, #255	; 0xff
    {
      synchrostatus = RTC->ISR & RTC_ISR_RSF;
      synchrocounter++;  
    } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));

    if ((RTC->ISR & RTC_ISR_RSF) != RESET)
 80068ba:	4b03      	ldr	r3, [pc, #12]	; (80068c8 <RTC_WaitForSynchro+0x50>)
 80068bc:	68d8      	ldr	r0, [r3, #12]
    {
      status = ERROR;
    }

    /* Enable the write protection for RTC registers */
    RTC->WPR = 0xFF;
 80068be:	625a      	str	r2, [r3, #36]	; 0x24
    {
      synchrostatus = RTC->ISR & RTC_ISR_RSF;
      synchrocounter++;  
    } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));

    if ((RTC->ISR & RTC_ISR_RSF) != RESET)
 80068c0:	0680      	lsls	r0, r0, #26
    {
      status = SUCCESS;
 80068c2:	0fc0      	lsrs	r0, r0, #31
    /* Enable the write protection for RTC registers */
    RTC->WPR = 0xFF;
  }

  return (status);
}
 80068c4:	b002      	add	sp, #8
 80068c6:	bd10      	pop	{r4, pc}
 80068c8:	40002800 	.word	0x40002800

080068cc <RTC_DeInit>:
ErrorStatus RTC_DeInit(void)
{
  ErrorStatus status = ERROR;
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80068cc:	23ca      	movs	r3, #202	; 0xca
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are deinitialized
  *          - ERROR: RTC registers are not deinitialized
  */
ErrorStatus RTC_DeInit(void)
{
 80068ce:	b510      	push	{r4, lr}
  ErrorStatus status = ERROR;
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80068d0:	4c10      	ldr	r4, [pc, #64]	; (8006914 <RTC_DeInit+0x48>)
 80068d2:	6263      	str	r3, [r4, #36]	; 0x24
  RTC->WPR = 0x53;
 80068d4:	3b77      	subs	r3, #119	; 0x77
 80068d6:	6263      	str	r3, [r4, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 80068d8:	f7ff ff7a 	bl	80067d0 <RTC_EnterInitMode>
 80068dc:	1c03      	adds	r3, r0, #0
  {
    status = ERROR;
 80068de:	2000      	movs	r0, #0
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 80068e0:	2b00      	cmp	r3, #0
 80068e2:	d013      	beq.n	800690c <RTC_DeInit+0x40>
  }  
  else
  {
    /* Reset TR, DR and CR registers */
    RTC->TR        = (uint32_t)0x00000000;
    RTC->WUTR      = (uint32_t)0x0000FFFF;
 80068e4:	4b0c      	ldr	r3, [pc, #48]	; (8006918 <RTC_DeInit+0x4c>)
    status = ERROR;
  }  
  else
  {
    /* Reset TR, DR and CR registers */
    RTC->TR        = (uint32_t)0x00000000;
 80068e6:	6020      	str	r0, [r4, #0]
    RTC->WUTR      = (uint32_t)0x0000FFFF;
 80068e8:	6163      	str	r3, [r4, #20]
    RTC->DR        = (uint32_t)0x00002101;
 80068ea:	4b0c      	ldr	r3, [pc, #48]	; (800691c <RTC_DeInit+0x50>)
 80068ec:	6063      	str	r3, [r4, #4]
    RTC->CR        &= (uint32_t)0x00000000;
 80068ee:	68a3      	ldr	r3, [r4, #8]
    RTC->PRER      = (uint32_t)0x007F00FF;
 80068f0:	4b0b      	ldr	r3, [pc, #44]	; (8006920 <RTC_DeInit+0x54>)
  {
    /* Reset TR, DR and CR registers */
    RTC->TR        = (uint32_t)0x00000000;
    RTC->WUTR      = (uint32_t)0x0000FFFF;
    RTC->DR        = (uint32_t)0x00002101;
    RTC->CR        &= (uint32_t)0x00000000;
 80068f2:	60a0      	str	r0, [r4, #8]
    RTC->PRER      = (uint32_t)0x007F00FF;
 80068f4:	6123      	str	r3, [r4, #16]
    RTC->ALRMAR    = (uint32_t)0x00000000;
 80068f6:	61e0      	str	r0, [r4, #28]
    RTC->SHIFTR    = (uint32_t)0x00000000;
 80068f8:	62e0      	str	r0, [r4, #44]	; 0x2c
    RTC->CALR       = (uint32_t)0x00000000;
 80068fa:	63e0      	str	r0, [r4, #60]	; 0x3c
    RTC->ALRMASSR  = (uint32_t)0x00000000;
 80068fc:	6460      	str	r0, [r4, #68]	; 0x44

    /* Reset ISR register and exit initialization mode */
    RTC->ISR = (uint32_t)0x00000000;
 80068fe:	60e0      	str	r0, [r4, #12]
    
    /* Reset Tamper and alternate functions configuration register */
    RTC->TAFCR = 0x00000000;
 8006900:	6420      	str	r0, [r4, #64]	; 0x40
      
    /* Wait till the RTC RSF flag is set */
    if (RTC_WaitForSynchro() == ERROR)
 8006902:	f7ff ffb9 	bl	8006878 <RTC_WaitForSynchro>
 8006906:	1e43      	subs	r3, r0, #1
 8006908:	4198      	sbcs	r0, r3
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  {
    status = ERROR;
 800690a:	b2c0      	uxtb	r0, r0
    }

  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;  
 800690c:	22ff      	movs	r2, #255	; 0xff
 800690e:	4b01      	ldr	r3, [pc, #4]	; (8006914 <RTC_DeInit+0x48>)
 8006910:	625a      	str	r2, [r3, #36]	; 0x24

  return status;
}
 8006912:	bd10      	pop	{r4, pc}
 8006914:	40002800 	.word	0x40002800
 8006918:	0000ffff 	.word	0x0000ffff
 800691c:	00002101 	.word	0x00002101
 8006920:	007f00ff 	.word	0x007f00ff

08006924 <RTC_RefClockCmd>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC reference clock detection is enabled
  *          - ERROR: RTC reference clock detection is disabled  
  */
ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
{
 8006924:	b538      	push	{r3, r4, r5, lr}

  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006926:	23ca      	movs	r3, #202	; 0xca
 8006928:	4c0f      	ldr	r4, [pc, #60]	; (8006968 <RTC_RefClockCmd+0x44>)
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC reference clock detection is enabled
  *          - ERROR: RTC reference clock detection is disabled  
  */
ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
{
 800692a:	1c05      	adds	r5, r0, #0

  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800692c:	6263      	str	r3, [r4, #36]	; 0x24
  RTC->WPR = 0x53;
 800692e:	3b77      	subs	r3, #119	; 0x77
 8006930:	6263      	str	r3, [r4, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8006932:	f7ff ff4d 	bl	80067d0 <RTC_EnterInitMode>
  {
    status = ERROR;
 8006936:	2300      	movs	r3, #0
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8006938:	2800      	cmp	r0, #0
 800693a:	d00b      	beq.n	8006954 <RTC_RefClockCmd+0x30>
  {
    status = ERROR;
  }
  else
  {
    if (NewState != DISABLE)
 800693c:	2d00      	cmp	r5, #0
 800693e:	d10e      	bne.n	800695e <RTC_RefClockCmd+0x3a>
      RTC->CR |= RTC_CR_REFCKON;
    }
    else
    {
      /* Disable the RTC reference clock detection */
      RTC->CR &= ~RTC_CR_REFCKON;
 8006940:	2210      	movs	r2, #16
 8006942:	68a3      	ldr	r3, [r4, #8]
 8006944:	4393      	bics	r3, r2
 8006946:	60a3      	str	r3, [r4, #8]
  * @retval None
  */
void RTC_ExitInitMode(void)
{
  /* Exit Initialization mode */
  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;
 8006948:	2180      	movs	r1, #128	; 0x80
 800694a:	4a07      	ldr	r2, [pc, #28]	; (8006968 <RTC_RefClockCmd+0x44>)
 800694c:	68d3      	ldr	r3, [r2, #12]
 800694e:	438b      	bics	r3, r1
 8006950:	60d3      	str	r3, [r2, #12]
      RTC->CR &= ~RTC_CR_REFCKON;
    }
    /* Exit Initialization mode */
    RTC_ExitInitMode();

    status = SUCCESS;
 8006952:	2301      	movs	r3, #1
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006954:	21ff      	movs	r1, #255	; 0xff
 8006956:	4a04      	ldr	r2, [pc, #16]	; (8006968 <RTC_RefClockCmd+0x44>)

  return status;
}
 8006958:	1c18      	adds	r0, r3, #0

    status = SUCCESS;
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 800695a:	6251      	str	r1, [r2, #36]	; 0x24

  return status;
}
 800695c:	bd38      	pop	{r3, r4, r5, pc}
  else
  {
    if (NewState != DISABLE)
    {
      /* Enable the RTC reference clock detection */
      RTC->CR |= RTC_CR_REFCKON;
 800695e:	68a2      	ldr	r2, [r4, #8]
 8006960:	3310      	adds	r3, #16
 8006962:	4313      	orrs	r3, r2
 8006964:	60a3      	str	r3, [r4, #8]
 8006966:	e7ef      	b.n	8006948 <RTC_RefClockCmd+0x24>
 8006968:	40002800 	.word	0x40002800

0800696c <RTC_BypassShadowCmd>:
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800696c:	22ca      	movs	r2, #202	; 0xca
 800696e:	4b09      	ldr	r3, [pc, #36]	; (8006994 <RTC_BypassShadowCmd+0x28>)
 8006970:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8006972:	3a77      	subs	r2, #119	; 0x77
 8006974:	625a      	str	r2, [r3, #36]	; 0x24
  
  if (NewState != DISABLE)
 8006976:	2800      	cmp	r0, #0
 8006978:	d107      	bne.n	800698a <RTC_BypassShadowCmd+0x1e>
    RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
  }
  else
  {
    /* Reset the BYPSHAD bit */
    RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
 800697a:	21df      	movs	r1, #223	; 0xdf
 800697c:	689a      	ldr	r2, [r3, #8]
 800697e:	400a      	ands	r2, r1
 8006980:	609a      	str	r2, [r3, #8]
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006982:	22ff      	movs	r2, #255	; 0xff
 8006984:	4b03      	ldr	r3, [pc, #12]	; (8006994 <RTC_BypassShadowCmd+0x28>)
 8006986:	625a      	str	r2, [r3, #36]	; 0x24
}
 8006988:	4770      	bx	lr
  RTC->WPR = 0x53;
  
  if (NewState != DISABLE)
  {
    /* Set the BYPSHAD bit */
    RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
 800698a:	6899      	ldr	r1, [r3, #8]
 800698c:	3a33      	subs	r2, #51	; 0x33
 800698e:	430a      	orrs	r2, r1
 8006990:	609a      	str	r2, [r3, #8]
 8006992:	e7f6      	b.n	8006982 <RTC_BypassShadowCmd+0x16>
 8006994:	40002800 	.word	0x40002800

08006998 <RTC_SetTime>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Time register is configured
  *          - ERROR: RTC Time register is not configured
  */
ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
 8006998:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  if (RTC_Format == RTC_Format_BIN)
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 800699a:	4b35      	ldr	r3, [pc, #212]	; (8006a70 <RTC_SetTime+0xd8>)
 800699c:	689b      	ldr	r3, [r3, #8]
  ErrorStatus status = ERROR;

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  if (RTC_Format == RTC_Format_BIN)
 800699e:	2800      	cmp	r0, #0
 80069a0:	d133      	bne.n	8006a0a <RTC_SetTime+0x72>
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 80069a2:	2740      	movs	r7, #64	; 0x40
 80069a4:	401f      	ands	r7, r3
 80069a6:	d15e      	bne.n	8006a66 <RTC_SetTime+0xce>
      assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
    }
    else
    {
      RTC_TimeStruct->RTC_H12 = 0x00;
 80069a8:	70cf      	strb	r7, [r1, #3]
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 80069aa:	780d      	ldrb	r5, [r1, #0]
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 80069ac:	2600      	movs	r6, #0
 80069ae:	2200      	movs	r2, #0
 80069b0:	2d09      	cmp	r5, #9
 80069b2:	d907      	bls.n	80069c4 <RTC_SetTime+0x2c>
  {
    bcdhigh++;
    Value -= 10;
 80069b4:	3d0a      	subs	r5, #10
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 80069b6:	3601      	adds	r6, #1
    Value -= 10;
 80069b8:	b2ed      	uxtb	r5, r5
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 80069ba:	b2f6      	uxtb	r6, r6
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 80069bc:	2d09      	cmp	r5, #9
 80069be:	d8f9      	bhi.n	80069b4 <RTC_SetTime+0x1c>
 80069c0:	0136      	lsls	r6, r6, #4
 80069c2:	b2f2      	uxtb	r2, r6
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 80069c4:	7848      	ldrb	r0, [r1, #1]
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 80069c6:	4315      	orrs	r5, r2
 80069c8:	042d      	lsls	r5, r5, #16
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 80069ca:	2200      	movs	r2, #0
 80069cc:	2809      	cmp	r0, #9
 80069ce:	d907      	bls.n	80069e0 <RTC_SetTime+0x48>
  {
    bcdhigh++;
    Value -= 10;
 80069d0:	380a      	subs	r0, #10
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 80069d2:	3201      	adds	r2, #1
    Value -= 10;
 80069d4:	b2c0      	uxtb	r0, r0
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 80069d6:	b2d2      	uxtb	r2, r2
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 80069d8:	2809      	cmp	r0, #9
 80069da:	d8f9      	bhi.n	80069d0 <RTC_SetTime+0x38>
 80069dc:	0112      	lsls	r2, r2, #4
 80069de:	b2d2      	uxtb	r2, r2
  }
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
 80069e0:	788b      	ldrb	r3, [r1, #2]
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 80069e2:	4310      	orrs	r0, r2
 80069e4:	0200      	lsls	r0, r0, #8
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 80069e6:	2b09      	cmp	r3, #9
 80069e8:	d940      	bls.n	8006a6c <RTC_SetTime+0xd4>
 80069ea:	2400      	movs	r4, #0
  {
    bcdhigh++;
    Value -= 10;
 80069ec:	3b0a      	subs	r3, #10
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 80069ee:	3401      	adds	r4, #1
    Value -= 10;
 80069f0:	b2db      	uxtb	r3, r3
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 80069f2:	b2e4      	uxtb	r4, r4
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 80069f4:	2b09      	cmp	r3, #9
 80069f6:	d8f9      	bhi.n	80069ec <RTC_SetTime+0x54>
 80069f8:	0124      	lsls	r4, r4, #4
 80069fa:	b2e1      	uxtb	r1, r4
 80069fc:	1c2a      	adds	r2, r5, #0
 80069fe:	433a      	orrs	r2, r7
 8006a00:	4302      	orrs	r2, r0
  }
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
 8006a02:	430b      	orrs	r3, r1
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 8006a04:	431a      	orrs	r2, r3
 8006a06:	1c14      	adds	r4, r2, #0
 8006a08:	e00b      	b.n	8006a22 <RTC_SetTime+0x8a>
    assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
    assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
  }
  else
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8006a0a:	2240      	movs	r2, #64	; 0x40
 8006a0c:	401a      	ands	r2, r3
 8006a0e:	d127      	bne.n	8006a60 <RTC_SetTime+0xc8>
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
    } 
    else
    {
      RTC_TimeStruct->RTC_H12 = 0x00;
 8006a10:	70ca      	strb	r2, [r1, #3]
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8006a12:	780c      	ldrb	r4, [r1, #0]
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8006a14:	784b      	ldrb	r3, [r1, #1]
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8006a16:	0424      	lsls	r4, r4, #16
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8006a18:	021b      	lsls	r3, r3, #8
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8006a1a:	431c      	orrs	r4, r3
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
 8006a1c:	788b      	ldrb	r3, [r1, #2]
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8006a1e:	431c      	orrs	r4, r3
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8006a20:	4314      	orrs	r4, r2
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
                   (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
  } 

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006a22:	23ca      	movs	r3, #202	; 0xca
 8006a24:	4d12      	ldr	r5, [pc, #72]	; (8006a70 <RTC_SetTime+0xd8>)
 8006a26:	626b      	str	r3, [r5, #36]	; 0x24
  RTC->WPR = 0x53;
 8006a28:	3b77      	subs	r3, #119	; 0x77
 8006a2a:	626b      	str	r3, [r5, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8006a2c:	f7ff fed0 	bl	80067d0 <RTC_EnterInitMode>
 8006a30:	1c03      	adds	r3, r0, #0
  {
    status = ERROR;
 8006a32:	2000      	movs	r0, #0
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8006a34:	2b00      	cmp	r3, #0
 8006a36:	d00f      	beq.n	8006a58 <RTC_SetTime+0xc0>
    status = ERROR;
  } 
  else
  {
    /* Set the RTC_TR register */
    RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8006a38:	4a0e      	ldr	r2, [pc, #56]	; (8006a74 <RTC_SetTime+0xdc>)
        status = SUCCESS;
      }
    }
    else
    {
      status = SUCCESS;
 8006a3a:	3001      	adds	r0, #1
    status = ERROR;
  } 
  else
  {
    /* Set the RTC_TR register */
    RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8006a3c:	4022      	ands	r2, r4
 8006a3e:	602a      	str	r2, [r5, #0]
  * @retval None
  */
void RTC_ExitInitMode(void)
{
  /* Exit Initialization mode */
  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;
 8006a40:	2280      	movs	r2, #128	; 0x80
 8006a42:	68eb      	ldr	r3, [r5, #12]
 8006a44:	4393      	bics	r3, r2
 8006a46:	60eb      	str	r3, [r5, #12]

    /* Exit Initialization mode */
    RTC_ExitInitMode(); 

    /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 8006a48:	68ab      	ldr	r3, [r5, #8]
 8006a4a:	069b      	lsls	r3, r3, #26
 8006a4c:	d404      	bmi.n	8006a58 <RTC_SetTime+0xc0>
    {
      if (RTC_WaitForSynchro() == ERROR)
 8006a4e:	f7ff ff13 	bl	8006878 <RTC_WaitForSynchro>
 8006a52:	1e43      	subs	r3, r0, #1
 8006a54:	4198      	sbcs	r0, r3
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  {
    status = ERROR;
 8006a56:	b2c0      	uxtb	r0, r0
      status = SUCCESS;
    }
  
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006a58:	22ff      	movs	r2, #255	; 0xff
 8006a5a:	4b05      	ldr	r3, [pc, #20]	; (8006a70 <RTC_SetTime+0xd8>)
 8006a5c:	625a      	str	r2, [r3, #36]	; 0x24
    
  return status;
}
 8006a5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006a60:	78ca      	ldrb	r2, [r1, #3]
 8006a62:	0412      	lsls	r2, r2, #16
 8006a64:	e7d5      	b.n	8006a12 <RTC_SetTime+0x7a>
 8006a66:	78cf      	ldrb	r7, [r1, #3]
 8006a68:	043f      	lsls	r7, r7, #16
 8006a6a:	e79e      	b.n	80069aa <RTC_SetTime+0x12>
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8006a6c:	2100      	movs	r1, #0
 8006a6e:	e7c5      	b.n	80069fc <RTC_SetTime+0x64>
 8006a70:	40002800 	.word	0x40002800
 8006a74:	007f7f7f 	.word	0x007f7f7f

08006a78 <RTC_TimeStructInit>:
  * @retval None
  */
void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
{
  /* Time = 00h:00min:00sec */
  RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
 8006a78:	2300      	movs	r3, #0
 8006a7a:	70c3      	strb	r3, [r0, #3]
  RTC_TimeStruct->RTC_Hours = 0;
 8006a7c:	7003      	strb	r3, [r0, #0]
  RTC_TimeStruct->RTC_Minutes = 0;
 8006a7e:	7043      	strb	r3, [r0, #1]
  RTC_TimeStruct->RTC_Seconds = 0; 
 8006a80:	7083      	strb	r3, [r0, #2]
}
 8006a82:	4770      	bx	lr

08006a84 <RTC_GetTime>:
  * @param RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
  *                        contain the returned current time configuration.
  * @retval None
  */
void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
 8006a84:	b5f0      	push	{r4, r5, r6, r7, lr}
  
  /* Fill the structure fields with the read parameters */
  RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
  RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
  RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
  RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
 8006a86:	2480      	movs	r4, #128	; 0x80

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
 8006a88:	257f      	movs	r5, #127	; 0x7f
 8006a8a:	4b13      	ldr	r3, [pc, #76]	; (8006ad8 <RTC_GetTime+0x54>)
  
  /* Fill the structure fields with the read parameters */
  RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
  RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
  RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
  RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
 8006a8c:	03e4      	lsls	r4, r4, #15

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
 8006a8e:	681e      	ldr	r6, [r3, #0]
  
  /* Fill the structure fields with the read parameters */
  RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8006a90:	02b2      	lsls	r2, r6, #10
  RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8006a92:	0473      	lsls	r3, r6, #17
  RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
  RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
 8006a94:	4034      	ands	r4, r6

  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
  
  /* Fill the structure fields with the read parameters */
  RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8006a96:	0e92      	lsrs	r2, r2, #26
  RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8006a98:	0e5b      	lsrs	r3, r3, #25
  RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8006a9a:	4035      	ands	r5, r6
  RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
 8006a9c:	0c24      	lsrs	r4, r4, #16

  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
  
  /* Fill the structure fields with the read parameters */
  RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8006a9e:	700a      	strb	r2, [r1, #0]
  RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8006aa0:	704b      	strb	r3, [r1, #1]
  RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8006aa2:	708d      	strb	r5, [r1, #2]
  RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
 8006aa4:	70cc      	strb	r4, [r1, #3]

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
 8006aa6:	2800      	cmp	r0, #0
 8006aa8:	d115      	bne.n	8006ad6 <RTC_GetTime+0x52>
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006aaa:	0914      	lsrs	r4, r2, #4
 8006aac:	00a0      	lsls	r0, r4, #2
 8006aae:	1824      	adds	r4, r4, r0
  return (tmp + (Value & (uint8_t)0x0F));
 8006ab0:	200f      	movs	r0, #15
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006ab2:	0064      	lsls	r4, r4, #1
  return (tmp + (Value & (uint8_t)0x0F));
 8006ab4:	4002      	ands	r2, r0
 8006ab6:	18a2      	adds	r2, r4, r2
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006ab8:	091c      	lsrs	r4, r3, #4

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
  {
    /* Convert the structure parameters to Binary format */
    RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 8006aba:	700a      	strb	r2, [r1, #0]
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006abc:	00a2      	lsls	r2, r4, #2
 8006abe:	18a2      	adds	r2, r4, r2
 8006ac0:	0052      	lsls	r2, r2, #1
  return (tmp + (Value & (uint8_t)0x0F));
 8006ac2:	4003      	ands	r3, r0
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006ac4:	092f      	lsrs	r7, r5, #4
  return (tmp + (Value & (uint8_t)0x0F));
 8006ac6:	18d3      	adds	r3, r2, r3
  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
  {
    /* Convert the structure parameters to Binary format */
    RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
    RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
 8006ac8:	704b      	strb	r3, [r1, #1]
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006aca:	00bb      	lsls	r3, r7, #2
 8006acc:	18ff      	adds	r7, r7, r3
 8006ace:	007f      	lsls	r7, r7, #1
  return (tmp + (Value & (uint8_t)0x0F));
 8006ad0:	4005      	ands	r5, r0
 8006ad2:	197d      	adds	r5, r7, r5
  if (RTC_Format == RTC_Format_BIN)
  {
    /* Convert the structure parameters to Binary format */
    RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
    RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
    RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);
 8006ad4:	708d      	strb	r5, [r1, #2]
  }
}
 8006ad6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006ad8:	40002800 	.word	0x40002800

08006adc <RTC_GetSubSecond>:
uint32_t RTC_GetSubSecond(void)
{
  uint32_t tmpreg = 0;
  
  /* Get subseconds values from the correspondent registers*/
  tmpreg = (uint32_t)(RTC->SSR);
 8006adc:	4b01      	ldr	r3, [pc, #4]	; (8006ae4 <RTC_GetSubSecond+0x8>)
 8006ade:	6a98      	ldr	r0, [r3, #40]	; 0x28
  
  /* Read DR register to unfroze calendar registers */
  (void) (RTC->DR);
 8006ae0:	685b      	ldr	r3, [r3, #4]
  
  return (tmpreg);
}
 8006ae2:	4770      	bx	lr
 8006ae4:	40002800 	.word	0x40002800

08006ae8 <RTC_SetDate>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Date register is configured
  *          - ERROR: RTC Date register is not configured
  */
ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
{
 8006ae8:	b538      	push	{r3, r4, r5, lr}
  ErrorStatus status = ERROR;
  
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
 8006aea:	2800      	cmp	r0, #0
 8006aec:	d136      	bne.n	8006b5c <RTC_SetDate+0x74>
 8006aee:	2310      	movs	r3, #16
 8006af0:	784a      	ldrb	r2, [r1, #1]
 8006af2:	4213      	tst	r3, r2
 8006af4:	d003      	beq.n	8006afe <RTC_SetDate+0x16>
  {
    RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
 8006af6:	439a      	bics	r2, r3
 8006af8:	320a      	adds	r2, #10
 8006afa:	b2d2      	uxtb	r2, r2
 8006afc:	704a      	strb	r2, [r1, #1]
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 8006afe:	78cb      	ldrb	r3, [r1, #3]
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8006b00:	2000      	movs	r0, #0
 8006b02:	2b09      	cmp	r3, #9
 8006b04:	d907      	bls.n	8006b16 <RTC_SetDate+0x2e>
  {
    bcdhigh++;
    Value -= 10;
 8006b06:	3b0a      	subs	r3, #10
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 8006b08:	3001      	adds	r0, #1
    Value -= 10;
 8006b0a:	b2db      	uxtb	r3, r3
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 8006b0c:	b2c0      	uxtb	r0, r0
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8006b0e:	2b09      	cmp	r3, #9
 8006b10:	d8f9      	bhi.n	8006b06 <RTC_SetDate+0x1e>
 8006b12:	0100      	lsls	r0, r0, #4
 8006b14:	b2c0      	uxtb	r0, r0
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 8006b16:	4303      	orrs	r3, r0
 8006b18:	0418      	lsls	r0, r3, #16
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8006b1a:	2300      	movs	r3, #0
 8006b1c:	2a09      	cmp	r2, #9
 8006b1e:	d907      	bls.n	8006b30 <RTC_SetDate+0x48>
  {
    bcdhigh++;
    Value -= 10;
 8006b20:	3a0a      	subs	r2, #10
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 8006b22:	3301      	adds	r3, #1
    Value -= 10;
 8006b24:	b2d2      	uxtb	r2, r2
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 8006b26:	b2db      	uxtb	r3, r3
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8006b28:	2a09      	cmp	r2, #9
 8006b2a:	d8f9      	bhi.n	8006b20 <RTC_SetDate+0x38>
 8006b2c:	011b      	lsls	r3, r3, #4
 8006b2e:	b2db      	uxtb	r3, r3
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 8006b30:	431a      	orrs	r2, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
 8006b32:	788b      	ldrb	r3, [r1, #2]
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 8006b34:	0212      	lsls	r2, r2, #8
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8006b36:	2b09      	cmp	r3, #9
 8006b38:	d93a      	bls.n	8006bb0 <RTC_SetDate+0xc8>
 8006b3a:	2400      	movs	r4, #0
  {
    bcdhigh++;
    Value -= 10;
 8006b3c:	3b0a      	subs	r3, #10
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 8006b3e:	3401      	adds	r4, #1
    Value -= 10;
 8006b40:	b2db      	uxtb	r3, r3
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 8006b42:	b2e4      	uxtb	r4, r4
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8006b44:	2b09      	cmp	r3, #9
 8006b46:	d8f9      	bhi.n	8006b3c <RTC_SetDate+0x54>
 8006b48:	0124      	lsls	r4, r4, #4
 8006b4a:	b2e5      	uxtb	r5, r4
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
 8006b4c:	780c      	ldrb	r4, [r1, #0]
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
 8006b4e:	432b      	orrs	r3, r5
              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
 8006b50:	0364      	lsls	r4, r4, #13
 8006b52:	4320      	orrs	r0, r4
 8006b54:	4310      	orrs	r0, r2
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 8006b56:	4318      	orrs	r0, r3
 8006b58:	1c04      	adds	r4, r0, #0
 8006b5a:	e009      	b.n	8006b70 <RTC_SetDate+0x88>
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8006b5c:	78cc      	ldrb	r4, [r1, #3]
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 8006b5e:	784b      	ldrb	r3, [r1, #1]
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8006b60:	0424      	lsls	r4, r4, #16
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 8006b62:	021b      	lsls	r3, r3, #8
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8006b64:	431c      	orrs	r4, r3
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
 8006b66:	780a      	ldrb	r2, [r1, #0]
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
 8006b68:	788b      	ldrb	r3, [r1, #2]
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
 8006b6a:	0352      	lsls	r2, r2, #13

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 8006b6c:	431c      	orrs	r4, r3
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8006b6e:	4314      	orrs	r4, r2
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
  }

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006b70:	23ca      	movs	r3, #202	; 0xca
 8006b72:	4d10      	ldr	r5, [pc, #64]	; (8006bb4 <RTC_SetDate+0xcc>)
 8006b74:	626b      	str	r3, [r5, #36]	; 0x24
  RTC->WPR = 0x53;
 8006b76:	3b77      	subs	r3, #119	; 0x77
 8006b78:	626b      	str	r3, [r5, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8006b7a:	f7ff fe29 	bl	80067d0 <RTC_EnterInitMode>
 8006b7e:	1c03      	adds	r3, r0, #0
  {
    status = ERROR;
 8006b80:	2000      	movs	r0, #0
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8006b82:	2b00      	cmp	r3, #0
 8006b84:	d00a      	beq.n	8006b9c <RTC_SetDate+0xb4>
  * @retval None
  */
void RTC_ExitInitMode(void)
{
  /* Exit Initialization mode */
  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;
 8006b86:	2280      	movs	r2, #128	; 0x80
    status = ERROR;
  } 
  else
  {
    /* Set the RTC_DR register */
    RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
 8006b88:	4b0b      	ldr	r3, [pc, #44]	; (8006bb8 <RTC_SetDate+0xd0>)
        status = SUCCESS;
      }
    }
    else
    {
      status = SUCCESS;
 8006b8a:	3001      	adds	r0, #1
    status = ERROR;
  } 
  else
  {
    /* Set the RTC_DR register */
    RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
 8006b8c:	401c      	ands	r4, r3
 8006b8e:	606c      	str	r4, [r5, #4]
  * @retval None
  */
void RTC_ExitInitMode(void)
{
  /* Exit Initialization mode */
  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;
 8006b90:	68eb      	ldr	r3, [r5, #12]
 8006b92:	4393      	bics	r3, r2
 8006b94:	60eb      	str	r3, [r5, #12]

    /* Exit Initialization mode */
    RTC_ExitInitMode(); 

    /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 8006b96:	68ab      	ldr	r3, [r5, #8]
 8006b98:	069b      	lsls	r3, r3, #26
 8006b9a:	d503      	bpl.n	8006ba4 <RTC_SetDate+0xbc>
    {
      status = SUCCESS;
    }
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006b9c:	22ff      	movs	r2, #255	; 0xff
 8006b9e:	4b05      	ldr	r3, [pc, #20]	; (8006bb4 <RTC_SetDate+0xcc>)
 8006ba0:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
}
 8006ba2:	bd38      	pop	{r3, r4, r5, pc}
    RTC_ExitInitMode(); 

    /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
    {
      if (RTC_WaitForSynchro() == ERROR)
 8006ba4:	f7ff fe68 	bl	8006878 <RTC_WaitForSynchro>
 8006ba8:	1e43      	subs	r3, r0, #1
 8006baa:	4198      	sbcs	r0, r3
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  {
    status = ERROR;
 8006bac:	b2c0      	uxtb	r0, r0
 8006bae:	e7f5      	b.n	8006b9c <RTC_SetDate+0xb4>
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8006bb0:	2500      	movs	r5, #0
 8006bb2:	e7cb      	b.n	8006b4c <RTC_SetDate+0x64>
 8006bb4:	40002800 	.word	0x40002800
 8006bb8:	00ffff3f 	.word	0x00ffff3f

08006bbc <RTC_DateStructInit>:
  * @retval None
  */
void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
{
  /* Monday, January 01 xx00 */
  RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
 8006bbc:	2302      	movs	r3, #2
 8006bbe:	7003      	strb	r3, [r0, #0]
  RTC_DateStruct->RTC_Date = 1;
 8006bc0:	3b01      	subs	r3, #1
 8006bc2:	7083      	strb	r3, [r0, #2]
  RTC_DateStruct->RTC_Month = RTC_Month_January;
 8006bc4:	7043      	strb	r3, [r0, #1]
  RTC_DateStruct->RTC_Year = 0;
 8006bc6:	2300      	movs	r3, #0
 8006bc8:	70c3      	strb	r3, [r0, #3]
}
 8006bca:	4770      	bx	lr

08006bcc <RTC_GetDate>:
  * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
  *                        contain the returned current date configuration.
  * @retval None
  */
void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
{
 8006bcc:	b570      	push	{r4, r5, r6, lr}

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
 8006bce:	253f      	movs	r5, #63	; 0x3f
 8006bd0:	4b12      	ldr	r3, [pc, #72]	; (8006c1c <RTC_GetDate+0x50>)
 8006bd2:	685b      	ldr	r3, [r3, #4]

  /* Fill the structure fields with the read parameters */
  RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8006bd4:	021c      	lsls	r4, r3, #8
  RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8006bd6:	04da      	lsls	r2, r3, #19
  RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
 8006bd8:	401d      	ands	r5, r3
  RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);  
 8006bda:	041b      	lsls	r3, r3, #16
  
  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 

  /* Fill the structure fields with the read parameters */
  RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8006bdc:	0e24      	lsrs	r4, r4, #24
  RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8006bde:	0ed2      	lsrs	r2, r2, #27
  RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
  RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);  
 8006be0:	0f5b      	lsrs	r3, r3, #29
  
  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 

  /* Fill the structure fields with the read parameters */
  RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8006be2:	70cc      	strb	r4, [r1, #3]
  RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8006be4:	704a      	strb	r2, [r1, #1]
  RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
 8006be6:	708d      	strb	r5, [r1, #2]
  RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);  
 8006be8:	700b      	strb	r3, [r1, #0]

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
 8006bea:	2800      	cmp	r0, #0
 8006bec:	d115      	bne.n	8006c1a <RTC_GetDate+0x4e>
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006bee:	0920      	lsrs	r0, r4, #4
 8006bf0:	0083      	lsls	r3, r0, #2
 8006bf2:	18c0      	adds	r0, r0, r3
  return (tmp + (Value & (uint8_t)0x0F));
 8006bf4:	230f      	movs	r3, #15
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006bf6:	0040      	lsls	r0, r0, #1
  return (tmp + (Value & (uint8_t)0x0F));
 8006bf8:	401c      	ands	r4, r3
 8006bfa:	1904      	adds	r4, r0, r4

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
  {
    /* Convert the structure parameters to Binary format */
    RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
 8006bfc:	70cc      	strb	r4, [r1, #3]
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006bfe:	0914      	lsrs	r4, r2, #4
 8006c00:	00a0      	lsls	r0, r4, #2
 8006c02:	1820      	adds	r0, r4, r0
 8006c04:	0040      	lsls	r0, r0, #1
  return (tmp + (Value & (uint8_t)0x0F));
 8006c06:	401a      	ands	r2, r3
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006c08:	092e      	lsrs	r6, r5, #4
  return (tmp + (Value & (uint8_t)0x0F));
 8006c0a:	1882      	adds	r2, r0, r2
  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
  {
    /* Convert the structure parameters to Binary format */
    RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
    RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
 8006c0c:	704a      	strb	r2, [r1, #1]
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006c0e:	00b2      	lsls	r2, r6, #2
 8006c10:	18b6      	adds	r6, r6, r2
 8006c12:	0076      	lsls	r6, r6, #1
  return (tmp + (Value & (uint8_t)0x0F));
 8006c14:	401d      	ands	r5, r3
 8006c16:	1975      	adds	r5, r6, r5
  if (RTC_Format == RTC_Format_BIN)
  {
    /* Convert the structure parameters to Binary format */
    RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
    RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
    RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
 8006c18:	708d      	strb	r5, [r1, #2]
    RTC_DateStruct->RTC_WeekDay = (uint8_t)(RTC_DateStruct->RTC_WeekDay);   
  }
}
 8006c1a:	bd70      	pop	{r4, r5, r6, pc}
 8006c1c:	40002800 	.word	0x40002800

08006c20 <RTC_SetAlarm>:
  assert_param(IS_RTC_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));

  if (RTC_Format == RTC_Format_BIN)
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8006c20:	4b35      	ldr	r3, [pc, #212]	; (8006cf8 <RTC_SetAlarm+0xd8>)
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
  *                          contains the alarm configuration parameters.
  * @retval None
  */
void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 8006c22:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_RTC_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));

  if (RTC_Format == RTC_Format_BIN)
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8006c24:	689b      	ldr	r3, [r3, #8]
  assert_param(IS_RTC_FORMAT(RTC_Format));
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_RTC_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));

  if (RTC_Format == RTC_Format_BIN)
 8006c26:	2800      	cmp	r0, #0
 8006c28:	d144      	bne.n	8006cb4 <RTC_SetAlarm+0x94>
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8006c2a:	2540      	movs	r5, #64	; 0x40
 8006c2c:	401d      	ands	r5, r3
 8006c2e:	d160      	bne.n	8006cf2 <RTC_SetAlarm+0xd2>
      assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
    } 
    else
    {
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 8006c30:	70d5      	strb	r5, [r2, #3]
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8006c32:	7810      	ldrb	r0, [r2, #0]
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8006c34:	2300      	movs	r3, #0
 8006c36:	2809      	cmp	r0, #9
 8006c38:	d907      	bls.n	8006c4a <RTC_SetAlarm+0x2a>
  {
    bcdhigh++;
    Value -= 10;
 8006c3a:	380a      	subs	r0, #10
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 8006c3c:	3301      	adds	r3, #1
    Value -= 10;
 8006c3e:	b2c0      	uxtb	r0, r0
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 8006c40:	b2db      	uxtb	r3, r3
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8006c42:	2809      	cmp	r0, #9
 8006c44:	d8f9      	bhi.n	8006c3a <RTC_SetAlarm+0x1a>
 8006c46:	011b      	lsls	r3, r3, #4
 8006c48:	b2db      	uxtb	r3, r3
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8006c4a:	4318      	orrs	r0, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8006c4c:	7853      	ldrb	r3, [r2, #1]
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8006c4e:	0400      	lsls	r0, r0, #16
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8006c50:	2100      	movs	r1, #0
 8006c52:	2b09      	cmp	r3, #9
 8006c54:	d907      	bls.n	8006c66 <RTC_SetAlarm+0x46>
  {
    bcdhigh++;
    Value -= 10;
 8006c56:	3b0a      	subs	r3, #10
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 8006c58:	3101      	adds	r1, #1
    Value -= 10;
 8006c5a:	b2db      	uxtb	r3, r3
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 8006c5c:	b2c9      	uxtb	r1, r1
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8006c5e:	2b09      	cmp	r3, #9
 8006c60:	d8f9      	bhi.n	8006c56 <RTC_SetAlarm+0x36>
 8006c62:	0109      	lsls	r1, r1, #4
 8006c64:	b2c9      	uxtb	r1, r1
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 8006c66:	7894      	ldrb	r4, [r2, #2]
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8006c68:	430b      	orrs	r3, r1
 8006c6a:	0219      	lsls	r1, r3, #8
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8006c6c:	2300      	movs	r3, #0
 8006c6e:	2c09      	cmp	r4, #9
 8006c70:	d907      	bls.n	8006c82 <RTC_SetAlarm+0x62>
  {
    bcdhigh++;
    Value -= 10;
 8006c72:	3c0a      	subs	r4, #10
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 8006c74:	3301      	adds	r3, #1
    Value -= 10;
 8006c76:	b2e4      	uxtb	r4, r4
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 8006c78:	b2db      	uxtb	r3, r3
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8006c7a:	2c09      	cmp	r4, #9
 8006c7c:	d8f9      	bhi.n	8006c72 <RTC_SetAlarm+0x52>
 8006c7e:	011b      	lsls	r3, r3, #4
 8006c80:	b2db      	uxtb	r3, r3
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 8006c82:	431c      	orrs	r4, r3
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8006c84:	7b13      	ldrb	r3, [r2, #12]
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8006c86:	2600      	movs	r6, #0
 8006c88:	2b09      	cmp	r3, #9
 8006c8a:	d907      	bls.n	8006c9c <RTC_SetAlarm+0x7c>
  {
    bcdhigh++;
    Value -= 10;
 8006c8c:	3b0a      	subs	r3, #10
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 8006c8e:	3601      	adds	r6, #1
    Value -= 10;
 8006c90:	b2db      	uxtb	r3, r3
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 8006c92:	b2f6      	uxtb	r6, r6
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8006c94:	2b09      	cmp	r3, #9
 8006c96:	d8f9      	bhi.n	8006c8c <RTC_SetAlarm+0x6c>
 8006c98:	0136      	lsls	r6, r6, #4
 8006c9a:	b2f6      	uxtb	r6, r6
 8006c9c:	6857      	ldr	r7, [r2, #4]
 8006c9e:	6892      	ldr	r2, [r2, #8]
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8006ca0:	431e      	orrs	r6, r3
 8006ca2:	433a      	orrs	r2, r7
 8006ca4:	4315      	orrs	r5, r2
 8006ca6:	4305      	orrs	r5, r0
 8006ca8:	4329      	orrs	r1, r5
 8006caa:	430c      	orrs	r4, r1
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8006cac:	1c23      	adds	r3, r4, #0
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8006cae:	0636      	lsls	r6, r6, #24
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8006cb0:	4333      	orrs	r3, r6
 8006cb2:	e012      	b.n	8006cda <RTC_SetAlarm+0xba>
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
    }
  }
  else
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8006cb4:	2040      	movs	r0, #64	; 0x40
 8006cb6:	4018      	ands	r0, r3
 8006cb8:	d118      	bne.n	8006cec <RTC_SetAlarm+0xcc>
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
    } 
    else
    {
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 8006cba:	70d0      	strb	r0, [r2, #3]
 8006cbc:	6893      	ldr	r3, [r2, #8]
 8006cbe:	6851      	ldr	r1, [r2, #4]
 8006cc0:	4319      	orrs	r1, r3
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 8006cc2:	7893      	ldrb	r3, [r2, #2]
 8006cc4:	430b      	orrs	r3, r1
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8006cc6:	7811      	ldrb	r1, [r2, #0]
 8006cc8:	0409      	lsls	r1, r1, #16
 8006cca:	430b      	orrs	r3, r1
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8006ccc:	7851      	ldrb	r1, [r2, #1]
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8006cce:	7b12      	ldrb	r2, [r2, #12]

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8006cd0:	0209      	lsls	r1, r1, #8
 8006cd2:	430b      	orrs	r3, r1
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8006cd4:	0612      	lsls	r2, r2, #24
 8006cd6:	4313      	orrs	r3, r2
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8006cd8:	4303      	orrs	r3, r0
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006cda:	21ca      	movs	r1, #202	; 0xca
 8006cdc:	4a06      	ldr	r2, [pc, #24]	; (8006cf8 <RTC_SetAlarm+0xd8>)
 8006cde:	6251      	str	r1, [r2, #36]	; 0x24
  RTC->WPR = 0x53;
 8006ce0:	3977      	subs	r1, #119	; 0x77
 8006ce2:	6251      	str	r1, [r2, #36]	; 0x24

  /* Configure the Alarm register */
  RTC->ALRMAR = (uint32_t)tmpreg;
 8006ce4:	61d3      	str	r3, [r2, #28]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006ce6:	23ff      	movs	r3, #255	; 0xff
 8006ce8:	6253      	str	r3, [r2, #36]	; 0x24
}
 8006cea:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006cec:	78d3      	ldrb	r3, [r2, #3]
 8006cee:	0418      	lsls	r0, r3, #16
 8006cf0:	e7e4      	b.n	8006cbc <RTC_SetAlarm+0x9c>
 8006cf2:	78d5      	ldrb	r5, [r2, #3]
 8006cf4:	042d      	lsls	r5, r5, #16
 8006cf6:	e79c      	b.n	8006c32 <RTC_SetAlarm+0x12>
 8006cf8:	40002800 	.word	0x40002800

08006cfc <RTC_AlarmStructInit>:
  * @retval None
  */
void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
{
  /* Alarm Time Settings : Time = 00h:00mn:00sec */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
 8006cfc:	2300      	movs	r3, #0
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;

  /* Alarm Date Settings : Date = 1st day of the month */
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
 8006cfe:	2201      	movs	r2, #1
  * @retval None
  */
void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
{
  /* Alarm Time Settings : Time = 00h:00mn:00sec */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
 8006d00:	70c3      	strb	r3, [r0, #3]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
 8006d02:	7003      	strb	r3, [r0, #0]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
 8006d04:	7043      	strb	r3, [r0, #1]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
 8006d06:	7083      	strb	r3, [r0, #2]

  /* Alarm Date Settings : Date = 1st day of the month */
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
 8006d08:	6083      	str	r3, [r0, #8]
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
 8006d0a:	7302      	strb	r2, [r0, #12]

  /* Alarm Masks Settings : Mask =  all fields are not masked */
  RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
 8006d0c:	6043      	str	r3, [r0, #4]
}
 8006d0e:	4770      	bx	lr

08006d10 <RTC_GetAlarm>:
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
  *                          contains the output alarm configuration values.
  * @retval None
  */
void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 8006d10:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006d12:	4647      	mov	r7, r8
 8006d14:	4680      	mov	r8, r0
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
 8006d16:	2080      	movs	r0, #128	; 0x80
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
 8006d18:	2180      	movs	r1, #128	; 0x80
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  assert_param(IS_RTC_ALARM(RTC_Alarm)); 

  /* Get the RTC_ALRMAR register */
  tmpreg = (uint32_t)(RTC->ALRMAR);
 8006d1a:	4b1e      	ldr	r3, [pc, #120]	; (8006d94 <RTC_GetAlarm+0x84>)
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
 8006d1c:	05c0      	lsls	r0, r0, #23
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  assert_param(IS_RTC_ALARM(RTC_Alarm)); 

  /* Get the RTC_ALRMAR register */
  tmpreg = (uint32_t)(RTC->ALRMAR);
 8006d1e:	69db      	ldr	r3, [r3, #28]
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
 8006d20:	03c9      	lsls	r1, r1, #15
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
 8006d22:	4018      	ands	r0, r3
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
 8006d24:	4019      	ands	r1, r3
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
 8006d26:	6090      	str	r0, [r2, #8]
  RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
 8006d28:	481b      	ldr	r0, [pc, #108]	; (8006d98 <RTC_GetAlarm+0x88>)
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
 8006d2a:	0c09      	lsrs	r1, r1, #16

  /* Get the RTC_ALRMAR register */
  tmpreg = (uint32_t)(RTC->ALRMAR);

  /* Fill the structure with the read parameters */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
 8006d2c:	029d      	lsls	r5, r3, #10
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
 8006d2e:	045c      	lsls	r4, r3, #17
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
  *                          contains the output alarm configuration values.
  * @retval None
  */
void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 8006d30:	b480      	push	{r7}
  /* Fill the structure with the read parameters */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
 8006d32:	267f      	movs	r6, #127	; 0x7f
 8006d34:	b2df      	uxtb	r7, r3
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
 8006d36:	70d1      	strb	r1, [r2, #3]
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
 8006d38:	0099      	lsls	r1, r3, #2
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
  RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
 8006d3a:	4003      	ands	r3, r0
 8006d3c:	6053      	str	r3, [r2, #4]

  if (RTC_Format == RTC_Format_BIN)
 8006d3e:	4643      	mov	r3, r8

  /* Get the RTC_ALRMAR register */
  tmpreg = (uint32_t)(RTC->ALRMAR);

  /* Fill the structure with the read parameters */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
 8006d40:	0ead      	lsrs	r5, r5, #26
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
 8006d42:	0e64      	lsrs	r4, r4, #25
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
 8006d44:	403e      	ands	r6, r7
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
 8006d46:	0e89      	lsrs	r1, r1, #26

  /* Get the RTC_ALRMAR register */
  tmpreg = (uint32_t)(RTC->ALRMAR);

  /* Fill the structure with the read parameters */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
 8006d48:	7015      	strb	r5, [r2, #0]
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
 8006d4a:	7054      	strb	r4, [r2, #1]
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
 8006d4c:	7096      	strb	r6, [r2, #2]
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
 8006d4e:	7311      	strb	r1, [r2, #12]
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
  RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);

  if (RTC_Format == RTC_Format_BIN)
 8006d50:	2b00      	cmp	r3, #0
 8006d52:	d11c      	bne.n	8006d8e <RTC_GetAlarm+0x7e>
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006d54:	0928      	lsrs	r0, r5, #4
 8006d56:	0083      	lsls	r3, r0, #2
 8006d58:	18c0      	adds	r0, r0, r3
  return (tmp + (Value & (uint8_t)0x0F));
 8006d5a:	230f      	movs	r3, #15
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006d5c:	0040      	lsls	r0, r0, #1
  return (tmp + (Value & (uint8_t)0x0F));
 8006d5e:	401d      	ands	r5, r3
 8006d60:	1945      	adds	r5, r0, r5
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
  RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);

  if (RTC_Format == RTC_Format_BIN)
  {
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 8006d62:	7015      	strb	r5, [r2, #0]
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006d64:	0925      	lsrs	r5, r4, #4
 8006d66:	00a8      	lsls	r0, r5, #2
 8006d68:	1828      	adds	r0, r5, r0
 8006d6a:	0040      	lsls	r0, r0, #1
  return (tmp + (Value & (uint8_t)0x0F));
 8006d6c:	401c      	ands	r4, r3
 8006d6e:	1904      	adds	r4, r0, r4
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006d70:	0936      	lsrs	r6, r6, #4
 8006d72:	00b0      	lsls	r0, r6, #2

  if (RTC_Format == RTC_Format_BIN)
  {
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
                                                        RTC_AlarmTime.RTC_Hours);
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 8006d74:	7054      	strb	r4, [r2, #1]
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006d76:	090c      	lsrs	r4, r1, #4
 8006d78:	1836      	adds	r6, r6, r0
 8006d7a:	00a0      	lsls	r0, r4, #2
 8006d7c:	1820      	adds	r0, r4, r0
 8006d7e:	0076      	lsls	r6, r6, #1
  return (tmp + (Value & (uint8_t)0x0F));
 8006d80:	401f      	ands	r7, r3
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8006d82:	0040      	lsls	r0, r0, #1
  return (tmp + (Value & (uint8_t)0x0F));
 8006d84:	4019      	ands	r1, r3
 8006d86:	19f7      	adds	r7, r6, r7
 8006d88:	1841      	adds	r1, r0, r1
  {
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
                                                        RTC_AlarmTime.RTC_Hours);
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
                                                        RTC_AlarmTime.RTC_Minutes);
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 8006d8a:	7097      	strb	r7, [r2, #2]
                                                        RTC_AlarmTime.RTC_Seconds);
    RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 8006d8c:	7311      	strb	r1, [r2, #12]
  }  
}
 8006d8e:	bc04      	pop	{r2}
 8006d90:	4690      	mov	r8, r2
 8006d92:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006d94:	40002800 	.word	0x40002800
 8006d98:	80808080 	.word	0x80808080

08006d9c <RTC_AlarmCmd>:
  *          - SUCCESS: RTC Alarm is enabled/disabled
  *          - ERROR: RTC Alarm is not enabled/disabled  
  */
ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
{
  __IO uint32_t alarmcounter = 0x00;
 8006d9c:	2300      	movs	r3, #0
  /* Check the parameters */
  assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006d9e:	22ca      	movs	r2, #202	; 0xca
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Alarm is enabled/disabled
  *          - ERROR: RTC Alarm is not enabled/disabled  
  */
ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
{
 8006da0:	b510      	push	{r4, lr}
 8006da2:	b082      	sub	sp, #8
  __IO uint32_t alarmcounter = 0x00;
 8006da4:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006da6:	4b14      	ldr	r3, [pc, #80]	; (8006df8 <RTC_AlarmCmd+0x5c>)
 8006da8:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8006daa:	3a77      	subs	r2, #119	; 0x77
 8006dac:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Alarm state */
  if (NewState != DISABLE)
  {
    RTC->CR |= (uint32_t)RTC_Alarm;
 8006dae:	689a      	ldr	r2, [r3, #8]
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Configure the Alarm state */
  if (NewState != DISABLE)
 8006db0:	2900      	cmp	r1, #0
 8006db2:	d11c      	bne.n	8006dee <RTC_AlarmCmd+0x52>
    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    do
    {
      alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
      alarmcounter++;  
    } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
 8006db4:	2480      	movs	r4, #128	; 0x80
    status = SUCCESS;    
  }
  else
  { 
    /* Disable the Alarm in RTC_CR register */
    RTC->CR &= (uint32_t)~RTC_Alarm;
 8006db6:	4382      	bics	r2, r0
 8006db8:	609a      	str	r2, [r3, #8]
 8006dba:	0a00      	lsrs	r0, r0, #8
   
    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    do
    {
      alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
 8006dbc:	1c19      	adds	r1, r3, #0
      alarmcounter++;  
    } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
 8006dbe:	01e4      	lsls	r4, r4, #7
 8006dc0:	e001      	b.n	8006dc6 <RTC_AlarmCmd+0x2a>
 8006dc2:	2a00      	cmp	r2, #0
 8006dc4:	d108      	bne.n	8006dd8 <RTC_AlarmCmd+0x3c>
    RTC->CR &= (uint32_t)~RTC_Alarm;
   
    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    do
    {
      alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
 8006dc6:	68cb      	ldr	r3, [r1, #12]
 8006dc8:	4003      	ands	r3, r0
 8006dca:	1c1a      	adds	r2, r3, #0
      alarmcounter++;  
 8006dcc:	9b01      	ldr	r3, [sp, #4]
 8006dce:	3301      	adds	r3, #1
 8006dd0:	9301      	str	r3, [sp, #4]
    } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
 8006dd2:	9b01      	ldr	r3, [sp, #4]
 8006dd4:	42a3      	cmp	r3, r4
 8006dd6:	d1f4      	bne.n	8006dc2 <RTC_AlarmCmd+0x26>
    
    if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
 8006dd8:	4b07      	ldr	r3, [pc, #28]	; (8006df8 <RTC_AlarmCmd+0x5c>)
 8006dda:	68db      	ldr	r3, [r3, #12]
 8006ddc:	4018      	ands	r0, r3
 8006dde:	1e43      	subs	r3, r0, #1
 8006de0:	4198      	sbcs	r0, r3
  /* Configure the Alarm state */
  if (NewState != DISABLE)
  {
    RTC->CR |= (uint32_t)RTC_Alarm;

    status = SUCCESS;    
 8006de2:	b2c0      	uxtb	r0, r0
      status = SUCCESS;
    }        
  } 

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006de4:	22ff      	movs	r2, #255	; 0xff
 8006de6:	4b04      	ldr	r3, [pc, #16]	; (8006df8 <RTC_AlarmCmd+0x5c>)
 8006de8:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
}
 8006dea:	b002      	add	sp, #8
 8006dec:	bd10      	pop	{r4, pc}
  RTC->WPR = 0x53;

  /* Configure the Alarm state */
  if (NewState != DISABLE)
  {
    RTC->CR |= (uint32_t)RTC_Alarm;
 8006dee:	4310      	orrs	r0, r2
 8006df0:	6098      	str	r0, [r3, #8]

    status = SUCCESS;    
 8006df2:	2001      	movs	r0, #1
 8006df4:	e7f6      	b.n	8006de4 <RTC_AlarmCmd+0x48>
 8006df6:	46c0      	nop			; (mov r8, r8)
 8006df8:	40002800 	.word	0x40002800

08006dfc <RTC_AlarmSubSecondConfig>:
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006dfc:	20ca      	movs	r0, #202	; 0xca
  RTC->WPR = 0x53;
  
  /* Configure the Alarm A or Alarm B SubSecond registers */
  tmpreg = (uint32_t) (((uint32_t)(RTC_AlarmSubSecondValue)) | ((uint32_t)(RTC_AlarmSubSecondMask) << 24));
 8006dfe:	0612      	lsls	r2, r2, #24
 8006e00:	4311      	orrs	r1, r2
  
  /* Configure the AlarmA SubSecond register */
  RTC->ALRMASSR = tmpreg;

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006e02:	22ff      	movs	r2, #255	; 0xff
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006e04:	4b03      	ldr	r3, [pc, #12]	; (8006e14 <RTC_AlarmSubSecondConfig+0x18>)
 8006e06:	6258      	str	r0, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8006e08:	3877      	subs	r0, #119	; 0x77
 8006e0a:	6258      	str	r0, [r3, #36]	; 0x24
  
  /* Configure the Alarm A or Alarm B SubSecond registers */
  tmpreg = (uint32_t) (((uint32_t)(RTC_AlarmSubSecondValue)) | ((uint32_t)(RTC_AlarmSubSecondMask) << 24));
  
  /* Configure the AlarmA SubSecond register */
  RTC->ALRMASSR = tmpreg;
 8006e0c:	6459      	str	r1, [r3, #68]	; 0x44

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006e0e:	625a      	str	r2, [r3, #36]	; 0x24

}
 8006e10:	4770      	bx	lr
 8006e12:	46c0      	nop			; (mov r8, r8)
 8006e14:	40002800 	.word	0x40002800

08006e18 <RTC_GetAlarmSubSecond>:
uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
{
  uint32_t tmpreg = 0;
  
  /* Get the RTC_ALRMAR register */
  tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
 8006e18:	4b02      	ldr	r3, [pc, #8]	; (8006e24 <RTC_GetAlarmSubSecond+0xc>)
 8006e1a:	6c58      	ldr	r0, [r3, #68]	; 0x44
 8006e1c:	0440      	lsls	r0, r0, #17
 8006e1e:	0c40      	lsrs	r0, r0, #17

  return (tmpreg);
}
 8006e20:	4770      	bx	lr
 8006e22:	46c0      	nop			; (mov r8, r8)
 8006e24:	40002800 	.word	0x40002800

08006e28 <RTC_WakeUpClockConfig>:
{
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006e28:	22ca      	movs	r2, #202	; 0xca
  RTC->WPR = 0x53;

  /* Clear the Wakeup Timer clock source bits in CR register */
  RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 8006e2a:	2107      	movs	r1, #7
{
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006e2c:	4b06      	ldr	r3, [pc, #24]	; (8006e48 <RTC_WakeUpClockConfig+0x20>)
 8006e2e:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8006e30:	3a77      	subs	r2, #119	; 0x77
 8006e32:	625a      	str	r2, [r3, #36]	; 0x24

  /* Clear the Wakeup Timer clock source bits in CR register */
  RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 8006e34:	689a      	ldr	r2, [r3, #8]
 8006e36:	438a      	bics	r2, r1
 8006e38:	609a      	str	r2, [r3, #8]

  /* Configure the clock source */
  RTC->CR |= (uint32_t)RTC_WakeUpClock;
 8006e3a:	689a      	ldr	r2, [r3, #8]
 8006e3c:	4310      	orrs	r0, r2
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006e3e:	22ff      	movs	r2, #255	; 0xff

  /* Clear the Wakeup Timer clock source bits in CR register */
  RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;

  /* Configure the clock source */
  RTC->CR |= (uint32_t)RTC_WakeUpClock;
 8006e40:	6098      	str	r0, [r3, #8]
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006e42:	625a      	str	r2, [r3, #36]	; 0x24
}
 8006e44:	4770      	bx	lr
 8006e46:	46c0      	nop			; (mov r8, r8)
 8006e48:	40002800 	.word	0x40002800

08006e4c <RTC_SetWakeUpCounter>:
{
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006e4c:	22ca      	movs	r2, #202	; 0xca
 8006e4e:	4b04      	ldr	r3, [pc, #16]	; (8006e60 <RTC_SetWakeUpCounter+0x14>)
 8006e50:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8006e52:	3a77      	subs	r2, #119	; 0x77
 8006e54:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Configure the Wakeup Timer counter */
  RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006e56:	32ac      	adds	r2, #172	; 0xac
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
  
  /* Configure the Wakeup Timer counter */
  RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
 8006e58:	6158      	str	r0, [r3, #20]
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006e5a:	625a      	str	r2, [r3, #36]	; 0x24
}
 8006e5c:	4770      	bx	lr
 8006e5e:	46c0      	nop			; (mov r8, r8)
 8006e60:	40002800 	.word	0x40002800

08006e64 <RTC_GetWakeUpCounter>:
  * @retval The RTC WakeUp Counter value.
  */
uint32_t RTC_GetWakeUpCounter(void)
{
  /* Get the counter value */
  return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
 8006e64:	4b02      	ldr	r3, [pc, #8]	; (8006e70 <RTC_GetWakeUpCounter+0xc>)
 8006e66:	6958      	ldr	r0, [r3, #20]
 8006e68:	0400      	lsls	r0, r0, #16
 8006e6a:	0c00      	lsrs	r0, r0, #16
}
 8006e6c:	4770      	bx	lr
 8006e6e:	46c0      	nop			; (mov r8, r8)
 8006e70:	40002800 	.word	0x40002800

08006e74 <RTC_WakeUpCmd>:
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
{
  __IO uint32_t wutcounter = 0x00;
 8006e74:	2300      	movs	r3, #0
  * @param  NewState: new state of the WakeUp timer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
{
 8006e76:	b510      	push	{r4, lr}
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006e78:	4915      	ldr	r1, [pc, #84]	; (8006ed0 <RTC_WakeUpCmd+0x5c>)
  * @param  NewState: new state of the WakeUp timer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
{
 8006e7a:	b082      	sub	sp, #8
  __IO uint32_t wutcounter = 0x00;
 8006e7c:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006e7e:	33ca      	adds	r3, #202	; 0xca
 8006e80:	624b      	str	r3, [r1, #36]	; 0x24
  RTC->WPR = 0x53;
 8006e82:	3b77      	subs	r3, #119	; 0x77
 8006e84:	624b      	str	r3, [r1, #36]	; 0x24

  if (NewState != DISABLE)
 8006e86:	2800      	cmp	r0, #0
 8006e88:	d11b      	bne.n	8006ec2 <RTC_WakeUpCmd+0x4e>
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
      wutcounter++;  
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 8006e8a:	2080      	movs	r0, #128	; 0x80
    status = SUCCESS;    
  }
  else
  {
    /* Disable the Wakeup Timer */
    RTC->CR &= (uint32_t)~RTC_CR_WUTE;
 8006e8c:	688a      	ldr	r2, [r1, #8]
 8006e8e:	4b11      	ldr	r3, [pc, #68]	; (8006ed4 <RTC_WakeUpCmd+0x60>)
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
 8006e90:	2404      	movs	r4, #4
    status = SUCCESS;    
  }
  else
  {
    /* Disable the Wakeup Timer */
    RTC->CR &= (uint32_t)~RTC_CR_WUTE;
 8006e92:	4013      	ands	r3, r2
 8006e94:	608b      	str	r3, [r1, #8]
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
      wutcounter++;  
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 8006e96:	01c0      	lsls	r0, r0, #7
 8006e98:	e001      	b.n	8006e9e <RTC_WakeUpCmd+0x2a>
 8006e9a:	2a00      	cmp	r2, #0
 8006e9c:	d108      	bne.n	8006eb0 <RTC_WakeUpCmd+0x3c>
    /* Disable the Wakeup Timer */
    RTC->CR &= (uint32_t)~RTC_CR_WUTE;
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
 8006e9e:	68cb      	ldr	r3, [r1, #12]
 8006ea0:	4023      	ands	r3, r4
 8006ea2:	1c1a      	adds	r2, r3, #0
      wutcounter++;  
 8006ea4:	9b01      	ldr	r3, [sp, #4]
 8006ea6:	3301      	adds	r3, #1
 8006ea8:	9301      	str	r3, [sp, #4]
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 8006eaa:	9b01      	ldr	r3, [sp, #4]
 8006eac:	4283      	cmp	r3, r0
 8006eae:	d1f4      	bne.n	8006e9a <RTC_WakeUpCmd+0x26>
    
    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
 8006eb0:	4b07      	ldr	r3, [pc, #28]	; (8006ed0 <RTC_WakeUpCmd+0x5c>)
 8006eb2:	68d8      	ldr	r0, [r3, #12]
 8006eb4:	0740      	lsls	r0, r0, #29

  if (NewState != DISABLE)
  {
    /* Enable the Wakeup Timer */
    RTC->CR |= (uint32_t)RTC_CR_WUTE;
    status = SUCCESS;    
 8006eb6:	0fc0      	lsrs	r0, r0, #31
      status = SUCCESS;
    }    
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006eb8:	22ff      	movs	r2, #255	; 0xff
 8006eba:	4b05      	ldr	r3, [pc, #20]	; (8006ed0 <RTC_WakeUpCmd+0x5c>)
 8006ebc:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
}
 8006ebe:	b002      	add	sp, #8
 8006ec0:	bd10      	pop	{r4, pc}
  RTC->WPR = 0x53;

  if (NewState != DISABLE)
  {
    /* Enable the Wakeup Timer */
    RTC->CR |= (uint32_t)RTC_CR_WUTE;
 8006ec2:	2280      	movs	r2, #128	; 0x80
 8006ec4:	688b      	ldr	r3, [r1, #8]
 8006ec6:	00d2      	lsls	r2, r2, #3
 8006ec8:	4313      	orrs	r3, r2
 8006eca:	608b      	str	r3, [r1, #8]
    status = SUCCESS;    
 8006ecc:	2001      	movs	r0, #1
 8006ece:	e7f3      	b.n	8006eb8 <RTC_WakeUpCmd+0x44>
 8006ed0:	40002800 	.word	0x40002800
 8006ed4:	fffffbff 	.word	0xfffffbff

08006ed8 <RTC_DayLightSavingConfig>:
  /* Check the parameters */
  assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
  assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006ed8:	22ca      	movs	r2, #202	; 0xca
 8006eda:	4b08      	ldr	r3, [pc, #32]	; (8006efc <RTC_DayLightSavingConfig+0x24>)
  *            @arg RTC_StoreOperation_Reset: BCK Bit Reset
  *            @arg RTC_StoreOperation_Set: BCK Bit Set
  * @retval None
  */
void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
{
 8006edc:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
  assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006ede:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8006ee0:	3a77      	subs	r2, #119	; 0x77
 8006ee2:	625a      	str	r2, [r3, #36]	; 0x24

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_BCK);
 8006ee4:	689c      	ldr	r4, [r3, #8]
 8006ee6:	4a06      	ldr	r2, [pc, #24]	; (8006f00 <RTC_DayLightSavingConfig+0x28>)
 8006ee8:	4022      	ands	r2, r4
 8006eea:	609a      	str	r2, [r3, #8]

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
 8006eec:	689a      	ldr	r2, [r3, #8]
 8006eee:	4311      	orrs	r1, r2

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006ef0:	22ff      	movs	r2, #255	; 0xff

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_BCK);

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
 8006ef2:	4308      	orrs	r0, r1
 8006ef4:	6098      	str	r0, [r3, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006ef6:	625a      	str	r2, [r3, #36]	; 0x24
}
 8006ef8:	bd10      	pop	{r4, pc}
 8006efa:	46c0      	nop			; (mov r8, r8)
 8006efc:	40002800 	.word	0x40002800
 8006f00:	fffbffff 	.word	0xfffbffff

08006f04 <RTC_GetStoreOperation>:
  *          - RTC_StoreOperation_Reset
  *          - RTC_StoreOperation_Set
  */
uint32_t RTC_GetStoreOperation(void)
{
  return (RTC->CR & RTC_CR_BCK);
 8006f04:	4b02      	ldr	r3, [pc, #8]	; (8006f10 <RTC_GetStoreOperation+0xc>)
 8006f06:	6898      	ldr	r0, [r3, #8]
 8006f08:	2380      	movs	r3, #128	; 0x80
 8006f0a:	02db      	lsls	r3, r3, #11
 8006f0c:	4018      	ands	r0, r3
}
 8006f0e:	4770      	bx	lr
 8006f10:	40002800 	.word	0x40002800

08006f14 <RTC_OutputConfig>:
  /* Check the parameters */
  assert_param(IS_RTC_OUTPUT(RTC_Output));
  assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006f14:	22ca      	movs	r2, #202	; 0xca
 8006f16:	4b08      	ldr	r3, [pc, #32]	; (8006f38 <RTC_OutputConfig+0x24>)
  *            @arg RTC_OutputPolarity_Low: The output pin is low when the 
  *                                         ALRAF is high (depending on OSEL)
  * @retval None
  */
void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
{
 8006f18:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_RTC_OUTPUT(RTC_Output));
  assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006f1a:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8006f1c:	3a77      	subs	r2, #119	; 0x77
 8006f1e:	625a      	str	r2, [r3, #36]	; 0x24

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
 8006f20:	689c      	ldr	r4, [r3, #8]
 8006f22:	4a06      	ldr	r2, [pc, #24]	; (8006f3c <RTC_OutputConfig+0x28>)
 8006f24:	4022      	ands	r2, r4
 8006f26:	609a      	str	r2, [r3, #8]

  /* Configure the output selection and polarity */
  RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
 8006f28:	689a      	ldr	r2, [r3, #8]
 8006f2a:	4311      	orrs	r1, r2

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006f2c:	22ff      	movs	r2, #255	; 0xff

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);

  /* Configure the output selection and polarity */
  RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
 8006f2e:	4308      	orrs	r0, r1
 8006f30:	6098      	str	r0, [r3, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006f32:	625a      	str	r2, [r3, #36]	; 0x24
}
 8006f34:	bd10      	pop	{r4, pc}
 8006f36:	46c0      	nop			; (mov r8, r8)
 8006f38:	40002800 	.word	0x40002800
 8006f3c:	ff8fffff 	.word	0xff8fffff

08006f40 <RTC_CalibOutputCmd>:
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006f40:	22ca      	movs	r2, #202	; 0xca
 8006f42:	4b0a      	ldr	r3, [pc, #40]	; (8006f6c <RTC_CalibOutputCmd+0x2c>)
 8006f44:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8006f46:	3a77      	subs	r2, #119	; 0x77
 8006f48:	625a      	str	r2, [r3, #36]	; 0x24
  
  if (NewState != DISABLE)
 8006f4a:	2800      	cmp	r0, #0
 8006f4c:	d107      	bne.n	8006f5e <RTC_CalibOutputCmd+0x1e>
    RTC->CR |= (uint32_t)RTC_CR_COE;
  }
  else
  { 
    /* Disable the RTC clock output */
    RTC->CR &= (uint32_t)~RTC_CR_COE;
 8006f4e:	6899      	ldr	r1, [r3, #8]
 8006f50:	4a07      	ldr	r2, [pc, #28]	; (8006f70 <RTC_CalibOutputCmd+0x30>)
 8006f52:	400a      	ands	r2, r1
 8006f54:	609a      	str	r2, [r3, #8]
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8006f56:	22ff      	movs	r2, #255	; 0xff
 8006f58:	4b04      	ldr	r3, [pc, #16]	; (8006f6c <RTC_CalibOutputCmd+0x2c>)
 8006f5a:	625a      	str	r2, [r3, #36]	; 0x24
}
 8006f5c:	4770      	bx	lr
  RTC->WPR = 0x53;
  
  if (NewState != DISABLE)
  {
    /* Enable the RTC clock output */
    RTC->CR |= (uint32_t)RTC_CR_COE;
 8006f5e:	2180      	movs	r1, #128	; 0x80
 8006f60:	689a      	ldr	r2, [r3, #8]
 8006f62:	0409      	lsls	r1, r1, #16
 8006f64:	430a      	orrs	r2, r1
 8006f66:	609a      	str	r2, [r3, #8]
 8006f68:	e7f5      	b.n	8006f56 <RTC_CalibOutputCmd+0x16>
 8006f6a:	46c0      	nop			; (mov r8, r8)
 8006f6c:	40002800 	.word	0x40002800
 8006f70:	ff7fffff 	.word	0xff7fffff

08006f74 <RTC_CalibOutputConfig>:
{
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006f74:	22ca      	movs	r2, #202	; 0xca
 8006f76:	4b07      	ldr	r3, [pc, #28]	; (8006f94 <RTC_CalibOutputConfig+0x20>)
 8006f78:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8006f7a:	3a77      	subs	r2, #119	; 0x77
 8006f7c:	625a      	str	r2, [r3, #36]	; 0x24
  
  /*clear flags before config*/
  RTC->CR &= (uint32_t)~(RTC_CR_CALSEL);
 8006f7e:	6899      	ldr	r1, [r3, #8]
 8006f80:	4a05      	ldr	r2, [pc, #20]	; (8006f98 <RTC_CalibOutputConfig+0x24>)
 8006f82:	400a      	ands	r2, r1
 8006f84:	609a      	str	r2, [r3, #8]

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)RTC_CalibOutput;
 8006f86:	689a      	ldr	r2, [r3, #8]
 8006f88:	4310      	orrs	r0, r2

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006f8a:	22ff      	movs	r2, #255	; 0xff
  
  /*clear flags before config*/
  RTC->CR &= (uint32_t)~(RTC_CR_CALSEL);

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)RTC_CalibOutput;
 8006f8c:	6098      	str	r0, [r3, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006f8e:	625a      	str	r2, [r3, #36]	; 0x24
}
 8006f90:	4770      	bx	lr
 8006f92:	46c0      	nop			; (mov r8, r8)
 8006f94:	40002800 	.word	0x40002800
 8006f98:	fff7ffff 	.word	0xfff7ffff

08006f9c <RTC_SmoothCalibConfig>:
  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006f9c:	23ca      	movs	r3, #202	; 0xca
  *          - ERROR: RTC Calib registers are not configured
*/
ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
                                  uint32_t RTC_SmoothCalibPlusPulses,
                                  uint32_t RTC_SmouthCalibMinusPulsesValue)
{
 8006f9e:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
  
  /* check if a calibration is pending*/
  if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
 8006fa0:	2680      	movs	r6, #128	; 0x80
  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006fa2:	4d11      	ldr	r5, [pc, #68]	; (8006fe8 <RTC_SmoothCalibConfig+0x4c>)
  RTC->WPR = 0x53;
  
  /* check if a calibration is pending*/
  if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
 8006fa4:	0276      	lsls	r6, r6, #9
  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006fa6:	626b      	str	r3, [r5, #36]	; 0x24
  RTC->WPR = 0x53;
 8006fa8:	3b77      	subs	r3, #119	; 0x77
 8006faa:	626b      	str	r3, [r5, #36]	; 0x24
  
  /* check if a calibration is pending*/
  if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
 8006fac:	68eb      	ldr	r3, [r5, #12]
  *          - ERROR: RTC Calib registers are not configured
*/
ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
                                  uint32_t RTC_SmoothCalibPlusPulses,
                                  uint32_t RTC_SmouthCalibMinusPulsesValue)
{
 8006fae:	1c07      	adds	r7, r0, #0
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
  
  /* check if a calibration is pending*/
  if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
 8006fb0:	4233      	tst	r3, r6
 8006fb2:	d00b      	beq.n	8006fcc <RTC_SmoothCalibConfig+0x30>
  {
    /* wait until the Calibration is completed*/
    while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
 8006fb4:	68eb      	ldr	r3, [r5, #12]
 8006fb6:	4233      	tst	r3, r6
 8006fb8:	d008      	beq.n	8006fcc <RTC_SmoothCalibConfig+0x30>
 8006fba:	2380      	movs	r3, #128	; 0x80
 8006fbc:	015b      	lsls	r3, r3, #5
 8006fbe:	e002      	b.n	8006fc6 <RTC_SmoothCalibConfig+0x2a>
 8006fc0:	3b01      	subs	r3, #1
 8006fc2:	2b00      	cmp	r3, #0
 8006fc4:	d002      	beq.n	8006fcc <RTC_SmoothCalibConfig+0x30>
 8006fc6:	68ec      	ldr	r4, [r5, #12]
 8006fc8:	4234      	tst	r4, r6
 8006fca:	d1f9      	bne.n	8006fc0 <RTC_SmoothCalibConfig+0x24>
      recalpfcount++;
    }
  }

  /* check if the calibration pending is completed or if there is no calibration operation at all*/
  if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
 8006fcc:	4b06      	ldr	r3, [pc, #24]	; (8006fe8 <RTC_SmoothCalibConfig+0x4c>)

    status = SUCCESS;
  }
  else
  {
    status = ERROR;
 8006fce:	2000      	movs	r0, #0
      recalpfcount++;
    }
  }

  /* check if the calibration pending is completed or if there is no calibration operation at all*/
  if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
 8006fd0:	68dc      	ldr	r4, [r3, #12]
 8006fd2:	03e4      	lsls	r4, r4, #15
 8006fd4:	d403      	bmi.n	8006fde <RTC_SmoothCalibConfig+0x42>
 8006fd6:	430a      	orrs	r2, r1
  {
    /* Configure the Smooth calibration settings */
    RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
 8006fd8:	4317      	orrs	r7, r2
 8006fda:	63df      	str	r7, [r3, #60]	; 0x3c

    status = SUCCESS;
 8006fdc:	3001      	adds	r0, #1
  {
    status = ERROR;
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8006fde:	22ff      	movs	r2, #255	; 0xff
 8006fe0:	4b01      	ldr	r3, [pc, #4]	; (8006fe8 <RTC_SmoothCalibConfig+0x4c>)
 8006fe2:	625a      	str	r2, [r3, #36]	; 0x24
  
  return (ErrorStatus)(status);
}
 8006fe4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006fe6:	46c0      	nop			; (mov r8, r8)
 8006fe8:	40002800 	.word	0x40002800

08006fec <RTC_TimeStampCmd>:
  /* Check the parameters */
  assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 8006fec:	4b0a      	ldr	r3, [pc, #40]	; (8007018 <RTC_TimeStampCmd+0x2c>)
 8006fee:	4a0b      	ldr	r2, [pc, #44]	; (800701c <RTC_TimeStampCmd+0x30>)
 8006ff0:	689b      	ldr	r3, [r3, #8]
 8006ff2:	4013      	ands	r3, r2

  /* Get the new configuration */
  if (NewState != DISABLE)
 8006ff4:	2900      	cmp	r1, #0
 8006ff6:	d109      	bne.n	800700c <RTC_TimeStampCmd+0x20>
  {
    tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
  }
  else
  {
    tmpreg |= (uint32_t)(RTC_TimeStampEdge);
 8006ff8:	4318      	orrs	r0, r3
  }

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8006ffa:	22ca      	movs	r2, #202	; 0xca
 8006ffc:	4b06      	ldr	r3, [pc, #24]	; (8007018 <RTC_TimeStampCmd+0x2c>)
 8006ffe:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8007000:	3a77      	subs	r2, #119	; 0x77
 8007002:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Time Stamp TSEDGE and Enable bits */
  RTC->CR = (uint32_t)tmpreg;

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8007004:	32ac      	adds	r2, #172	; 0xac
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Configure the Time Stamp TSEDGE and Enable bits */
  RTC->CR = (uint32_t)tmpreg;
 8007006:	6098      	str	r0, [r3, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8007008:	625a      	str	r2, [r3, #36]	; 0x24
}
 800700a:	4770      	bx	lr
 800700c:	2280      	movs	r2, #128	; 0x80
 800700e:	0112      	lsls	r2, r2, #4
 8007010:	4313      	orrs	r3, r2
  tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));

  /* Get the new configuration */
  if (NewState != DISABLE)
  {
    tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
 8007012:	4318      	orrs	r0, r3
 8007014:	e7f1      	b.n	8006ffa <RTC_TimeStampCmd+0xe>
 8007016:	46c0      	nop			; (mov r8, r8)
 8007018:	40002800 	.word	0x40002800
 800701c:	fffff7f7 	.word	0xfffff7f7

08007020 <RTC_GetTimeStamp>:

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the TimeStamp time and date registers values */
  tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
 8007020:	4b28      	ldr	r3, [pc, #160]	; (80070c4 <RTC_GetTimeStamp+0xa4>)
  *                             contains the TimeStamp date values.     
  * @retval None
  */
void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
                                      RTC_DateTypeDef* RTC_StampDateStruct)
{
 8007022:	b530      	push	{r4, r5, lr}

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the TimeStamp time and date registers values */
  tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
 8007024:	6b1d      	ldr	r5, [r3, #48]	; 0x30
  tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
 8007026:	6b5b      	ldr	r3, [r3, #52]	; 0x34

  /* Fill the Time structure fields with the read parameters */
  RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8007028:	02ac      	lsls	r4, r5, #10
 800702a:	0ea4      	lsrs	r4, r4, #26
 800702c:	700c      	strb	r4, [r1, #0]
  RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
 800702e:	046c      	lsls	r4, r5, #17
 8007030:	0e64      	lsrs	r4, r4, #25
 8007032:	704c      	strb	r4, [r1, #1]
  RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
 8007034:	247f      	movs	r4, #127	; 0x7f
 8007036:	402c      	ands	r4, r5
 8007038:	708c      	strb	r4, [r1, #2]
  RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
 800703a:	2480      	movs	r4, #128	; 0x80
 800703c:	03e4      	lsls	r4, r4, #15
 800703e:	402c      	ands	r4, r5
 8007040:	0c24      	lsrs	r4, r4, #16
 8007042:	70cc      	strb	r4, [r1, #3]

  /* Fill the Date structure fields with the read parameters */
  RTC_StampDateStruct->RTC_Year = 0;
 8007044:	2400      	movs	r4, #0
 8007046:	70d4      	strb	r4, [r2, #3]
  RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8007048:	04dc      	lsls	r4, r3, #19
 800704a:	0ee4      	lsrs	r4, r4, #27
 800704c:	7054      	strb	r4, [r2, #1]
  RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
 800704e:	243f      	movs	r4, #63	; 0x3f
 8007050:	401c      	ands	r4, r3
  RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
 8007052:	041b      	lsls	r3, r3, #16
 8007054:	0f5b      	lsrs	r3, r3, #29
  RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  

  /* Fill the Date structure fields with the read parameters */
  RTC_StampDateStruct->RTC_Year = 0;
  RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
  RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
 8007056:	7094      	strb	r4, [r2, #2]
  RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
 8007058:	7013      	strb	r3, [r2, #0]

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
 800705a:	2800      	cmp	r0, #0
 800705c:	d130      	bne.n	80070c0 <RTC_GetTimeStamp+0xa0>
  {
    /* Convert the Time structure parameters to Binary format */
    RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
 800705e:	780b      	ldrb	r3, [r1, #0]
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8007060:	091c      	lsrs	r4, r3, #4
 8007062:	00a0      	lsls	r0, r4, #2
 8007064:	1824      	adds	r4, r4, r0
  return (tmp + (Value & (uint8_t)0x0F));
 8007066:	200f      	movs	r0, #15
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8007068:	0064      	lsls	r4, r4, #1
  return (tmp + (Value & (uint8_t)0x0F));
 800706a:	4003      	ands	r3, r0
 800706c:	18e3      	adds	r3, r4, r3

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
  {
    /* Convert the Time structure parameters to Binary format */
    RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
 800706e:	700b      	strb	r3, [r1, #0]
    RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
 8007070:	784b      	ldrb	r3, [r1, #1]
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8007072:	091d      	lsrs	r5, r3, #4
 8007074:	00ac      	lsls	r4, r5, #2
 8007076:	192c      	adds	r4, r5, r4
 8007078:	0064      	lsls	r4, r4, #1
  return (tmp + (Value & (uint8_t)0x0F));
 800707a:	4003      	ands	r3, r0
 800707c:	18e3      	adds	r3, r4, r3
  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
  {
    /* Convert the Time structure parameters to Binary format */
    RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
    RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
 800707e:	704b      	strb	r3, [r1, #1]
    RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
 8007080:	788b      	ldrb	r3, [r1, #2]
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8007082:	091d      	lsrs	r5, r3, #4
 8007084:	00ac      	lsls	r4, r5, #2
 8007086:	192c      	adds	r4, r5, r4
 8007088:	0064      	lsls	r4, r4, #1
  return (tmp + (Value & (uint8_t)0x0F));
 800708a:	4003      	ands	r3, r0
 800708c:	18e3      	adds	r3, r4, r3
  if (RTC_Format == RTC_Format_BIN)
  {
    /* Convert the Time structure parameters to Binary format */
    RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
    RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
    RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
 800708e:	708b      	strb	r3, [r1, #2]

    /* Convert the Date structure parameters to Binary format */
    RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
 8007090:	7853      	ldrb	r3, [r2, #1]
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8007092:	091c      	lsrs	r4, r3, #4
 8007094:	00a1      	lsls	r1, r4, #2
 8007096:	1861      	adds	r1, r4, r1
 8007098:	0049      	lsls	r1, r1, #1
  return (tmp + (Value & (uint8_t)0x0F));
 800709a:	4003      	ands	r3, r0
 800709c:	18cb      	adds	r3, r1, r3
    RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
    RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
    RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);

    /* Convert the Date structure parameters to Binary format */
    RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
 800709e:	7053      	strb	r3, [r2, #1]
    RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
 80070a0:	7893      	ldrb	r3, [r2, #2]
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 80070a2:	091c      	lsrs	r4, r3, #4
 80070a4:	00a1      	lsls	r1, r4, #2
 80070a6:	1861      	adds	r1, r4, r1
 80070a8:	0049      	lsls	r1, r1, #1
  return (tmp + (Value & (uint8_t)0x0F));
 80070aa:	4003      	ands	r3, r0
 80070ac:	18cb      	adds	r3, r1, r3
    RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
    RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);

    /* Convert the Date structure parameters to Binary format */
    RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
    RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
 80070ae:	7093      	strb	r3, [r2, #2]
    RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
 80070b0:	7813      	ldrb	r3, [r2, #0]
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 80070b2:	091c      	lsrs	r4, r3, #4
 80070b4:	00a1      	lsls	r1, r4, #2
 80070b6:	1861      	adds	r1, r4, r1
 80070b8:	0049      	lsls	r1, r1, #1
  return (tmp + (Value & (uint8_t)0x0F));
 80070ba:	4003      	ands	r3, r0
 80070bc:	18cb      	adds	r3, r1, r3
    RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);

    /* Convert the Date structure parameters to Binary format */
    RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
    RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
    RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
 80070be:	7013      	strb	r3, [r2, #0]
  }
}
 80070c0:	bd30      	pop	{r4, r5, pc}
 80070c2:	46c0      	nop			; (mov r8, r8)
 80070c4:	40002800 	.word	0x40002800

080070c8 <RTC_GetTimeStampSubSecond>:
  * @retval RTC current timestamp Subseconds value.
  */
uint32_t RTC_GetTimeStampSubSecond(void)
{
  /* Get timestamp subseconds values from the correspondent registers */
  return (uint32_t)(RTC->TSSSR);
 80070c8:	4b01      	ldr	r3, [pc, #4]	; (80070d0 <RTC_GetTimeStampSubSecond+0x8>)
 80070ca:	6b98      	ldr	r0, [r3, #56]	; 0x38
}
 80070cc:	4770      	bx	lr
 80070ce:	46c0      	nop			; (mov r8, r8)
 80070d0:	40002800 	.word	0x40002800

080070d4 <RTC_TamperTriggerConfig>:
  assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
 
  if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
  {  
    /* Configure the RTC_TAFCR register */
    RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
 80070d4:	4a05      	ldr	r2, [pc, #20]	; (80070ec <RTC_TamperTriggerConfig+0x18>)
 80070d6:	0040      	lsls	r0, r0, #1
 80070d8:	6c13      	ldr	r3, [r2, #64]	; 0x40
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
  assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
 
  if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
 80070da:	2900      	cmp	r1, #0
 80070dc:	d002      	beq.n	80070e4 <RTC_TamperTriggerConfig+0x10>
    RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
  }
  else
  { 
    /* Configure the RTC_TAFCR register */
    RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
 80070de:	4318      	orrs	r0, r3
 80070e0:	6410      	str	r0, [r2, #64]	; 0x40
  }  
}
 80070e2:	4770      	bx	lr
  assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
 
  if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
  {  
    /* Configure the RTC_TAFCR register */
    RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
 80070e4:	4383      	bics	r3, r0
 80070e6:	6413      	str	r3, [r2, #64]	; 0x40
 80070e8:	e7fb      	b.n	80070e2 <RTC_TamperTriggerConfig+0xe>
 80070ea:	46c0      	nop			; (mov r8, r8)
 80070ec:	40002800 	.word	0x40002800

080070f0 <RTC_TamperCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected Tamper pin */
    RTC->TAFCR |= (uint32_t)RTC_Tamper;
 80070f0:	4a04      	ldr	r2, [pc, #16]	; (8007104 <RTC_TamperCmd+0x14>)
 80070f2:	6c13      	ldr	r3, [r2, #64]	; 0x40
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER(RTC_Tamper));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80070f4:	2900      	cmp	r1, #0
 80070f6:	d102      	bne.n	80070fe <RTC_TamperCmd+0xe>
    RTC->TAFCR |= (uint32_t)RTC_Tamper;
  }
  else
  {
    /* Disable the selected Tamper pin */
    RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
 80070f8:	4383      	bics	r3, r0
 80070fa:	6413      	str	r3, [r2, #64]	; 0x40
  }  
}
 80070fc:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected Tamper pin */
    RTC->TAFCR |= (uint32_t)RTC_Tamper;
 80070fe:	4318      	orrs	r0, r3
 8007100:	6410      	str	r0, [r2, #64]	; 0x40
 8007102:	e7fb      	b.n	80070fc <RTC_TamperCmd+0xc>
 8007104:	40002800 	.word	0x40002800

08007108 <RTC_TamperFilterConfig>:
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
   
  /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
 8007108:	4b04      	ldr	r3, [pc, #16]	; (800711c <RTC_TamperFilterConfig+0x14>)
 800710a:	4a05      	ldr	r2, [pc, #20]	; (8007120 <RTC_TamperFilterConfig+0x18>)
 800710c:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800710e:	400a      	ands	r2, r1
 8007110:	641a      	str	r2, [r3, #64]	; 0x40

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
 8007112:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8007114:	4310      	orrs	r0, r2
 8007116:	6418      	str	r0, [r3, #64]	; 0x40
}
 8007118:	4770      	bx	lr
 800711a:	46c0      	nop			; (mov r8, r8)
 800711c:	40002800 	.word	0x40002800
 8007120:	ffffe7ff 	.word	0xffffe7ff

08007124 <RTC_TamperSamplingFreqConfig>:
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
 
  /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
 8007124:	4b04      	ldr	r3, [pc, #16]	; (8007138 <RTC_TamperSamplingFreqConfig+0x14>)
 8007126:	4a05      	ldr	r2, [pc, #20]	; (800713c <RTC_TamperSamplingFreqConfig+0x18>)
 8007128:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800712a:	400a      	ands	r2, r1
 800712c:	641a      	str	r2, [r3, #64]	; 0x40

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
 800712e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8007130:	4310      	orrs	r0, r2
 8007132:	6418      	str	r0, [r3, #64]	; 0x40
}
 8007134:	4770      	bx	lr
 8007136:	46c0      	nop			; (mov r8, r8)
 8007138:	40002800 	.word	0x40002800
 800713c:	fffff8ff 	.word	0xfffff8ff

08007140 <RTC_TamperPinsPrechargeDuration>:
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
   
  /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
 8007140:	4b04      	ldr	r3, [pc, #16]	; (8007154 <RTC_TamperPinsPrechargeDuration+0x14>)
 8007142:	4a05      	ldr	r2, [pc, #20]	; (8007158 <RTC_TamperPinsPrechargeDuration+0x18>)
 8007144:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8007146:	400a      	ands	r2, r1
 8007148:	641a      	str	r2, [r3, #64]	; 0x40

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
 800714a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800714c:	4310      	orrs	r0, r2
 800714e:	6418      	str	r0, [r3, #64]	; 0x40
}
 8007150:	4770      	bx	lr
 8007152:	46c0      	nop			; (mov r8, r8)
 8007154:	40002800 	.word	0x40002800
 8007158:	ffff9fff 	.word	0xffff9fff

0800715c <RTC_TimeStampOnTamperDetectionCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
   
  if (NewState != DISABLE)
  {
    /* Save timestamp on tamper detection event */
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
 800715c:	4a06      	ldr	r2, [pc, #24]	; (8007178 <RTC_TimeStampOnTamperDetectionCmd+0x1c>)
void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
   
  if (NewState != DISABLE)
 800715e:	2800      	cmp	r0, #0
 8007160:	d104      	bne.n	800716c <RTC_TimeStampOnTamperDetectionCmd+0x10>
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
  }
  else
  {
    /* Tamper detection does not cause a timestamp to be saved */
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
 8007162:	2180      	movs	r1, #128	; 0x80
 8007164:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8007166:	438b      	bics	r3, r1
 8007168:	6413      	str	r3, [r2, #64]	; 0x40
  }
}
 800716a:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
   
  if (NewState != DISABLE)
  {
    /* Save timestamp on tamper detection event */
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
 800716c:	2380      	movs	r3, #128	; 0x80
 800716e:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8007170:	430b      	orrs	r3, r1
 8007172:	6413      	str	r3, [r2, #64]	; 0x40
 8007174:	e7f9      	b.n	800716a <RTC_TimeStampOnTamperDetectionCmd+0xe>
 8007176:	46c0      	nop			; (mov r8, r8)
 8007178:	40002800 	.word	0x40002800

0800717c <RTC_TamperPullUpCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
 if (NewState != DISABLE)
  {
    /* Enable precharge of the selected Tamper pin */
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
 800717c:	4a06      	ldr	r2, [pc, #24]	; (8007198 <RTC_TamperPullUpCmd+0x1c>)
void RTC_TamperPullUpCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
 if (NewState != DISABLE)
 800717e:	2800      	cmp	r0, #0
 8007180:	d105      	bne.n	800718e <RTC_TamperPullUpCmd+0x12>
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
  }
  else
  {
    /* Disable precharge of the selected Tamper pin */
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
 8007182:	2180      	movs	r1, #128	; 0x80
 8007184:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8007186:	0209      	lsls	r1, r1, #8
 8007188:	430b      	orrs	r3, r1
 800718a:	6413      	str	r3, [r2, #64]	; 0x40
  } 
}
 800718c:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
 if (NewState != DISABLE)
  {
    /* Enable precharge of the selected Tamper pin */
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
 800718e:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8007190:	4b02      	ldr	r3, [pc, #8]	; (800719c <RTC_TamperPullUpCmd+0x20>)
 8007192:	400b      	ands	r3, r1
 8007194:	6413      	str	r3, [r2, #64]	; 0x40
 8007196:	e7f9      	b.n	800718c <RTC_TamperPullUpCmd+0x10>
 8007198:	40002800 	.word	0x40002800
 800719c:	ffff7fff 	.word	0xffff7fff

080071a0 <RTC_WriteBackupRegister>:
  * @param  Data: Data to be written in the specified RTC Backup data register.                     
  * @retval None
  */
void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
{
  __IO uint32_t tmp = 0;
 80071a0:	2300      	movs	r3, #0
  *                                 specify the register.
  * @param  Data: Data to be written in the specified RTC Backup data register.                     
  * @retval None
  */
void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
{
 80071a2:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 80071a4:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_RTC_BKP(RTC_BKP_DR));

  tmp = RTC_BASE + 0x50;
 80071a6:	4b05      	ldr	r3, [pc, #20]	; (80071bc <RTC_WriteBackupRegister+0x1c>)
  tmp += (RTC_BKP_DR * 4);
 80071a8:	0080      	lsls	r0, r0, #2
  __IO uint32_t tmp = 0;
  
  /* Check the parameters */
  assert_param(IS_RTC_BKP(RTC_BKP_DR));

  tmp = RTC_BASE + 0x50;
 80071aa:	9301      	str	r3, [sp, #4]
  tmp += (RTC_BKP_DR * 4);
 80071ac:	9b01      	ldr	r3, [sp, #4]
 80071ae:	18c0      	adds	r0, r0, r3
 80071b0:	9001      	str	r0, [sp, #4]

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 80071b2:	9b01      	ldr	r3, [sp, #4]
 80071b4:	6019      	str	r1, [r3, #0]
}
 80071b6:	b002      	add	sp, #8
 80071b8:	4770      	bx	lr
 80071ba:	46c0      	nop			; (mov r8, r8)
 80071bc:	40002850 	.word	0x40002850

080071c0 <RTC_ReadBackupRegister>:
  *                          specify the register.                   
  * @retval None
  */
uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
{
  __IO uint32_t tmp = 0;
 80071c0:	2300      	movs	r3, #0
  *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
  *                          specify the register.                   
  * @retval None
  */
uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
{
 80071c2:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 80071c4:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_RTC_BKP(RTC_BKP_DR));

  tmp = RTC_BASE + 0x50;
 80071c6:	4b05      	ldr	r3, [pc, #20]	; (80071dc <RTC_ReadBackupRegister+0x1c>)
  tmp += (RTC_BKP_DR * 4);
 80071c8:	0080      	lsls	r0, r0, #2
  __IO uint32_t tmp = 0;
  
  /* Check the parameters */
  assert_param(IS_RTC_BKP(RTC_BKP_DR));

  tmp = RTC_BASE + 0x50;
 80071ca:	9301      	str	r3, [sp, #4]
  tmp += (RTC_BKP_DR * 4);
 80071cc:	9b01      	ldr	r3, [sp, #4]
 80071ce:	18c0      	adds	r0, r0, r3
 80071d0:	9001      	str	r0, [sp, #4]
  
  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 80071d2:	9b01      	ldr	r3, [sp, #4]
 80071d4:	6818      	ldr	r0, [r3, #0]
}
 80071d6:	b002      	add	sp, #8
 80071d8:	4770      	bx	lr
 80071da:	46c0      	nop			; (mov r8, r8)
 80071dc:	40002850 	.word	0x40002850

080071e0 <RTC_OutputTypeConfig>:
void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
{
  /* Check the parameters */
  assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
 80071e0:	4b04      	ldr	r3, [pc, #16]	; (80071f4 <RTC_OutputTypeConfig+0x14>)
 80071e2:	4a05      	ldr	r2, [pc, #20]	; (80071f8 <RTC_OutputTypeConfig+0x18>)
 80071e4:	6c19      	ldr	r1, [r3, #64]	; 0x40
 80071e6:	400a      	ands	r2, r1
 80071e8:	641a      	str	r2, [r3, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
 80071ea:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80071ec:	4310      	orrs	r0, r2
 80071ee:	6418      	str	r0, [r3, #64]	; 0x40
}
 80071f0:	4770      	bx	lr
 80071f2:	46c0      	nop			; (mov r8, r8)
 80071f4:	40002800 	.word	0x40002800
 80071f8:	fffbffff 	.word	0xfffbffff

080071fc <RTC_SynchroShiftConfig>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Shift registers are configured
  *          - ERROR: RTC Shift registers are not configured
*/
ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
{
 80071fc:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
  assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80071fe:	23ca      	movs	r3, #202	; 0xca
 8007200:	4c14      	ldr	r4, [pc, #80]	; (8007254 <RTC_SynchroShiftConfig+0x58>)
 8007202:	6263      	str	r3, [r4, #36]	; 0x24
  RTC->WPR = 0x53;
 8007204:	3b77      	subs	r3, #119	; 0x77
 8007206:	6263      	str	r3, [r4, #36]	; 0x24
  
  /* Check if a Shift is pending*/
  if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
 8007208:	68e2      	ldr	r2, [r4, #12]
 800720a:	3b4b      	subs	r3, #75	; 0x4b
 800720c:	4213      	tst	r3, r2
 800720e:	d00c      	beq.n	800722a <RTC_SynchroShiftConfig+0x2e>
  {
    /* Wait until the shift is completed*/
    while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
 8007210:	68e2      	ldr	r2, [r4, #12]
 8007212:	4213      	tst	r3, r2
 8007214:	d009      	beq.n	800722a <RTC_SynchroShiftConfig+0x2e>
 8007216:	2380      	movs	r3, #128	; 0x80
 8007218:	2508      	movs	r5, #8
 800721a:	015b      	lsls	r3, r3, #5
 800721c:	e002      	b.n	8007224 <RTC_SynchroShiftConfig+0x28>
 800721e:	3b01      	subs	r3, #1
 8007220:	2b00      	cmp	r3, #0
 8007222:	d002      	beq.n	800722a <RTC_SynchroShiftConfig+0x2e>
 8007224:	68e2      	ldr	r2, [r4, #12]
 8007226:	4215      	tst	r5, r2
 8007228:	d1f9      	bne.n	800721e <RTC_SynchroShiftConfig+0x22>
      shpfcount++;
    }
  }

  /* Check if the Shift pending is completed or if there is no Shift operation at all*/
  if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
 800722a:	4a0a      	ldr	r2, [pc, #40]	; (8007254 <RTC_SynchroShiftConfig+0x58>)
      status = ERROR;
    }
  }
  else
  {
    status = ERROR;
 800722c:	2300      	movs	r3, #0
      shpfcount++;
    }
  }

  /* Check if the Shift pending is completed or if there is no Shift operation at all*/
  if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
 800722e:	68d4      	ldr	r4, [r2, #12]
 8007230:	0724      	lsls	r4, r4, #28
 8007232:	d402      	bmi.n	800723a <RTC_SynchroShiftConfig+0x3e>
  {
    /* check if the reference clock detection is disabled */
    if((RTC->CR & RTC_CR_REFCKON) == RESET)
 8007234:	6894      	ldr	r4, [r2, #8]
 8007236:	06e4      	lsls	r4, r4, #27
 8007238:	d504      	bpl.n	8007244 <RTC_SynchroShiftConfig+0x48>
  {
    status = ERROR;
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 800723a:	21ff      	movs	r1, #255	; 0xff
 800723c:	4a05      	ldr	r2, [pc, #20]	; (8007254 <RTC_SynchroShiftConfig+0x58>)
  
  return (ErrorStatus)(status);
}
 800723e:	1c18      	adds	r0, r3, #0
  {
    status = ERROR;
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8007240:	6251      	str	r1, [r2, #36]	; 0x24
  
  return (ErrorStatus)(status);
}
 8007242:	bd38      	pop	{r3, r4, r5, pc}
  {
    /* check if the reference clock detection is disabled */
    if((RTC->CR & RTC_CR_REFCKON) == RESET)
    {
      /* Configure the Shift settings */
      RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
 8007244:	4308      	orrs	r0, r1
 8007246:	62d0      	str	r0, [r2, #44]	; 0x2c
    
      if(RTC_WaitForSynchro() == ERROR)
 8007248:	f7ff fb16 	bl	8006878 <RTC_WaitForSynchro>
 800724c:	1e43      	subs	r3, r0, #1
 800724e:	4198      	sbcs	r0, r3
        status = SUCCESS;
      }
    }
    else
    {
      status = ERROR;
 8007250:	b2c3      	uxtb	r3, r0
 8007252:	e7f2      	b.n	800723a <RTC_SynchroShiftConfig+0x3e>
 8007254:	40002800 	.word	0x40002800

08007258 <RTC_ITConfig>:
  /* Check the parameters */
  assert_param(IS_RTC_CONFIG_IT(RTC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8007258:	22ca      	movs	r2, #202	; 0xca
 800725a:	4b10      	ldr	r3, [pc, #64]	; (800729c <RTC_ITConfig+0x44>)
  * @param  NewState: new state of the specified RTC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
{
 800725c:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_RTC_CONFIG_IT(RTC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800725e:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8007260:	3a77      	subs	r2, #119	; 0x77
 8007262:	625a      	str	r2, [r3, #36]	; 0x24

  if (NewState != DISABLE)
 8007264:	2900      	cmp	r1, #0
 8007266:	d10d      	bne.n	8007284 <RTC_ITConfig+0x2c>
    RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
  }
  else
  {
    /* Configure the Interrupts in the RTC_CR register */
    RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
 8007268:	2104      	movs	r1, #4
 800726a:	1c04      	adds	r4, r0, #0
 800726c:	689a      	ldr	r2, [r3, #8]
 800726e:	438c      	bics	r4, r1
 8007270:	43a2      	bics	r2, r4
 8007272:	609a      	str	r2, [r3, #8]
    /* Configure the Tamper Interrupt in the RTC_TAFCR */
    RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
 8007274:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8007276:	4008      	ands	r0, r1
 8007278:	4382      	bics	r2, r0
 800727a:	641a      	str	r2, [r3, #64]	; 0x40
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800727c:	22ff      	movs	r2, #255	; 0xff
 800727e:	4b07      	ldr	r3, [pc, #28]	; (800729c <RTC_ITConfig+0x44>)
 8007280:	625a      	str	r2, [r3, #36]	; 0x24
}
 8007282:	bd10      	pop	{r4, pc}
  RTC->WPR = 0x53;

  if (NewState != DISABLE)
  {
    /* Configure the Interrupts in the RTC_CR register */
    RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
 8007284:	1c04      	adds	r4, r0, #0
 8007286:	6899      	ldr	r1, [r3, #8]
 8007288:	3a4f      	subs	r2, #79	; 0x4f
 800728a:	4394      	bics	r4, r2
 800728c:	4321      	orrs	r1, r4
 800728e:	6099      	str	r1, [r3, #8]
    /* Configure the Tamper Interrupt in the RTC_TAFCR */
    RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
 8007290:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8007292:	4010      	ands	r0, r2
 8007294:	4308      	orrs	r0, r1
 8007296:	6418      	str	r0, [r3, #64]	; 0x40
 8007298:	e7f0      	b.n	800727c <RTC_ITConfig+0x24>
 800729a:	46c0      	nop			; (mov r8, r8)
 800729c:	40002800 	.word	0x40002800

080072a0 <RTC_GetFlagStatus>:
  
  /* Check the parameters */
  assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
  
  /* Get all the flags */
  tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
 80072a0:	4b04      	ldr	r3, [pc, #16]	; (80072b4 <RTC_GetFlagStatus+0x14>)
 80072a2:	68da      	ldr	r2, [r3, #12]
 80072a4:	4b04      	ldr	r3, [pc, #16]	; (80072b8 <RTC_GetFlagStatus+0x18>)
 80072a6:	4013      	ands	r3, r2
  
  /* Return the status of the flag */
  if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
 80072a8:	4018      	ands	r0, r3
 80072aa:	1e43      	subs	r3, r0, #1
 80072ac:	4198      	sbcs	r0, r3
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 80072ae:	b2c0      	uxtb	r0, r0
}
 80072b0:	4770      	bx	lr
 80072b2:	46c0      	nop			; (mov r8, r8)
 80072b4:	40002800 	.word	0x40002800
 80072b8:	00017978 	.word	0x00017978

080072bc <RTC_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));

  /* Clear the Flags in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0001FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));    
 80072bc:	4b05      	ldr	r3, [pc, #20]	; (80072d4 <RTC_ClearFlag+0x18>)
 80072be:	4906      	ldr	r1, [pc, #24]	; (80072d8 <RTC_ClearFlag+0x1c>)
 80072c0:	4018      	ands	r0, r3
 80072c2:	2380      	movs	r3, #128	; 0x80
 80072c4:	4318      	orrs	r0, r3
 80072c6:	43c0      	mvns	r0, r0
 80072c8:	68ca      	ldr	r2, [r1, #12]
 80072ca:	4013      	ands	r3, r2
 80072cc:	4318      	orrs	r0, r3
 80072ce:	60c8      	str	r0, [r1, #12]
}
 80072d0:	4770      	bx	lr
 80072d2:	46c0      	nop			; (mov r8, r8)
 80072d4:	0001ff7f 	.word	0x0001ff7f
 80072d8:	40002800 	.word	0x40002800

080072dc <RTC_GetITStatus>:
 
  /* Check the parameters */
  assert_param(IS_RTC_GET_IT(RTC_IT));
  
  /* Get the TAMPER Interrupt enable bit and pending bit */
  tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
 80072dc:	490c      	ldr	r1, [pc, #48]	; (8007310 <RTC_GetITStatus+0x34>)
  *            @arg RTC_IT_TAMP1: Tamper1 event interrupt 
  *            @arg RTC_IT_TAMP2: Tamper2 event interrupt 
  * @retval The new state of RTC_IT (SET or RESET).
  */
ITStatus RTC_GetITStatus(uint32_t RTC_IT)
{
 80072de:	b530      	push	{r4, r5, lr}
 
  /* Check the parameters */
  assert_param(IS_RTC_GET_IT(RTC_IT));
  
  /* Get the TAMPER Interrupt enable bit and pending bit */
  tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
 80072e0:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 
  /* Get the Interrupt enable Status */
  enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & ((RTC_IT >> (RTC_IT >> 18)) >> 15)));
 80072e2:	688a      	ldr	r2, [r1, #8]
  
  /* Get the Interrupt pending bit */
  tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
 80072e4:	68cc      	ldr	r4, [r1, #12]
 
  /* Check the parameters */
  assert_param(IS_RTC_GET_IT(RTC_IT));
  
  /* Get the TAMPER Interrupt enable bit and pending bit */
  tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
 80072e6:	2104      	movs	r1, #4
 
  /* Get the Interrupt enable Status */
  enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & ((RTC_IT >> (RTC_IT >> 18)) >> 15)));
 80072e8:	1c05      	adds	r5, r0, #0
 
  /* Check the parameters */
  assert_param(IS_RTC_GET_IT(RTC_IT));
  
  /* Get the TAMPER Interrupt enable bit and pending bit */
  tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
 80072ea:	4019      	ands	r1, r3
 
  /* Get the Interrupt enable Status */
  enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & ((RTC_IT >> (RTC_IT >> 18)) >> 15)));
 80072ec:	0c83      	lsrs	r3, r0, #18
 80072ee:	40dd      	lsrs	r5, r3
 80072f0:	0beb      	lsrs	r3, r5, #15
 80072f2:	4002      	ands	r2, r0
 80072f4:	400b      	ands	r3, r1
 80072f6:	4313      	orrs	r3, r2
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 80072f8:	2200      	movs	r2, #0
  
  /* Get the Interrupt pending bit */
  tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
  
  /* Get the status of the Interrupt */
  if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
 80072fa:	2b00      	cmp	r3, #0
 80072fc:	d006      	beq.n	800730c <RTC_GetITStatus+0x30>
 80072fe:	0424      	lsls	r4, r4, #16
 8007300:	0c24      	lsrs	r4, r4, #16
 
  /* Get the Interrupt enable Status */
  enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & ((RTC_IT >> (RTC_IT >> 18)) >> 15)));
  
  /* Get the Interrupt pending bit */
  tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
 8007302:	0900      	lsrs	r0, r0, #4
  
  /* Get the status of the Interrupt */
  if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
 8007304:	4020      	ands	r0, r4
 8007306:	1e44      	subs	r4, r0, #1
 8007308:	41a0      	sbcs	r0, r4
  {
    bitstatus = SET;
 800730a:	b2c2      	uxtb	r2, r0
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 800730c:	1c10      	adds	r0, r2, #0
 800730e:	bd30      	pop	{r4, r5, pc}
 8007310:	40002800 	.word	0x40002800

08007314 <RTC_ClearITPendingBit>:

  /* Get the RTC_ISR Interrupt pending bits mask */
  tmpreg = (uint32_t)(RTC_IT >> 4);

  /* Clear the interrupt pending bits in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
 8007314:	0300      	lsls	r0, r0, #12
 8007316:	0c00      	lsrs	r0, r0, #16
  *            @arg RTC_IT_TAMP1: Tamper1 event interrupt
  *            @arg RTC_IT_TAMP2: Tamper2 event interrupt
  * @retval None
  */
void RTC_ClearITPendingBit(uint32_t RTC_IT)
{
 8007318:	b510      	push	{r4, lr}

  /* Get the RTC_ISR Interrupt pending bits mask */
  tmpreg = (uint32_t)(RTC_IT >> 4);

  /* Clear the interrupt pending bits in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
 800731a:	1c03      	adds	r3, r0, #0
 800731c:	2480      	movs	r4, #128	; 0x80
 800731e:	4323      	orrs	r3, r4
 8007320:	43d8      	mvns	r0, r3
 8007322:	1c23      	adds	r3, r4, #0
 8007324:	4902      	ldr	r1, [pc, #8]	; (8007330 <RTC_ClearITPendingBit+0x1c>)
 8007326:	68ca      	ldr	r2, [r1, #12]
 8007328:	4013      	ands	r3, r2
 800732a:	4318      	orrs	r0, r3
 800732c:	60c8      	str	r0, [r1, #12]
}
 800732e:	bd10      	pop	{r4, pc}
 8007330:	40002800 	.word	0x40002800

08007334 <SYSCFG_DeInit>:
  * @note   To unlock the configuration, perform a system reset.
  */
void SYSCFG_DeInit(void)
{
  /* Set SYSCFG_CFGR1 register to reset value without affecting MEM_MODE bits */
  SYSCFG->CFGR1 &= SYSCFG_CFGR1_MEM_MODE;
 8007334:	2103      	movs	r1, #3
 8007336:	4b07      	ldr	r3, [pc, #28]	; (8007354 <SYSCFG_DeInit+0x20>)
 8007338:	681a      	ldr	r2, [r3, #0]
 800733a:	400a      	ands	r2, r1
 800733c:	601a      	str	r2, [r3, #0]
  /* Set EXTICRx registers to reset value */
  SYSCFG->EXTICR[0] = 0;
 800733e:	2200      	movs	r2, #0
 8007340:	609a      	str	r2, [r3, #8]
  SYSCFG->EXTICR[1] = 0;
 8007342:	60da      	str	r2, [r3, #12]
  SYSCFG->EXTICR[2] = 0;
 8007344:	611a      	str	r2, [r3, #16]
  SYSCFG->EXTICR[3] = 0;
 8007346:	615a      	str	r2, [r3, #20]
  /* Set CFGR2 register to reset value: clear SRAM parity error flag */
  SYSCFG->CFGR2 |= (uint32_t) SYSCFG_CFGR2_SRAM_PE;
 8007348:	699a      	ldr	r2, [r3, #24]
 800734a:	31fd      	adds	r1, #253	; 0xfd
 800734c:	430a      	orrs	r2, r1
 800734e:	619a      	str	r2, [r3, #24]
}
 8007350:	4770      	bx	lr
 8007352:	46c0      	nop			; (mov r8, r8)
 8007354:	40010000 	.word	0x40010000

08007358 <SYSCFG_MemoryRemapConfig>:

  /* Get CFGR1 register value */
  tmpctrl = SYSCFG->CFGR1;

  /* Clear MEM_MODE bits */
  tmpctrl &= (uint32_t) (~SYSCFG_CFGR1_MEM_MODE);
 8007358:	2103      	movs	r1, #3

  /* Check the parameter */
  assert_param(IS_SYSCFG_MEMORY_REMAP(SYSCFG_MemoryRemap));

  /* Get CFGR1 register value */
  tmpctrl = SYSCFG->CFGR1;
 800735a:	4a03      	ldr	r2, [pc, #12]	; (8007368 <SYSCFG_MemoryRemapConfig+0x10>)
 800735c:	6813      	ldr	r3, [r2, #0]

  /* Clear MEM_MODE bits */
  tmpctrl &= (uint32_t) (~SYSCFG_CFGR1_MEM_MODE);
 800735e:	438b      	bics	r3, r1

  /* Set the new MEM_MODE bits value */
  tmpctrl |= (uint32_t) SYSCFG_MemoryRemap;
 8007360:	4318      	orrs	r0, r3

  /* Set CFGR1 register with the new memory remap configuration */
  SYSCFG->CFGR1 = tmpctrl;
 8007362:	6010      	str	r0, [r2, #0]
}
 8007364:	4770      	bx	lr
 8007366:	46c0      	nop			; (mov r8, r8)
 8007368:	40010000 	.word	0x40010000

0800736c <SYSCFG_DMAChannelRemapConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Remap the DMA channel */
    SYSCFG->CFGR1 |= (uint32_t)SYSCFG_DMARemap;
 800736c:	4a04      	ldr	r2, [pc, #16]	; (8007380 <SYSCFG_DMAChannelRemapConfig+0x14>)
 800736e:	6813      	ldr	r3, [r2, #0]
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_DMA_REMAP(SYSCFG_DMARemap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8007370:	2900      	cmp	r1, #0
 8007372:	d102      	bne.n	800737a <SYSCFG_DMAChannelRemapConfig+0xe>
    SYSCFG->CFGR1 |= (uint32_t)SYSCFG_DMARemap;
  }
  else
  {
    /* use the default DMA channel mapping */
    SYSCFG->CFGR1 &= (uint32_t)(~SYSCFG_DMARemap);
 8007374:	4383      	bics	r3, r0
 8007376:	6013      	str	r3, [r2, #0]
  }
}
 8007378:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Remap the DMA channel */
    SYSCFG->CFGR1 |= (uint32_t)SYSCFG_DMARemap;
 800737a:	4318      	orrs	r0, r3
 800737c:	6010      	str	r0, [r2, #0]
 800737e:	e7fb      	b.n	8007378 <SYSCFG_DMAChannelRemapConfig+0xc>
 8007380:	40010000 	.word	0x40010000

08007384 <SYSCFG_I2CFastModePlusConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable fast mode plus driving capability for selected pin */
    SYSCFG->CFGR1 |= (uint32_t)SYSCFG_I2CFastModePlus;
 8007384:	4a04      	ldr	r2, [pc, #16]	; (8007398 <SYSCFG_I2CFastModePlusConfig+0x14>)
 8007386:	6813      	ldr	r3, [r2, #0]
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_I2C_FMP(SYSCFG_I2CFastModePlus));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8007388:	2900      	cmp	r1, #0
 800738a:	d102      	bne.n	8007392 <SYSCFG_I2CFastModePlusConfig+0xe>
    SYSCFG->CFGR1 |= (uint32_t)SYSCFG_I2CFastModePlus;
  }
  else
  {
    /* Disable fast mode plus driving capability for selected pin */
    SYSCFG->CFGR1 &= (uint32_t)(~SYSCFG_I2CFastModePlus);
 800738c:	4383      	bics	r3, r0
 800738e:	6013      	str	r3, [r2, #0]
  }
}
 8007390:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable fast mode plus driving capability for selected pin */
    SYSCFG->CFGR1 |= (uint32_t)SYSCFG_I2CFastModePlus;
 8007392:	4318      	orrs	r0, r3
 8007394:	6010      	str	r0, [r2, #0]
 8007396:	e7fb      	b.n	8007390 <SYSCFG_I2CFastModePlusConfig+0xc>
 8007398:	40010000 	.word	0x40010000

0800739c <SYSCFG_IRDAEnvSelection>:
void SYSCFG_IRDAEnvSelection(uint32_t SYSCFG_IRDAEnv)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_IRDA_ENV(SYSCFG_IRDAEnv));
  
  SYSCFG->CFGR1 &= ~(SYSCFG_CFGR1_IRDA_ENV_SEL);
 800739c:	21c0      	movs	r1, #192	; 0xc0
 800739e:	4b04      	ldr	r3, [pc, #16]	; (80073b0 <SYSCFG_IRDAEnvSelection+0x14>)
 80073a0:	681a      	ldr	r2, [r3, #0]
 80073a2:	438a      	bics	r2, r1
 80073a4:	601a      	str	r2, [r3, #0]
  SYSCFG->CFGR1 |= (SYSCFG_IRDAEnv);
 80073a6:	681a      	ldr	r2, [r3, #0]
 80073a8:	4310      	orrs	r0, r2
 80073aa:	6018      	str	r0, [r3, #0]
}
 80073ac:	4770      	bx	lr
 80073ae:	46c0      	nop			; (mov r8, r8)
 80073b0:	40010000 	.word	0x40010000

080073b4 <SYSCFG_EXTILineConfig>:

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 80073b4:	2303      	movs	r3, #3
  *         For STM32F072: (0..15) for GPIOA, GPIOB, GPIOC, GPIOD, GPIOE, (0..10) for GPIOF.
  *         For STM32F031: (0..15) for GPIOA, GPIOB, (13..15) for GPIOC and (0..1, 6..7) for GPIOF.
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 80073b6:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 80073b8:	240f      	movs	r4, #15
 80073ba:	400b      	ands	r3, r1
 80073bc:	009b      	lsls	r3, r3, #2
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 80073be:	4098      	lsls	r0, r3
 80073c0:	4a06      	ldr	r2, [pc, #24]	; (80073dc <SYSCFG_EXTILineConfig+0x28>)

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 80073c2:	409c      	lsls	r4, r3
 80073c4:	4694      	mov	ip, r2
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 80073c6:	1c03      	adds	r3, r0, #0
 80073c8:	0889      	lsrs	r1, r1, #2
 80073ca:	0089      	lsls	r1, r1, #2
 80073cc:	4461      	add	r1, ip
  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 80073ce:	688a      	ldr	r2, [r1, #8]
 80073d0:	43a2      	bics	r2, r4
 80073d2:	608a      	str	r2, [r1, #8]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 80073d4:	688a      	ldr	r2, [r1, #8]
 80073d6:	4313      	orrs	r3, r2
 80073d8:	608b      	str	r3, [r1, #8]
}
 80073da:	bd10      	pop	{r4, pc}
 80073dc:	40010000 	.word	0x40010000

080073e0 <SYSCFG_GetPendingIT>:
  * @retval The new state of IT_LINE_SR.
  */
uint32_t  SYSCFG_GetPendingIT(uint32_t ITSourceLine)
{
   assert_param(IS_SYSCFG_ITLINE(ITSourceLine));
   return(SYSCFG->IT_LINE_SR[(ITSourceLine >> 0x18)] & (ITSourceLine & 0x00FFFFFF));
 80073e0:	0e03      	lsrs	r3, r0, #24
 80073e2:	4a04      	ldr	r2, [pc, #16]	; (80073f4 <SYSCFG_GetPendingIT+0x14>)
 80073e4:	3320      	adds	r3, #32
 80073e6:	009b      	lsls	r3, r3, #2
 80073e8:	589b      	ldr	r3, [r3, r2]
 80073ea:	0200      	lsls	r0, r0, #8
 80073ec:	0a00      	lsrs	r0, r0, #8
 80073ee:	4018      	ands	r0, r3
}
 80073f0:	4770      	bx	lr
 80073f2:	46c0      	nop			; (mov r8, r8)
 80073f4:	40010000 	.word	0x40010000

080073f8 <SYSCFG_BreakConfig>:
void SYSCFG_BreakConfig(uint32_t SYSCFG_Break)
{
  /* Check the parameter */
  assert_param(IS_SYSCFG_LOCK_CONFIG(SYSCFG_Break));

  SYSCFG->CFGR2 |= (uint32_t) SYSCFG_Break;
 80073f8:	4a02      	ldr	r2, [pc, #8]	; (8007404 <SYSCFG_BreakConfig+0xc>)
 80073fa:	6993      	ldr	r3, [r2, #24]
 80073fc:	4318      	orrs	r0, r3
 80073fe:	6190      	str	r0, [r2, #24]
}
 8007400:	4770      	bx	lr
 8007402:	46c0      	nop			; (mov r8, r8)
 8007404:	40010000 	.word	0x40010000

08007408 <SYSCFG_GetFlagStatus>:

  /* Check the parameter */
  assert_param(IS_SYSCFG_FLAG(SYSCFG_Flag));

  /* Check the status of the specified SPI flag */
  if ((SYSCFG->CFGR2 & SYSCFG_CFGR2_SRAM_PE) != (uint32_t)RESET)
 8007408:	4b02      	ldr	r3, [pc, #8]	; (8007414 <SYSCFG_GetFlagStatus+0xc>)
 800740a:	6998      	ldr	r0, [r3, #24]
 800740c:	05c0      	lsls	r0, r0, #23
  {
    /* SYSCFG_Flag is reset */
    bitstatus = RESET;
  }
  /* Return the SYSCFG_Flag status */
  return  bitstatus;
 800740e:	0fc0      	lsrs	r0, r0, #31
}
 8007410:	4770      	bx	lr
 8007412:	46c0      	nop			; (mov r8, r8)
 8007414:	40010000 	.word	0x40010000

08007418 <SYSCFG_ClearFlag>:
void SYSCFG_ClearFlag(uint32_t SYSCFG_Flag)
{
  /* Check the parameter */
  assert_param(IS_SYSCFG_FLAG(SYSCFG_Flag));

  SYSCFG->CFGR2 |= (uint32_t) SYSCFG_Flag;
 8007418:	4a02      	ldr	r2, [pc, #8]	; (8007424 <SYSCFG_ClearFlag+0xc>)
 800741a:	6993      	ldr	r3, [r2, #24]
 800741c:	4318      	orrs	r0, r3
 800741e:	6190      	str	r0, [r2, #24]
}
 8007420:	4770      	bx	lr
 8007422:	46c0      	nop			; (mov r8, r8)
 8007424:	40010000 	.word	0x40010000

08007428 <TIM_DeInit>:
  * @note   TIM2 is not applicable for STM32F030 devices.    
  * @retval None
  *   
  */
void TIM_DeInit(TIM_TypeDef* TIMx)
{
 8007428:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 

  if (TIMx == TIM1)
 800742a:	4b3c      	ldr	r3, [pc, #240]	; (800751c <TIM_DeInit+0xf4>)
 800742c:	4298      	cmp	r0, r3
 800742e:	d024      	beq.n	800747a <TIM_DeInit+0x52>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
  }     
  else if (TIMx == TIM2)
 8007430:	2380      	movs	r3, #128	; 0x80
 8007432:	05db      	lsls	r3, r3, #23
 8007434:	4298      	cmp	r0, r3
 8007436:	d02b      	beq.n	8007490 <TIM_DeInit+0x68>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
  }
  else if (TIMx == TIM3)
 8007438:	4b39      	ldr	r3, [pc, #228]	; (8007520 <TIM_DeInit+0xf8>)
 800743a:	4298      	cmp	r0, r3
 800743c:	d031      	beq.n	80074a2 <TIM_DeInit+0x7a>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
  }
  else if (TIMx == TIM6)
 800743e:	4b39      	ldr	r3, [pc, #228]	; (8007524 <TIM_DeInit+0xfc>)
 8007440:	4298      	cmp	r0, r3
 8007442:	d037      	beq.n	80074b4 <TIM_DeInit+0x8c>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
  } 
  else if (TIMx == TIM7)
 8007444:	4b38      	ldr	r3, [pc, #224]	; (8007528 <TIM_DeInit+0x100>)
 8007446:	4298      	cmp	r0, r3
 8007448:	d03d      	beq.n	80074c6 <TIM_DeInit+0x9e>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
  }
  else if (TIMx == TIM14) 
 800744a:	4b38      	ldr	r3, [pc, #224]	; (800752c <TIM_DeInit+0x104>)
 800744c:	4298      	cmp	r0, r3
 800744e:	d043      	beq.n	80074d8 <TIM_DeInit+0xb0>
  {       
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);  
  }        
  else if (TIMx == TIM15)
 8007450:	4b37      	ldr	r3, [pc, #220]	; (8007530 <TIM_DeInit+0x108>)
 8007452:	4298      	cmp	r0, r3
 8007454:	d04b      	beq.n	80074ee <TIM_DeInit+0xc6>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
  } 
  else if (TIMx == TIM16)
 8007456:	4b37      	ldr	r3, [pc, #220]	; (8007534 <TIM_DeInit+0x10c>)
 8007458:	4298      	cmp	r0, r3
 800745a:	d053      	beq.n	8007504 <TIM_DeInit+0xdc>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
  } 
  else
  {
    if (TIMx == TIM17)
 800745c:	4b36      	ldr	r3, [pc, #216]	; (8007538 <TIM_DeInit+0x110>)
 800745e:	4298      	cmp	r0, r3
 8007460:	d000      	beq.n	8007464 <TIM_DeInit+0x3c>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
    }  
  }
     
}
 8007462:	bd08      	pop	{r3, pc}
  } 
  else
  {
    if (TIMx == TIM17)
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
 8007464:	2080      	movs	r0, #128	; 0x80
 8007466:	2101      	movs	r1, #1
 8007468:	02c0      	lsls	r0, r0, #11
 800746a:	f7ff f929 	bl	80066c0 <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
 800746e:	2080      	movs	r0, #128	; 0x80
 8007470:	2100      	movs	r1, #0
 8007472:	02c0      	lsls	r0, r0, #11
 8007474:	f7ff f924 	bl	80066c0 <RCC_APB2PeriphResetCmd>
 8007478:	e7f3      	b.n	8007462 <TIM_DeInit+0x3a>
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 

  if (TIMx == TIM1)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
 800747a:	2080      	movs	r0, #128	; 0x80
 800747c:	2101      	movs	r1, #1
 800747e:	0100      	lsls	r0, r0, #4
 8007480:	f7ff f91e 	bl	80066c0 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
 8007484:	2080      	movs	r0, #128	; 0x80
 8007486:	2100      	movs	r1, #0
 8007488:	0100      	lsls	r0, r0, #4
 800748a:	f7ff f919 	bl	80066c0 <RCC_APB2PeriphResetCmd>
 800748e:	e7e8      	b.n	8007462 <TIM_DeInit+0x3a>
  }     
  else if (TIMx == TIM2)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
 8007490:	2001      	movs	r0, #1
 8007492:	2101      	movs	r1, #1
 8007494:	f7ff f920 	bl	80066d8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
 8007498:	2001      	movs	r0, #1
 800749a:	2100      	movs	r1, #0
 800749c:	f7ff f91c 	bl	80066d8 <RCC_APB1PeriphResetCmd>
 80074a0:	e7df      	b.n	8007462 <TIM_DeInit+0x3a>
  }
  else if (TIMx == TIM3)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
 80074a2:	2002      	movs	r0, #2
 80074a4:	2101      	movs	r1, #1
 80074a6:	f7ff f917 	bl	80066d8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
 80074aa:	2002      	movs	r0, #2
 80074ac:	2100      	movs	r1, #0
 80074ae:	f7ff f913 	bl	80066d8 <RCC_APB1PeriphResetCmd>
 80074b2:	e7d6      	b.n	8007462 <TIM_DeInit+0x3a>
  }
  else if (TIMx == TIM6)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
 80074b4:	2010      	movs	r0, #16
 80074b6:	2101      	movs	r1, #1
 80074b8:	f7ff f90e 	bl	80066d8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
 80074bc:	2010      	movs	r0, #16
 80074be:	2100      	movs	r1, #0
 80074c0:	f7ff f90a 	bl	80066d8 <RCC_APB1PeriphResetCmd>
 80074c4:	e7cd      	b.n	8007462 <TIM_DeInit+0x3a>
  } 
  else if (TIMx == TIM7)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
 80074c6:	2020      	movs	r0, #32
 80074c8:	2101      	movs	r1, #1
 80074ca:	f7ff f905 	bl	80066d8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
 80074ce:	2020      	movs	r0, #32
 80074d0:	2100      	movs	r1, #0
 80074d2:	f7ff f901 	bl	80066d8 <RCC_APB1PeriphResetCmd>
 80074d6:	e7c4      	b.n	8007462 <TIM_DeInit+0x3a>
  }
  else if (TIMx == TIM14) 
  {       
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
 80074d8:	2080      	movs	r0, #128	; 0x80
 80074da:	2101      	movs	r1, #1
 80074dc:	0040      	lsls	r0, r0, #1
 80074de:	f7ff f8fb 	bl	80066d8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);  
 80074e2:	2080      	movs	r0, #128	; 0x80
 80074e4:	2100      	movs	r1, #0
 80074e6:	0040      	lsls	r0, r0, #1
 80074e8:	f7ff f8f6 	bl	80066d8 <RCC_APB1PeriphResetCmd>
 80074ec:	e7b9      	b.n	8007462 <TIM_DeInit+0x3a>
  }        
  else if (TIMx == TIM15)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
 80074ee:	2080      	movs	r0, #128	; 0x80
 80074f0:	2101      	movs	r1, #1
 80074f2:	0240      	lsls	r0, r0, #9
 80074f4:	f7ff f8e4 	bl	80066c0 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
 80074f8:	2080      	movs	r0, #128	; 0x80
 80074fa:	2100      	movs	r1, #0
 80074fc:	0240      	lsls	r0, r0, #9
 80074fe:	f7ff f8df 	bl	80066c0 <RCC_APB2PeriphResetCmd>
 8007502:	e7ae      	b.n	8007462 <TIM_DeInit+0x3a>
  } 
  else if (TIMx == TIM16)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
 8007504:	2080      	movs	r0, #128	; 0x80
 8007506:	2101      	movs	r1, #1
 8007508:	0280      	lsls	r0, r0, #10
 800750a:	f7ff f8d9 	bl	80066c0 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
 800750e:	2080      	movs	r0, #128	; 0x80
 8007510:	2100      	movs	r1, #0
 8007512:	0280      	lsls	r0, r0, #10
 8007514:	f7ff f8d4 	bl	80066c0 <RCC_APB2PeriphResetCmd>
 8007518:	e7a3      	b.n	8007462 <TIM_DeInit+0x3a>
 800751a:	46c0      	nop			; (mov r8, r8)
 800751c:	40012c00 	.word	0x40012c00
 8007520:	40000400 	.word	0x40000400
 8007524:	40001000 	.word	0x40001000
 8007528:	40001400 	.word	0x40001400
 800752c:	40002000 	.word	0x40002000
 8007530:	40014000 	.word	0x40014000
 8007534:	40014400 	.word	0x40014400
 8007538:	40014800 	.word	0x40014800

0800753c <TIM_TimeBaseInit>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 800753c:	8803      	ldrh	r3, [r0, #0]

  if((TIMx == TIM1) || (TIMx == TIM2) || (TIMx == TIM3))
 800753e:	4a1f      	ldr	r2, [pc, #124]	; (80075bc <TIM_TimeBaseInit+0x80>)
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8007540:	b29b      	uxth	r3, r3

  if((TIMx == TIM1) || (TIMx == TIM2) || (TIMx == TIM3))
 8007542:	4290      	cmp	r0, r2
 8007544:	d01e      	beq.n	8007584 <TIM_TimeBaseInit+0x48>
 8007546:	2280      	movs	r2, #128	; 0x80
 8007548:	05d2      	lsls	r2, r2, #23
 800754a:	4290      	cmp	r0, r2
 800754c:	d02a      	beq.n	80075a4 <TIM_TimeBaseInit+0x68>
 800754e:	4a1c      	ldr	r2, [pc, #112]	; (80075c0 <TIM_TimeBaseInit+0x84>)
 8007550:	4290      	cmp	r0, r2
 8007552:	d027      	beq.n	80075a4 <TIM_TimeBaseInit+0x68>
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
  }
 
  if(TIMx != TIM6)
 8007554:	4a1b      	ldr	r2, [pc, #108]	; (80075c4 <TIM_TimeBaseInit+0x88>)
 8007556:	4290      	cmp	r0, r2
 8007558:	d029      	beq.n	80075ae <TIM_TimeBaseInit+0x72>
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 800755a:	4a1b      	ldr	r2, [pc, #108]	; (80075c8 <TIM_TimeBaseInit+0x8c>)
 800755c:	4013      	ands	r3, r2
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 800755e:	890a      	ldrh	r2, [r1, #8]
 8007560:	4313      	orrs	r3, r2
  }

  TIMx->CR1 = tmpcr1;
 8007562:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 8007564:	684b      	ldr	r3, [r1, #4]
 8007566:	62c3      	str	r3, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8007568:	880b      	ldrh	r3, [r1, #0]
 800756a:	8503      	strh	r3, [r0, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
 800756c:	4b17      	ldr	r3, [pc, #92]	; (80075cc <TIM_TimeBaseInit+0x90>)
 800756e:	4298      	cmp	r0, r3
 8007570:	d015      	beq.n	800759e <TIM_TimeBaseInit+0x62>
 8007572:	4b17      	ldr	r3, [pc, #92]	; (80075d0 <TIM_TimeBaseInit+0x94>)
 8007574:	4298      	cmp	r0, r3
 8007576:	d012      	beq.n	800759e <TIM_TimeBaseInit+0x62>
 8007578:	4b16      	ldr	r3, [pc, #88]	; (80075d4 <TIM_TimeBaseInit+0x98>)
 800757a:	4298      	cmp	r0, r3
 800757c:	d00f      	beq.n	800759e <TIM_TimeBaseInit+0x62>
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler and the Repetition counter
     values immediately */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;           
 800757e:	2301      	movs	r3, #1
 8007580:	8283      	strh	r3, [r0, #20]
}
 8007582:	4770      	bx	lr
  tmpcr1 = TIMx->CR1;  

  if((TIMx == TIM1) || (TIMx == TIM2) || (TIMx == TIM3))
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
 8007584:	2270      	movs	r2, #112	; 0x70
 8007586:	4393      	bics	r3, r2
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8007588:	884a      	ldrh	r2, [r1, #2]
 800758a:	4313      	orrs	r3, r2
  }
 
  if(TIMx != TIM6)
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 800758c:	4a0e      	ldr	r2, [pc, #56]	; (80075c8 <TIM_TimeBaseInit+0x8c>)
 800758e:	4013      	ands	r3, r2
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8007590:	890a      	ldrh	r2, [r1, #8]
 8007592:	4313      	orrs	r3, r2
  }

  TIMx->CR1 = tmpcr1;
 8007594:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 8007596:	684b      	ldr	r3, [r1, #4]
 8007598:	62c3      	str	r3, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 800759a:	880b      	ldrh	r3, [r1, #0]
 800759c:	8503      	strh	r3, [r0, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 800759e:	7a8b      	ldrb	r3, [r1, #10]
 80075a0:	8603      	strh	r3, [r0, #48]	; 0x30
 80075a2:	e7ec      	b.n	800757e <TIM_TimeBaseInit+0x42>
  tmpcr1 = TIMx->CR1;  

  if((TIMx == TIM1) || (TIMx == TIM2) || (TIMx == TIM3))
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
 80075a4:	2270      	movs	r2, #112	; 0x70
 80075a6:	4393      	bics	r3, r2
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 80075a8:	884a      	ldrh	r2, [r1, #2]
 80075aa:	4313      	orrs	r3, r2
 80075ac:	e7d5      	b.n	800755a <TIM_TimeBaseInit+0x1e>
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
  }

  TIMx->CR1 = tmpcr1;
 80075ae:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 80075b0:	684b      	ldr	r3, [r1, #4]
 80075b2:	62c3      	str	r3, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 80075b4:	880b      	ldrh	r3, [r1, #0]
 80075b6:	8503      	strh	r3, [r0, #40]	; 0x28
 80075b8:	e7e1      	b.n	800757e <TIM_TimeBaseInit+0x42>
 80075ba:	46c0      	nop			; (mov r8, r8)
 80075bc:	40012c00 	.word	0x40012c00
 80075c0:	40000400 	.word	0x40000400
 80075c4:	40001000 	.word	0x40001000
 80075c8:	fffffcff 	.word	0xfffffcff
 80075cc:	40014000 	.word	0x40014000
 80075d0:	40014400 	.word	0x40014400
 80075d4:	40014800 	.word	0x40014800

080075d8 <TIM_TimeBaseStructInit>:
  * @retval None
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
 80075d8:	2301      	movs	r3, #1
 80075da:	425b      	negs	r3, r3
 80075dc:	6043      	str	r3, [r0, #4]
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 80075de:	2300      	movs	r3, #0
 80075e0:	8003      	strh	r3, [r0, #0]
  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
 80075e2:	8103      	strh	r3, [r0, #8]
  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
 80075e4:	8043      	strh	r3, [r0, #2]
  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
 80075e6:	7283      	strb	r3, [r0, #10]
}
 80075e8:	4770      	bx	lr
 80075ea:	46c0      	nop			; (mov r8, r8)

080075ec <TIM_PrescalerConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
  
  /* Set the Prescaler value */
  TIMx->PSC = Prescaler;
 80075ec:	8501      	strh	r1, [r0, #40]	; 0x28
  /* Set or reset the UG Bit */
  TIMx->EGR = TIM_PSCReloadMode;
 80075ee:	8282      	strh	r2, [r0, #20]
}
 80075f0:	4770      	bx	lr
 80075f2:	46c0      	nop			; (mov r8, r8)

080075f4 <TIM_CounterModeConfig>:
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
  
  tmpcr1 = TIMx->CR1;
  /* Reset the CMS and DIR Bits */
  tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
 80075f4:	2270      	movs	r2, #112	; 0x70
  
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
  
  tmpcr1 = TIMx->CR1;
 80075f6:	8803      	ldrh	r3, [r0, #0]
  /* Reset the CMS and DIR Bits */
  tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
 80075f8:	4393      	bics	r3, r2
  /* Set the Counter Mode */
  tmpcr1 |= TIM_CounterMode;
 80075fa:	4319      	orrs	r1, r3
  /* Write to TIMx CR1 register */
  TIMx->CR1 = tmpcr1;
 80075fc:	8001      	strh	r1, [r0, #0]
}
 80075fe:	4770      	bx	lr

08007600 <TIM_SetCounter>:
{
  /* Check the parameters */
   assert_param(IS_TIM_ALL_PERIPH(TIMx));
   
  /* Set the Counter Register value */
  TIMx->CNT = Counter;
 8007600:	6241      	str	r1, [r0, #36]	; 0x24
}
 8007602:	4770      	bx	lr

08007604 <TIM_SetAutoreload>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  
  /* Set the Autoreload Register value */
  TIMx->ARR = Autoreload;
 8007604:	62c1      	str	r1, [r0, #44]	; 0x2c
}
 8007606:	4770      	bx	lr

08007608 <TIM_GetCounter>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  
  /* Get the Counter Register value */
  return TIMx->CNT;
 8007608:	6a40      	ldr	r0, [r0, #36]	; 0x24
}
 800760a:	4770      	bx	lr

0800760c <TIM_GetPrescaler>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  
  /* Get the Prescaler Register value */
  return TIMx->PSC;
 800760c:	8d00      	ldrh	r0, [r0, #40]	; 0x28
 800760e:	b280      	uxth	r0, r0
}
 8007610:	4770      	bx	lr
 8007612:	46c0      	nop			; (mov r8, r8)

08007614 <TIM_UpdateDisableConfig>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8007614:	2900      	cmp	r1, #0
 8007616:	d104      	bne.n	8007622 <TIM_UpdateDisableConfig+0xe>
    TIMx->CR1 |= TIM_CR1_UDIS;
  }
  else
  {
    /* Reset the Update Disable Bit */
    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
 8007618:	2202      	movs	r2, #2
 800761a:	8803      	ldrh	r3, [r0, #0]
 800761c:	4393      	bics	r3, r2
 800761e:	8003      	strh	r3, [r0, #0]
  }
}
 8007620:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
 8007622:	2302      	movs	r3, #2
 8007624:	8802      	ldrh	r2, [r0, #0]
 8007626:	4313      	orrs	r3, r2
 8007628:	8003      	strh	r3, [r0, #0]
 800762a:	e7f9      	b.n	8007620 <TIM_UpdateDisableConfig+0xc>

0800762c <TIM_UpdateRequestConfig>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
  
  if (TIM_UpdateSource != TIM_UpdateSource_Global)
 800762c:	2900      	cmp	r1, #0
 800762e:	d104      	bne.n	800763a <TIM_UpdateRequestConfig+0xe>
    TIMx->CR1 |= TIM_CR1_URS;
  }
  else
  {
    /* Reset the URS Bit */
    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
 8007630:	2204      	movs	r2, #4
 8007632:	8803      	ldrh	r3, [r0, #0]
 8007634:	4393      	bics	r3, r2
 8007636:	8003      	strh	r3, [r0, #0]
  }
}
 8007638:	4770      	bx	lr
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
  
  if (TIM_UpdateSource != TIM_UpdateSource_Global)
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
 800763a:	2304      	movs	r3, #4
 800763c:	8802      	ldrh	r2, [r0, #0]
 800763e:	4313      	orrs	r3, r2
 8007640:	8003      	strh	r3, [r0, #0]
 8007642:	e7f9      	b.n	8007638 <TIM_UpdateRequestConfig+0xc>

08007644 <TIM_ARRPreloadConfig>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8007644:	2900      	cmp	r1, #0
 8007646:	d104      	bne.n	8007652 <TIM_ARRPreloadConfig+0xe>
    TIMx->CR1 |= TIM_CR1_ARPE;
  }
  else
  {
    /* Reset the ARR Preload Bit */
    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
 8007648:	2280      	movs	r2, #128	; 0x80
 800764a:	8803      	ldrh	r3, [r0, #0]
 800764c:	4393      	bics	r3, r2
 800764e:	8003      	strh	r3, [r0, #0]
  }
}
 8007650:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 8007652:	2380      	movs	r3, #128	; 0x80
 8007654:	8802      	ldrh	r2, [r0, #0]
 8007656:	4313      	orrs	r3, r2
 8007658:	8003      	strh	r3, [r0, #0]
 800765a:	e7f9      	b.n	8007650 <TIM_ARRPreloadConfig+0xc>

0800765c <TIM_SelectOnePulseMode>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
  
  /* Reset the OPM Bit */
  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
 800765c:	2208      	movs	r2, #8
 800765e:	8803      	ldrh	r3, [r0, #0]
 8007660:	4393      	bics	r3, r2
 8007662:	8003      	strh	r3, [r0, #0]
  /* Configure the OPM Mode */
  TIMx->CR1 |= TIM_OPMode;
 8007664:	8803      	ldrh	r3, [r0, #0]
 8007666:	4319      	orrs	r1, r3
 8007668:	8001      	strh	r1, [r0, #0]
}
 800766a:	4770      	bx	lr

0800766c <TIM_SetClockDivision>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_CKD_DIV(TIM_CKD));
  
  /* Reset the CKD Bits */
  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
 800766c:	8802      	ldrh	r2, [r0, #0]
 800766e:	4b03      	ldr	r3, [pc, #12]	; (800767c <TIM_SetClockDivision+0x10>)
 8007670:	4013      	ands	r3, r2
 8007672:	8003      	strh	r3, [r0, #0]
  /* Set the CKD value */
  TIMx->CR1 |= TIM_CKD;
 8007674:	8803      	ldrh	r3, [r0, #0]
 8007676:	4319      	orrs	r1, r3
 8007678:	8001      	strh	r1, [r0, #0]
}
 800767a:	4770      	bx	lr
 800767c:	fffffcff 	.word	0xfffffcff

08007680 <TIM_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8007680:	2900      	cmp	r1, #0
 8007682:	d104      	bne.n	800768e <TIM_Cmd+0xe>
    TIMx->CR1 |= TIM_CR1_CEN;
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
 8007684:	2201      	movs	r2, #1
 8007686:	8803      	ldrh	r3, [r0, #0]
 8007688:	4393      	bics	r3, r2
 800768a:	8003      	strh	r3, [r0, #0]
  }
}
 800768c:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 800768e:	2301      	movs	r3, #1
 8007690:	8802      	ldrh	r2, [r0, #0]
 8007692:	4313      	orrs	r3, r2
 8007694:	8003      	strh	r3, [r0, #0]
 8007696:	e7f9      	b.n	800768c <TIM_Cmd+0xc>

08007698 <TIM_BDTRConfig>:
  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 8007698:	884a      	ldrh	r2, [r1, #2]
 800769a:	880b      	ldrh	r3, [r1, #0]
 800769c:	4313      	orrs	r3, r2
 800769e:	888a      	ldrh	r2, [r1, #4]
 80076a0:	4313      	orrs	r3, r2
 80076a2:	88ca      	ldrh	r2, [r1, #6]
 80076a4:	4313      	orrs	r3, r2
 80076a6:	890a      	ldrh	r2, [r1, #8]
 80076a8:	4313      	orrs	r3, r2
 80076aa:	894a      	ldrh	r2, [r1, #10]
 80076ac:	4313      	orrs	r3, r2
 80076ae:	898a      	ldrh	r2, [r1, #12]
 80076b0:	4313      	orrs	r3, r2
 80076b2:	2244      	movs	r2, #68	; 0x44
 80076b4:	5283      	strh	r3, [r0, r2]
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
             TIM_BDTRInitStruct->TIM_AutomaticOutput;
}
 80076b6:	4770      	bx	lr

080076b8 <TIM_BDTRStructInit>:
  * @retval None
  */
void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
{
  /* Set the default configuration */
  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
 80076b8:	2300      	movs	r3, #0
 80076ba:	8003      	strh	r3, [r0, #0]
  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
 80076bc:	8043      	strh	r3, [r0, #2]
  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
 80076be:	8083      	strh	r3, [r0, #4]
  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
 80076c0:	80c3      	strh	r3, [r0, #6]
  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
 80076c2:	8103      	strh	r3, [r0, #8]
  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
 80076c4:	8143      	strh	r3, [r0, #10]
  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
 80076c6:	8183      	strh	r3, [r0, #12]
}
 80076c8:	4770      	bx	lr
 80076ca:	46c0      	nop			; (mov r8, r8)

080076cc <TIM_CtrlPWMOutputs>:
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 80076cc:	2244      	movs	r2, #68	; 0x44
void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80076ce:	2900      	cmp	r1, #0
 80076d0:	d104      	bne.n	80076dc <TIM_CtrlPWMOutputs+0x10>
    TIMx->BDTR |= TIM_BDTR_MOE;
  }
  else
  {
    /* Disable the TIM Main Output */
    TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
 80076d2:	5a83      	ldrh	r3, [r0, r2]
 80076d4:	045b      	lsls	r3, r3, #17
 80076d6:	0c5b      	lsrs	r3, r3, #17
 80076d8:	5283      	strh	r3, [r0, r2]
  }  
}
 80076da:	4770      	bx	lr
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 80076dc:	2380      	movs	r3, #128	; 0x80
 80076de:	5a81      	ldrh	r1, [r0, r2]
 80076e0:	021b      	lsls	r3, r3, #8
 80076e2:	430b      	orrs	r3, r1
 80076e4:	5283      	strh	r3, [r0, r2]
 80076e6:	e7f8      	b.n	80076da <TIM_CtrlPWMOutputs+0xe>

080076e8 <TIM_OC1Init>:
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
 /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
 80076e8:	2201      	movs	r2, #1
 80076ea:	8c03      	ldrh	r3, [r0, #32]
  *         that contains the configuration information for the specified TIM 
  *         peripheral.
  * @retval None
  */
void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 80076ec:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
 /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
 80076ee:	4393      	bics	r3, r2
 80076f0:	8403      	strh	r3, [r0, #32]
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80076f2:	8c03      	ldrh	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80076f4:	8884      	ldrh	r4, [r0, #4]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 80076f6:	8b05      	ldrh	r5, [r0, #24]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
 80076f8:	3272      	adds	r2, #114	; 0x72
 80076fa:	4395      	bics	r5, r2

  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 80076fc:	880a      	ldrh	r2, [r1, #0]
 /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80076fe:	b2a4      	uxth	r4, r4
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));

  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8007700:	4315      	orrs	r5, r2
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
 8007702:	2202      	movs	r2, #2
 8007704:	4393      	bics	r3, r2
 8007706:	1c1e      	adds	r6, r3, #0
 8007708:	898a      	ldrh	r2, [r1, #12]
 800770a:	884b      	ldrh	r3, [r1, #2]
 800770c:	4313      	orrs	r3, r2
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
    
  if((TIMx == TIM1) || (TIMx == TIM15) || (TIMx == TIM16) || (TIMx == TIM17))
 800770e:	4a11      	ldr	r2, [pc, #68]	; (8007754 <TIM_OC1Init+0x6c>)
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
 8007710:	4333      	orrs	r3, r6
    
  if((TIMx == TIM1) || (TIMx == TIM15) || (TIMx == TIM16) || (TIMx == TIM17))
 8007712:	4290      	cmp	r0, r2
 8007714:	d00e      	beq.n	8007734 <TIM_OC1Init+0x4c>
 8007716:	4a10      	ldr	r2, [pc, #64]	; (8007758 <TIM_OC1Init+0x70>)
 8007718:	4290      	cmp	r0, r2
 800771a:	d00b      	beq.n	8007734 <TIM_OC1Init+0x4c>
 800771c:	4a0f      	ldr	r2, [pc, #60]	; (800775c <TIM_OC1Init+0x74>)
 800771e:	4290      	cmp	r0, r2
 8007720:	d008      	beq.n	8007734 <TIM_OC1Init+0x4c>
 8007722:	4a0f      	ldr	r2, [pc, #60]	; (8007760 <TIM_OC1Init+0x78>)
 8007724:	4290      	cmp	r0, r2
 8007726:	d005      	beq.n	8007734 <TIM_OC1Init+0x4c>
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
 8007728:	688a      	ldr	r2, [r1, #8]
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800772a:	8084      	strh	r4, [r0, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800772c:	8305      	strh	r5, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
 800772e:	6342      	str	r2, [r0, #52]	; 0x34
 
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8007730:	8403      	strh	r3, [r0, #32]
}
 8007732:	bd70      	pop	{r4, r5, r6, pc}
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
 8007734:	2208      	movs	r2, #8
 8007736:	4393      	bics	r3, r2
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 8007738:	89ca      	ldrh	r2, [r1, #14]
 800773a:	8a4e      	ldrh	r6, [r1, #18]
 800773c:	4313      	orrs	r3, r2
    
    /* Reset the Output N State */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
 800773e:	2204      	movs	r2, #4
 8007740:	4393      	bics	r3, r2
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 8007742:	888a      	ldrh	r2, [r1, #4]
 8007744:	4313      	orrs	r3, r2
    
    /* Reset the Ouput Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
 8007746:	4a07      	ldr	r2, [pc, #28]	; (8007764 <TIM_OC1Init+0x7c>)
 8007748:	4014      	ands	r4, r2
 800774a:	8a0a      	ldrh	r2, [r1, #16]
 800774c:	4332      	orrs	r2, r6
    
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
 800774e:	4314      	orrs	r4, r2
 8007750:	e7ea      	b.n	8007728 <TIM_OC1Init+0x40>
 8007752:	46c0      	nop			; (mov r8, r8)
 8007754:	40012c00 	.word	0x40012c00
 8007758:	40014000 	.word	0x40014000
 800775c:	40014400 	.word	0x40014400
 8007760:	40014800 	.word	0x40014800
 8007764:	fffffcff 	.word	0xfffffcff

08007768 <TIM_OC2Init>:
  assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
   /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
 8007768:	2210      	movs	r2, #16
 800776a:	8c03      	ldrh	r3, [r0, #32]
  *         that contains the configuration information for the specified TIM 
  *         peripheral.
  * @retval None
  */
void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 800776c:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
   /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
 800776e:	4393      	bics	r3, r2
 8007770:	8403      	strh	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
 8007772:	8c02      	ldrh	r2, [r0, #32]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
 8007774:	4b1e      	ldr	r3, [pc, #120]	; (80077f0 <TIM_OC2Init+0x88>)
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8007776:	8885      	ldrh	r5, [r0, #4]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8007778:	8b04      	ldrh	r4, [r0, #24]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 800777a:	880e      	ldrh	r6, [r1, #0]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
 800777c:	401c      	ands	r4, r3
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
 800777e:	2320      	movs	r3, #32
 8007780:	439a      	bics	r2, r3
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
 8007782:	898b      	ldrh	r3, [r1, #12]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8007784:	0236      	lsls	r6, r6, #8
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
 8007786:	011b      	lsls	r3, r3, #4
 8007788:	431a      	orrs	r2, r3
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
 800778a:	884b      	ldrh	r3, [r1, #2]
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
 800778c:	b292      	uxth	r2, r2
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
 800778e:	011b      	lsls	r3, r3, #4
 8007790:	431a      	orrs	r2, r3
 8007792:	b293      	uxth	r3, r2
    
  if((TIMx == TIM1) || (TIMx == TIM15))
 8007794:	4a17      	ldr	r2, [pc, #92]	; (80077f4 <TIM_OC2Init+0x8c>)
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8007796:	4334      	orrs	r4, r6
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8007798:	b2ad      	uxth	r5, r5
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 800779a:	b2a4      	uxth	r4, r4
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
    
  if((TIMx == TIM1) || (TIMx == TIM15))
 800779c:	4290      	cmp	r0, r2
 800779e:	d00f      	beq.n	80077c0 <TIM_OC2Init+0x58>
 80077a0:	4a15      	ldr	r2, [pc, #84]	; (80077f8 <TIM_OC2Init+0x90>)
 80077a2:	4290      	cmp	r0, r2
 80077a4:	d005      	beq.n	80077b2 <TIM_OC2Init+0x4a>
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 80077a6:	688a      	ldr	r2, [r1, #8]
      /* Set the Output N Idle state */
      tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
    }
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80077a8:	8085      	strh	r5, [r0, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 80077aa:	8304      	strh	r4, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 80077ac:	6382      	str	r2, [r0, #56]	; 0x38
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80077ae:	8403      	strh	r3, [r0, #32]
}
 80077b0:	bd70      	pop	{r4, r5, r6, pc}
  {
    /* Check the parameters */
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Ouput Compare State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
 80077b2:	4a12      	ldr	r2, [pc, #72]	; (80077fc <TIM_OC2Init+0x94>)
 80077b4:	4015      	ands	r5, r2
    
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
 80077b6:	8a0a      	ldrh	r2, [r1, #16]
 80077b8:	0092      	lsls	r2, r2, #2
 80077ba:	4315      	orrs	r5, r2
 80077bc:	b2ad      	uxth	r5, r5
 80077be:	e7f2      	b.n	80077a6 <TIM_OC2Init+0x3e>
  {
    /* Check the parameters */
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Ouput Compare State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
 80077c0:	4a0e      	ldr	r2, [pc, #56]	; (80077fc <TIM_OC2Init+0x94>)
 80077c2:	4015      	ands	r5, r2
    
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
 80077c4:	8a0a      	ldrh	r2, [r1, #16]
 80077c6:	0092      	lsls	r2, r2, #2
 80077c8:	4315      	orrs	r5, r2
      assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
      assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
      assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
      
      /* Reset the Output N Polarity level */
      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
 80077ca:	2280      	movs	r2, #128	; 0x80
 80077cc:	4393      	bics	r3, r2
      /* Set the Output N Polarity */
      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
 80077ce:	89ca      	ldrh	r2, [r1, #14]
 80077d0:	0112      	lsls	r2, r2, #4
 80077d2:	4313      	orrs	r3, r2
      
      /* Reset the Output N State */
      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
 80077d4:	4a0a      	ldr	r2, [pc, #40]	; (8007800 <TIM_OC2Init+0x98>)
 80077d6:	4013      	ands	r3, r2
      /* Set the Output N State */
      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
 80077d8:	888a      	ldrh	r2, [r1, #4]
 80077da:	0112      	lsls	r2, r2, #4
 80077dc:	4313      	orrs	r3, r2
      
      /* Reset the Output Compare N IDLE State */
      tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
 80077de:	4a09      	ldr	r2, [pc, #36]	; (8007804 <TIM_OC2Init+0x9c>)
      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
      
      /* Reset the Output N State */
      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
      /* Set the Output N State */
      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
 80077e0:	b29b      	uxth	r3, r3
      
      /* Reset the Output Compare N IDLE State */
      tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
 80077e2:	4015      	ands	r5, r2
      
      /* Set the Output N Idle state */
      tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
 80077e4:	8a4a      	ldrh	r2, [r1, #18]
 80077e6:	0092      	lsls	r2, r2, #2
 80077e8:	4315      	orrs	r5, r2
 80077ea:	b2ad      	uxth	r5, r5
 80077ec:	e7db      	b.n	80077a6 <TIM_OC2Init+0x3e>
 80077ee:	46c0      	nop			; (mov r8, r8)
 80077f0:	ffff8cff 	.word	0xffff8cff
 80077f4:	40012c00 	.word	0x40012c00
 80077f8:	40014000 	.word	0x40014000
 80077fc:	fffffbff 	.word	0xfffffbff
 8007800:	0000ffbf 	.word	0x0000ffbf
 8007804:	0000f7ff 	.word	0x0000f7ff

08007808 <TIM_OC3Init>:
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
 8007808:	8c02      	ldrh	r2, [r0, #32]
 800780a:	4b1a      	ldr	r3, [pc, #104]	; (8007874 <TIM_OC3Init+0x6c>)
  *         that contains the configuration information for the specified TIM 
  *         peripheral.
  * @retval None
  */
void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 800780c:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
 800780e:	4013      	ands	r3, r2
 8007810:	8403      	strh	r3, [r0, #32]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
 8007812:	2373      	movs	r3, #115	; 0x73
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8007814:	8c02      	ldrh	r2, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8007816:	8885      	ldrh	r5, [r0, #4]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8007818:	8b86      	ldrh	r6, [r0, #28]
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
 800781a:	898c      	ldrh	r4, [r1, #12]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
 800781c:	439e      	bics	r6, r3
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 800781e:	880b      	ldrh	r3, [r1, #0]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
 8007820:	0224      	lsls	r4, r4, #8
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8007822:	431e      	orrs	r6, r3
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
 8007824:	4b14      	ldr	r3, [pc, #80]	; (8007878 <TIM_OC3Init+0x70>)
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8007826:	b2ad      	uxth	r5, r5
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
 8007828:	401a      	ands	r2, r3
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
 800782a:	884b      	ldrh	r3, [r1, #2]
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
 800782c:	4322      	orrs	r2, r4
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
 800782e:	021b      	lsls	r3, r3, #8
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
 8007830:	b292      	uxth	r2, r2
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
 8007832:	431a      	orrs	r2, r3
 8007834:	b293      	uxth	r3, r2
    
  if(TIMx == TIM1)
 8007836:	4a11      	ldr	r2, [pc, #68]	; (800787c <TIM_OC3Init+0x74>)
 8007838:	4290      	cmp	r0, r2
 800783a:	d005      	beq.n	8007848 <TIM_OC3Init+0x40>
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 800783c:	688a      	ldr	r2, [r1, #8]
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800783e:	8085      	strh	r5, [r0, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8007840:	8386      	strh	r6, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 8007842:	63c2      	str	r2, [r0, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8007844:	8403      	strh	r3, [r0, #32]
}
 8007846:	bd70      	pop	{r4, r5, r6, pc}
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
 8007848:	4a0d      	ldr	r2, [pc, #52]	; (8007880 <TIM_OC3Init+0x78>)
 800784a:	4013      	ands	r3, r2
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
 800784c:	89ca      	ldrh	r2, [r1, #14]
 800784e:	0212      	lsls	r2, r2, #8
 8007850:	4313      	orrs	r3, r2
    /* Reset the Output N State */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
 8007852:	4a0c      	ldr	r2, [pc, #48]	; (8007884 <TIM_OC3Init+0x7c>)
 8007854:	4013      	ands	r3, r2
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
 8007856:	888a      	ldrh	r2, [r1, #4]
 8007858:	0212      	lsls	r2, r2, #8
 800785a:	4313      	orrs	r3, r2
    /* Reset the Ouput Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
 800785c:	4a0a      	ldr	r2, [pc, #40]	; (8007888 <TIM_OC3Init+0x80>)
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
    /* Reset the Output N State */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
 800785e:	b29b      	uxth	r3, r3
    /* Reset the Ouput Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
 8007860:	4015      	ands	r5, r2
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
 8007862:	8a0a      	ldrh	r2, [r1, #16]
 8007864:	0112      	lsls	r2, r2, #4
 8007866:	4315      	orrs	r5, r2
 8007868:	b2aa      	uxth	r2, r5
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
 800786a:	8a4d      	ldrh	r5, [r1, #18]
 800786c:	012d      	lsls	r5, r5, #4
 800786e:	432a      	orrs	r2, r5
 8007870:	b295      	uxth	r5, r2
 8007872:	e7e3      	b.n	800783c <TIM_OC3Init+0x34>
 8007874:	fffffeff 	.word	0xfffffeff
 8007878:	fffffdff 	.word	0xfffffdff
 800787c:	40012c00 	.word	0x40012c00
 8007880:	fffff7ff 	.word	0xfffff7ff
 8007884:	0000fbff 	.word	0x0000fbff
 8007888:	ffffcfff 	.word	0xffffcfff

0800788c <TIM_OC4Init>:
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
  /* Disable the Channel 2: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
 800788c:	8c02      	ldrh	r2, [r0, #32]
 800788e:	4b14      	ldr	r3, [pc, #80]	; (80078e0 <TIM_OC4Init+0x54>)
  *         that contains the configuration information for the specified TIM 
  *         peripheral.
  * @retval None
  */
void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8007890:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
  /* Disable the Channel 2: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
 8007892:	4013      	ands	r3, r2
 8007894:	8403      	strh	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8007896:	8c04      	ldrh	r4, [r0, #32]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
 8007898:	4a12      	ldr	r2, [pc, #72]	; (80078e4 <TIM_OC4Init+0x58>)
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800789a:	8886      	ldrh	r6, [r0, #4]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 800789c:	880d      	ldrh	r5, [r1, #0]
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800789e:	8b83      	ldrh	r3, [r0, #28]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 80078a0:	022d      	lsls	r5, r5, #8
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
 80078a2:	401a      	ands	r2, r3
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 80078a4:	432a      	orrs	r2, r5
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
 80078a6:	4b10      	ldr	r3, [pc, #64]	; (80078e8 <TIM_OC4Init+0x5c>)
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
 80078a8:	898d      	ldrh	r5, [r1, #12]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
 80078aa:	4023      	ands	r3, r4
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
 80078ac:	032d      	lsls	r5, r5, #12
 80078ae:	432b      	orrs	r3, r5
 80078b0:	b29c      	uxth	r4, r3
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
 80078b2:	884b      	ldrh	r3, [r1, #2]
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80078b4:	b2b6      	uxth	r6, r6
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
 80078b6:	031b      	lsls	r3, r3, #12
 80078b8:	4323      	orrs	r3, r4
    
  if(TIMx == TIM1)
 80078ba:	4c0c      	ldr	r4, [pc, #48]	; (80078ec <TIM_OC4Init+0x60>)
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 80078bc:	b292      	uxth	r2, r2
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
 80078be:	b29b      	uxth	r3, r3
    
  if(TIMx == TIM1)
 80078c0:	42a0      	cmp	r0, r4
 80078c2:	d005      	beq.n	80078d0 <TIM_OC4Init+0x44>
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80078c4:	8086      	strh	r6, [r0, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
 80078c6:	8382      	strh	r2, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
 80078c8:	688a      	ldr	r2, [r1, #8]
 80078ca:	6402      	str	r2, [r0, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80078cc:	8403      	strh	r3, [r0, #32]
}
 80078ce:	bd70      	pop	{r4, r5, r6, pc}
    
  if(TIMx == TIM1)
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Ouput Compare IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
 80078d0:	4c07      	ldr	r4, [pc, #28]	; (80078f0 <TIM_OC4Init+0x64>)
 80078d2:	4026      	ands	r6, r4
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
 80078d4:	8a0c      	ldrh	r4, [r1, #16]
 80078d6:	01a4      	lsls	r4, r4, #6
 80078d8:	4326      	orrs	r6, r4
 80078da:	b2b6      	uxth	r6, r6
 80078dc:	e7f2      	b.n	80078c4 <TIM_OC4Init+0x38>
 80078de:	46c0      	nop			; (mov r8, r8)
 80078e0:	ffffefff 	.word	0xffffefff
 80078e4:	ffff8cff 	.word	0xffff8cff
 80078e8:	ffffdfff 	.word	0xffffdfff
 80078ec:	40012c00 	.word	0x40012c00
 80078f0:	ffffbfff 	.word	0xffffbfff

080078f4 <TIM_OCStructInit>:
  * @retval None
  */
void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
{
  /* Set the default configuration */
  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
 80078f4:	2300      	movs	r3, #0
 80078f6:	8003      	strh	r3, [r0, #0]
  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
 80078f8:	8043      	strh	r3, [r0, #2]
  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
 80078fa:	8083      	strh	r3, [r0, #4]
  TIM_OCInitStruct->TIM_Pulse = 0x0000000;
 80078fc:	6083      	str	r3, [r0, #8]
  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
 80078fe:	8183      	strh	r3, [r0, #12]
  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
 8007900:	81c3      	strh	r3, [r0, #14]
  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
 8007902:	8203      	strh	r3, [r0, #16]
  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
 8007904:	8243      	strh	r3, [r0, #18]
}
 8007906:	4770      	bx	lr

08007908 <TIM_SelectOCxM>:
  *            @arg TIM_ForcedAction_Active
  *            @arg TIM_ForcedAction_InActive
  * @retval None
  */
void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
{
 8007908:	b530      	push	{r4, r5, lr}
  assert_param(IS_TIM_OCM(TIM_OCMode));
  
  tmp = (uint32_t) TIMx;
  tmp += CCMR_OFFSET;

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
 800790a:	2501      	movs	r5, #1
 800790c:	408d      	lsls	r5, r1

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 800790e:	8c03      	ldrh	r3, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));  
  assert_param(IS_TIM_OCM(TIM_OCMode));
  
  tmp = (uint32_t) TIMx;
  tmp += CCMR_OFFSET;
 8007910:	1c04      	adds	r4, r0, #0

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 8007912:	43ab      	bics	r3, r5
 8007914:	8403      	strh	r3, [r0, #32]

  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
 8007916:	2308      	movs	r3, #8
 8007918:	1c08      	adds	r0, r1, #0
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));  
  assert_param(IS_TIM_OCM(TIM_OCMode));
  
  tmp = (uint32_t) TIMx;
  tmp += CCMR_OFFSET;
 800791a:	3418      	adds	r4, #24
  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;

  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
 800791c:	4398      	bics	r0, r3
 800791e:	d00d      	beq.n	800793c <TIM_SelectOCxM+0x34>
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= TIM_OCMode;
  }
  else
  {
    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
 8007920:	1f0b      	subs	r3, r1, #4
 8007922:	b29b      	uxth	r3, r3
 8007924:	085b      	lsrs	r3, r3, #1
 8007926:	191b      	adds	r3, r3, r4

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
 8007928:	6818      	ldr	r0, [r3, #0]
 800792a:	4909      	ldr	r1, [pc, #36]	; (8007950 <TIM_SelectOCxM+0x48>)
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 800792c:	0212      	lsls	r2, r2, #8
  else
  {
    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
 800792e:	4001      	ands	r1, r0
 8007930:	6019      	str	r1, [r3, #0]
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 8007932:	6819      	ldr	r1, [r3, #0]
 8007934:	b292      	uxth	r2, r2
 8007936:	430a      	orrs	r2, r1
 8007938:	601a      	str	r2, [r3, #0]
  }
}
 800793a:	bd30      	pop	{r4, r5, pc}
  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
  {
    tmp += (TIM_Channel>>1);

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
 800793c:	2070      	movs	r0, #112	; 0x70
  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;

  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
  {
    tmp += (TIM_Channel>>1);
 800793e:	0849      	lsrs	r1, r1, #1
 8007940:	1861      	adds	r1, r4, r1

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
 8007942:	680b      	ldr	r3, [r1, #0]
 8007944:	4383      	bics	r3, r0
 8007946:	600b      	str	r3, [r1, #0]
   
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= TIM_OCMode;
 8007948:	680b      	ldr	r3, [r1, #0]
 800794a:	431a      	orrs	r2, r3
 800794c:	600a      	str	r2, [r1, #0]
 800794e:	e7f4      	b.n	800793a <TIM_SelectOCxM+0x32>
 8007950:	ffff8fff 	.word	0xffff8fff

08007954 <TIM_SetCompare1>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  
  /* Set the Capture Compare1 Register value */
  TIMx->CCR1 = Compare1;
 8007954:	6341      	str	r1, [r0, #52]	; 0x34
}
 8007956:	4770      	bx	lr

08007958 <TIM_SetCompare2>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  
  /* Set the Capture Compare2 Register value */
  TIMx->CCR2 = Compare2;
 8007958:	6381      	str	r1, [r0, #56]	; 0x38
}
 800795a:	4770      	bx	lr

0800795c <TIM_SetCompare3>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  
  /* Set the Capture Compare3 Register value */
  TIMx->CCR3 = Compare3;
 800795c:	63c1      	str	r1, [r0, #60]	; 0x3c
}
 800795e:	4770      	bx	lr

08007960 <TIM_SetCompare4>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  
  /* Set the Capture Compare4 Register value */
  TIMx->CCR4 = Compare4;
 8007960:	6401      	str	r1, [r0, #64]	; 0x40
}
 8007962:	4770      	bx	lr

08007964 <TIM_ForcedOC1Config>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
  /* Reset the OC1M Bits */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
 8007964:	2270      	movs	r2, #112	; 0x70
{
  uint16_t tmpccmr1 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 8007966:	8b03      	ldrh	r3, [r0, #24]
  /* Reset the OC1M Bits */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
 8007968:	4393      	bics	r3, r2
  /* Configure The Forced output Mode */
  tmpccmr1 |= TIM_ForcedAction;
 800796a:	4319      	orrs	r1, r3
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800796c:	8301      	strh	r1, [r0, #24]
}
 800796e:	4770      	bx	lr

08007970 <TIM_ForcedOC2Config>:
  
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  
  tmpccmr1 = TIMx->CCMR1;
 8007970:	8b02      	ldrh	r2, [r0, #24]
  /* Reset the OC2M Bits */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
 8007972:	4b03      	ldr	r3, [pc, #12]	; (8007980 <TIM_ForcedOC2Config+0x10>)
  /* Configure The Forced output Mode */
  tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
 8007974:	0209      	lsls	r1, r1, #8
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  
  tmpccmr1 = TIMx->CCMR1;
  /* Reset the OC2M Bits */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
 8007976:	4013      	ands	r3, r2
  /* Configure The Forced output Mode */
  tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
 8007978:	4319      	orrs	r1, r3
 800797a:	b289      	uxth	r1, r1
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800797c:	8301      	strh	r1, [r0, #24]
}
 800797e:	4770      	bx	lr
 8007980:	ffff8fff 	.word	0xffff8fff

08007984 <TIM_ForcedOC3Config>:
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  
  tmpccmr2 = TIMx->CCMR2;
  /* Reset the OC1M Bits */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
 8007984:	2270      	movs	r2, #112	; 0x70
  
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  
  tmpccmr2 = TIMx->CCMR2;
 8007986:	8b83      	ldrh	r3, [r0, #28]
  /* Reset the OC1M Bits */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
 8007988:	4393      	bics	r3, r2
  /* Configure The Forced output Mode */
  tmpccmr2 |= TIM_ForcedAction;
 800798a:	4319      	orrs	r1, r3
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800798c:	8381      	strh	r1, [r0, #28]
}
 800798e:	4770      	bx	lr

08007990 <TIM_ForcedOC4Config>:
  uint16_t tmpccmr2 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  
  tmpccmr2 = TIMx->CCMR2;
 8007990:	8b82      	ldrh	r2, [r0, #28]
  /* Reset the OC2M Bits */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
 8007992:	4b03      	ldr	r3, [pc, #12]	; (80079a0 <TIM_ForcedOC4Config+0x10>)
  /* Configure The Forced output Mode */
  tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
 8007994:	0209      	lsls	r1, r1, #8
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  
  tmpccmr2 = TIMx->CCMR2;
  /* Reset the OC2M Bits */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
 8007996:	4013      	ands	r3, r2
  /* Configure The Forced output Mode */
  tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
 8007998:	4319      	orrs	r1, r3
 800799a:	b289      	uxth	r1, r1
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800799c:	8381      	strh	r1, [r0, #28]
}
 800799e:	4770      	bx	lr
 80079a0:	ffff8fff 	.word	0xffff8fff

080079a4 <TIM_CCPreloadControl>:
void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80079a4:	2900      	cmp	r1, #0
 80079a6:	d104      	bne.n	80079b2 <TIM_CCPreloadControl+0xe>
    TIMx->CR2 |= TIM_CR2_CCPC;
  }
  else
  {
    /* Reset the CCPC Bit */
    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
 80079a8:	2201      	movs	r2, #1
 80079aa:	8883      	ldrh	r3, [r0, #4]
 80079ac:	4393      	bics	r3, r2
 80079ae:	8083      	strh	r3, [r0, #4]
  }
}
 80079b0:	4770      	bx	lr
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the CCPC Bit */
    TIMx->CR2 |= TIM_CR2_CCPC;
 80079b2:	2301      	movs	r3, #1
 80079b4:	8882      	ldrh	r2, [r0, #4]
 80079b6:	4313      	orrs	r3, r2
 80079b8:	8083      	strh	r3, [r0, #4]
 80079ba:	e7f9      	b.n	80079b0 <TIM_CCPreloadControl+0xc>

080079bc <TIM_OC1PreloadConfig>:
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  
  tmpccmr1 = TIMx->CCMR1;
  /* Reset the OC1PE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
 80079bc:	2208      	movs	r2, #8
  uint16_t tmpccmr1 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  
  tmpccmr1 = TIMx->CCMR1;
 80079be:	8b03      	ldrh	r3, [r0, #24]
  /* Reset the OC1PE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
 80079c0:	4393      	bics	r3, r2
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= TIM_OCPreload;
 80079c2:	4319      	orrs	r1, r3
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 80079c4:	8301      	strh	r1, [r0, #24]
}
 80079c6:	4770      	bx	lr

080079c8 <TIM_OC2PreloadConfig>:
  uint16_t tmpccmr1 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  
  tmpccmr1 = TIMx->CCMR1;
 80079c8:	8b02      	ldrh	r2, [r0, #24]
  /* Reset the OC2PE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
 80079ca:	4b03      	ldr	r3, [pc, #12]	; (80079d8 <TIM_OC2PreloadConfig+0x10>)
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
 80079cc:	0209      	lsls	r1, r1, #8
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  
  tmpccmr1 = TIMx->CCMR1;
  /* Reset the OC2PE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
 80079ce:	4013      	ands	r3, r2
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
 80079d0:	4319      	orrs	r1, r3
 80079d2:	b289      	uxth	r1, r1
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 80079d4:	8301      	strh	r1, [r0, #24]
}
 80079d6:	4770      	bx	lr
 80079d8:	fffff7ff 	.word	0xfffff7ff

080079dc <TIM_OC3PreloadConfig>:
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  
  tmpccmr2 = TIMx->CCMR2;
  /* Reset the OC3PE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
 80079dc:	2208      	movs	r2, #8
  
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  
  tmpccmr2 = TIMx->CCMR2;
 80079de:	8b83      	ldrh	r3, [r0, #28]
  /* Reset the OC3PE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
 80079e0:	4393      	bics	r3, r2
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= TIM_OCPreload;
 80079e2:	4319      	orrs	r1, r3
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 80079e4:	8381      	strh	r1, [r0, #28]
}
 80079e6:	4770      	bx	lr

080079e8 <TIM_OC4PreloadConfig>:
  
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  
  tmpccmr2 = TIMx->CCMR2;
 80079e8:	8b82      	ldrh	r2, [r0, #28]
  /* Reset the OC4PE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
 80079ea:	4b03      	ldr	r3, [pc, #12]	; (80079f8 <TIM_OC4PreloadConfig+0x10>)
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
 80079ec:	0209      	lsls	r1, r1, #8
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  
  tmpccmr2 = TIMx->CCMR2;
  /* Reset the OC4PE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
 80079ee:	4013      	ands	r3, r2
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
 80079f0:	4319      	orrs	r1, r3
 80079f2:	b289      	uxth	r1, r1
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 80079f4:	8381      	strh	r1, [r0, #28]
}
 80079f6:	4770      	bx	lr
 80079f8:	fffff7ff 	.word	0xfffff7ff

080079fc <TIM_OC1FastConfig>:
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
  
  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
  /* Reset the OC1FE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
 80079fc:	2204      	movs	r2, #4
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
  
  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 80079fe:	8b03      	ldrh	r3, [r0, #24]
  /* Reset the OC1FE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
 8007a00:	4393      	bics	r3, r2
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= TIM_OCFast;
 8007a02:	4319      	orrs	r1, r3
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8007a04:	8301      	strh	r1, [r0, #24]
}
 8007a06:	4770      	bx	lr

08007a08 <TIM_OC2FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
  
  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8007a08:	8b02      	ldrh	r2, [r0, #24]
  /* Reset the OC2FE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
 8007a0a:	4b03      	ldr	r3, [pc, #12]	; (8007a18 <TIM_OC2FastConfig+0x10>)
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
 8007a0c:	0209      	lsls	r1, r1, #8
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
  
  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
  /* Reset the OC2FE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
 8007a0e:	4013      	ands	r3, r2
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
 8007a10:	4319      	orrs	r1, r3
 8007a12:	b289      	uxth	r1, r1
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8007a14:	8301      	strh	r1, [r0, #24]
}
 8007a16:	4770      	bx	lr
 8007a18:	fffffbff 	.word	0xfffffbff

08007a1c <TIM_OC3FastConfig>:
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
  
  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
  /* Reset the OC3FE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
 8007a1c:	2204      	movs	r2, #4
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
  
  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 8007a1e:	8b83      	ldrh	r3, [r0, #28]
  /* Reset the OC3FE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
 8007a20:	4393      	bics	r3, r2
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= TIM_OCFast;
 8007a22:	4319      	orrs	r1, r3
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 8007a24:	8381      	strh	r1, [r0, #28]
}
 8007a26:	4770      	bx	lr

08007a28 <TIM_OC4FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
  
  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 8007a28:	8b82      	ldrh	r2, [r0, #28]
  /* Reset the OC4FE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
 8007a2a:	4b03      	ldr	r3, [pc, #12]	; (8007a38 <TIM_OC4FastConfig+0x10>)
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
 8007a2c:	0209      	lsls	r1, r1, #8
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
  
  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
  /* Reset the OC4FE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
 8007a2e:	4013      	ands	r3, r2
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
 8007a30:	4319      	orrs	r1, r3
 8007a32:	b289      	uxth	r1, r1
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 8007a34:	8381      	strh	r1, [r0, #28]
}
 8007a36:	4770      	bx	lr
 8007a38:	fffffbff 	.word	0xfffffbff

08007a3c <TIM_ClearOC1Ref>:
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
  
  tmpccmr1 = TIMx->CCMR1;
  /* Reset the OC1CE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
 8007a3c:	2280      	movs	r2, #128	; 0x80
  
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
  
  tmpccmr1 = TIMx->CCMR1;
 8007a3e:	8b03      	ldrh	r3, [r0, #24]
  /* Reset the OC1CE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
 8007a40:	4393      	bics	r3, r2
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= TIM_OCClear;
 8007a42:	4319      	orrs	r1, r3
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8007a44:	8301      	strh	r1, [r0, #24]
}
 8007a46:	4770      	bx	lr

08007a48 <TIM_ClearOC2Ref>:
  
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
  
  tmpccmr1 = TIMx->CCMR1;
 8007a48:	8b03      	ldrh	r3, [r0, #24]
  /* Reset the OC2CE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
 8007a4a:	0209      	lsls	r1, r1, #8
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
  
  tmpccmr1 = TIMx->CCMR1;
  /* Reset the OC2CE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
 8007a4c:	045b      	lsls	r3, r3, #17
 8007a4e:	0c5b      	lsrs	r3, r3, #17
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
 8007a50:	4319      	orrs	r1, r3
 8007a52:	b289      	uxth	r1, r1
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8007a54:	8301      	strh	r1, [r0, #24]
}
 8007a56:	4770      	bx	lr

08007a58 <TIM_ClearOC3Ref>:
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
  
  tmpccmr2 = TIMx->CCMR2;
  /* Reset the OC3CE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
 8007a58:	2280      	movs	r2, #128	; 0x80
  
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
  
  tmpccmr2 = TIMx->CCMR2;
 8007a5a:	8b83      	ldrh	r3, [r0, #28]
  /* Reset the OC3CE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
 8007a5c:	4393      	bics	r3, r2
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= TIM_OCClear;
 8007a5e:	4319      	orrs	r1, r3
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8007a60:	8381      	strh	r1, [r0, #28]
}
 8007a62:	4770      	bx	lr

08007a64 <TIM_ClearOC4Ref>:
  
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
  
  tmpccmr2 = TIMx->CCMR2;
 8007a64:	8b83      	ldrh	r3, [r0, #28]
  /* Reset the OC4CE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
 8007a66:	0209      	lsls	r1, r1, #8
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
  
  tmpccmr2 = TIMx->CCMR2;
  /* Reset the OC4CE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
 8007a68:	045b      	lsls	r3, r3, #17
 8007a6a:	0c5b      	lsrs	r3, r3, #17
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
 8007a6c:	4319      	orrs	r1, r3
 8007a6e:	b289      	uxth	r1, r1
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8007a70:	8381      	strh	r1, [r0, #28]
}
 8007a72:	4770      	bx	lr

08007a74 <TIM_OC1PolarityConfig>:
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  
  tmpccer = TIMx->CCER;
  /* Set or Reset the CC1P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
 8007a74:	2202      	movs	r2, #2
  
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  
  tmpccer = TIMx->CCER;
 8007a76:	8c03      	ldrh	r3, [r0, #32]
  /* Set or Reset the CC1P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
 8007a78:	4393      	bics	r3, r2
  tmpccer |= TIM_OCPolarity;
 8007a7a:	4319      	orrs	r1, r3
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8007a7c:	8401      	strh	r1, [r0, #32]
}
 8007a7e:	4770      	bx	lr

08007a80 <TIM_OC1NPolarityConfig>:
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   
  tmpccer = TIMx->CCER;
  /* Set or Reset the CC1NP Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
 8007a80:	2208      	movs	r2, #8
  uint16_t tmpccer = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   
  tmpccer = TIMx->CCER;
 8007a82:	8c03      	ldrh	r3, [r0, #32]
  /* Set or Reset the CC1NP Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
 8007a84:	4393      	bics	r3, r2
  tmpccer |= TIM_OCNPolarity;
 8007a86:	4319      	orrs	r1, r3
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8007a88:	8401      	strh	r1, [r0, #32]
}
 8007a8a:	4770      	bx	lr

08007a8c <TIM_OC2PolarityConfig>:
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  
  tmpccer = TIMx->CCER;
  /* Set or Reset the CC2P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
 8007a8c:	2220      	movs	r2, #32
  
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  
  tmpccer = TIMx->CCER;
 8007a8e:	8c03      	ldrh	r3, [r0, #32]
  /* Set or Reset the CC2P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
  tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
 8007a90:	0109      	lsls	r1, r1, #4
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  
  tmpccer = TIMx->CCER;
  /* Set or Reset the CC2P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
 8007a92:	4393      	bics	r3, r2
  tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
 8007a94:	4319      	orrs	r1, r3
 8007a96:	b289      	uxth	r1, r1
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8007a98:	8401      	strh	r1, [r0, #32]
}
 8007a9a:	4770      	bx	lr

08007a9c <TIM_OC2NPolarityConfig>:
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
  
  tmpccer = TIMx->CCER;
  /* Set or Reset the CC2NP Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
 8007a9c:	2280      	movs	r2, #128	; 0x80
  uint16_t tmpccer = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
  
  tmpccer = TIMx->CCER;
 8007a9e:	8c03      	ldrh	r3, [r0, #32]
  /* Set or Reset the CC2NP Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
 8007aa0:	0109      	lsls	r1, r1, #4
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
  
  tmpccer = TIMx->CCER;
  /* Set or Reset the CC2NP Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
 8007aa2:	4393      	bics	r3, r2
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
 8007aa4:	4319      	orrs	r1, r3
 8007aa6:	b289      	uxth	r1, r1
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8007aa8:	8401      	strh	r1, [r0, #32]
}
 8007aaa:	4770      	bx	lr

08007aac <TIM_OC3PolarityConfig>:
  
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  
  tmpccer = TIMx->CCER;
 8007aac:	8c02      	ldrh	r2, [r0, #32]
  /* Set or Reset the CC3P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
 8007aae:	4b03      	ldr	r3, [pc, #12]	; (8007abc <TIM_OC3PolarityConfig+0x10>)
  tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
 8007ab0:	0209      	lsls	r1, r1, #8
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  
  tmpccer = TIMx->CCER;
  /* Set or Reset the CC3P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
 8007ab2:	4013      	ands	r3, r2
  tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
 8007ab4:	4319      	orrs	r1, r3
 8007ab6:	b289      	uxth	r1, r1
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8007ab8:	8401      	strh	r1, [r0, #32]
}
 8007aba:	4770      	bx	lr
 8007abc:	fffffdff 	.word	0xfffffdff

08007ac0 <TIM_OC3NPolarityConfig>:
 
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
    
  tmpccer = TIMx->CCER;
 8007ac0:	8c02      	ldrh	r2, [r0, #32]
  /* Set or Reset the CC3NP Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
 8007ac2:	4b03      	ldr	r3, [pc, #12]	; (8007ad0 <TIM_OC3NPolarityConfig+0x10>)
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
 8007ac4:	0209      	lsls	r1, r1, #8
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
    
  tmpccer = TIMx->CCER;
  /* Set or Reset the CC3NP Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
 8007ac6:	4013      	ands	r3, r2
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
 8007ac8:	4319      	orrs	r1, r3
 8007aca:	b289      	uxth	r1, r1
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8007acc:	8401      	strh	r1, [r0, #32]
}
 8007ace:	4770      	bx	lr
 8007ad0:	fffff7ff 	.word	0xfffff7ff

08007ad4 <TIM_OC4PolarityConfig>:
  
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  
  tmpccer = TIMx->CCER;
 8007ad4:	8c02      	ldrh	r2, [r0, #32]
  /* Set or Reset the CC4P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
 8007ad6:	4b03      	ldr	r3, [pc, #12]	; (8007ae4 <TIM_OC4PolarityConfig+0x10>)
  tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
 8007ad8:	0309      	lsls	r1, r1, #12
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  
  tmpccer = TIMx->CCER;
  /* Set or Reset the CC4P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
 8007ada:	4013      	ands	r3, r2
  tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
 8007adc:	4319      	orrs	r1, r3
 8007ade:	b289      	uxth	r1, r1
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8007ae0:	8401      	strh	r1, [r0, #32]
}
 8007ae2:	4770      	bx	lr
 8007ae4:	ffffdfff 	.word	0xffffdfff

08007ae8 <TIM_SelectOCREFClear>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(TIM_OCREFERENCECECLEAR_SOURCE(TIM_OCReferenceClear));

  /* Set the TIM_OCReferenceClear source */
  TIMx->SMCR &=  (uint16_t)~((uint16_t)TIM_SMCR_OCCS);
 8007ae8:	2208      	movs	r2, #8
 8007aea:	8903      	ldrh	r3, [r0, #8]
 8007aec:	4393      	bics	r3, r2
 8007aee:	8103      	strh	r3, [r0, #8]
  TIMx->SMCR |=  TIM_OCReferenceClear;
 8007af0:	8903      	ldrh	r3, [r0, #8]
 8007af2:	4319      	orrs	r1, r3
 8007af4:	8101      	strh	r1, [r0, #8]
}
 8007af6:	4770      	bx	lr

08007af8 <TIM_CCxCmd>:
  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
  * @retval None
  */
void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
{
 8007af8:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx)); 
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = CCER_CCE_SET << TIM_Channel;
 8007afa:	2401      	movs	r4, #1
 8007afc:	408c      	lsls	r4, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t)~ tmp;

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
 8007afe:	408a      	lsls	r2, r1
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = CCER_CCE_SET << TIM_Channel;

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t)~ tmp;
 8007b00:	8c03      	ldrh	r3, [r0, #32]
 8007b02:	43a3      	bics	r3, r4
 8007b04:	8403      	strh	r3, [r0, #32]

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
 8007b06:	8c03      	ldrh	r3, [r0, #32]
 8007b08:	431a      	orrs	r2, r3
 8007b0a:	b292      	uxth	r2, r2
 8007b0c:	8402      	strh	r2, [r0, #32]
}
 8007b0e:	bd10      	pop	{r4, pc}

08007b10 <TIM_CCxNCmd>:
  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
  *          This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
  * @retval None
  */
void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
{
 8007b10:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = CCER_CCNE_SET << TIM_Channel;
 8007b12:	2404      	movs	r4, #4
 8007b14:	408c      	lsls	r4, r1

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint16_t) ~tmp;

  /* Set or reset the CCxNE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
 8007b16:	408a      	lsls	r2, r1
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = CCER_CCNE_SET << TIM_Channel;

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint16_t) ~tmp;
 8007b18:	8c03      	ldrh	r3, [r0, #32]
 8007b1a:	43a3      	bics	r3, r4
 8007b1c:	8403      	strh	r3, [r0, #32]

  /* Set or reset the CCxNE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
 8007b1e:	8c03      	ldrh	r3, [r0, #32]
 8007b20:	431a      	orrs	r2, r3
 8007b22:	b292      	uxth	r2, r2
 8007b24:	8402      	strh	r2, [r0, #32]
}
 8007b26:	bd10      	pop	{r4, pc}

08007b28 <TIM_SelectCOM>:
void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8007b28:	2900      	cmp	r1, #0
 8007b2a:	d104      	bne.n	8007b36 <TIM_SelectCOM+0xe>
    TIMx->CR2 |= TIM_CR2_CCUS;
  }
  else
  {
    /* Reset the COM Bit */
    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
 8007b2c:	2204      	movs	r2, #4
 8007b2e:	8883      	ldrh	r3, [r0, #4]
 8007b30:	4393      	bics	r3, r2
 8007b32:	8083      	strh	r3, [r0, #4]
  }
}
 8007b34:	4770      	bx	lr
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the COM Bit */
    TIMx->CR2 |= TIM_CR2_CCUS;
 8007b36:	2304      	movs	r3, #4
 8007b38:	8882      	ldrh	r2, [r0, #4]
 8007b3a:	4313      	orrs	r3, r2
 8007b3c:	8083      	strh	r3, [r0, #4]
 8007b3e:	e7f9      	b.n	8007b34 <TIM_SelectCOM+0xc>

08007b40 <TIM_ICInit>:
  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));

  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8007b40:	880b      	ldrh	r3, [r1, #0]
  *         that contains the configuration information for the specified TIM 
  *         peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8007b42:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));

  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8007b44:	2b00      	cmp	r3, #0
 8007b46:	d02a      	beq.n	8007b9e <TIM_ICInit+0x5e>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
 8007b48:	2b04      	cmp	r3, #4
 8007b4a:	d04a      	beq.n	8007be2 <TIM_ICInit+0xa2>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 8007b4c:	2b08      	cmp	r3, #8
 8007b4e:	d100      	bne.n	8007b52 <TIM_ICInit+0x12>
 8007b50:	e06d      	b.n	8007c2e <TIM_ICInit+0xee>
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

   /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
 8007b52:	8c04      	ldrh	r4, [r0, #32]
 8007b54:	4b47      	ldr	r3, [pc, #284]	; (8007c74 <TIM_ICInit+0x134>)
  }
  else
  {
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    /* TI4 Configuration */
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8007b56:	890a      	ldrh	r2, [r1, #8]
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

   /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
 8007b58:	4023      	ands	r3, r4
  }
  else
  {
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    /* TI4 Configuration */
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8007b5a:	884f      	ldrh	r7, [r1, #2]
 8007b5c:	888e      	ldrh	r6, [r1, #4]
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

   /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
 8007b5e:	8403      	strh	r3, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 8007b60:	8b85      	ldrh	r5, [r0, #28]
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
 8007b62:	4c45      	ldr	r4, [pc, #276]	; (8007c78 <TIM_ICInit+0x138>)
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 8007b64:	0236      	lsls	r6, r6, #8
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
 8007b66:	402c      	ands	r4, r5
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 8007b68:	4334      	orrs	r4, r6
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

   /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
 8007b6a:	8c03      	ldrh	r3, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 12);
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 8007b6c:	b2a5      	uxth	r5, r4
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);  
 8007b6e:	0314      	lsls	r4, r2, #12
  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P | TIM_CCER_CC4NP));
 8007b70:	4a42      	ldr	r2, [pc, #264]	; (8007c7c <TIM_ICInit+0x13c>)
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);  
 8007b72:	432c      	orrs	r4, r5
  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P | TIM_CCER_CC4NP));
 8007b74:	4013      	ands	r3, r2
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 8007b76:	2280      	movs	r2, #128	; 0x80

   /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);
 8007b78:	033d      	lsls	r5, r7, #12
  tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);  
  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P | TIM_CCER_CC4NP));
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 8007b7a:	432b      	orrs	r3, r5
 8007b7c:	0152      	lsls	r2, r2, #5
 8007b7e:	b29b      	uxth	r3, r3
 8007b80:	4313      	orrs	r3, r2
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);  
 8007b82:	b2a4      	uxth	r4, r4
  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P | TIM_CCER_CC4NP));
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8007b84:	8384      	strh	r4, [r0, #28]
  TIMx->CCER = tmpccer;
 8007b86:	8403      	strh	r3, [r0, #32]
    /* TI4 Configuration */
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8007b88:	88cb      	ldrh	r3, [r1, #6]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC4PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
 8007b8a:	4a3d      	ldr	r2, [pc, #244]	; (8007c80 <TIM_ICInit+0x140>)
 8007b8c:	8b81      	ldrh	r1, [r0, #28]
  /* Set the IC4PSC value */
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
 8007b8e:	021b      	lsls	r3, r3, #8
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC4PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
 8007b90:	400a      	ands	r2, r1
 8007b92:	8382      	strh	r2, [r0, #28]
  /* Set the IC4PSC value */
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
 8007b94:	8b82      	ldrh	r2, [r0, #28]
 8007b96:	4313      	orrs	r3, r2
 8007b98:	b29b      	uxth	r3, r3
 8007b9a:	8383      	strh	r3, [r0, #28]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8007b9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
 8007b9e:	2601      	movs	r6, #1
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
 8007ba0:	27f3      	movs	r7, #243	; 0xf3
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
 8007ba2:	8c02      	ldrh	r2, [r0, #32]

  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
  {
    assert_param(IS_TIM_LIST4_PERIPH(TIMx));
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8007ba4:	888d      	ldrh	r5, [r1, #4]
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
 8007ba6:	43b2      	bics	r2, r6

  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
  {
    assert_param(IS_TIM_LIST4_PERIPH(TIMx));
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8007ba8:	884b      	ldrh	r3, [r1, #2]
 8007baa:	890c      	ldrh	r4, [r1, #8]
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
 8007bac:	8402      	strh	r2, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007bae:	8b02      	ldrh	r2, [r0, #24]
  tmpccer = TIMx->CCER;
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8007bb0:	0124      	lsls	r4, r4, #4
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
 8007bb2:	43ba      	bics	r2, r7
 8007bb4:	4314      	orrs	r4, r2
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8007bb6:	8c06      	ldrh	r6, [r0, #32]
 8007bb8:	b2a2      	uxth	r2, r4
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8007bba:	432a      	orrs	r2, r5
 8007bbc:	1c14      	adds	r4, r2, #0
 
  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
 8007bbe:	1c35      	adds	r5, r6, #0
 8007bc0:	220a      	movs	r2, #10
 8007bc2:	4395      	bics	r5, r2
 8007bc4:	2201      	movs	r2, #1
 8007bc6:	4313      	orrs	r3, r2
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 8007bc8:	432b      	orrs	r3, r5
 8007bca:	b29b      	uxth	r3, r3
  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8007bcc:	8304      	strh	r4, [r0, #24]
  TIMx->CCER = tmpccer;
 8007bce:	8403      	strh	r3, [r0, #32]
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8007bd0:	88cb      	ldrh	r3, [r1, #6]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
 8007bd2:	210c      	movs	r1, #12
 8007bd4:	8b02      	ldrh	r2, [r0, #24]
 8007bd6:	438a      	bics	r2, r1
 8007bd8:	8302      	strh	r2, [r0, #24]
  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 8007bda:	8b02      	ldrh	r2, [r0, #24]
 8007bdc:	4313      	orrs	r3, r2
 8007bde:	8303      	strh	r3, [r0, #24]
 8007be0:	e7dc      	b.n	8007b9c <TIM_ICInit+0x5c>
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
 8007be2:	2410      	movs	r4, #16
 8007be4:	8c03      	ldrh	r3, [r0, #32]
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
  {
    assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8007be6:	888a      	ldrh	r2, [r1, #4]
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
 8007be8:	43a3      	bics	r3, r4
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
  {
    assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8007bea:	884f      	ldrh	r7, [r1, #2]
 8007bec:	890e      	ldrh	r6, [r1, #8]
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
 8007bee:	8403      	strh	r3, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007bf0:	8b05      	ldrh	r5, [r0, #24]
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
 8007bf2:	4b21      	ldr	r3, [pc, #132]	; (8007c78 <TIM_ICInit+0x138>)
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8007bf4:	0336      	lsls	r6, r6, #12
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
 8007bf6:	402b      	ands	r3, r5
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8007bf8:	4333      	orrs	r3, r6
 8007bfa:	b29d      	uxth	r5, r3
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
 8007bfc:	0213      	lsls	r3, r2, #8
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
 8007bfe:	22a0      	movs	r2, #160	; 0xa0
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8007c00:	8c04      	ldrh	r4, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
 8007c02:	432b      	orrs	r3, r5
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
 8007c04:	4394      	bics	r4, r2
 8007c06:	1c22      	adds	r2, r4, #0
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);  
 8007c08:	2410      	movs	r4, #16
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
 8007c0a:	013d      	lsls	r5, r7, #4
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);  
 8007c0c:	432a      	orrs	r2, r5
 8007c0e:	b292      	uxth	r2, r2
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
 8007c10:	b29b      	uxth	r3, r3
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);  
 8007c12:	4322      	orrs	r2, r4
  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8007c14:	8303      	strh	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8007c16:	8402      	strh	r2, [r0, #32]
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8007c18:	88cb      	ldrh	r3, [r1, #6]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
 8007c1a:	4a19      	ldr	r2, [pc, #100]	; (8007c80 <TIM_ICInit+0x140>)
 8007c1c:	8b01      	ldrh	r1, [r0, #24]
  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 8007c1e:	021b      	lsls	r3, r3, #8
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
 8007c20:	400a      	ands	r2, r1
 8007c22:	8302      	strh	r2, [r0, #24]
  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 8007c24:	8b02      	ldrh	r2, [r0, #24]
 8007c26:	4313      	orrs	r3, r2
 8007c28:	b29b      	uxth	r3, r3
 8007c2a:	8303      	strh	r3, [r0, #24]
 8007c2c:	e7b6      	b.n	8007b9c <TIM_ICInit+0x5c>
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
 8007c2e:	27f3      	movs	r7, #243	; 0xf3
static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
 8007c30:	8c02      	ldrh	r2, [r0, #32]
 8007c32:	4b14      	ldr	r3, [pc, #80]	; (8007c84 <TIM_ICInit+0x144>)
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
  {
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    /* TI3 Configuration */
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
 8007c34:	888d      	ldrh	r5, [r1, #4]
static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
 8007c36:	4013      	ands	r3, r2
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
  {
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    /* TI3 Configuration */
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
 8007c38:	884e      	ldrh	r6, [r1, #2]
 8007c3a:	890c      	ldrh	r4, [r1, #8]
static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
 8007c3c:	8403      	strh	r3, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 8007c3e:	8b82      	ldrh	r2, [r0, #28]
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8007c40:	0124      	lsls	r4, r4, #4
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
 8007c42:	43ba      	bics	r2, r7
 8007c44:	4314      	orrs	r4, r2
 8007c46:	b2a2      	uxth	r2, r4
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8007c48:	432a      	orrs	r2, r5
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
 8007c4a:	8c03      	ldrh	r3, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 8);
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8007c4c:	1c14      	adds	r4, r2, #0
  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
 8007c4e:	4a0e      	ldr	r2, [pc, #56]	; (8007c88 <TIM_ICInit+0x148>)
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);
 8007c50:	0235      	lsls	r5, r6, #8
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
 8007c52:	4013      	ands	r3, r2
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);  
 8007c54:	2280      	movs	r2, #128	; 0x80
 8007c56:	432b      	orrs	r3, r5
 8007c58:	0052      	lsls	r2, r2, #1
 8007c5a:	b29b      	uxth	r3, r3
 8007c5c:	4313      	orrs	r3, r2
  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8007c5e:	8384      	strh	r4, [r0, #28]
  TIMx->CCER = tmpccer;
 8007c60:	8403      	strh	r3, [r0, #32]
    /* TI3 Configuration */
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8007c62:	88cb      	ldrh	r3, [r1, #6]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC3PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
 8007c64:	210c      	movs	r1, #12
 8007c66:	8b82      	ldrh	r2, [r0, #28]
 8007c68:	438a      	bics	r2, r1
 8007c6a:	8382      	strh	r2, [r0, #28]
  /* Set the IC3PSC value */
  TIMx->CCMR2 |= TIM_ICPSC;
 8007c6c:	8b82      	ldrh	r2, [r0, #28]
 8007c6e:	4313      	orrs	r3, r2
 8007c70:	8383      	strh	r3, [r0, #28]
 8007c72:	e793      	b.n	8007b9c <TIM_ICInit+0x5c>
 8007c74:	ffffefff 	.word	0xffffefff
 8007c78:	00000cff 	.word	0x00000cff
 8007c7c:	00005fff 	.word	0x00005fff
 8007c80:	fffff3ff 	.word	0xfffff3ff
 8007c84:	fffffeff 	.word	0xfffffeff
 8007c88:	fffff5ff 	.word	0xfffff5ff

08007c8c <TIM_ICStructInit>:
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 8007c8c:	2300      	movs	r3, #0
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 8007c8e:	2201      	movs	r2, #1
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 8007c90:	8003      	strh	r3, [r0, #0]
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
 8007c92:	8043      	strh	r3, [r0, #2]
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 8007c94:	8082      	strh	r2, [r0, #4]
  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
 8007c96:	80c3      	strh	r3, [r0, #6]
  TIM_ICInitStruct->TIM_ICFilter = 0x00;
 8007c98:	8103      	strh	r3, [r0, #8]
}
 8007c9a:	4770      	bx	lr

08007c9c <TIM_PWMIConfig>:
  *         that contains the configuration information for the specified TIM 
  *         peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8007c9c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007c9e:	4657      	mov	r7, sl
 8007ca0:	464e      	mov	r6, r9
 8007ca2:	4645      	mov	r5, r8
 8007ca4:	b4e0      	push	{r5, r6, r7}
  uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
  uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
 8007ca6:	884d      	ldrh	r5, [r1, #2]
  else
  {
    icoppositepolarity = TIM_ICPolarity_Rising;
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
 8007ca8:	888a      	ldrh	r2, [r1, #4]
  {
    icoppositepolarity = TIM_ICPolarity_Falling;
  }
  else
  {
    icoppositepolarity = TIM_ICPolarity_Rising;
 8007caa:	426e      	negs	r6, r5
 8007cac:	416e      	adcs	r6, r5
  {
    icoppositeselection = TIM_ICSelection_IndirectTI;
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
 8007cae:	1e53      	subs	r3, r2, #1
 8007cb0:	425f      	negs	r7, r3
 8007cb2:	417b      	adcs	r3, r7
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8007cb4:	880f      	ldrh	r7, [r1, #0]
  {
    icoppositeselection = TIM_ICSelection_IndirectTI;
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
 8007cb6:	3301      	adds	r3, #1
  *         that contains the configuration information for the specified TIM 
  *         peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8007cb8:	b082      	sub	sp, #8
  {
    icoppositepolarity = TIM_ICPolarity_Falling;
  }
  else
  {
    icoppositepolarity = TIM_ICPolarity_Rising;
 8007cba:	0074      	lsls	r4, r6, #1
  {
    icoppositeselection = TIM_ICSelection_IndirectTI;
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
 8007cbc:	4699      	mov	r9, r3
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8007cbe:	2f00      	cmp	r7, #0
 8007cc0:	d050      	beq.n	8007d64 <TIM_PWMIConfig+0xc8>
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
 8007cc2:	2310      	movs	r3, #16
 8007cc4:	8c07      	ldrh	r7, [r0, #32]
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
  else
  { 
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 8007cc6:	890e      	ldrh	r6, [r1, #8]
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
 8007cc8:	439f      	bics	r7, r3
 8007cca:	8407      	strh	r7, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007ccc:	8b03      	ldrh	r3, [r0, #24]
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
 8007cce:	0212      	lsls	r2, r2, #8
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
  tmpccmr1 = TIMx->CCMR1;
 8007cd0:	4698      	mov	r8, r3
  tmpccer = TIMx->CCER;
 8007cd2:	8c03      	ldrh	r3, [r0, #32]
 8007cd4:	469a      	mov	sl, r3
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
 8007cd6:	4b45      	ldr	r3, [pc, #276]	; (8007dec <TIM_PWMIConfig+0x150>)
 8007cd8:	469c      	mov	ip, r3
 8007cda:	4643      	mov	r3, r8
 8007cdc:	4667      	mov	r7, ip
 8007cde:	403b      	ands	r3, r7
 8007ce0:	469c      	mov	ip, r3
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8007ce2:	0333      	lsls	r3, r6, #12
 8007ce4:	4698      	mov	r8, r3
 8007ce6:	4663      	mov	r3, ip
 8007ce8:	4647      	mov	r7, r8
 8007cea:	433b      	orrs	r3, r7
 8007cec:	466f      	mov	r7, sp
 8007cee:	80fb      	strh	r3, [r7, #6]
 8007cf0:	88fb      	ldrh	r3, [r7, #6]
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
 8007cf2:	4657      	mov	r7, sl
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
 8007cf4:	431a      	orrs	r2, r3
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
 8007cf6:	012b      	lsls	r3, r5, #4
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
 8007cf8:	25a0      	movs	r5, #160	; 0xa0
 8007cfa:	43af      	bics	r7, r5
 8007cfc:	1c3d      	adds	r5, r7, #0
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);  
 8007cfe:	2710      	movs	r7, #16
 8007d00:	431d      	orrs	r5, r3
 8007d02:	b2ad      	uxth	r5, r5
 8007d04:	433d      	orrs	r5, r7
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
 8007d06:	b292      	uxth	r2, r2
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);  
  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8007d08:	8302      	strh	r2, [r0, #24]
  TIMx->CCER = tmpccer;
 8007d0a:	8405      	strh	r5, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
 8007d0c:	8b05      	ldrh	r5, [r0, #24]
 8007d0e:	4a38      	ldr	r2, [pc, #224]	; (8007df0 <TIM_PWMIConfig+0x154>)
  { 
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8007d10:	88c9      	ldrh	r1, [r1, #6]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
 8007d12:	402a      	ands	r2, r5
 8007d14:	8302      	strh	r2, [r0, #24]
  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 8007d16:	8b05      	ldrh	r5, [r0, #24]
 8007d18:	020a      	lsls	r2, r1, #8
 8007d1a:	432a      	orrs	r2, r5
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
 8007d1c:	2501      	movs	r5, #1
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8007d1e:	464b      	mov	r3, r9
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 8007d20:	b292      	uxth	r2, r2
 8007d22:	8302      	strh	r2, [r0, #24]
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
 8007d24:	8c02      	ldrh	r2, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
 8007d26:	37e3      	adds	r7, #227	; 0xe3
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
 8007d28:	43aa      	bics	r2, r5
 8007d2a:	8402      	strh	r2, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007d2c:	8b02      	ldrh	r2, [r0, #24]
  tmpccer = TIMx->CCER;
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8007d2e:	0136      	lsls	r6, r6, #4
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
 8007d30:	43ba      	bics	r2, r7
 8007d32:	4332      	orrs	r2, r6
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8007d34:	4313      	orrs	r3, r2
 
  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
 8007d36:	220a      	movs	r2, #10
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8007d38:	8c05      	ldrh	r5, [r0, #32]
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8007d3a:	b29b      	uxth	r3, r3
 
  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
 8007d3c:	4395      	bics	r5, r2
 8007d3e:	1c2a      	adds	r2, r5, #0
 8007d40:	2501      	movs	r5, #1
 8007d42:	432a      	orrs	r2, r5
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 8007d44:	4314      	orrs	r4, r2
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
 8007d46:	220c      	movs	r2, #12
 
  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8007d48:	8303      	strh	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8007d4a:	8404      	strh	r4, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
 8007d4c:	8b03      	ldrh	r3, [r0, #24]
 8007d4e:	4393      	bics	r3, r2
 8007d50:	8303      	strh	r3, [r0, #24]
  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 8007d52:	8b03      	ldrh	r3, [r0, #24]
 8007d54:	4319      	orrs	r1, r3
 8007d56:	8301      	strh	r1, [r0, #24]
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8007d58:	b002      	add	sp, #8
 8007d5a:	bc1c      	pop	{r2, r3, r4}
 8007d5c:	4690      	mov	r8, r2
 8007d5e:	4699      	mov	r9, r3
 8007d60:	46a2      	mov	sl, r4
 8007d62:	bdf0      	pop	{r4, r5, r6, r7, pc}
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
 8007d64:	2301      	movs	r3, #1
 8007d66:	8c07      	ldrh	r7, [r0, #32]
    icoppositeselection = TIM_ICSelection_DirectTI;
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 8007d68:	890c      	ldrh	r4, [r1, #8]
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
 8007d6a:	439f      	bics	r7, r3
 8007d6c:	8407      	strh	r7, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007d6e:	8b07      	ldrh	r7, [r0, #24]
  tmpccer = TIMx->CCER;
 8007d70:	8c03      	ldrh	r3, [r0, #32]
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
 8007d72:	0176      	lsls	r6, r6, #5
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8007d74:	469c      	mov	ip, r3
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
 8007d76:	23f3      	movs	r3, #243	; 0xf3
 8007d78:	439f      	bics	r7, r3
 8007d7a:	46b8      	mov	r8, r7
 8007d7c:	4643      	mov	r3, r8
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8007d7e:	0127      	lsls	r7, r4, #4
 8007d80:	431f      	orrs	r7, r3
 8007d82:	b2bf      	uxth	r7, r7
 8007d84:	433a      	orrs	r2, r7
 
  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
 8007d86:	4663      	mov	r3, ip
 8007d88:	270a      	movs	r7, #10
 8007d8a:	43bb      	bics	r3, r7
 8007d8c:	2701      	movs	r7, #1
 8007d8e:	433d      	orrs	r5, r7
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 8007d90:	431d      	orrs	r5, r3
 8007d92:	b2ad      	uxth	r5, r5
  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8007d94:	8302      	strh	r2, [r0, #24]
  TIMx->CCER = tmpccer;
 8007d96:	8405      	strh	r5, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
 8007d98:	250c      	movs	r5, #12
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
 8007d9a:	464b      	mov	r3, r9
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8007d9c:	88ca      	ldrh	r2, [r1, #6]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
 8007d9e:	8b01      	ldrh	r1, [r0, #24]
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8007da0:	0324      	lsls	r4, r4, #12
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
 8007da2:	43a9      	bics	r1, r5
 8007da4:	8301      	strh	r1, [r0, #24]
  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 8007da6:	8b01      	ldrh	r1, [r0, #24]
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
 8007da8:	3504      	adds	r5, #4
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 8007daa:	4311      	orrs	r1, r2
 8007dac:	8301      	strh	r1, [r0, #24]
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
 8007dae:	8c01      	ldrh	r1, [r0, #32]
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
 8007db0:	021b      	lsls	r3, r3, #8
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
 8007db2:	43a9      	bics	r1, r5
 8007db4:	8401      	strh	r1, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007db6:	8b07      	ldrh	r7, [r0, #24]
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
 8007db8:	4d0c      	ldr	r5, [pc, #48]	; (8007dec <TIM_PWMIConfig+0x150>)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8007dba:	8c01      	ldrh	r1, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
 8007dbc:	403d      	ands	r5, r7
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8007dbe:	432c      	orrs	r4, r5
 8007dc0:	b2a4      	uxth	r4, r4
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
 8007dc2:	431c      	orrs	r4, r3
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
 8007dc4:	23a0      	movs	r3, #160	; 0xa0
 8007dc6:	4399      	bics	r1, r3
 8007dc8:	1c0b      	adds	r3, r1, #0
 8007dca:	2110      	movs	r1, #16
 8007dcc:	430b      	orrs	r3, r1
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);  
 8007dce:	431e      	orrs	r6, r3
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
 8007dd0:	b2a4      	uxth	r4, r4
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);  
  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8007dd2:	8304      	strh	r4, [r0, #24]
  TIMx->CCER = tmpccer;
 8007dd4:	8406      	strh	r6, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
 8007dd6:	8b01      	ldrh	r1, [r0, #24]
 8007dd8:	4b05      	ldr	r3, [pc, #20]	; (8007df0 <TIM_PWMIConfig+0x154>)
  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 8007dda:	0212      	lsls	r2, r2, #8
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
 8007ddc:	400b      	ands	r3, r1
 8007dde:	8303      	strh	r3, [r0, #24]
  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 8007de0:	8b03      	ldrh	r3, [r0, #24]
 8007de2:	431a      	orrs	r2, r3
 8007de4:	b292      	uxth	r2, r2
 8007de6:	8302      	strh	r2, [r0, #24]
 8007de8:	e7b6      	b.n	8007d58 <TIM_PWMIConfig+0xbc>
 8007dea:	46c0      	nop			; (mov r8, r8)
 8007dec:	00000cff 	.word	0x00000cff
 8007df0:	fffff3ff 	.word	0xfffff3ff

08007df4 <TIM_GetCapture1>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  
  /* Get the Capture 1 Register value */
  return TIMx->CCR1;
 8007df4:	6b40      	ldr	r0, [r0, #52]	; 0x34
}
 8007df6:	4770      	bx	lr

08007df8 <TIM_GetCapture2>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  
  /* Get the Capture 2 Register value */
  return TIMx->CCR2;
 8007df8:	6b80      	ldr	r0, [r0, #56]	; 0x38
}
 8007dfa:	4770      	bx	lr

08007dfc <TIM_GetCapture3>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
  
  /* Get the Capture 3 Register value */
  return TIMx->CCR3;
 8007dfc:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
}
 8007dfe:	4770      	bx	lr

08007e00 <TIM_GetCapture4>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  
  /* Get the Capture 4 Register value */
  return TIMx->CCR4;
 8007e00:	6c00      	ldr	r0, [r0, #64]	; 0x40
}
 8007e02:	4770      	bx	lr

08007e04 <TIM_SetIC1Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
 8007e04:	220c      	movs	r2, #12
 8007e06:	8b03      	ldrh	r3, [r0, #24]
 8007e08:	4393      	bics	r3, r2
 8007e0a:	8303      	strh	r3, [r0, #24]
  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 8007e0c:	8b03      	ldrh	r3, [r0, #24]
 8007e0e:	4319      	orrs	r1, r3
 8007e10:	8301      	strh	r1, [r0, #24]
}
 8007e12:	4770      	bx	lr

08007e14 <TIM_SetIC2Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
 8007e14:	8b02      	ldrh	r2, [r0, #24]
 8007e16:	4b04      	ldr	r3, [pc, #16]	; (8007e28 <TIM_SetIC2Prescaler+0x14>)
  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 8007e18:	0209      	lsls	r1, r1, #8
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
 8007e1a:	4013      	ands	r3, r2
 8007e1c:	8303      	strh	r3, [r0, #24]
  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 8007e1e:	8b03      	ldrh	r3, [r0, #24]
 8007e20:	4319      	orrs	r1, r3
 8007e22:	b289      	uxth	r1, r1
 8007e24:	8301      	strh	r1, [r0, #24]
}
 8007e26:	4770      	bx	lr
 8007e28:	fffff3ff 	.word	0xfffff3ff

08007e2c <TIM_SetIC3Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC3PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
 8007e2c:	220c      	movs	r2, #12
 8007e2e:	8b83      	ldrh	r3, [r0, #28]
 8007e30:	4393      	bics	r3, r2
 8007e32:	8383      	strh	r3, [r0, #28]
  /* Set the IC3PSC value */
  TIMx->CCMR2 |= TIM_ICPSC;
 8007e34:	8b83      	ldrh	r3, [r0, #28]
 8007e36:	4319      	orrs	r1, r3
 8007e38:	8381      	strh	r1, [r0, #28]
}
 8007e3a:	4770      	bx	lr

08007e3c <TIM_SetIC4Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC4PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
 8007e3c:	8b82      	ldrh	r2, [r0, #28]
 8007e3e:	4b04      	ldr	r3, [pc, #16]	; (8007e50 <TIM_SetIC4Prescaler+0x14>)
  /* Set the IC4PSC value */
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
 8007e40:	0209      	lsls	r1, r1, #8
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  
  /* Reset the IC4PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
 8007e42:	4013      	ands	r3, r2
 8007e44:	8383      	strh	r3, [r0, #28]
  /* Set the IC4PSC value */
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
 8007e46:	8b83      	ldrh	r3, [r0, #28]
 8007e48:	4319      	orrs	r1, r3
 8007e4a:	b289      	uxth	r1, r1
 8007e4c:	8381      	strh	r1, [r0, #28]
}
 8007e4e:	4770      	bx	lr
 8007e50:	fffff3ff 	.word	0xfffff3ff

08007e54 <TIM_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 8007e54:	8983      	ldrh	r3, [r0, #12]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8007e56:	2a00      	cmp	r2, #0
 8007e58:	d102      	bne.n	8007e60 <TIM_ITConfig+0xc>
    TIMx->DIER |= TIM_IT;
  }
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
 8007e5a:	438b      	bics	r3, r1
 8007e5c:	8183      	strh	r3, [r0, #12]
  }
}
 8007e5e:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 8007e60:	4319      	orrs	r1, r3
 8007e62:	8181      	strh	r1, [r0, #12]
 8007e64:	e7fb      	b.n	8007e5e <TIM_ITConfig+0xa>
 8007e66:	46c0      	nop			; (mov r8, r8)

08007e68 <TIM_GenerateEvent>:
{ 
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource)); 
  /* Set the event sources */
  TIMx->EGR = TIM_EventSource;
 8007e68:	8281      	strh	r1, [r0, #20]
}
 8007e6a:	4770      	bx	lr

08007e6c <TIM_GetFlagStatus>:
   
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
  
  if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
 8007e6c:	8a00      	ldrh	r0, [r0, #16]
 8007e6e:	4008      	ands	r0, r1
 8007e70:	1e41      	subs	r1, r0, #1
 8007e72:	4188      	sbcs	r0, r1
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 8007e74:	b2c0      	uxtb	r0, r0
}
 8007e76:	4770      	bx	lr

08007e78 <TIM_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
   
  /* Clear the flags */
  TIMx->SR = (uint16_t)~TIM_FLAG;
 8007e78:	43c9      	mvns	r1, r1
 8007e7a:	b289      	uxth	r1, r1
 8007e7c:	8201      	strh	r1, [r0, #16]
}
 8007e7e:	4770      	bx	lr

08007e80 <TIM_GetITStatus>:
  
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 8007e80:	8a02      	ldrh	r2, [r0, #16]
  
  itenable = TIMx->DIER & TIM_IT;
 8007e82:	8980      	ldrh	r0, [r0, #12]
 8007e84:	b283      	uxth	r3, r0
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8007e86:	2000      	movs	r0, #0
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
  
  itenable = TIMx->DIER & TIM_IT;
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 8007e88:	420a      	tst	r2, r1
 8007e8a:	d003      	beq.n	8007e94 <TIM_GetITStatus+0x14>
 8007e8c:	4019      	ands	r1, r3
 8007e8e:	1e48      	subs	r0, r1, #1
 8007e90:	4181      	sbcs	r1, r0
  {
    bitstatus = SET;
 8007e92:	b2c8      	uxtb	r0, r1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8007e94:	4770      	bx	lr
 8007e96:	46c0      	nop			; (mov r8, r8)

08007e98 <TIM_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
   
  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 8007e98:	43c9      	mvns	r1, r1
 8007e9a:	b289      	uxth	r1, r1
 8007e9c:	8201      	strh	r1, [r0, #16]
}
 8007e9e:	4770      	bx	lr

08007ea0 <TIM_DMAConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
  /* Set the DMA Base and the DMA Burst Length */
  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
 8007ea0:	2348      	movs	r3, #72	; 0x48
 8007ea2:	430a      	orrs	r2, r1
 8007ea4:	52c2      	strh	r2, [r0, r3]
}
 8007ea6:	4770      	bx	lr

08007ea8 <TIM_DMACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 8007ea8:	8983      	ldrh	r3, [r0, #12]
  /* Check the parameters */
  assert_param(IS_TIM_LIST10_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8007eaa:	2a00      	cmp	r2, #0
 8007eac:	d102      	bne.n	8007eb4 <TIM_DMACmd+0xc>
    TIMx->DIER |= TIM_DMASource; 
  }
  else
  {
    /* Disable the DMA sources */
    TIMx->DIER &= (uint16_t)~TIM_DMASource;
 8007eae:	438b      	bics	r3, r1
 8007eb0:	8183      	strh	r3, [r0, #12]
  }
}
 8007eb2:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 8007eb4:	4319      	orrs	r1, r3
 8007eb6:	8181      	strh	r1, [r0, #12]
 8007eb8:	e7fb      	b.n	8007eb2 <TIM_DMACmd+0xa>
 8007eba:	46c0      	nop			; (mov r8, r8)

08007ebc <TIM_SelectCCDMA>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST5_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8007ebc:	2900      	cmp	r1, #0
 8007ebe:	d104      	bne.n	8007eca <TIM_SelectCCDMA+0xe>
    TIMx->CR2 |= TIM_CR2_CCDS;
  }
  else
  {
    /* Reset the CCDS Bit */
    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
 8007ec0:	2208      	movs	r2, #8
 8007ec2:	8883      	ldrh	r3, [r0, #4]
 8007ec4:	4393      	bics	r3, r2
 8007ec6:	8083      	strh	r3, [r0, #4]
  }
}
 8007ec8:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Set the CCDS Bit */
    TIMx->CR2 |= TIM_CR2_CCDS;
 8007eca:	2308      	movs	r3, #8
 8007ecc:	8882      	ldrh	r2, [r0, #4]
 8007ece:	4313      	orrs	r3, r2
 8007ed0:	8083      	strh	r3, [r0, #4]
 8007ed2:	e7f9      	b.n	8007ec8 <TIM_SelectCCDMA+0xc>

08007ed4 <TIM_InternalClockConfig>:
void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  /* Disable slave mode to clock the prescaler directly with the internal clock */
  TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
 8007ed4:	2207      	movs	r2, #7
 8007ed6:	8903      	ldrh	r3, [r0, #8]
 8007ed8:	4393      	bics	r3, r2
 8007eda:	8103      	strh	r3, [r0, #8]
}
 8007edc:	4770      	bx	lr
 8007ede:	46c0      	nop			; (mov r8, r8)

08007ee0 <TIM_ITRxExternalClockConfig>:
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
 8007ee0:	2270      	movs	r2, #112	; 0x70
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8007ee2:	8903      	ldrh	r3, [r0, #8]
  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
 8007ee4:	4393      	bics	r3, r2
  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
 8007ee6:	4319      	orrs	r1, r3
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
  /* Select the Internal Trigger */
  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 8007ee8:	2307      	movs	r3, #7
  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8007eea:	8101      	strh	r1, [r0, #8]
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
  /* Select the Internal Trigger */
  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 8007eec:	8902      	ldrh	r2, [r0, #8]
 8007eee:	4313      	orrs	r3, r2
 8007ef0:	8103      	strh	r3, [r0, #8]
}
 8007ef2:	4770      	bx	lr

08007ef4 <TIM_TIxExternalClockConfig>:
  *          This parameter must be a value between 0x0 and 0xF.
  * @retval None
  */
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
{
 8007ef4:	b570      	push	{r4, r5, r6, lr}
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
 8007ef6:	8c04      	ldrh	r4, [r0, #32]
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));
  
  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 8007ef8:	2960      	cmp	r1, #96	; 0x60
 8007efa:	d01d      	beq.n	8007f38 <TIM_TIxExternalClockConfig+0x44>
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
 8007efc:	2501      	movs	r5, #1
 8007efe:	43ac      	bics	r4, r5
 8007f00:	8404      	strh	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007f02:	8b04      	ldrh	r4, [r0, #24]
  tmpccer = TIMx->CCER;
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
 8007f04:	35f2      	adds	r5, #242	; 0xf2
 8007f06:	43ac      	bics	r4, r5
 8007f08:	2501      	movs	r5, #1
 8007f0a:	432c      	orrs	r4, r5
 8007f0c:	b2a4      	uxth	r4, r4
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8007f0e:	011b      	lsls	r3, r3, #4
 8007f10:	4323      	orrs	r3, r4
 
  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
 8007f12:	240a      	movs	r4, #10
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8007f14:	8c06      	ldrh	r6, [r0, #32]
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8007f16:	b29b      	uxth	r3, r3
 
  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
 8007f18:	43a6      	bics	r6, r4
 8007f1a:	4335      	orrs	r5, r6
 8007f1c:	b2ad      	uxth	r5, r5
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 8007f1e:	432a      	orrs	r2, r5
  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8007f20:	8303      	strh	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8007f22:	8402      	strh	r2, [r0, #32]
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
 8007f24:	2270      	movs	r2, #112	; 0x70
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8007f26:	8903      	ldrh	r3, [r0, #8]
  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
 8007f28:	4393      	bics	r3, r2
  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
 8007f2a:	4319      	orrs	r1, r3
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
  }
  /* Select the Trigger source */
  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 8007f2c:	2307      	movs	r3, #7
  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8007f2e:	8101      	strh	r1, [r0, #8]
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
  }
  /* Select the Trigger source */
  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 8007f30:	8902      	ldrh	r2, [r0, #8]
 8007f32:	4313      	orrs	r3, r2
 8007f34:	8103      	strh	r3, [r0, #8]
}
 8007f36:	bd70      	pop	{r4, r5, r6, pc}
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
 8007f38:	2510      	movs	r5, #16
 8007f3a:	43ac      	bics	r4, r5
 8007f3c:	8404      	strh	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007f3e:	8b06      	ldrh	r6, [r0, #24]
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
 8007f40:	4c09      	ldr	r4, [pc, #36]	; (8007f68 <TIM_TIxExternalClockConfig+0x74>)
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8007f42:	031b      	lsls	r3, r3, #12
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
 8007f44:	4034      	ands	r4, r6
 8007f46:	2680      	movs	r6, #128	; 0x80
 8007f48:	0076      	lsls	r6, r6, #1
 8007f4a:	4334      	orrs	r4, r6
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
 8007f4c:	4323      	orrs	r3, r4
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
 8007f4e:	24a0      	movs	r4, #160	; 0xa0
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8007f50:	8c05      	ldrh	r5, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 4);
 8007f52:	0112      	lsls	r2, r2, #4
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
 8007f54:	43a5      	bics	r5, r4
 8007f56:	1c2c      	adds	r4, r5, #0
 8007f58:	2510      	movs	r5, #16
 8007f5a:	432c      	orrs	r4, r5
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);  
 8007f5c:	4322      	orrs	r2, r4
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
 8007f5e:	b29b      	uxth	r3, r3
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);  
 8007f60:	b292      	uxth	r2, r2
  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8007f62:	8303      	strh	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8007f64:	8402      	strh	r2, [r0, #32]
 8007f66:	e7dd      	b.n	8007f24 <TIM_TIxExternalClockConfig+0x30>
 8007f68:	00000cff 	.word	0x00000cff

08007f6c <TIM_ETRClockMode1Config>:
  
  tmpsmcr = TIMx->SMCR;
  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 8007f6c:	021b      	lsls	r3, r3, #8
 8007f6e:	431a      	orrs	r2, r3
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  
  tmpsmcr = TIMx->SMCR;
  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
 8007f70:	23ff      	movs	r3, #255	; 0xff
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
                             uint16_t ExtTRGFilter)
{
 8007f72:	b510      	push	{r4, lr}
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  
  tmpsmcr = TIMx->SMCR;
 8007f74:	8904      	ldrh	r4, [r0, #8]
  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
 8007f76:	401c      	ands	r4, r3
 8007f78:	4322      	orrs	r2, r4
 8007f7a:	b292      	uxth	r2, r2
  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 8007f7c:	4311      	orrs	r1, r2
  /* Reset the SMS Bits */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
  /* Select the External clock mode1 */
  tmpsmcr |= TIM_SlaveMode_External1;
  /* Select the Trigger selection : ETRF */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
 8007f7e:	2277      	movs	r2, #119	; 0x77
  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8007f80:	8101      	strh	r1, [r0, #8]
  
  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
  
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8007f82:	8903      	ldrh	r3, [r0, #8]
  /* Reset the SMS Bits */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
  /* Select the External clock mode1 */
  tmpsmcr |= TIM_SlaveMode_External1;
  /* Select the Trigger selection : ETRF */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
 8007f84:	4393      	bics	r3, r2
  tmpsmcr |= TIM_TS_ETRF;
 8007f86:	4313      	orrs	r3, r2
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8007f88:	8103      	strh	r3, [r0, #8]
}
 8007f8a:	bd10      	pop	{r4, pc}

08007f8c <TIM_ETRClockMode2Config>:
  
  tmpsmcr = TIMx->SMCR;
  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 8007f8c:	021b      	lsls	r3, r3, #8
 8007f8e:	431a      	orrs	r2, r3
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  
  tmpsmcr = TIMx->SMCR;
  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
 8007f90:	23ff      	movs	r3, #255	; 0xff
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 8007f92:	b510      	push	{r4, lr}
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  
  tmpsmcr = TIMx->SMCR;
 8007f94:	8904      	ldrh	r4, [r0, #8]
  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
 8007f96:	401c      	ands	r4, r3
 8007f98:	4322      	orrs	r2, r4
 8007f9a:	b292      	uxth	r2, r2
  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 8007f9c:	4311      	orrs	r1, r2
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  
  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
  /* Enable the External clock mode2 */
  TIMx->SMCR |= TIM_SMCR_ECE;
 8007f9e:	2280      	movs	r2, #128	; 0x80
  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8007fa0:	8101      	strh	r1, [r0, #8]
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  
  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
  /* Enable the External clock mode2 */
  TIMx->SMCR |= TIM_SMCR_ECE;
 8007fa2:	8903      	ldrh	r3, [r0, #8]
 8007fa4:	01d2      	lsls	r2, r2, #7
 8007fa6:	4313      	orrs	r3, r2
 8007fa8:	8103      	strh	r3, [r0, #8]
}
 8007faa:	bd10      	pop	{r4, pc}

08007fac <TIM_SelectInputTrigger>:
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
 8007fac:	2270      	movs	r2, #112	; 0x70
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8007fae:	8903      	ldrh	r3, [r0, #8]
  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
 8007fb0:	4393      	bics	r3, r2
  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
 8007fb2:	4319      	orrs	r1, r3
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8007fb4:	8101      	strh	r1, [r0, #8]
}
 8007fb6:	4770      	bx	lr

08007fb8 <TIM_SelectOutputTrigger>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST9_PERIPH(TIMx));
  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));

  /* Reset the MMS Bits */
  TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
 8007fb8:	2270      	movs	r2, #112	; 0x70
 8007fba:	8883      	ldrh	r3, [r0, #4]
 8007fbc:	4393      	bics	r3, r2
 8007fbe:	8083      	strh	r3, [r0, #4]
  /* Select the TRGO source */
  TIMx->CR2 |=  TIM_TRGOSource;
 8007fc0:	8883      	ldrh	r3, [r0, #4]
 8007fc2:	4319      	orrs	r1, r3
 8007fc4:	8081      	strh	r1, [r0, #4]
}
 8007fc6:	4770      	bx	lr

08007fc8 <TIM_SelectSlaveMode>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
  
  /* Reset the SMS Bits */
  TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
 8007fc8:	2207      	movs	r2, #7
 8007fca:	8903      	ldrh	r3, [r0, #8]
 8007fcc:	4393      	bics	r3, r2
 8007fce:	8103      	strh	r3, [r0, #8]
  /* Select the Slave Mode */
  TIMx->SMCR |= TIM_SlaveMode;
 8007fd0:	8903      	ldrh	r3, [r0, #8]
 8007fd2:	4319      	orrs	r1, r3
 8007fd4:	8101      	strh	r1, [r0, #8]
}
 8007fd6:	4770      	bx	lr

08007fd8 <TIM_SelectMasterSlaveMode>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
  
  /* Reset the MSM Bit */
  TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
 8007fd8:	2280      	movs	r2, #128	; 0x80
 8007fda:	8903      	ldrh	r3, [r0, #8]
 8007fdc:	4393      	bics	r3, r2
 8007fde:	8103      	strh	r3, [r0, #8]
  
  /* Set or Reset the MSM Bit */
  TIMx->SMCR |= TIM_MasterSlaveMode;
 8007fe0:	8903      	ldrh	r3, [r0, #8]
 8007fe2:	4319      	orrs	r1, r3
 8007fe4:	8101      	strh	r1, [r0, #8]
}
 8007fe6:	4770      	bx	lr

08007fe8 <TIM_ETRConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
                   uint16_t ExtTRGFilter)
{
 8007fe8:	b530      	push	{r4, r5, lr}
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  
  tmpsmcr = TIMx->SMCR;
  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
 8007fea:	25ff      	movs	r5, #255	; 0xff
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  
  tmpsmcr = TIMx->SMCR;
 8007fec:	8904      	ldrh	r4, [r0, #8]
  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 8007fee:	021b      	lsls	r3, r3, #8
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  
  tmpsmcr = TIMx->SMCR;
  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
 8007ff0:	402c      	ands	r4, r5
 8007ff2:	4321      	orrs	r1, r4
 8007ff4:	430a      	orrs	r2, r1
  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 8007ff6:	431a      	orrs	r2, r3
 8007ff8:	b292      	uxth	r2, r2
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8007ffa:	8102      	strh	r2, [r0, #8]
}
 8007ffc:	bd30      	pop	{r4, r5, pc}
 8007ffe:	46c0      	nop			; (mov r8, r8)

08008000 <TIM_EncoderInterfaceConfig>:
  *            @arg TIM_ICPolarity_Rising: IC Rising edge.
  * @retval None
  */
void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
{
 8008000:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
 8008002:	2407      	movs	r4, #7
  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
  
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8008004:	8906      	ldrh	r6, [r0, #8]
  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8008006:	8b07      	ldrh	r7, [r0, #24]
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
 8008008:	43a6      	bics	r6, r4
  tmpsmcr |= TIM_EncoderMode;
 800800a:	4331      	orrs	r1, r6
  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
 800800c:	2602      	movs	r6, #2
  tmpccer = TIMx->CCER;
  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
  tmpsmcr |= TIM_EncoderMode;
  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
 800800e:	4c07      	ldr	r4, [pc, #28]	; (800802c <TIM_EncoderInterfaceConfig+0x2c>)
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8008010:	8c05      	ldrh	r5, [r0, #32]
  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
  tmpsmcr |= TIM_EncoderMode;
  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
 8008012:	403c      	ands	r4, r7
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
 8008014:	36ff      	adds	r6, #255	; 0xff
 8008016:	4334      	orrs	r4, r6
  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP)) & (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
 8008018:	3e57      	subs	r6, #87	; 0x57
 800801a:	43b5      	bics	r5, r6
 800801c:	432a      	orrs	r2, r5
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 800801e:	011b      	lsls	r3, r3, #4
 8008020:	431a      	orrs	r2, r3
 8008022:	b292      	uxth	r2, r2
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8008024:	8101      	strh	r1, [r0, #8]
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8008026:	8304      	strh	r4, [r0, #24]
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8008028:	8402      	strh	r2, [r0, #32]
}
 800802a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800802c:	fffffcfc 	.word	0xfffffcfc

08008030 <TIM_SelectHallSensor>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8008030:	2900      	cmp	r1, #0
 8008032:	d104      	bne.n	800803e <TIM_SelectHallSensor+0xe>
    TIMx->CR2 |= TIM_CR2_TI1S;
  }
  else
  {
    /* Reset the TI1S Bit */
    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
 8008034:	2280      	movs	r2, #128	; 0x80
 8008036:	8883      	ldrh	r3, [r0, #4]
 8008038:	4393      	bics	r3, r2
 800803a:	8083      	strh	r3, [r0, #4]
  }
}
 800803c:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Set the TI1S Bit */
    TIMx->CR2 |= TIM_CR2_TI1S;
 800803e:	2380      	movs	r3, #128	; 0x80
 8008040:	8882      	ldrh	r2, [r0, #4]
 8008042:	4313      	orrs	r3, r2
 8008044:	8083      	strh	r3, [r0, #4]
 8008046:	e7f9      	b.n	800803c <TIM_SelectHallSensor+0xc>

08008048 <TIM_RemapConfig>:
 /* Check the parameters */
  assert_param(IS_TIM_LIST11_PERIPH(TIMx));
  assert_param(IS_TIM_REMAP(TIM_Remap));

  /* Set the Timer remapping configuration */
  TIMx->OR =  TIM_Remap;
 8008048:	2350      	movs	r3, #80	; 0x50
 800804a:	52c1      	strh	r1, [r0, r3]
}
 800804c:	4770      	bx	lr
 800804e:	46c0      	nop			; (mov r8, r8)

08008050 <USART_DeInit>:
  * @note   USART5, USART6, USART7 and USART8 are available only for STM32F091 devices.  
  * @note   USART2 is not available for STM32F031 devices.
  * @retval None
  */
void USART_DeInit(USART_TypeDef* USARTx)
{
 8008050:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
 8008052:	4b35      	ldr	r3, [pc, #212]	; (8008128 <USART_DeInit+0xd8>)
 8008054:	4298      	cmp	r0, r3
 8008056:	d01e      	beq.n	8008096 <USART_DeInit+0x46>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
  }
  else if (USARTx == USART2)
 8008058:	4b34      	ldr	r3, [pc, #208]	; (800812c <USART_DeInit+0xdc>)
 800805a:	4298      	cmp	r0, r3
 800805c:	d026      	beq.n	80080ac <USART_DeInit+0x5c>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
  }
  else if (USARTx == USART3)
 800805e:	4b34      	ldr	r3, [pc, #208]	; (8008130 <USART_DeInit+0xe0>)
 8008060:	4298      	cmp	r0, r3
 8008062:	d02e      	beq.n	80080c2 <USART_DeInit+0x72>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
  }
    else if (USARTx == USART4)
 8008064:	4b33      	ldr	r3, [pc, #204]	; (8008134 <USART_DeInit+0xe4>)
 8008066:	4298      	cmp	r0, r3
 8008068:	d036      	beq.n	80080d8 <USART_DeInit+0x88>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART4, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART4, DISABLE);
  }
  else if (USARTx == USART5)
 800806a:	4b33      	ldr	r3, [pc, #204]	; (8008138 <USART_DeInit+0xe8>)
 800806c:	4298      	cmp	r0, r3
 800806e:	d03e      	beq.n	80080ee <USART_DeInit+0x9e>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART5, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART5, DISABLE);
  }
    else if (USARTx == USART6)
 8008070:	4b32      	ldr	r3, [pc, #200]	; (800813c <USART_DeInit+0xec>)
 8008072:	4298      	cmp	r0, r3
 8008074:	d046      	beq.n	8008104 <USART_DeInit+0xb4>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
  }
  else if (USARTx == USART7)
 8008076:	4b32      	ldr	r3, [pc, #200]	; (8008140 <USART_DeInit+0xf0>)
 8008078:	4298      	cmp	r0, r3
 800807a:	d04c      	beq.n	8008116 <USART_DeInit+0xc6>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART7, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART7, DISABLE);
  }
  else 
  {
    if  (USARTx == USART8)
 800807c:	4b31      	ldr	r3, [pc, #196]	; (8008144 <USART_DeInit+0xf4>)
 800807e:	4298      	cmp	r0, r3
 8008080:	d000      	beq.n	8008084 <USART_DeInit+0x34>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART8, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART8, DISABLE);
    }
  }
}
 8008082:	bd08      	pop	{r3, pc}
  }
  else 
  {
    if  (USARTx == USART8)
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART8, ENABLE);
 8008084:	2080      	movs	r0, #128	; 0x80
 8008086:	2101      	movs	r1, #1
 8008088:	f7fe fb1a 	bl	80066c0 <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART8, DISABLE);
 800808c:	2080      	movs	r0, #128	; 0x80
 800808e:	2100      	movs	r1, #0
 8008090:	f7fe fb16 	bl	80066c0 <RCC_APB2PeriphResetCmd>
 8008094:	e7f5      	b.n	8008082 <USART_DeInit+0x32>
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
 8008096:	2080      	movs	r0, #128	; 0x80
 8008098:	2101      	movs	r1, #1
 800809a:	01c0      	lsls	r0, r0, #7
 800809c:	f7fe fb10 	bl	80066c0 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 80080a0:	2080      	movs	r0, #128	; 0x80
 80080a2:	2100      	movs	r1, #0
 80080a4:	01c0      	lsls	r0, r0, #7
 80080a6:	f7fe fb0b 	bl	80066c0 <RCC_APB2PeriphResetCmd>
 80080aa:	e7ea      	b.n	8008082 <USART_DeInit+0x32>
  }
  else if (USARTx == USART2)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
 80080ac:	2080      	movs	r0, #128	; 0x80
 80080ae:	2101      	movs	r1, #1
 80080b0:	0280      	lsls	r0, r0, #10
 80080b2:	f7fe fb11 	bl	80066d8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
 80080b6:	2080      	movs	r0, #128	; 0x80
 80080b8:	2100      	movs	r1, #0
 80080ba:	0280      	lsls	r0, r0, #10
 80080bc:	f7fe fb0c 	bl	80066d8 <RCC_APB1PeriphResetCmd>
 80080c0:	e7df      	b.n	8008082 <USART_DeInit+0x32>
  }
  else if (USARTx == USART3)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
 80080c2:	2080      	movs	r0, #128	; 0x80
 80080c4:	2101      	movs	r1, #1
 80080c6:	02c0      	lsls	r0, r0, #11
 80080c8:	f7fe fb06 	bl	80066d8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 80080cc:	2080      	movs	r0, #128	; 0x80
 80080ce:	2100      	movs	r1, #0
 80080d0:	02c0      	lsls	r0, r0, #11
 80080d2:	f7fe fb01 	bl	80066d8 <RCC_APB1PeriphResetCmd>
 80080d6:	e7d4      	b.n	8008082 <USART_DeInit+0x32>
  }
    else if (USARTx == USART4)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART4, ENABLE);
 80080d8:	2080      	movs	r0, #128	; 0x80
 80080da:	2101      	movs	r1, #1
 80080dc:	0300      	lsls	r0, r0, #12
 80080de:	f7fe fafb 	bl	80066d8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART4, DISABLE);
 80080e2:	2080      	movs	r0, #128	; 0x80
 80080e4:	2100      	movs	r1, #0
 80080e6:	0300      	lsls	r0, r0, #12
 80080e8:	f7fe faf6 	bl	80066d8 <RCC_APB1PeriphResetCmd>
 80080ec:	e7c9      	b.n	8008082 <USART_DeInit+0x32>
  }
  else if (USARTx == USART5)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART5, ENABLE);
 80080ee:	2080      	movs	r0, #128	; 0x80
 80080f0:	2101      	movs	r1, #1
 80080f2:	0340      	lsls	r0, r0, #13
 80080f4:	f7fe faf0 	bl	80066d8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART5, DISABLE);
 80080f8:	2080      	movs	r0, #128	; 0x80
 80080fa:	2100      	movs	r1, #0
 80080fc:	0340      	lsls	r0, r0, #13
 80080fe:	f7fe faeb 	bl	80066d8 <RCC_APB1PeriphResetCmd>
 8008102:	e7be      	b.n	8008082 <USART_DeInit+0x32>
  }
    else if (USARTx == USART6)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
 8008104:	2020      	movs	r0, #32
 8008106:	2101      	movs	r1, #1
 8008108:	f7fe fada 	bl	80066c0 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
 800810c:	2020      	movs	r0, #32
 800810e:	2100      	movs	r1, #0
 8008110:	f7fe fad6 	bl	80066c0 <RCC_APB2PeriphResetCmd>
 8008114:	e7b5      	b.n	8008082 <USART_DeInit+0x32>
  }
  else if (USARTx == USART7)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART7, ENABLE);
 8008116:	2040      	movs	r0, #64	; 0x40
 8008118:	2101      	movs	r1, #1
 800811a:	f7fe fad1 	bl	80066c0 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART7, DISABLE);
 800811e:	2040      	movs	r0, #64	; 0x40
 8008120:	2100      	movs	r1, #0
 8008122:	f7fe facd 	bl	80066c0 <RCC_APB2PeriphResetCmd>
 8008126:	e7ac      	b.n	8008082 <USART_DeInit+0x32>
 8008128:	40013800 	.word	0x40013800
 800812c:	40004400 	.word	0x40004400
 8008130:	40004800 	.word	0x40004800
 8008134:	40004c00 	.word	0x40004c00
 8008138:	40005000 	.word	0x40005000
 800813c:	40011400 	.word	0x40011400
 8008140:	40011800 	.word	0x40011800
 8008144:	40011c00 	.word	0x40011c00

08008148 <USART_Init>:
  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
  
  /* Disable USART */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 8008148:	2201      	movs	r2, #1
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 800814a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800814c:	1c0d      	adds	r5, r1, #0
  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
  
  /* Disable USART */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 800814e:	6803      	ldr	r3, [r0, #0]
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8008150:	b08b      	sub	sp, #44	; 0x2c
  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
  
  /* Disable USART */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 8008152:	4393      	bics	r3, r2
 8008154:	6003      	str	r3, [r0, #0]
  
  /*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8008156:	6842      	ldr	r2, [r0, #4]
  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8008158:	4b23      	ldr	r3, [pc, #140]	; (80081e8 <USART_Init+0xa0>)
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 800815a:	1c04      	adds	r4, r0, #0
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
  
  /*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 800815c:	4013      	ands	r3, r2
  
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 800815e:	688a      	ldr	r2, [r1, #8]
 8008160:	4313      	orrs	r3, r2
  
  /* Write to USART CR2 */
  USARTx->CR2 = tmpreg;
 8008162:	6043      	str	r3, [r0, #4]
  
  /*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8008164:	6802      	ldr	r2, [r0, #0]
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 8008166:	4b21      	ldr	r3, [pc, #132]	; (80081ec <USART_Init+0xa4>)
 8008168:	401a      	ands	r2, r3
  
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 800816a:	68cb      	ldr	r3, [r1, #12]
 800816c:	6849      	ldr	r1, [r1, #4]
 800816e:	430b      	orrs	r3, r1
 8008170:	6929      	ldr	r1, [r5, #16]
 8008172:	430b      	orrs	r3, r1
 8008174:	4313      	orrs	r3, r2
    USART_InitStruct->USART_Mode;
  
  /* Write to USART CR1 */
  USARTx->CR1 = tmpreg;
 8008176:	6003      	str	r3, [r0, #0]
  
  /*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8008178:	6882      	ldr	r2, [r0, #8]
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 800817a:	4b1d      	ldr	r3, [pc, #116]	; (80081f0 <USART_Init+0xa8>)
 800817c:	4013      	ands	r3, r2
  
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 800817e:	696a      	ldr	r2, [r5, #20]
 8008180:	4313      	orrs	r3, r2
  
  /* Write to USART CR3 */
  USARTx->CR3 = tmpreg;
 8008182:	6083      	str	r3, [r0, #8]
  
  /*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8008184:	4668      	mov	r0, sp
 8008186:	f7fe f973 	bl	8006470 <RCC_GetClocksFreq>
  
  if (USARTx == USART1)
 800818a:	4b1a      	ldr	r3, [pc, #104]	; (80081f4 <USART_Init+0xac>)
 800818c:	429c      	cmp	r4, r3
 800818e:	d025      	beq.n	80081dc <USART_Init+0x94>
  {
    apbclock = RCC_ClocksStatus.USART1CLK_Frequency;
  }
  else if (USARTx == USART2)
 8008190:	4b19      	ldr	r3, [pc, #100]	; (80081f8 <USART_Init+0xb0>)
 8008192:	429c      	cmp	r4, r3
 8008194:	d024      	beq.n	80081e0 <USART_Init+0x98>
  {
    apbclock = RCC_ClocksStatus.USART2CLK_Frequency;
  }
   else if (USARTx == USART3)
 8008196:	4b19      	ldr	r3, [pc, #100]	; (80081fc <USART_Init+0xb4>)
 8008198:	429c      	cmp	r4, r3
 800819a:	d023      	beq.n	80081e4 <USART_Init+0x9c>
  {
    apbclock = RCC_ClocksStatus.USART3CLK_Frequency;
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK_Frequency;
 800819c:	9f02      	ldr	r7, [sp, #8]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 800819e:	6823      	ldr	r3, [r4, #0]
 80081a0:	041b      	lsls	r3, r3, #16
 80081a2:	d500      	bpl.n	80081a6 <USART_Init+0x5e>
  {
    /* (divider * 10) computing in case Oversampling mode is 8 Samples */
    divider = (uint32_t)((2 * apbclock) / (USART_InitStruct->USART_BaudRate));
 80081a4:	007f      	lsls	r7, r7, #1
    tmpreg  = (uint32_t)((2 * apbclock) % (USART_InitStruct->USART_BaudRate));
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* (divider * 10) computing in case Oversampling mode is 16 Samples */
    divider = (uint32_t)((apbclock) / (USART_InitStruct->USART_BaudRate));
 80081a6:	682e      	ldr	r6, [r5, #0]
 80081a8:	1c38      	adds	r0, r7, #0
 80081aa:	1c31      	adds	r1, r6, #0
 80081ac:	f7fb fae2 	bl	8003774 <__aeabi_uidiv>
    tmpreg  = (uint32_t)((apbclock) % (USART_InitStruct->USART_BaudRate));
 80081b0:	1c31      	adds	r1, r6, #0
    tmpreg  = (uint32_t)((2 * apbclock) % (USART_InitStruct->USART_BaudRate));
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* (divider * 10) computing in case Oversampling mode is 16 Samples */
    divider = (uint32_t)((apbclock) / (USART_InitStruct->USART_BaudRate));
 80081b2:	1c05      	adds	r5, r0, #0
    tmpreg  = (uint32_t)((apbclock) % (USART_InitStruct->USART_BaudRate));
 80081b4:	1c38      	adds	r0, r7, #0
 80081b6:	f7fb fb63 	bl	8003880 <__aeabi_uidivmod>
  }
  
  /* round the divider : if fractional part i greater than 0.5 increment divider */
  if (tmpreg >=  (USART_InitStruct->USART_BaudRate) / 2)
  {
    divider++;
 80081ba:	2300      	movs	r3, #0
    divider = (uint32_t)((apbclock) / (USART_InitStruct->USART_BaudRate));
    tmpreg  = (uint32_t)((apbclock) % (USART_InitStruct->USART_BaudRate));
  }
  
  /* round the divider : if fractional part i greater than 0.5 increment divider */
  if (tmpreg >=  (USART_InitStruct->USART_BaudRate) / 2)
 80081bc:	0876      	lsrs	r6, r6, #1
  {
    divider++;
 80081be:	42b1      	cmp	r1, r6
 80081c0:	415b      	adcs	r3, r3
 80081c2:	18ed      	adds	r5, r5, r3
  } 
  
  /* Implement the divider in case Oversampling mode is 8 Samples */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 80081c4:	6823      	ldr	r3, [r4, #0]
 80081c6:	041b      	lsls	r3, r3, #16
 80081c8:	d504      	bpl.n	80081d4 <USART_Init+0x8c>
  {
    /* get the LSB of divider and shift it to the right by 1 bit */
    tmpreg = (divider & (uint16_t)0x000F) >> 1;
    
    /* update the divider value */
    divider = (divider & (uint16_t)0xFFF0) | tmpreg;
 80081ca:	4b0d      	ldr	r3, [pc, #52]	; (8008200 <USART_Init+0xb8>)
  
  /* Implement the divider in case Oversampling mode is 8 Samples */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
  {
    /* get the LSB of divider and shift it to the right by 1 bit */
    tmpreg = (divider & (uint16_t)0x000F) >> 1;
 80081cc:	072a      	lsls	r2, r5, #28
 80081ce:	0f52      	lsrs	r2, r2, #29
    
    /* update the divider value */
    divider = (divider & (uint16_t)0xFFF0) | tmpreg;
 80081d0:	401d      	ands	r5, r3
 80081d2:	4315      	orrs	r5, r2
  }
  
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)divider;
 80081d4:	b2ad      	uxth	r5, r5
 80081d6:	81a5      	strh	r5, [r4, #12]
}
 80081d8:	b00b      	add	sp, #44	; 0x2c
 80081da:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
  
  if (USARTx == USART1)
  {
    apbclock = RCC_ClocksStatus.USART1CLK_Frequency;
 80081dc:	9f06      	ldr	r7, [sp, #24]
 80081de:	e7de      	b.n	800819e <USART_Init+0x56>
  }
  else if (USARTx == USART2)
  {
    apbclock = RCC_ClocksStatus.USART2CLK_Frequency;
 80081e0:	9f07      	ldr	r7, [sp, #28]
 80081e2:	e7dc      	b.n	800819e <USART_Init+0x56>
  }
   else if (USARTx == USART3)
  {
    apbclock = RCC_ClocksStatus.USART3CLK_Frequency;
 80081e4:	9f08      	ldr	r7, [sp, #32]
 80081e6:	e7da      	b.n	800819e <USART_Init+0x56>
 80081e8:	ffffcfff 	.word	0xffffcfff
 80081ec:	ffffe9f3 	.word	0xffffe9f3
 80081f0:	fffffcff 	.word	0xfffffcff
 80081f4:	40013800 	.word	0x40013800
 80081f8:	40004400 	.word	0x40004400
 80081fc:	40004800 	.word	0x40004800
 8008200:	0000fff0 	.word	0x0000fff0

08008204 <USART_StructInit>:
  * @retval None
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
 8008204:	2396      	movs	r3, #150	; 0x96
 8008206:	019b      	lsls	r3, r3, #6
 8008208:	6003      	str	r3, [r0, #0]
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
  USART_InitStruct->USART_Parity = USART_Parity_No ;
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 800820a:	220c      	movs	r2, #12
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 800820c:	2300      	movs	r3, #0
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
  USART_InitStruct->USART_Parity = USART_Parity_No ;
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 800820e:	6102      	str	r2, [r0, #16]
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 8008210:	6043      	str	r3, [r0, #4]
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
 8008212:	6083      	str	r3, [r0, #8]
  USART_InitStruct->USART_Parity = USART_Parity_No ;
 8008214:	60c3      	str	r3, [r0, #12]
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 8008216:	6143      	str	r3, [r0, #20]
}
 8008218:	4770      	bx	lr
 800821a:	46c0      	nop			; (mov r8, r8)

0800821c <USART_ClockInit>:
  assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 800821c:	6842      	ldr	r2, [r0, #4]
  /* Clear CLKEN, CPOL, CPHA, LBCL and SSM bits */
  tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 800821e:	4b06      	ldr	r3, [pc, #24]	; (8008238 <USART_ClockInit+0x1c>)
  *         structure that contains the configuration information for the specified 
  *         USART peripheral.  
  * @retval None
  */
void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
{
 8008220:	b510      	push	{r4, lr}
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear CLKEN, CPOL, CPHA, LBCL and SSM bits */
  tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 8008222:	401a      	ands	r2, r3
  /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 8008224:	680c      	ldr	r4, [r1, #0]
 8008226:	684b      	ldr	r3, [r1, #4]
 8008228:	4323      	orrs	r3, r4
 800822a:	688c      	ldr	r4, [r1, #8]
 800822c:	68c9      	ldr	r1, [r1, #12]
 800822e:	4323      	orrs	r3, r4
 8008230:	430b      	orrs	r3, r1
 8008232:	4313      	orrs	r3, r2
                       USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit);
  /* Write to USART CR2 */
  USARTx->CR2 = tmpreg;
 8008234:	6043      	str	r3, [r0, #4]
}
 8008236:	bd10      	pop	{r4, pc}
 8008238:	fffff0ff 	.word	0xfffff0ff

0800823c <USART_ClockStructInit>:
  * @retval None
  */
void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
{
  /* USART_ClockInitStruct members default value */
  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 800823c:	2300      	movs	r3, #0
 800823e:	6003      	str	r3, [r0, #0]
  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 8008240:	6043      	str	r3, [r0, #4]
  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 8008242:	6083      	str	r3, [r0, #8]
  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 8008244:	60c3      	str	r3, [r0, #12]
}
 8008246:	4770      	bx	lr

08008248 <USART_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8008248:	2900      	cmp	r1, #0
 800824a:	d104      	bne.n	8008256 <USART_Cmd+0xe>
    USARTx->CR1 |= USART_CR1_UE;
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 800824c:	2201      	movs	r2, #1
 800824e:	6803      	ldr	r3, [r0, #0]
 8008250:	4393      	bics	r3, r2
 8008252:	6003      	str	r3, [r0, #0]
  }
}
 8008254:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 8008256:	2301      	movs	r3, #1
 8008258:	6802      	ldr	r2, [r0, #0]
 800825a:	4313      	orrs	r3, r2
 800825c:	6003      	str	r3, [r0, #0]
 800825e:	e7f9      	b.n	8008254 <USART_Cmd+0xc>

08008260 <USART_DirectionModeCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the USART's transfer interface by setting the TE and/or RE bits 
       in the USART CR1 register */
    USARTx->CR1 |= USART_DirectionMode;
 8008260:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_MODE(USART_DirectionMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 8008262:	2a00      	cmp	r2, #0
 8008264:	d102      	bne.n	800826c <USART_DirectionModeCmd+0xc>
  }
  else
  {
    /* Disable the USART's transfer interface by clearing the TE and/or RE bits
       in the USART CR3 register */
    USARTx->CR1 &= (uint32_t)~USART_DirectionMode;
 8008266:	438b      	bics	r3, r1
 8008268:	6003      	str	r3, [r0, #0]
  }
}
 800826a:	4770      	bx	lr

  if (NewState != DISABLE)
  {
    /* Enable the USART's transfer interface by setting the TE and/or RE bits 
       in the USART CR1 register */
    USARTx->CR1 |= USART_DirectionMode;
 800826c:	4319      	orrs	r1, r3
 800826e:	6001      	str	r1, [r0, #0]
 8008270:	e7fb      	b.n	800826a <USART_DirectionModeCmd+0xa>
 8008272:	46c0      	nop			; (mov r8, r8)

08008274 <USART_OverSampling8Cmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8008274:	2900      	cmp	r1, #0
 8008276:	d104      	bne.n	8008282 <USART_OverSampling8Cmd+0xe>
    USARTx->CR1 |= USART_CR1_OVER8;
  }
  else
  {
    /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_OVER8);
 8008278:	6802      	ldr	r2, [r0, #0]
 800827a:	4b05      	ldr	r3, [pc, #20]	; (8008290 <USART_OverSampling8Cmd+0x1c>)
 800827c:	4013      	ands	r3, r2
 800827e:	6003      	str	r3, [r0, #0]
  }
}  
 8008280:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_OVER8;
 8008282:	2280      	movs	r2, #128	; 0x80
 8008284:	6803      	ldr	r3, [r0, #0]
 8008286:	0212      	lsls	r2, r2, #8
 8008288:	4313      	orrs	r3, r2
 800828a:	6003      	str	r3, [r0, #0]
 800828c:	e7f8      	b.n	8008280 <USART_OverSampling8Cmd+0xc>
 800828e:	46c0      	nop			; (mov r8, r8)
 8008290:	ffff7fff 	.word	0xffff7fff

08008294 <USART_OneBitMethodCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8008294:	2900      	cmp	r1, #0
 8008296:	d104      	bne.n	80082a2 <USART_OneBitMethodCmd+0xe>
    USARTx->CR3 |= USART_CR3_ONEBIT;
  }
  else
  {
    /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_ONEBIT);
 8008298:	6882      	ldr	r2, [r0, #8]
 800829a:	4b05      	ldr	r3, [pc, #20]	; (80082b0 <USART_OneBitMethodCmd+0x1c>)
 800829c:	4013      	ands	r3, r2
 800829e:	6083      	str	r3, [r0, #8]
  }
}
 80082a0:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_ONEBIT;
 80082a2:	2280      	movs	r2, #128	; 0x80
 80082a4:	6883      	ldr	r3, [r0, #8]
 80082a6:	0112      	lsls	r2, r2, #4
 80082a8:	4313      	orrs	r3, r2
 80082aa:	6083      	str	r3, [r0, #8]
 80082ac:	e7f8      	b.n	80082a0 <USART_OneBitMethodCmd+0xc>
 80082ae:	46c0      	nop			; (mov r8, r8)
 80082b0:	fffff7ff 	.word	0xfffff7ff

080082b4 <USART_MSBFirstCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80082b4:	2900      	cmp	r1, #0
 80082b6:	d104      	bne.n	80082c2 <USART_MSBFirstCmd+0xe>
  }
  else
  {
    /* Disable the most significant bit first transmitted/received following the 
       start bit by clearing the MSBFIRST bit in the CR2 register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_MSBFIRST);
 80082b8:	6842      	ldr	r2, [r0, #4]
 80082ba:	4b05      	ldr	r3, [pc, #20]	; (80082d0 <USART_MSBFirstCmd+0x1c>)
 80082bc:	4013      	ands	r3, r2
 80082be:	6043      	str	r3, [r0, #4]
  }
}
 80082c0:	4770      	bx	lr
  
  if (NewState != DISABLE)
  {
    /* Enable the most significant bit first transmitted/received following the 
       start bit by setting the MSBFIRST bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_MSBFIRST;
 80082c2:	2280      	movs	r2, #128	; 0x80
 80082c4:	6843      	ldr	r3, [r0, #4]
 80082c6:	0312      	lsls	r2, r2, #12
 80082c8:	4313      	orrs	r3, r2
 80082ca:	6043      	str	r3, [r0, #4]
 80082cc:	e7f8      	b.n	80082c0 <USART_MSBFirstCmd+0xc>
 80082ce:	46c0      	nop			; (mov r8, r8)
 80082d0:	fff7ffff 	.word	0xfff7ffff

080082d4 <USART_DataInvCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80082d4:	2900      	cmp	r1, #0
 80082d6:	d104      	bne.n	80082e2 <USART_DataInvCmd+0xe>
  }
  else
  {
    /* Disable the binary data inversion feature by clearing the DATAINV bit in 
       the CR2 register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_DATAINV);
 80082d8:	6842      	ldr	r2, [r0, #4]
 80082da:	4b05      	ldr	r3, [pc, #20]	; (80082f0 <USART_DataInvCmd+0x1c>)
 80082dc:	4013      	ands	r3, r2
 80082de:	6043      	str	r3, [r0, #4]
  }
}
 80082e0:	4770      	bx	lr

  if (NewState != DISABLE)
  {
    /* Enable the binary data inversion feature by setting the DATAINV bit in 
       the CR2 register */
    USARTx->CR2 |= USART_CR2_DATAINV;
 80082e2:	2280      	movs	r2, #128	; 0x80
 80082e4:	6843      	ldr	r3, [r0, #4]
 80082e6:	02d2      	lsls	r2, r2, #11
 80082e8:	4313      	orrs	r3, r2
 80082ea:	6043      	str	r3, [r0, #4]
 80082ec:	e7f8      	b.n	80082e0 <USART_DataInvCmd+0xc>
 80082ee:	46c0      	nop			; (mov r8, r8)
 80082f0:	fffbffff 	.word	0xfffbffff

080082f4 <USART_InvPinCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the active level inversion for selected pins by setting the TXINV 
       and/or RXINV bits in the USART CR2 register */
    USARTx->CR2 |= USART_InvPin;
 80082f4:	6843      	ldr	r3, [r0, #4]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_INVERSTION_PIN(USART_InvPin));  
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 80082f6:	2a00      	cmp	r2, #0
 80082f8:	d102      	bne.n	8008300 <USART_InvPinCmd+0xc>
  }
  else
  {
    /* Disable the active level inversion for selected requests by clearing the 
       TXINV and/or RXINV bits in the USART CR2 register */
    USARTx->CR2 &= (uint32_t)~USART_InvPin;
 80082fa:	438b      	bics	r3, r1
 80082fc:	6043      	str	r3, [r0, #4]
  }
}
 80082fe:	4770      	bx	lr

  if (NewState != DISABLE)
  {
    /* Enable the active level inversion for selected pins by setting the TXINV 
       and/or RXINV bits in the USART CR2 register */
    USARTx->CR2 |= USART_InvPin;
 8008300:	4319      	orrs	r1, r3
 8008302:	6041      	str	r1, [r0, #4]
 8008304:	e7fb      	b.n	80082fe <USART_InvPinCmd+0xa>
 8008306:	46c0      	nop			; (mov r8, r8)

08008308 <USART_SWAPPinCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008308:	2900      	cmp	r1, #0
 800830a:	d104      	bne.n	8008316 <USART_SWAPPinCmd+0xe>
    USARTx->CR2 |= USART_CR2_SWAP;
  }
  else
  {
    /* Disable the SWAP feature by clearing the SWAP bit in the CR2 register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_SWAP);
 800830c:	6842      	ldr	r2, [r0, #4]
 800830e:	4b05      	ldr	r3, [pc, #20]	; (8008324 <USART_SWAPPinCmd+0x1c>)
 8008310:	4013      	ands	r3, r2
 8008312:	6043      	str	r3, [r0, #4]
  }
}
 8008314:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the SWAP feature by setting the SWAP bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_SWAP;
 8008316:	2280      	movs	r2, #128	; 0x80
 8008318:	6843      	ldr	r3, [r0, #4]
 800831a:	0212      	lsls	r2, r2, #8
 800831c:	4313      	orrs	r3, r2
 800831e:	6043      	str	r3, [r0, #4]
 8008320:	e7f8      	b.n	8008314 <USART_SWAPPinCmd+0xc>
 8008322:	46c0      	nop			; (mov r8, r8)
 8008324:	ffff7fff 	.word	0xffff7fff

08008328 <USART_ReceiverTimeOutCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008328:	2900      	cmp	r1, #0
 800832a:	d104      	bne.n	8008336 <USART_ReceiverTimeOutCmd+0xe>
  }
  else
  {
    /* Disable the receiver time out feature by clearing the RTOEN bit in the CR2 
       register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_RTOEN);
 800832c:	6842      	ldr	r2, [r0, #4]
 800832e:	4b05      	ldr	r3, [pc, #20]	; (8008344 <USART_ReceiverTimeOutCmd+0x1c>)
 8008330:	4013      	ands	r3, r2
 8008332:	6043      	str	r3, [r0, #4]
  }
}
 8008334:	4770      	bx	lr

  if (NewState != DISABLE)
  {
    /* Enable the receiver time out feature by setting the RTOEN bit in the CR2 
       register */
    USARTx->CR2 |= USART_CR2_RTOEN;
 8008336:	2280      	movs	r2, #128	; 0x80
 8008338:	6843      	ldr	r3, [r0, #4]
 800833a:	0412      	lsls	r2, r2, #16
 800833c:	4313      	orrs	r3, r2
 800833e:	6043      	str	r3, [r0, #4]
 8008340:	e7f8      	b.n	8008334 <USART_ReceiverTimeOutCmd+0xc>
 8008342:	46c0      	nop			; (mov r8, r8)
 8008344:	ff7fffff 	.word	0xff7fffff

08008348 <USART_SetReceiverTimeOut>:
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_USART_TIMEOUT(USART_ReceiverTimeOut));

  /* Clear the receiver Time Out value by clearing the RTO[23:0] bits in the RTOR
     register  */
  USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_RTO);
 8008348:	6943      	ldr	r3, [r0, #20]
 800834a:	0e1b      	lsrs	r3, r3, #24
 800834c:	061b      	lsls	r3, r3, #24
 800834e:	6143      	str	r3, [r0, #20]
  /* Set the receiver Time Out value by setting the RTO[23:0] bits in the RTOR
     register  */
  USARTx->RTOR |= USART_ReceiverTimeOut;
 8008350:	6943      	ldr	r3, [r0, #20]
 8008352:	4319      	orrs	r1, r3
 8008354:	6141      	str	r1, [r0, #20]
}
 8008356:	4770      	bx	lr

08008358 <USART_SetPrescaler>:
{ 
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  
  /* Clear the USART prescaler */
  USARTx->GTPR &= USART_GTPR_GT;
 8008358:	22ff      	movs	r2, #255	; 0xff
 800835a:	8a03      	ldrh	r3, [r0, #16]
 800835c:	4393      	bics	r3, r2
 800835e:	8203      	strh	r3, [r0, #16]
  /* Set the USART prescaler */
  USARTx->GTPR |= USART_Prescaler;
 8008360:	8a03      	ldrh	r3, [r0, #16]
 8008362:	4319      	orrs	r1, r3
 8008364:	8201      	strh	r1, [r0, #16]
}
 8008366:	4770      	bx	lr

08008368 <USART_STOPModeCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8008368:	2900      	cmp	r1, #0
 800836a:	d104      	bne.n	8008376 <USART_STOPModeCmd+0xe>
  }
  else
  {
    /* Disable the selected USART in STOP mode by clearing the UE bit in the CR1
       register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UESM);
 800836c:	2202      	movs	r2, #2
 800836e:	6803      	ldr	r3, [r0, #0]
 8008370:	4393      	bics	r3, r2
 8008372:	6003      	str	r3, [r0, #0]
  }
}
 8008374:	4770      	bx	lr
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART in STOP mode by setting the UESM bit in the CR1
       register */
    USARTx->CR1 |= USART_CR1_UESM;
 8008376:	2302      	movs	r3, #2
 8008378:	6802      	ldr	r2, [r0, #0]
 800837a:	4313      	orrs	r3, r2
 800837c:	6003      	str	r3, [r0, #0]
 800837e:	e7f9      	b.n	8008374 <USART_STOPModeCmd+0xc>

08008380 <USART_StopModeWakeUpSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_USART_STOPMODE_WAKEUPSOURCE(USART_WakeUpSource));

  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_WUS);
 8008380:	6882      	ldr	r2, [r0, #8]
 8008382:	4b03      	ldr	r3, [pc, #12]	; (8008390 <USART_StopModeWakeUpSourceConfig+0x10>)
 8008384:	4013      	ands	r3, r2
 8008386:	6083      	str	r3, [r0, #8]
  USARTx->CR3 |= USART_WakeUpSource;
 8008388:	6883      	ldr	r3, [r0, #8]
 800838a:	4319      	orrs	r1, r3
 800838c:	6081      	str	r1, [r0, #8]
}
 800838e:	4770      	bx	lr
 8008390:	ffcfffff 	.word	0xffcfffff

08008394 <USART_AutoBaudRateCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008394:	2900      	cmp	r1, #0
 8008396:	d104      	bne.n	80083a2 <USART_AutoBaudRateCmd+0xe>
  }
  else
  {
    /* Disable the auto baud rate feature by clearing the ABREN bit in the CR2 
       register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABREN);
 8008398:	6842      	ldr	r2, [r0, #4]
 800839a:	4b05      	ldr	r3, [pc, #20]	; (80083b0 <USART_AutoBaudRateCmd+0x1c>)
 800839c:	4013      	ands	r3, r2
 800839e:	6043      	str	r3, [r0, #4]
  }
}
 80083a0:	4770      	bx	lr

  if (NewState != DISABLE)
  {
    /* Enable the auto baud rate feature by setting the ABREN bit in the CR2 
       register */
    USARTx->CR2 |= USART_CR2_ABREN;
 80083a2:	2280      	movs	r2, #128	; 0x80
 80083a4:	6843      	ldr	r3, [r0, #4]
 80083a6:	0352      	lsls	r2, r2, #13
 80083a8:	4313      	orrs	r3, r2
 80083aa:	6043      	str	r3, [r0, #4]
 80083ac:	e7f8      	b.n	80083a0 <USART_AutoBaudRateCmd+0xc>
 80083ae:	46c0      	nop			; (mov r8, r8)
 80083b0:	ffefffff 	.word	0xffefffff

080083b4 <USART_AutoBaudRateConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_USART_AUTOBAUDRATE_MODE(USART_AutoBaudRate));

  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABRMODE);
 80083b4:	6842      	ldr	r2, [r0, #4]
 80083b6:	4b03      	ldr	r3, [pc, #12]	; (80083c4 <USART_AutoBaudRateConfig+0x10>)
 80083b8:	4013      	ands	r3, r2
 80083ba:	6043      	str	r3, [r0, #4]
  USARTx->CR2 |= USART_AutoBaudRate;
 80083bc:	6843      	ldr	r3, [r0, #4]
 80083be:	4319      	orrs	r1, r3
 80083c0:	6041      	str	r1, [r0, #4]
}
 80083c2:	4770      	bx	lr
 80083c4:	ff9fffff 	.word	0xff9fffff

080083c8 <USART_SendData>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->TDR = (Data & (uint16_t)0x01FF);
 80083c8:	05c9      	lsls	r1, r1, #23
 80083ca:	0dc9      	lsrs	r1, r1, #23
 80083cc:	8501      	strh	r1, [r0, #40]	; 0x28
}
 80083ce:	4770      	bx	lr

080083d0 <USART_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Receive Data */
  return (uint16_t)(USARTx->RDR & (uint16_t)0x01FF);
 80083d0:	8c80      	ldrh	r0, [r0, #36]	; 0x24
 80083d2:	05c0      	lsls	r0, r0, #23
 80083d4:	0dc0      	lsrs	r0, r0, #23
}
 80083d6:	4770      	bx	lr

080083d8 <USART_SetAddress>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Clear the USART address */
  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADD);
 80083d8:	6843      	ldr	r3, [r0, #4]
  /* Set the USART address node */
  USARTx->CR2 |=((uint32_t)USART_Address << (uint32_t)0x18);
 80083da:	0609      	lsls	r1, r1, #24
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Clear the USART address */
  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADD);
 80083dc:	021b      	lsls	r3, r3, #8
 80083de:	0a1b      	lsrs	r3, r3, #8
 80083e0:	6043      	str	r3, [r0, #4]
  /* Set the USART address node */
  USARTx->CR2 |=((uint32_t)USART_Address << (uint32_t)0x18);
 80083e2:	6843      	ldr	r3, [r0, #4]
 80083e4:	4319      	orrs	r1, r3
 80083e6:	6041      	str	r1, [r0, #4]
}
 80083e8:	4770      	bx	lr
 80083ea:	46c0      	nop			; (mov r8, r8)

080083ec <USART_MuteModeCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
 80083ec:	2900      	cmp	r1, #0
 80083ee:	d104      	bne.n	80083fa <USART_MuteModeCmd+0xe>
    USARTx->CR1 |= USART_CR1_MME;
  }
  else
  {
    /* Disable the USART mute mode by clearing the MME bit in the CR1 register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_MME);
 80083f0:	6802      	ldr	r2, [r0, #0]
 80083f2:	4b05      	ldr	r3, [pc, #20]	; (8008408 <USART_MuteModeCmd+0x1c>)
 80083f4:	4013      	ands	r3, r2
 80083f6:	6003      	str	r3, [r0, #0]
  }
}
 80083f8:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
  {
    /* Enable the USART mute mode by setting the MME bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_MME;
 80083fa:	2280      	movs	r2, #128	; 0x80
 80083fc:	6803      	ldr	r3, [r0, #0]
 80083fe:	0192      	lsls	r2, r2, #6
 8008400:	4313      	orrs	r3, r2
 8008402:	6003      	str	r3, [r0, #0]
 8008404:	e7f8      	b.n	80083f8 <USART_MuteModeCmd+0xc>
 8008406:	46c0      	nop			; (mov r8, r8)
 8008408:	ffffdfff 	.word	0xffffdfff

0800840c <USART_MuteModeWakeUpConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_MUTEMODE_WAKEUP(USART_WakeUp));

  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_WAKE);
 800840c:	6802      	ldr	r2, [r0, #0]
 800840e:	4b03      	ldr	r3, [pc, #12]	; (800841c <USART_MuteModeWakeUpConfig+0x10>)
 8008410:	4013      	ands	r3, r2
 8008412:	6003      	str	r3, [r0, #0]
  USARTx->CR1 |= USART_WakeUp;
 8008414:	6803      	ldr	r3, [r0, #0]
 8008416:	4319      	orrs	r1, r3
 8008418:	6001      	str	r1, [r0, #0]
}
 800841a:	4770      	bx	lr
 800841c:	fffff7ff 	.word	0xfffff7ff

08008420 <USART_AddressDetectionConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_ADDRESS_DETECTION(USART_AddressLength));

  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADDM7);
 8008420:	2210      	movs	r2, #16
 8008422:	6843      	ldr	r3, [r0, #4]
 8008424:	4393      	bics	r3, r2
 8008426:	6043      	str	r3, [r0, #4]
  USARTx->CR2 |= USART_AddressLength;
 8008428:	6843      	ldr	r3, [r0, #4]
 800842a:	4319      	orrs	r1, r3
 800842c:	6041      	str	r1, [r0, #4]
}
 800842e:	4770      	bx	lr

08008430 <USART_LINBreakDetectLengthConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));

  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LBDL);
 8008430:	2220      	movs	r2, #32
 8008432:	6843      	ldr	r3, [r0, #4]
 8008434:	4393      	bics	r3, r2
 8008436:	6043      	str	r3, [r0, #4]
  USARTx->CR2 |= USART_LINBreakDetectLength;  
 8008438:	6843      	ldr	r3, [r0, #4]
 800843a:	4319      	orrs	r1, r3
 800843c:	6041      	str	r1, [r0, #4]
}
 800843e:	4770      	bx	lr

08008440 <USART_LINCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008440:	2900      	cmp	r1, #0
 8008442:	d104      	bne.n	800844e <USART_LINCmd+0xe>
    USARTx->CR2 |= USART_CR2_LINEN;
  }
  else
  {
    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LINEN);
 8008444:	6842      	ldr	r2, [r0, #4]
 8008446:	4b05      	ldr	r3, [pc, #20]	; (800845c <USART_LINCmd+0x1c>)
 8008448:	4013      	ands	r3, r2
 800844a:	6043      	str	r3, [r0, #4]
  }
}
 800844c:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_LINEN;
 800844e:	2280      	movs	r2, #128	; 0x80
 8008450:	6843      	ldr	r3, [r0, #4]
 8008452:	01d2      	lsls	r2, r2, #7
 8008454:	4313      	orrs	r3, r2
 8008456:	6043      	str	r3, [r0, #4]
 8008458:	e7f8      	b.n	800844c <USART_LINCmd+0xc>
 800845a:	46c0      	nop			; (mov r8, r8)
 800845c:	ffffbfff 	.word	0xffffbfff

08008460 <USART_HalfDuplexCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8008460:	2900      	cmp	r1, #0
 8008462:	d104      	bne.n	800846e <USART_HalfDuplexCmd+0xe>
    USARTx->CR3 |= USART_CR3_HDSEL;
  }
  else
  {
    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_HDSEL);
 8008464:	2208      	movs	r2, #8
 8008466:	6883      	ldr	r3, [r0, #8]
 8008468:	4393      	bics	r3, r2
 800846a:	6083      	str	r3, [r0, #8]
  }
}
 800846c:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_HDSEL;
 800846e:	2308      	movs	r3, #8
 8008470:	6882      	ldr	r2, [r0, #8]
 8008472:	4313      	orrs	r3, r2
 8008474:	6083      	str	r3, [r0, #8]
 8008476:	e7f9      	b.n	800846c <USART_HalfDuplexCmd+0xc>

08008478 <USART_SetGuardTime>:
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));

  /* Clear the USART Guard time */
  USARTx->GTPR &= USART_GTPR_PSC;
 8008478:	22ff      	movs	r2, #255	; 0xff
 800847a:	8a03      	ldrh	r3, [r0, #16]
  /* Set the USART guard time */
  USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 800847c:	0209      	lsls	r1, r1, #8
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));

  /* Clear the USART Guard time */
  USARTx->GTPR &= USART_GTPR_PSC;
 800847e:	4013      	ands	r3, r2
 8008480:	8203      	strh	r3, [r0, #16]
  /* Set the USART guard time */
  USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 8008482:	8a03      	ldrh	r3, [r0, #16]
 8008484:	4319      	orrs	r1, r3
 8008486:	8201      	strh	r1, [r0, #16]
}
 8008488:	4770      	bx	lr
 800848a:	46c0      	nop			; (mov r8, r8)

0800848c <USART_SmartCardCmd>:
void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800848c:	2900      	cmp	r1, #0
 800848e:	d104      	bne.n	800849a <USART_SmartCardCmd+0xe>
    USARTx->CR3 |= USART_CR3_SCEN;
  }
  else
  {
    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCEN);
 8008490:	2220      	movs	r2, #32
 8008492:	6883      	ldr	r3, [r0, #8]
 8008494:	4393      	bics	r3, r2
 8008496:	6083      	str	r3, [r0, #8]
  }
}
 8008498:	4770      	bx	lr
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_SCEN;
 800849a:	2320      	movs	r3, #32
 800849c:	6882      	ldr	r2, [r0, #8]
 800849e:	4313      	orrs	r3, r2
 80084a0:	6083      	str	r3, [r0, #8]
 80084a2:	e7f9      	b.n	8008498 <USART_SmartCardCmd+0xc>

080084a4 <USART_SmartCardNACKCmd>:
void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80084a4:	2900      	cmp	r1, #0
 80084a6:	d104      	bne.n	80084b2 <USART_SmartCardNACKCmd+0xe>
    USARTx->CR3 |= USART_CR3_NACK;
  }
  else
  {
    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_NACK);
 80084a8:	2210      	movs	r2, #16
 80084aa:	6883      	ldr	r3, [r0, #8]
 80084ac:	4393      	bics	r3, r2
 80084ae:	6083      	str	r3, [r0, #8]
  }
}
 80084b0:	4770      	bx	lr
  assert_param(IS_USART_123_PERIPH(USARTx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_NACK;
 80084b2:	2310      	movs	r3, #16
 80084b4:	6882      	ldr	r2, [r0, #8]
 80084b6:	4313      	orrs	r3, r2
 80084b8:	6083      	str	r3, [r0, #8]
 80084ba:	e7f9      	b.n	80084b0 <USART_SmartCardNACKCmd+0xc>

080084bc <USART_SetAutoRetryCount>:
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_USART_AUTO_RETRY_COUNTER(USART_AutoCount));
  /* Clear the USART auto retry count */
  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCARCNT);
 80084bc:	6882      	ldr	r2, [r0, #8]
 80084be:	4b04      	ldr	r3, [pc, #16]	; (80084d0 <USART_SetAutoRetryCount+0x14>)
  /* Set the USART auto retry count*/
  USARTx->CR3 |= (uint32_t)((uint32_t)USART_AutoCount << 0x11);
 80084c0:	0449      	lsls	r1, r1, #17
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_USART_AUTO_RETRY_COUNTER(USART_AutoCount));
  /* Clear the USART auto retry count */
  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCARCNT);
 80084c2:	4013      	ands	r3, r2
 80084c4:	6083      	str	r3, [r0, #8]
  /* Set the USART auto retry count*/
  USARTx->CR3 |= (uint32_t)((uint32_t)USART_AutoCount << 0x11);
 80084c6:	6883      	ldr	r3, [r0, #8]
 80084c8:	4319      	orrs	r1, r3
 80084ca:	6081      	str	r1, [r0, #8]
}
 80084cc:	4770      	bx	lr
 80084ce:	46c0      	nop			; (mov r8, r8)
 80084d0:	fff1ffff 	.word	0xfff1ffff

080084d4 <USART_SetBlockLength>:
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));

  /* Clear the Smart card block length */
  USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_BLEN);
 80084d4:	6943      	ldr	r3, [r0, #20]
  /* Set the Smart Card block length */
  USARTx->RTOR |= (uint32_t)((uint32_t)USART_BlockLength << 0x18);
 80084d6:	0609      	lsls	r1, r1, #24
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));

  /* Clear the Smart card block length */
  USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_BLEN);
 80084d8:	021b      	lsls	r3, r3, #8
 80084da:	0a1b      	lsrs	r3, r3, #8
 80084dc:	6143      	str	r3, [r0, #20]
  /* Set the Smart Card block length */
  USARTx->RTOR |= (uint32_t)((uint32_t)USART_BlockLength << 0x18);
 80084de:	6943      	ldr	r3, [r0, #20]
 80084e0:	4319      	orrs	r1, r3
 80084e2:	6141      	str	r1, [r0, #20]
}
 80084e4:	4770      	bx	lr
 80084e6:	46c0      	nop			; (mov r8, r8)

080084e8 <USART_IrDAConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));

  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IRLP);
 80084e8:	2204      	movs	r2, #4
 80084ea:	6883      	ldr	r3, [r0, #8]
 80084ec:	4393      	bics	r3, r2
 80084ee:	6083      	str	r3, [r0, #8]
  USARTx->CR3 |= USART_IrDAMode;
 80084f0:	6883      	ldr	r3, [r0, #8]
 80084f2:	4319      	orrs	r1, r3
 80084f4:	6081      	str	r1, [r0, #8]
}
 80084f6:	4770      	bx	lr

080084f8 <USART_IrDACmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80084f8:	2900      	cmp	r1, #0
 80084fa:	d104      	bne.n	8008506 <USART_IrDACmd+0xe>
    USARTx->CR3 |= USART_CR3_IREN;
  }
  else
  {
    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IREN);
 80084fc:	2202      	movs	r2, #2
 80084fe:	6883      	ldr	r3, [r0, #8]
 8008500:	4393      	bics	r3, r2
 8008502:	6083      	str	r3, [r0, #8]
  }
}
 8008504:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_IREN;
 8008506:	2302      	movs	r3, #2
 8008508:	6882      	ldr	r2, [r0, #8]
 800850a:	4313      	orrs	r3, r2
 800850c:	6083      	str	r3, [r0, #8]
 800850e:	e7f9      	b.n	8008504 <USART_IrDACmd+0xc>

08008510 <USART_DECmd>:
void USART_DECmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008510:	2900      	cmp	r1, #0
 8008512:	d104      	bne.n	800851e <USART_DECmd+0xe>
    USARTx->CR3 |= USART_CR3_DEM;
  }
  else
  {
    /* Disable the DE functionality by clearing the DEM bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEM);
 8008514:	6882      	ldr	r2, [r0, #8]
 8008516:	4b05      	ldr	r3, [pc, #20]	; (800852c <USART_DECmd+0x1c>)
 8008518:	4013      	ands	r3, r2
 800851a:	6083      	str	r3, [r0, #8]
  }
}
 800851c:	4770      	bx	lr
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the DE functionality by setting the DEM bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_DEM;
 800851e:	2280      	movs	r2, #128	; 0x80
 8008520:	6883      	ldr	r3, [r0, #8]
 8008522:	01d2      	lsls	r2, r2, #7
 8008524:	4313      	orrs	r3, r2
 8008526:	6083      	str	r3, [r0, #8]
 8008528:	e7f8      	b.n	800851c <USART_DECmd+0xc>
 800852a:	46c0      	nop			; (mov r8, r8)
 800852c:	ffffbfff 	.word	0xffffbfff

08008530 <USART_DEPolarityConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DE_POLARITY(USART_DEPolarity));

  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEP);
 8008530:	6882      	ldr	r2, [r0, #8]
 8008532:	4b03      	ldr	r3, [pc, #12]	; (8008540 <USART_DEPolarityConfig+0x10>)
 8008534:	4013      	ands	r3, r2
 8008536:	6083      	str	r3, [r0, #8]
  USARTx->CR3 |= USART_DEPolarity;
 8008538:	6883      	ldr	r3, [r0, #8]
 800853a:	4319      	orrs	r1, r3
 800853c:	6081      	str	r1, [r0, #8]
}
 800853e:	4770      	bx	lr
 8008540:	ffff7fff 	.word	0xffff7fff

08008544 <USART_SetDEAssertionTime>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEAssertionTime)); 

  /* Clear the DE assertion time */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEAT);
 8008544:	6802      	ldr	r2, [r0, #0]
 8008546:	4b04      	ldr	r3, [pc, #16]	; (8008558 <USART_SetDEAssertionTime+0x14>)
  /* Set the new value for the DE assertion time */
  USARTx->CR1 |=((uint32_t)USART_DEAssertionTime << (uint32_t)0x15);
 8008548:	0549      	lsls	r1, r1, #21
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEAssertionTime)); 

  /* Clear the DE assertion time */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEAT);
 800854a:	4013      	ands	r3, r2
 800854c:	6003      	str	r3, [r0, #0]
  /* Set the new value for the DE assertion time */
  USARTx->CR1 |=((uint32_t)USART_DEAssertionTime << (uint32_t)0x15);
 800854e:	6803      	ldr	r3, [r0, #0]
 8008550:	4319      	orrs	r1, r3
 8008552:	6001      	str	r1, [r0, #0]
}
 8008554:	4770      	bx	lr
 8008556:	46c0      	nop			; (mov r8, r8)
 8008558:	fc1fffff 	.word	0xfc1fffff

0800855c <USART_SetDEDeassertionTime>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEDeassertionTime)); 

  /* Clear the DE deassertion time */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEDT);
 800855c:	6802      	ldr	r2, [r0, #0]
 800855e:	4b04      	ldr	r3, [pc, #16]	; (8008570 <USART_SetDEDeassertionTime+0x14>)
  /* Set the new value for the DE deassertion time */
  USARTx->CR1 |=((uint32_t)USART_DEDeassertionTime << (uint32_t)0x10);
 8008560:	0409      	lsls	r1, r1, #16
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEDeassertionTime)); 

  /* Clear the DE deassertion time */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEDT);
 8008562:	4013      	ands	r3, r2
 8008564:	6003      	str	r3, [r0, #0]
  /* Set the new value for the DE deassertion time */
  USARTx->CR1 |=((uint32_t)USART_DEDeassertionTime << (uint32_t)0x10);
 8008566:	6803      	ldr	r3, [r0, #0]
 8008568:	4319      	orrs	r1, r3
 800856a:	6001      	str	r1, [r0, #0]
}
 800856c:	4770      	bx	lr
 800856e:	46c0      	nop			; (mov r8, r8)
 8008570:	ffe0ffff 	.word	0xffe0ffff

08008574 <USART_DMACmd>:

  if (NewState != DISABLE)
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 8008574:	6883      	ldr	r3, [r0, #8]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 8008576:	2a00      	cmp	r2, #0
 8008578:	d102      	bne.n	8008580 <USART_DMACmd+0xc>
  }
  else
  {
    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 &= (uint32_t)~USART_DMAReq;
 800857a:	438b      	bics	r3, r1
 800857c:	6083      	str	r3, [r0, #8]
  }
}
 800857e:	4770      	bx	lr

  if (NewState != DISABLE)
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 8008580:	4319      	orrs	r1, r3
 8008582:	6081      	str	r1, [r0, #8]
 8008584:	e7fb      	b.n	800857e <USART_DMACmd+0xa>
 8008586:	46c0      	nop			; (mov r8, r8)

08008588 <USART_DMAReceptionErrorConfig>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DMAONERROR(USART_DMAOnError)); 
  
  /* Clear the DMA Reception error detection bit */
  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DDRE);
 8008588:	6882      	ldr	r2, [r0, #8]
 800858a:	4b03      	ldr	r3, [pc, #12]	; (8008598 <USART_DMAReceptionErrorConfig+0x10>)
 800858c:	4013      	ands	r3, r2
 800858e:	6083      	str	r3, [r0, #8]
  /* Set the new value for the DMA Reception error detection bit */
  USARTx->CR3 |= USART_DMAOnError;
 8008590:	6883      	ldr	r3, [r0, #8]
 8008592:	4319      	orrs	r1, r3
 8008594:	6081      	str	r1, [r0, #8]
}
 8008596:	4770      	bx	lr
 8008598:	ffffdfff 	.word	0xffffdfff

0800859c <USART_ITConfig>:
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
  
  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
 800859c:	23ff      	movs	r3, #255	; 0xff
  * @param  NewState: new state of the specified USARTx interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint32_t USART_IT, FunctionalState NewState)
{
 800859e:	b510      	push	{r4, lr}
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  usartxbase = (uint32_t)USARTx;
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
 80085a0:	b28c      	uxth	r4, r1
  
  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
 80085a2:	4019      	ands	r1, r3
  itmask = (((uint32_t)0x01) << itpos);
 80085a4:	3bfe      	subs	r3, #254	; 0xfe
 80085a6:	408b      	lsls	r3, r1
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  usartxbase = (uint32_t)USARTx;
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
 80085a8:	0a24      	lsrs	r4, r4, #8
  
  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 80085aa:	1c19      	adds	r1, r3, #0
  
  if (usartreg == 0x02) /* The IT is in CR2 register */
 80085ac:	2c02      	cmp	r4, #2
 80085ae:	d00a      	beq.n	80085c6 <USART_ITConfig+0x2a>
  {
    usartxbase += 0x04;
  }
  else if (usartreg == 0x03) /* The IT is in CR3 register */
 80085b0:	2c03      	cmp	r4, #3
 80085b2:	d00a      	beq.n	80085ca <USART_ITConfig+0x2e>
  else /* The IT is in CR1 register */
  {
  }
  if (NewState != DISABLE)
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 80085b4:	6803      	ldr	r3, [r0, #0]
    usartxbase += 0x08;
  }
  else /* The IT is in CR1 register */
  {
  }
  if (NewState != DISABLE)
 80085b6:	2a00      	cmp	r2, #0
 80085b8:	d102      	bne.n	80085c0 <USART_ITConfig+0x24>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 80085ba:	438b      	bics	r3, r1
 80085bc:	6003      	str	r3, [r0, #0]
  }
}
 80085be:	bd10      	pop	{r4, pc}
  else /* The IT is in CR1 register */
  {
  }
  if (NewState != DISABLE)
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 80085c0:	4319      	orrs	r1, r3
 80085c2:	6001      	str	r1, [r0, #0]
 80085c4:	e7fb      	b.n	80085be <USART_ITConfig+0x22>
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
  
  if (usartreg == 0x02) /* The IT is in CR2 register */
  {
    usartxbase += 0x04;
 80085c6:	3004      	adds	r0, #4
 80085c8:	e7f4      	b.n	80085b4 <USART_ITConfig+0x18>
  }
  else if (usartreg == 0x03) /* The IT is in CR3 register */
  {
    usartxbase += 0x08;
 80085ca:	3008      	adds	r0, #8
 80085cc:	e7f2      	b.n	80085b4 <USART_ITConfig+0x18>
 80085ce:	46c0      	nop			; (mov r8, r8)

080085d0 <USART_RequestCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the USART ReQuest by setting the dedicated request bit in the RQR
       register.*/
      USARTx->RQR |= USART_Request;
 80085d0:	8b03      	ldrh	r3, [r0, #24]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_REQUEST(USART_Request));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 80085d2:	2a00      	cmp	r2, #0
 80085d4:	d102      	bne.n	80085dc <USART_RequestCmd+0xc>
  }
  else
  {
    /* Disable the USART ReQuest by clearing the dedicated request bit in the RQR
       register.*/
    USARTx->RQR &= (uint32_t)~USART_Request;
 80085d6:	438b      	bics	r3, r1
 80085d8:	8303      	strh	r3, [r0, #24]
  }
}
 80085da:	4770      	bx	lr

  if (NewState != DISABLE)
  {
    /* Enable the USART ReQuest by setting the dedicated request bit in the RQR
       register.*/
      USARTx->RQR |= USART_Request;
 80085dc:	4319      	orrs	r1, r3
 80085de:	b289      	uxth	r1, r1
 80085e0:	8301      	strh	r1, [r0, #24]
 80085e2:	e7fa      	b.n	80085da <USART_RequestCmd+0xa>

080085e4 <USART_OverrunDetectionConfig>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_OVRDETECTION(USART_OVRDetection));
  
  /* Clear the OVR detection bit */
  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_OVRDIS);
 80085e4:	6882      	ldr	r2, [r0, #8]
 80085e6:	4b03      	ldr	r3, [pc, #12]	; (80085f4 <USART_OverrunDetectionConfig+0x10>)
 80085e8:	4013      	ands	r3, r2
 80085ea:	6083      	str	r3, [r0, #8]
  /* Set the new value for the OVR detection bit */
  USARTx->CR3 |= USART_OVRDetection;
 80085ec:	6883      	ldr	r3, [r0, #8]
 80085ee:	4319      	orrs	r1, r3
 80085f0:	6081      	str	r1, [r0, #8]
}
 80085f2:	4770      	bx	lr
 80085f4:	ffffefff 	.word	0xffffefff

080085f8 <USART_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_FLAG(USART_FLAG));
  
  if ((USARTx->ISR & USART_FLAG) != (uint16_t)RESET)
 80085f8:	69c0      	ldr	r0, [r0, #28]
 80085fa:	4008      	ands	r0, r1
 80085fc:	1e41      	subs	r1, r0, #1
 80085fe:	4188      	sbcs	r0, r1
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 8008600:	b2c0      	uxtb	r0, r0
}
 8008602:	4770      	bx	lr

08008604 <USART_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
     
  USARTx->ICR = USART_FLAG;
 8008604:	6201      	str	r1, [r0, #32]
}
 8008606:	4770      	bx	lr

08008608 <USART_GetITStatus>:
  assert_param(IS_USART_GET_IT(USART_IT)); 
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
 8008608:	23ff      	movs	r3, #255	; 0xff
 800860a:	400b      	ands	r3, r1
  *            @arg USART_IT_FE:  Framing Error interrupt.
  *            @arg USART_IT_PE:  Parity Error interrupt.
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint32_t USART_IT)
{
 800860c:	b510      	push	{r4, lr}
  assert_param(IS_USART_GET_IT(USART_IT)); 
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
 800860e:	1c1c      	adds	r4, r3, #0
  itmask = (uint32_t)0x01 << itmask;
 8008610:	2301      	movs	r3, #1
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_GET_IT(USART_IT)); 
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
 8008612:	b28a      	uxth	r2, r1
 8008614:	0a12      	lsrs	r2, r2, #8
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
  itmask = (uint32_t)0x01 << itmask;
 8008616:	40a3      	lsls	r3, r4
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8008618:	2a01      	cmp	r2, #1
 800861a:	d010      	beq.n	800863e <USART_GetITStatus+0x36>
  {
    itmask &= USARTx->CR1;
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 800861c:	2a02      	cmp	r2, #2
 800861e:	d011      	beq.n	8008644 <USART_GetITStatus+0x3c>
  {
    itmask &= USARTx->CR2;
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 8008620:	6882      	ldr	r2, [r0, #8]
 8008622:	4013      	ands	r3, r2
  }
  
  bitpos = USART_IT >> 0x10;
  bitpos = (uint32_t)0x01 << bitpos;
  bitpos &= USARTx->ISR;
 8008624:	69c2      	ldr	r2, [r0, #28]
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8008626:	2000      	movs	r0, #0
  }
  
  bitpos = USART_IT >> 0x10;
  bitpos = (uint32_t)0x01 << bitpos;
  bitpos &= USARTx->ISR;
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 8008628:	2b00      	cmp	r3, #0
 800862a:	d007      	beq.n	800863c <USART_GetITStatus+0x34>
  {
    itmask &= USARTx->CR3;
  }
  
  bitpos = USART_IT >> 0x10;
  bitpos = (uint32_t)0x01 << bitpos;
 800862c:	2301      	movs	r3, #1
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
  }
  
  bitpos = USART_IT >> 0x10;
 800862e:	0c09      	lsrs	r1, r1, #16
  bitpos = (uint32_t)0x01 << bitpos;
 8008630:	408b      	lsls	r3, r1
  bitpos &= USARTx->ISR;
 8008632:	401a      	ands	r2, r3
 8008634:	1c10      	adds	r0, r2, #0
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 8008636:	1e41      	subs	r1, r0, #1
 8008638:	4188      	sbcs	r0, r1
  {
    bitstatus = SET;
 800863a:	b2c0      	uxtb	r0, r0
  {
    bitstatus = RESET;
  }
  
  return bitstatus;  
}
 800863c:	bd10      	pop	{r4, pc}
  itmask = USART_IT & IT_MASK;
  itmask = (uint32_t)0x01 << itmask;
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
  {
    itmask &= USARTx->CR1;
 800863e:	6802      	ldr	r2, [r0, #0]
 8008640:	4013      	ands	r3, r2
 8008642:	e7ef      	b.n	8008624 <USART_GetITStatus+0x1c>
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
  {
    itmask &= USARTx->CR2;
 8008644:	6842      	ldr	r2, [r0, #4]
 8008646:	4013      	ands	r3, r2
 8008648:	e7ec      	b.n	8008624 <USART_GetITStatus+0x1c>
 800864a:	46c0      	nop			; (mov r8, r8)

0800864c <USART_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CLEAR_IT(USART_IT)); 
  
  bitpos = USART_IT >> 0x10;
  itmask = ((uint32_t)0x01 << (uint32_t)bitpos);
 800864c:	2301      	movs	r3, #1
  uint32_t bitpos = 0, itmask = 0;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CLEAR_IT(USART_IT)); 
  
  bitpos = USART_IT >> 0x10;
 800864e:	0c09      	lsrs	r1, r1, #16
  itmask = ((uint32_t)0x01 << (uint32_t)bitpos);
 8008650:	408b      	lsls	r3, r1
  USARTx->ICR = (uint32_t)itmask;
 8008652:	6203      	str	r3, [r0, #32]
}
 8008654:	4770      	bx	lr
 8008656:	46c0      	nop			; (mov r8, r8)

08008658 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8008658:	b538      	push	{r3, r4, r5, lr}
 800865a:	1c15      	adds	r5, r2, #0
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800865c:	6c02      	ldr	r2, [r0, #64]	; 0x40

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 800865e:	1c04      	adds	r4, r0, #0
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8008660:	2a00      	cmp	r2, #0
 8008662:	d107      	bne.n	8008674 <prvCopyDataToQueue+0x1c>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8008664:	6805      	ldr	r5, [r0, #0]
 8008666:	2d00      	cmp	r5, #0
 8008668:	d02d      	beq.n	80086c6 <prvCopyDataToQueue+0x6e>
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
 800866a:	2000      	movs	r0, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
 800866c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800866e:	3301      	adds	r3, #1
 8008670:	63a3      	str	r3, [r4, #56]	; 0x38

	return xReturn;
}
 8008672:	bd38      	pop	{r3, r4, r5, pc}
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 8008674:	2d00      	cmp	r5, #0
 8008676:	d10e      	bne.n	8008696 <prvCopyDataToQueue+0x3e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8008678:	6880      	ldr	r0, [r0, #8]
 800867a:	f001 ffab 	bl	800a5d4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800867e:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8008680:	68a3      	ldr	r3, [r4, #8]
 8008682:	4694      	mov	ip, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8008684:	6862      	ldr	r2, [r4, #4]
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8008686:	4463      	add	r3, ip
 8008688:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800868a:	4293      	cmp	r3, r2
 800868c:	d3ed      	bcc.n	800866a <prvCopyDataToQueue+0x12>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800868e:	6823      	ldr	r3, [r4, #0]
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
 8008690:	2000      	movs	r0, #0
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8008692:	60a3      	str	r3, [r4, #8]
 8008694:	e7ea      	b.n	800866c <prvCopyDataToQueue+0x14>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8008696:	68c0      	ldr	r0, [r0, #12]
 8008698:	f001 ff9c 	bl	800a5d4 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800869c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800869e:	68e2      	ldr	r2, [r4, #12]
 80086a0:	425b      	negs	r3, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80086a2:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80086a4:	18d2      	adds	r2, r2, r3
 80086a6:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80086a8:	428a      	cmp	r2, r1
 80086aa:	d203      	bcs.n	80086b4 <prvCopyDataToQueue+0x5c>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 80086ac:	6862      	ldr	r2, [r4, #4]
 80086ae:	4694      	mov	ip, r2
 80086b0:	4463      	add	r3, ip
 80086b2:	60e3      	str	r3, [r4, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 80086b4:	2d02      	cmp	r5, #2
 80086b6:	d1d8      	bne.n	800866a <prvCopyDataToQueue+0x12>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 80086b8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80086ba:	2b00      	cmp	r3, #0
 80086bc:	d0d5      	beq.n	800866a <prvCopyDataToQueue+0x12>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
 80086be:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80086c0:	3b01      	subs	r3, #1
 80086c2:	63a3      	str	r3, [r4, #56]	; 0x38
 80086c4:	e7d1      	b.n	800866a <prvCopyDataToQueue+0x12>
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 80086c6:	6840      	ldr	r0, [r0, #4]
 80086c8:	f001 f9b2 	bl	8009a30 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 80086cc:	6065      	str	r5, [r4, #4]
 80086ce:	e7cd      	b.n	800866c <prvCopyDataToQueue+0x14>

080086d0 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 80086d0:	6c02      	ldr	r2, [r0, #64]	; 0x40
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 80086d2:	b510      	push	{r4, lr}
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 80086d4:	2a00      	cmp	r2, #0
 80086d6:	d009      	beq.n	80086ec <prvCopyDataFromQueue+0x1c>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 80086d8:	68c3      	ldr	r3, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 80086da:	6844      	ldr	r4, [r0, #4]

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 80086dc:	189b      	adds	r3, r3, r2
 80086de:	60c3      	str	r3, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 80086e0:	42a3      	cmp	r3, r4
 80086e2:	d204      	bcs.n	80086ee <prvCopyDataFromQueue+0x1e>
 80086e4:	1c08      	adds	r0, r1, #0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 80086e6:	1c19      	adds	r1, r3, #0
 80086e8:	f001 ff74 	bl	800a5d4 <memcpy>
	}
}
 80086ec:	bd10      	pop	{r4, pc}
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 80086ee:	6803      	ldr	r3, [r0, #0]
 80086f0:	60c3      	str	r3, [r0, #12]
 80086f2:	e7f7      	b.n	80086e4 <prvCopyDataFromQueue+0x14>

080086f4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 80086f4:	b538      	push	{r3, r4, r5, lr}
 80086f6:	1c04      	adds	r4, r0, #0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 80086f8:	f001 fc66 	bl	8009fc8 <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 80086fc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80086fe:	2b00      	cmp	r3, #0
 8008700:	dd1b      	ble.n	800873a <prvUnlockQueue+0x46>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8008702:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008704:	2b00      	cmp	r3, #0
 8008706:	d018      	beq.n	800873a <prvUnlockQueue+0x46>
 8008708:	1c25      	adds	r5, r4, #0
 800870a:	3524      	adds	r5, #36	; 0x24
 800870c:	e008      	b.n	8008720 <prvUnlockQueue+0x2c>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
 800870e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8008710:	3b01      	subs	r3, #1
 8008712:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8008714:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8008716:	2b00      	cmp	r3, #0
 8008718:	dd0f      	ble.n	800873a <prvUnlockQueue+0x46>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800871a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800871c:	2b00      	cmp	r3, #0
 800871e:	d00c      	beq.n	800873a <prvUnlockQueue+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8008720:	1c28      	adds	r0, r5, #0
 8008722:	f001 f893 	bl	800984c <xTaskRemoveFromEventList>
 8008726:	2800      	cmp	r0, #0
 8008728:	d0f1      	beq.n	800870e <prvUnlockQueue+0x1a>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
 800872a:	f001 f929 	bl	8009980 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
 800872e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8008730:	3b01      	subs	r3, #1
 8008732:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8008734:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8008736:	2b00      	cmp	r3, #0
 8008738:	dcef      	bgt.n	800871a <prvUnlockQueue+0x26>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
 800873a:	2301      	movs	r3, #1
 800873c:	425b      	negs	r3, r3
 800873e:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 8008740:	f001 fc4e 	bl	8009fe0 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8008744:	f001 fc40 	bl	8009fc8 <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8008748:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800874a:	2b00      	cmp	r3, #0
 800874c:	dd1b      	ble.n	8008786 <prvUnlockQueue+0x92>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800874e:	6923      	ldr	r3, [r4, #16]
 8008750:	2b00      	cmp	r3, #0
 8008752:	d018      	beq.n	8008786 <prvUnlockQueue+0x92>
 8008754:	1c25      	adds	r5, r4, #0
 8008756:	3510      	adds	r5, #16
 8008758:	e008      	b.n	800876c <prvUnlockQueue+0x78>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
 800875a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800875c:	3b01      	subs	r3, #1
 800875e:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8008760:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8008762:	2b00      	cmp	r3, #0
 8008764:	dd0f      	ble.n	8008786 <prvUnlockQueue+0x92>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8008766:	6923      	ldr	r3, [r4, #16]
 8008768:	2b00      	cmp	r3, #0
 800876a:	d00c      	beq.n	8008786 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800876c:	1c28      	adds	r0, r5, #0
 800876e:	f001 f86d 	bl	800984c <xTaskRemoveFromEventList>
 8008772:	2800      	cmp	r0, #0
 8008774:	d0f1      	beq.n	800875a <prvUnlockQueue+0x66>
				{
					vTaskMissedYield();
 8008776:	f001 f903 	bl	8009980 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
 800877a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800877c:	3b01      	subs	r3, #1
 800877e:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8008780:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8008782:	2b00      	cmp	r3, #0
 8008784:	dcef      	bgt.n	8008766 <prvUnlockQueue+0x72>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 8008786:	2301      	movs	r3, #1
 8008788:	425b      	negs	r3, r3
 800878a:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 800878c:	f001 fc28 	bl	8009fe0 <vPortExitCritical>
}
 8008790:	bd38      	pop	{r3, r4, r5, pc}
 8008792:	46c0      	nop			; (mov r8, r8)

08008794 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 8008794:	b538      	push	{r3, r4, r5, lr}
 8008796:	1c04      	adds	r4, r0, #0
 8008798:	1c0d      	adds	r5, r1, #0
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 800879a:	f001 fc15 	bl	8009fc8 <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800879e:	6c21      	ldr	r1, [r4, #64]	; 0x40
 80087a0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80087a2:	6822      	ldr	r2, [r4, #0]
 80087a4:	434b      	muls	r3, r1
 80087a6:	18d0      	adds	r0, r2, r3
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 80087a8:	1a5b      	subs	r3, r3, r1
 80087aa:	18d3      	adds	r3, r2, r3
 80087ac:	60e3      	str	r3, [r4, #12]
		pxQueue->xRxLock = queueUNLOCKED;
 80087ae:	2301      	movs	r3, #1

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 80087b0:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80087b2:	2000      	movs	r0, #0
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->xRxLock = queueUNLOCKED;
 80087b4:	425b      	negs	r3, r3
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80087b6:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 80087b8:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->xRxLock = queueUNLOCKED;
 80087ba:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
 80087bc:	64a3      	str	r3, [r4, #72]	; 0x48

		if( xNewQueue == pdFALSE )
 80087be:	2d00      	cmp	r5, #0
 80087c0:	d10f      	bne.n	80087e2 <xQueueGenericReset+0x4e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80087c2:	6923      	ldr	r3, [r4, #16]
 80087c4:	2b00      	cmp	r3, #0
 80087c6:	d103      	bne.n	80087d0 <xQueueGenericReset+0x3c>
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
		}
	}
	taskEXIT_CRITICAL();
 80087c8:	f001 fc0a 	bl	8009fe0 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
 80087cc:	2001      	movs	r0, #1
 80087ce:	bd38      	pop	{r3, r4, r5, pc}
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 80087d0:	1c20      	adds	r0, r4, #0
 80087d2:	3010      	adds	r0, #16
 80087d4:	f001 f83a 	bl	800984c <xTaskRemoveFromEventList>
 80087d8:	2801      	cmp	r0, #1
 80087da:	d1f5      	bne.n	80087c8 <xQueueGenericReset+0x34>
				{
					queueYIELD_IF_USING_PREEMPTION();
 80087dc:	f001 fbe8 	bl	8009fb0 <vPortYield>
 80087e0:	e7f2      	b.n	80087c8 <xQueueGenericReset+0x34>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80087e2:	1c20      	adds	r0, r4, #0
 80087e4:	3010      	adds	r0, #16
 80087e6:	f001 fb4d 	bl	8009e84 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 80087ea:	1c20      	adds	r0, r4, #0
 80087ec:	3024      	adds	r0, #36	; 0x24
 80087ee:	f001 fb49 	bl	8009e84 <vListInitialise>
 80087f2:	e7e9      	b.n	80087c8 <xQueueGenericReset+0x34>

080087f4 <xQueueGenericCreate>:
	return pdPASS;
}
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
 80087f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80087f6:	1c05      	adds	r5, r0, #0
 80087f8:	1c0e      	adds	r6, r1, #0
 80087fa:	1c17      	adds	r7, r2, #0
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
 80087fc:	2800      	cmp	r0, #0
 80087fe:	d019      	beq.n	8008834 <xQueueGenericCreate+0x40>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
 8008800:	2054      	movs	r0, #84	; 0x54
 8008802:	f001 fb03 	bl	8009e0c <pvPortMalloc>
 8008806:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
 8008808:	d014      	beq.n	8008834 <xQueueGenericCreate+0x40>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800880a:	1c30      	adds	r0, r6, #0
 800880c:	4368      	muls	r0, r5
 800880e:	3001      	adds	r0, #1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
 8008810:	f001 fafc 	bl	8009e0c <pvPortMalloc>
 8008814:	6020      	str	r0, [r4, #0]
			if( pxNewQueue->pcHead != NULL )
 8008816:	2800      	cmp	r0, #0
 8008818:	d009      	beq.n	800882e <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
 800881a:	63e5      	str	r5, [r4, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
 800881c:	6426      	str	r6, [r4, #64]	; 0x40
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800881e:	1c20      	adds	r0, r4, #0
 8008820:	2101      	movs	r1, #1
 8008822:	f7ff ffb7 	bl	8008794 <xQueueGenericReset>

				#if ( configUSE_TRACE_FACILITY == 1 )
				{
					pxNewQueue->ucQueueType = ucQueueType;
 8008826:	2350      	movs	r3, #80	; 0x50
 8008828:	54e7      	strb	r7, [r4, r3]
	}

	configASSERT( xReturn );

	return xReturn;
}
 800882a:	1c20      	adds	r0, r4, #0
 800882c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
 800882e:	1c20      	adds	r0, r4, #0
 8008830:	f001 fb16 	bl	8009e60 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
 8008834:	2400      	movs	r4, #0
 8008836:	e7f8      	b.n	800882a <xQueueGenericCreate+0x36>

08008838 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
 8008838:	b510      	push	{r4, lr}
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 800883a:	2202      	movs	r2, #2
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
 800883c:	1c0c      	adds	r4, r1, #0
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 800883e:	2100      	movs	r1, #0
 8008840:	f7ff ffd8 	bl	80087f4 <xQueueGenericCreate>

		if( xHandle != NULL )
 8008844:	2800      	cmp	r0, #0
 8008846:	d000      	beq.n	800884a <xQueueCreateCountingSemaphore+0x12>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 8008848:	6384      	str	r4, [r0, #56]	; 0x38
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
		return xHandle;
	}
 800884a:	bd10      	pop	{r4, pc}

0800884c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 800884c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800884e:	464f      	mov	r7, r9
 8008850:	4646      	mov	r6, r8
 8008852:	b4c0      	push	{r6, r7}
 8008854:	1c1e      	adds	r6, r3, #0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8008856:	2310      	movs	r3, #16

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 8008858:	1c04      	adds	r4, r0, #0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800885a:	4698      	mov	r8, r3

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 800885c:	b085      	sub	sp, #20
 800885e:	9201      	str	r2, [sp, #4]
 8008860:	4689      	mov	r9, r1
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8008862:	4480      	add	r8, r0
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 8008864:	f001 fbb0 	bl	8009fc8 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8008868:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800886a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 800886c:	2500      	movs	r5, #0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 800886e:	2700      	movs	r7, #0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8008870:	4293      	cmp	r3, r2
 8008872:	d32e      	bcc.n	80088d2 <xQueueGenericSend+0x86>
 8008874:	2e02      	cmp	r6, #2
 8008876:	d02c      	beq.n	80088d2 <xQueueGenericSend+0x86>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 8008878:	9b01      	ldr	r3, [sp, #4]
 800887a:	2b00      	cmp	r3, #0
 800887c:	d062      	beq.n	8008944 <xQueueGenericSend+0xf8>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
 800887e:	2d00      	cmp	r5, #0
 8008880:	d039      	beq.n	80088f6 <xQueueGenericSend+0xaa>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 8008882:	f001 fbad 	bl	8009fe0 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8008886:	f000 fd81 	bl	800938c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800888a:	f001 fb9d 	bl	8009fc8 <vPortEnterCritical>
 800888e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8008890:	3301      	adds	r3, #1
 8008892:	d044      	beq.n	800891e <xQueueGenericSend+0xd2>
 8008894:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8008896:	3301      	adds	r3, #1
 8008898:	d031      	beq.n	80088fe <xQueueGenericSend+0xb2>
 800889a:	f001 fba1 	bl	8009fe0 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800889e:	a802      	add	r0, sp, #8
 80088a0:	a901      	add	r1, sp, #4
 80088a2:	f001 f83b 	bl	800991c <xTaskCheckForTimeOut>
 80088a6:	2800      	cmp	r0, #0
 80088a8:	d132      	bne.n	8008910 <xQueueGenericSend+0xc4>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 80088aa:	f001 fb8d 	bl	8009fc8 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 80088ae:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80088b0:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80088b2:	4293      	cmp	r3, r2
 80088b4:	d035      	beq.n	8008922 <xQueueGenericSend+0xd6>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 80088b6:	f001 fb93 	bl	8009fe0 <vPortExitCritical>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 80088ba:	1c20      	adds	r0, r4, #0
 80088bc:	f7ff ff1a 	bl	80086f4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80088c0:	f000 fe16 	bl	80094f0 <xTaskResumeAll>
 80088c4:	2501      	movs	r5, #1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 80088c6:	f001 fb7f 	bl	8009fc8 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80088ca:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80088cc:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80088ce:	4293      	cmp	r3, r2
 80088d0:	d2d0      	bcs.n	8008874 <xQueueGenericSend+0x28>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80088d2:	1c20      	adds	r0, r4, #0
 80088d4:	4649      	mov	r1, r9
 80088d6:	1c32      	adds	r2, r6, #0
 80088d8:	f7ff febe 	bl	8008658 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80088dc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80088de:	2b00      	cmp	r3, #0
 80088e0:	d134      	bne.n	800894c <xQueueGenericSend+0x100>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 80088e2:	2800      	cmp	r0, #0
 80088e4:	d138      	bne.n	8008958 <xQueueGenericSend+0x10c>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 80088e6:	f001 fb7b 	bl	8009fe0 <vPortExitCritical>
				return pdPASS;
 80088ea:	2001      	movs	r0, #1
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
 80088ec:	b005      	add	sp, #20
 80088ee:	bc0c      	pop	{r2, r3}
 80088f0:	4690      	mov	r8, r2
 80088f2:	4699      	mov	r9, r3
 80088f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 80088f6:	a802      	add	r0, sp, #8
 80088f8:	f001 f804 	bl	8009904 <vTaskSetTimeOutState>
 80088fc:	e7c1      	b.n	8008882 <xQueueGenericSend+0x36>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 80088fe:	64a7      	str	r7, [r4, #72]	; 0x48
 8008900:	f001 fb6e 	bl	8009fe0 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8008904:	a802      	add	r0, sp, #8
 8008906:	a901      	add	r1, sp, #4
 8008908:	f001 f808 	bl	800991c <xTaskCheckForTimeOut>
 800890c:	2800      	cmp	r0, #0
 800890e:	d0cc      	beq.n	80088aa <xQueueGenericSend+0x5e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 8008910:	1c20      	adds	r0, r4, #0
 8008912:	f7ff feef 	bl	80086f4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8008916:	f000 fdeb 	bl	80094f0 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 800891a:	2000      	movs	r0, #0
 800891c:	e7e6      	b.n	80088ec <xQueueGenericSend+0xa0>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 800891e:	6467      	str	r7, [r4, #68]	; 0x44
 8008920:	e7b8      	b.n	8008894 <xQueueGenericSend+0x48>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8008922:	f001 fb5d 	bl	8009fe0 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8008926:	4640      	mov	r0, r8
 8008928:	9901      	ldr	r1, [sp, #4]
 800892a:	f000 ff3d 	bl	80097a8 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 800892e:	1c20      	adds	r0, r4, #0
 8008930:	f7ff fee0 	bl	80086f4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 8008934:	f000 fddc 	bl	80094f0 <xTaskResumeAll>
 8008938:	2800      	cmp	r0, #0
 800893a:	d1c3      	bne.n	80088c4 <xQueueGenericSend+0x78>
				{
					portYIELD_WITHIN_API();
 800893c:	f001 fb38 	bl	8009fb0 <vPortYield>
 8008940:	2501      	movs	r5, #1
 8008942:	e7c0      	b.n	80088c6 <xQueueGenericSend+0x7a>
			{
				if( xTicksToWait == ( TickType_t ) 0 )
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8008944:	f001 fb4c 	bl	8009fe0 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 8008948:	2000      	movs	r0, #0
 800894a:	e7cf      	b.n	80088ec <xQueueGenericSend+0xa0>
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 800894c:	1c20      	adds	r0, r4, #0
 800894e:	3024      	adds	r0, #36	; 0x24
 8008950:	f000 ff7c 	bl	800984c <xTaskRemoveFromEventList>
 8008954:	2801      	cmp	r0, #1
 8008956:	d1c6      	bne.n	80088e6 <xQueueGenericSend+0x9a>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 8008958:	f001 fb2a 	bl	8009fb0 <vPortYield>
 800895c:	e7c3      	b.n	80088e6 <xQueueGenericSend+0x9a>
 800895e:	46c0      	nop			; (mov r8, r8)

08008960 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
 8008960:	b538      	push	{r3, r4, r5, lr}
 8008962:	1c05      	adds	r5, r0, #0
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
 8008964:	2054      	movs	r0, #84	; 0x54
 8008966:	f001 fa51 	bl	8009e0c <pvPortMalloc>
 800896a:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
 800896c:	d01a      	beq.n	80089a4 <xQueueCreateMutex+0x44>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 800896e:	2300      	movs	r3, #0

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
 8008970:	2201      	movs	r2, #1
			pxNewQueue->u.pcReadFrom = NULL;

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8008972:	6383      	str	r3, [r0, #56]	; 0x38
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
 8008974:	6403      	str	r3, [r0, #64]	; 0x40
		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 8008976:	6043      	str	r3, [r0, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 8008978:	6003      	str	r3, [r0, #0]

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
 800897a:	6083      	str	r3, [r0, #8]
			pxNewQueue->u.pcReadFrom = NULL;
 800897c:	60c3      	str	r3, [r0, #12]
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
 800897e:	3b01      	subs	r3, #1
 8008980:	6443      	str	r3, [r0, #68]	; 0x44
			pxNewQueue->xTxLock = queueUNLOCKED;
 8008982:	6483      	str	r3, [r0, #72]	; 0x48

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				pxNewQueue->ucQueueType = ucQueueType;
 8008984:	3351      	adds	r3, #81	; 0x51

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
 8008986:	63c2      	str	r2, [r0, #60]	; 0x3c
			pxNewQueue->xRxLock = queueUNLOCKED;
			pxNewQueue->xTxLock = queueUNLOCKED;

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				pxNewQueue->ucQueueType = ucQueueType;
 8008988:	54c5      	strb	r5, [r0, r3]
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 800898a:	3010      	adds	r0, #16
 800898c:	f001 fa7a 	bl	8009e84 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 8008990:	1c20      	adds	r0, r4, #0
 8008992:	3024      	adds	r0, #36	; 0x24
 8008994:	f001 fa76 	bl	8009e84 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 8008998:	1c20      	adds	r0, r4, #0
 800899a:	2100      	movs	r1, #0
 800899c:	2200      	movs	r2, #0
 800899e:	2300      	movs	r3, #0
 80089a0:	f7ff ff54 	bl	800884c <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
 80089a4:	1c20      	adds	r0, r4, #0
 80089a6:	bd38      	pop	{r3, r4, r5, pc}

080089a8 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
 80089a8:	b570      	push	{r4, r5, r6, lr}
 80089aa:	1c04      	adds	r4, r0, #0
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
 80089ac:	6846      	ldr	r6, [r0, #4]
 80089ae:	f000 fff7 	bl	80099a0 <xTaskGetCurrentTaskHandle>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
 80089b2:	2500      	movs	r5, #0
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
 80089b4:	4286      	cmp	r6, r0
 80089b6:	d001      	beq.n	80089bc <xQueueGiveMutexRecursive+0x14>

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
	}
 80089b8:	1c28      	adds	r0, r5, #0
 80089ba:	bd70      	pop	{r4, r5, r6, pc}
			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.uxRecursiveCallCount )--;
 80089bc:	68e3      	ldr	r3, [r4, #12]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
 80089be:	3501      	adds	r5, #1
			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.uxRecursiveCallCount )--;
 80089c0:	3b01      	subs	r3, #1
 80089c2:	60e3      	str	r3, [r4, #12]

			/* Have we unwound the call count? */
			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 80089c4:	2b00      	cmp	r3, #0
 80089c6:	d1f7      	bne.n	80089b8 <xQueueGiveMutexRecursive+0x10>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 80089c8:	1c20      	adds	r0, r4, #0
 80089ca:	2100      	movs	r1, #0
 80089cc:	2200      	movs	r2, #0
 80089ce:	f7ff ff3d 	bl	800884c <xQueueGenericSend>
 80089d2:	e7f1      	b.n	80089b8 <xQueueGiveMutexRecursive+0x10>

080089d4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 80089d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80089d6:	464f      	mov	r7, r9
 80089d8:	4646      	mov	r6, r8
 80089da:	1c04      	adds	r4, r0, #0
 80089dc:	b4c0      	push	{r6, r7}
 80089de:	4690      	mov	r8, r2
 80089e0:	1c1d      	adds	r5, r3, #0
 80089e2:	4689      	mov	r9, r1
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80089e4:	f001 fb06 	bl	8009ff4 <ulSetInterruptMaskFromISR>
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80089e8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80089ea:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80089ec:	1c07      	adds	r7, r0, #0
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80089ee:	4293      	cmp	r3, r2
 80089f0:	d30a      	bcc.n	8008a08 <xQueueGenericSendFromISR+0x34>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 80089f2:	2600      	movs	r6, #0
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80089f4:	2d02      	cmp	r5, #2
 80089f6:	d007      	beq.n	8008a08 <xQueueGenericSendFromISR+0x34>
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80089f8:	1c38      	adds	r0, r7, #0
 80089fa:	f001 fb01 	bl	800a000 <vClearInterruptMaskFromISR>

	return xReturn;
}
 80089fe:	1c30      	adds	r0, r6, #0
 8008a00:	bc0c      	pop	{r2, r3}
 8008a02:	4690      	mov	r8, r2
 8008a04:	4699      	mov	r9, r3
 8008a06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
 8008a08:	1c20      	adds	r0, r4, #0
 8008a0a:	4649      	mov	r1, r9
 8008a0c:	1c2a      	adds	r2, r5, #0
 8008a0e:	f7ff fe23 	bl	8008658 <prvCopyDataToQueue>
 8008a12:	2800      	cmp	r0, #0
 8008a14:	d005      	beq.n	8008a22 <xQueueGenericSendFromISR+0x4e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
 8008a16:	4643      	mov	r3, r8
 8008a18:	2b00      	cmp	r3, #0
 8008a1a:	d002      	beq.n	8008a22 <xQueueGenericSendFromISR+0x4e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
 8008a1c:	2301      	movs	r3, #1
 8008a1e:	4642      	mov	r2, r8
 8008a20:	6013      	str	r3, [r2, #0]
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
 8008a22:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8008a24:	3301      	adds	r3, #1
 8008a26:	d004      	beq.n	8008a32 <xQueueGenericSendFromISR+0x5e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 8008a28:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8008a2a:	3301      	adds	r3, #1
 8008a2c:	64a3      	str	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
 8008a2e:	2601      	movs	r6, #1
 8008a30:	e7e2      	b.n	80089f8 <xQueueGenericSendFromISR+0x24>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8008a32:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008a34:	2b00      	cmp	r3, #0
 8008a36:	d0fa      	beq.n	8008a2e <xQueueGenericSendFromISR+0x5a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8008a38:	1c20      	adds	r0, r4, #0
 8008a3a:	3024      	adds	r0, #36	; 0x24
 8008a3c:	f000 ff06 	bl	800984c <xTaskRemoveFromEventList>
 8008a40:	2800      	cmp	r0, #0
 8008a42:	d0f4      	beq.n	8008a2e <xQueueGenericSendFromISR+0x5a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 8008a44:	4643      	mov	r3, r8
 8008a46:	2b00      	cmp	r3, #0
 8008a48:	d0f1      	beq.n	8008a2e <xQueueGenericSendFromISR+0x5a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 8008a4a:	2301      	movs	r3, #1
 8008a4c:	4642      	mov	r2, r8
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
 8008a4e:	2601      	movs	r6, #1
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 8008a50:	6013      	str	r3, [r2, #0]
 8008a52:	e7d1      	b.n	80089f8 <xQueueGenericSendFromISR+0x24>

08008a54 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
 8008a54:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008a56:	464f      	mov	r7, r9
 8008a58:	4646      	mov	r6, r8
 8008a5a:	1c04      	adds	r4, r0, #0
 8008a5c:	b4c0      	push	{r6, r7}
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8008a5e:	1c06      	adds	r6, r0, #0
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
 8008a60:	b085      	sub	sp, #20
 8008a62:	4698      	mov	r8, r3
 8008a64:	4689      	mov	r9, r1
 8008a66:	9201      	str	r2, [sp, #4]
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 8008a68:	f001 faae 	bl	8009fc8 <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 8008a6c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
BaseType_t xEntryTimeSet = pdFALSE;
 8008a6e:	2500      	movs	r5, #0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 8008a70:	2700      	movs	r7, #0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8008a72:	3624      	adds	r6, #36	; 0x24
	{
		taskENTER_CRITICAL();
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 8008a74:	2b00      	cmp	r3, #0
 8008a76:	d133      	bne.n	8008ae0 <xQueueGenericReceive+0x8c>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 8008a78:	9b01      	ldr	r3, [sp, #4]
 8008a7a:	2b00      	cmp	r3, #0
 8008a7c:	d075      	beq.n	8008b6a <xQueueGenericReceive+0x116>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
 8008a7e:	2d00      	cmp	r5, #0
 8008a80:	d055      	beq.n	8008b2e <xQueueGenericReceive+0xda>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 8008a82:	f001 faad 	bl	8009fe0 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8008a86:	f000 fc81 	bl	800938c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8008a8a:	f001 fa9d 	bl	8009fc8 <vPortEnterCritical>
 8008a8e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8008a90:	3301      	adds	r3, #1
 8008a92:	d060      	beq.n	8008b56 <xQueueGenericReceive+0x102>
 8008a94:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8008a96:	3301      	adds	r3, #1
 8008a98:	d04d      	beq.n	8008b36 <xQueueGenericReceive+0xe2>
 8008a9a:	f001 faa1 	bl	8009fe0 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8008a9e:	a802      	add	r0, sp, #8
 8008aa0:	a901      	add	r1, sp, #4
 8008aa2:	f000 ff3b 	bl	800991c <xTaskCheckForTimeOut>
 8008aa6:	2800      	cmp	r0, #0
 8008aa8:	d14e      	bne.n	8008b48 <xQueueGenericReceive+0xf4>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8008aaa:	f001 fa8d 	bl	8009fc8 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8008aae:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8008ab0:	2b00      	cmp	r3, #0
 8008ab2:	d133      	bne.n	8008b1c <xQueueGenericReceive+0xc8>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8008ab4:	f001 fa94 	bl	8009fe0 <vPortExitCritical>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8008ab8:	6823      	ldr	r3, [r4, #0]
 8008aba:	2b00      	cmp	r3, #0
 8008abc:	d04d      	beq.n	8008b5a <xQueueGenericReceive+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8008abe:	1c30      	adds	r0, r6, #0
 8008ac0:	9901      	ldr	r1, [sp, #4]
 8008ac2:	f000 fe71 	bl	80097a8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8008ac6:	1c20      	adds	r0, r4, #0
 8008ac8:	f7ff fe14 	bl	80086f4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8008acc:	f000 fd10 	bl	80094f0 <xTaskResumeAll>
 8008ad0:	2800      	cmp	r0, #0
 8008ad2:	d01f      	beq.n	8008b14 <xQueueGenericReceive+0xc0>
 8008ad4:	2501      	movs	r5, #1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 8008ad6:	f001 fa77 	bl	8009fc8 <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 8008ada:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8008adc:	2b00      	cmp	r3, #0
 8008ade:	d0cb      	beq.n	8008a78 <xQueueGenericReceive+0x24>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8008ae0:	1c20      	adds	r0, r4, #0
 8008ae2:	4649      	mov	r1, r9
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 8008ae4:	68e5      	ldr	r5, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8008ae6:	f7ff fdf3 	bl	80086d0 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 8008aea:	4643      	mov	r3, r8
 8008aec:	2b00      	cmp	r3, #0
 8008aee:	d144      	bne.n	8008b7a <xQueueGenericReceive+0x126>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
 8008af0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8008af2:	3b01      	subs	r3, #1
 8008af4:	63a3      	str	r3, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8008af6:	6823      	ldr	r3, [r4, #0]
 8008af8:	2b00      	cmp	r3, #0
 8008afa:	d04d      	beq.n	8008b98 <xQueueGenericReceive+0x144>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8008afc:	6923      	ldr	r3, [r4, #16]
 8008afe:	2b00      	cmp	r3, #0
 8008b00:	d03f      	beq.n	8008b82 <xQueueGenericReceive+0x12e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 8008b02:	1c20      	adds	r0, r4, #0
 8008b04:	3010      	adds	r0, #16
 8008b06:	f000 fea1 	bl	800984c <xTaskRemoveFromEventList>
 8008b0a:	2801      	cmp	r0, #1
 8008b0c:	d139      	bne.n	8008b82 <xQueueGenericReceive+0x12e>
						{
							queueYIELD_IF_USING_PREEMPTION();
 8008b0e:	f001 fa4f 	bl	8009fb0 <vPortYield>
 8008b12:	e036      	b.n	8008b82 <xQueueGenericReceive+0x12e>

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
				{
					portYIELD_WITHIN_API();
 8008b14:	f001 fa4c 	bl	8009fb0 <vPortYield>
 8008b18:	2501      	movs	r5, #1
 8008b1a:	e7dc      	b.n	8008ad6 <xQueueGenericReceive+0x82>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8008b1c:	f001 fa60 	bl	8009fe0 <vPortExitCritical>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 8008b20:	1c20      	adds	r0, r4, #0
 8008b22:	f7ff fde7 	bl	80086f4 <prvUnlockQueue>
 8008b26:	2501      	movs	r5, #1
				( void ) xTaskResumeAll();
 8008b28:	f000 fce2 	bl	80094f0 <xTaskResumeAll>
 8008b2c:	e7d3      	b.n	8008ad6 <xQueueGenericReceive+0x82>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 8008b2e:	a802      	add	r0, sp, #8
 8008b30:	f000 fee8 	bl	8009904 <vTaskSetTimeOutState>
 8008b34:	e7a5      	b.n	8008a82 <xQueueGenericReceive+0x2e>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 8008b36:	64a7      	str	r7, [r4, #72]	; 0x48
 8008b38:	f001 fa52 	bl	8009fe0 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8008b3c:	a802      	add	r0, sp, #8
 8008b3e:	a901      	add	r1, sp, #4
 8008b40:	f000 feec 	bl	800991c <xTaskCheckForTimeOut>
 8008b44:	2800      	cmp	r0, #0
 8008b46:	d0b0      	beq.n	8008aaa <xQueueGenericReceive+0x56>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 8008b48:	1c20      	adds	r0, r4, #0
 8008b4a:	f7ff fdd3 	bl	80086f4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8008b4e:	f000 fccf 	bl	80094f0 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
 8008b52:	2000      	movs	r0, #0
 8008b54:	e00c      	b.n	8008b70 <xQueueGenericReceive+0x11c>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 8008b56:	6467      	str	r7, [r4, #68]	; 0x44
 8008b58:	e79c      	b.n	8008a94 <xQueueGenericReceive+0x40>

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
						taskENTER_CRITICAL();
 8008b5a:	f001 fa35 	bl	8009fc8 <vPortEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 8008b5e:	6860      	ldr	r0, [r4, #4]
 8008b60:	f000 ff30 	bl	80099c4 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
 8008b64:	f001 fa3c 	bl	8009fe0 <vPortExitCritical>
 8008b68:	e7a9      	b.n	8008abe <xQueueGenericReceive+0x6a>
			{
				if( xTicksToWait == ( TickType_t ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8008b6a:	f001 fa39 	bl	8009fe0 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 8008b6e:	2000      	movs	r0, #0
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
 8008b70:	b005      	add	sp, #20
 8008b72:	bc0c      	pop	{r2, r3}
 8008b74:	4690      	mov	r8, r2
 8008b76:	4699      	mov	r9, r3
 8008b78:	bdf0      	pop	{r4, r5, r6, r7, pc}
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8008b7a:	6a63      	ldr	r3, [r4, #36]	; 0x24
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 8008b7c:	60e5      	str	r5, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8008b7e:	2b00      	cmp	r3, #0
 8008b80:	d103      	bne.n	8008b8a <xQueueGenericReceive+0x136>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
 8008b82:	f001 fa2d 	bl	8009fe0 <vPortExitCritical>
				return pdPASS;
 8008b86:	2001      	movs	r0, #1
 8008b88:	e7f2      	b.n	8008b70 <xQueueGenericReceive+0x11c>
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8008b8a:	1c20      	adds	r0, r4, #0
 8008b8c:	3024      	adds	r0, #36	; 0x24
 8008b8e:	f000 fe5d 	bl	800984c <xTaskRemoveFromEventList>
 8008b92:	2800      	cmp	r0, #0
 8008b94:	d0f5      	beq.n	8008b82 <xQueueGenericReceive+0x12e>
 8008b96:	e7ba      	b.n	8008b0e <xQueueGenericReceive+0xba>
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8008b98:	f000 ff80 	bl	8009a9c <pvTaskIncrementMutexHeldCount>
 8008b9c:	6060      	str	r0, [r4, #4]
 8008b9e:	e7ad      	b.n	8008afc <xQueueGenericReceive+0xa8>

08008ba0 <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
 8008ba0:	b570      	push	{r4, r5, r6, lr}
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8008ba2:	6845      	ldr	r5, [r0, #4]
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
 8008ba4:	1c04      	adds	r4, r0, #0
 8008ba6:	1c0e      	adds	r6, r1, #0
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8008ba8:	f000 fefa 	bl	80099a0 <xTaskGetCurrentTaskHandle>
 8008bac:	4285      	cmp	r5, r0
 8008bae:	d00c      	beq.n	8008bca <xQueueTakeMutexRecursive+0x2a>
			( pxMutex->u.uxRecursiveCallCount )++;
			xReturn = pdPASS;
		}
		else
		{
			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
 8008bb0:	1c20      	adds	r0, r4, #0
 8008bb2:	2100      	movs	r1, #0
 8008bb4:	1c32      	adds	r2, r6, #0
 8008bb6:	2300      	movs	r3, #0
 8008bb8:	f7ff ff4c 	bl	8008a54 <xQueueGenericReceive>

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn == pdPASS )
 8008bbc:	2801      	cmp	r0, #1
 8008bbe:	d000      	beq.n	8008bc2 <xQueueTakeMutexRecursive+0x22>
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
	}
 8008bc0:	bd70      	pop	{r4, r5, r6, pc}
			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn == pdPASS )
			{
				( pxMutex->u.uxRecursiveCallCount )++;
 8008bc2:	68e3      	ldr	r3, [r4, #12]
 8008bc4:	3301      	adds	r3, #1
 8008bc6:	60e3      	str	r3, [r4, #12]
 8008bc8:	e7fa      	b.n	8008bc0 <xQueueTakeMutexRecursive+0x20>

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
		{
			( pxMutex->u.uxRecursiveCallCount )++;
 8008bca:	68e3      	ldr	r3, [r4, #12]
			xReturn = pdPASS;
 8008bcc:	2001      	movs	r0, #1

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
		{
			( pxMutex->u.uxRecursiveCallCount )++;
 8008bce:	3301      	adds	r3, #1
 8008bd0:	60e3      	str	r3, [r4, #12]
 8008bd2:	e7f5      	b.n	8008bc0 <xQueueTakeMutexRecursive+0x20>

08008bd4 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
 8008bd4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008bd6:	4647      	mov	r7, r8
 8008bd8:	1c04      	adds	r4, r0, #0
 8008bda:	b480      	push	{r7}
 8008bdc:	4690      	mov	r8, r2
 8008bde:	1c0f      	adds	r7, r1, #0
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8008be0:	f001 fa08 	bl	8009ff4 <ulSetInterruptMaskFromISR>
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 8008be4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8008be6:	1c06      	adds	r6, r0, #0

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
 8008be8:	2500      	movs	r5, #0
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 8008bea:	2b00      	cmp	r3, #0
 8008bec:	d106      	bne.n	8008bfc <xQueueReceiveFromISR+0x28>
		{
			xReturn = pdFAIL;
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8008bee:	1c30      	adds	r0, r6, #0
 8008bf0:	f001 fa06 	bl	800a000 <vClearInterruptMaskFromISR>

	return xReturn;
}
 8008bf4:	1c28      	adds	r0, r5, #0
 8008bf6:	bc04      	pop	{r2}
 8008bf8:	4690      	mov	r8, r2
 8008bfa:	bdf0      	pop	{r4, r5, r6, r7, pc}
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8008bfc:	1c20      	adds	r0, r4, #0
 8008bfe:	1c39      	adds	r1, r7, #0
 8008c00:	f7ff fd66 	bl	80086d0 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
 8008c04:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8008c06:	3b01      	subs	r3, #1
 8008c08:	63a3      	str	r3, [r4, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
 8008c0a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8008c0c:	3301      	adds	r3, #1
 8008c0e:	d004      	beq.n	8008c1a <xQueueReceiveFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
 8008c10:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8008c12:	3301      	adds	r3, #1
 8008c14:	6463      	str	r3, [r4, #68]	; 0x44
			}

			xReturn = pdPASS;
 8008c16:	2501      	movs	r5, #1
 8008c18:	e7e9      	b.n	8008bee <xQueueReceiveFromISR+0x1a>
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8008c1a:	6923      	ldr	r3, [r4, #16]
 8008c1c:	2b00      	cmp	r3, #0
 8008c1e:	d0fa      	beq.n	8008c16 <xQueueReceiveFromISR+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8008c20:	1c20      	adds	r0, r4, #0
 8008c22:	3010      	adds	r0, #16
 8008c24:	f000 fe12 	bl	800984c <xTaskRemoveFromEventList>
 8008c28:	2800      	cmp	r0, #0
 8008c2a:	d0f4      	beq.n	8008c16 <xQueueReceiveFromISR+0x42>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
 8008c2c:	4643      	mov	r3, r8
 8008c2e:	2b00      	cmp	r3, #0
 8008c30:	d0f1      	beq.n	8008c16 <xQueueReceiveFromISR+0x42>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 8008c32:	2301      	movs	r3, #1
 8008c34:	4642      	mov	r2, r8
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
 8008c36:	2501      	movs	r5, #1
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 8008c38:	6013      	str	r3, [r2, #0]
 8008c3a:	e7d8      	b.n	8008bee <xQueueReceiveFromISR+0x1a>

08008c3c <xQueuePeekFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
 8008c3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008c3e:	1c04      	adds	r4, r0, #0
 8008c40:	1c0f      	adds	r7, r1, #0
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8008c42:	f001 f9d7 	bl	8009ff4 <ulSetInterruptMaskFromISR>
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 8008c46:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8008c48:	1c06      	adds	r6, r0, #0

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
 8008c4a:	2500      	movs	r5, #0
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 8008c4c:	2b00      	cmp	r3, #0
 8008c4e:	d006      	beq.n	8008c5e <xQueuePeekFromISR+0x22>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 8008c50:	68e5      	ldr	r5, [r4, #12]
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8008c52:	1c20      	adds	r0, r4, #0
 8008c54:	1c39      	adds	r1, r7, #0
 8008c56:	f7ff fd3b 	bl	80086d0 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 8008c5a:	60e5      	str	r5, [r4, #12]

			xReturn = pdPASS;
 8008c5c:	2501      	movs	r5, #1
		{
			xReturn = pdFAIL;
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8008c5e:	1c30      	adds	r0, r6, #0
 8008c60:	f001 f9ce 	bl	800a000 <vClearInterruptMaskFromISR>

	return xReturn;
}
 8008c64:	1c28      	adds	r0, r5, #0
 8008c66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08008c68 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 8008c68:	b510      	push	{r4, lr}
 8008c6a:	1c04      	adds	r4, r0, #0
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
 8008c6c:	f001 f9ac 	bl	8009fc8 <vPortEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 8008c70:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	}
	taskEXIT_CRITICAL();
 8008c72:	f001 f9b5 	bl	8009fe0 <vPortExitCritical>

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8008c76:	1c20      	adds	r0, r4, #0
 8008c78:	bd10      	pop	{r4, pc}
 8008c7a:	46c0      	nop			; (mov r8, r8)

08008c7c <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
 8008c7c:	b538      	push	{r3, r4, r5, lr}
 8008c7e:	1c05      	adds	r5, r0, #0
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 8008c80:	f001 f9a2 	bl	8009fc8 <vPortEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 8008c84:	6bac      	ldr	r4, [r5, #56]	; 0x38
 8008c86:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8008c88:	1b1c      	subs	r4, r3, r4
	}
	taskEXIT_CRITICAL();
 8008c8a:	f001 f9a9 	bl	8009fe0 <vPortExitCritical>

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8008c8e:	1c20      	adds	r0, r4, #0
 8008c90:	bd38      	pop	{r3, r4, r5, pc}
 8008c92:	46c0      	nop			; (mov r8, r8)

08008c94 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 8008c94:	6b80      	ldr	r0, [r0, #56]	; 0x38

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8008c96:	4770      	bx	lr

08008c98 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 8008c98:	b510      	push	{r4, lr}
 8008c9a:	1c04      	adds	r4, r0, #0
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	if( pxQueue->pcHead != NULL )
 8008c9c:	6800      	ldr	r0, [r0, #0]
 8008c9e:	2800      	cmp	r0, #0
 8008ca0:	d001      	beq.n	8008ca6 <vQueueDelete+0xe>
	{
		vPortFree( pxQueue->pcHead );
 8008ca2:	f001 f8dd 	bl	8009e60 <vPortFree>
	}
	vPortFree( pxQueue );
 8008ca6:	1c20      	adds	r0, r4, #0
 8008ca8:	f001 f8da 	bl	8009e60 <vPortFree>
}
 8008cac:	bd10      	pop	{r4, pc}
 8008cae:	46c0      	nop			; (mov r8, r8)

08008cb0 <uxQueueGetQueueNumber>:

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
	{
		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
 8008cb0:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
	}
 8008cb2:	4770      	bx	lr

08008cb4 <vQueueSetQueueNumber>:

#if ( configUSE_TRACE_FACILITY == 1 )

	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
	{
		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 8008cb4:	64c1      	str	r1, [r0, #76]	; 0x4c
	}
 8008cb6:	4770      	bx	lr

08008cb8 <ucQueueGetQueueType>:

#if ( configUSE_TRACE_FACILITY == 1 )

	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
	{
		return ( ( Queue_t * ) xQueue )->ucQueueType;
 8008cb8:	2350      	movs	r3, #80	; 0x50
 8008cba:	5cc0      	ldrb	r0, [r0, r3]
	}
 8008cbc:	4770      	bx	lr
 8008cbe:	46c0      	nop			; (mov r8, r8)

08008cc0 <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 8008cc0:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8008cc2:	4243      	negs	r3, r0
 8008cc4:	4158      	adcs	r0, r3
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 8008cc6:	4770      	bx	lr

08008cc8 <xQueueIsQueueFullFromISR>:
BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 8008cc8:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8008cca:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 8008ccc:	1a18      	subs	r0, r3, r0
 8008cce:	4243      	negs	r3, r0
 8008cd0:	4158      	adcs	r0, r3
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 8008cd2:	4770      	bx	lr

08008cd4 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
	{
 8008cd4:	b538      	push	{r3, r4, r5, lr}
 8008cd6:	1c04      	adds	r4, r0, #0
 8008cd8:	1c0d      	adds	r5, r1, #0
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 8008cda:	f001 f975 	bl	8009fc8 <vPortEnterCritical>
 8008cde:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8008ce0:	3301      	adds	r3, #1
 8008ce2:	d013      	beq.n	8008d0c <vQueueWaitForMessageRestricted+0x38>
 8008ce4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8008ce6:	3301      	adds	r3, #1
 8008ce8:	d00d      	beq.n	8008d06 <vQueueWaitForMessageRestricted+0x32>
 8008cea:	f001 f979 	bl	8009fe0 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 8008cee:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8008cf0:	2b00      	cmp	r3, #0
 8008cf2:	d104      	bne.n	8008cfe <vQueueWaitForMessageRestricted+0x2a>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8008cf4:	1c20      	adds	r0, r4, #0
 8008cf6:	1c29      	adds	r1, r5, #0
 8008cf8:	3024      	adds	r0, #36	; 0x24
 8008cfa:	f000 fd95 	bl	8009828 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 8008cfe:	1c20      	adds	r0, r4, #0
 8008d00:	f7ff fcf8 	bl	80086f4 <prvUnlockQueue>
	}
 8008d04:	bd38      	pop	{r3, r4, r5, pc}
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 8008d06:	2300      	movs	r3, #0
 8008d08:	64a3      	str	r3, [r4, #72]	; 0x48
 8008d0a:	e7ee      	b.n	8008cea <vQueueWaitForMessageRestricted+0x16>
 8008d0c:	2300      	movs	r3, #0
 8008d0e:	6463      	str	r3, [r4, #68]	; 0x44
 8008d10:	e7e8      	b.n	8008ce4 <vQueueWaitForMessageRestricted+0x10>
 8008d12:	46c0      	nop			; (mov r8, r8)

08008d14 <prvListTaskWithinSingleList.part.1>:
}
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
 8008d14:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008d16:	4656      	mov	r6, sl
 8008d18:	465f      	mov	r7, fp
 8008d1a:	464d      	mov	r5, r9
 8008d1c:	4644      	mov	r4, r8
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 8008d1e:	684b      	ldr	r3, [r1, #4]
}
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
 8008d20:	b4f0      	push	{r4, r5, r6, r7}
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 8008d22:	685e      	ldr	r6, [r3, #4]
 8008d24:	2308      	movs	r3, #8
 8008d26:	469a      	mov	sl, r3
 8008d28:	448a      	add	sl, r1
}
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
 8008d2a:	4693      	mov	fp, r2
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 8008d2c:	604e      	str	r6, [r1, #4]
 8008d2e:	4556      	cmp	r6, sl
 8008d30:	d045      	beq.n	8008dbe <prvListTaskWithinSingleList.part.1+0xaa>
 8008d32:	68f3      	ldr	r3, [r6, #12]
 8008d34:	1c04      	adds	r4, r0, #0
 8008d36:	4698      	mov	r8, r3
					be reported as being in the Blocked state. */
					if( eState == eSuspended )
					{
						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
						{
							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
 8008d38:	2302      	movs	r3, #2
 8008d3a:	4699      	mov	r9, r3
				{
					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
				}
				#else
				{
					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
 8008d3c:	2300      	movs	r3, #0
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
 8008d3e:	2000      	movs	r0, #0
				{
					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
				}
				#else
				{
					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
 8008d40:	469c      	mov	ip, r3
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 8008d42:	6876      	ldr	r6, [r6, #4]
 8008d44:	604e      	str	r6, [r1, #4]
 8008d46:	45b2      	cmp	sl, r6
 8008d48:	d036      	beq.n	8008db8 <prvListTaskWithinSingleList.part.1+0xa4>
 8008d4a:	68f5      	ldr	r5, [r6, #12]

				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
 8008d4c:	1c2b      	adds	r3, r5, #0
 8008d4e:	3334      	adds	r3, #52	; 0x34
 8008d50:	6063      	str	r3, [r4, #4]
				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
 8008d52:	6beb      	ldr	r3, [r5, #60]	; 0x3c
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );

				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
 8008d54:	6025      	str	r5, [r4, #0]
				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
 8008d56:	60a3      	str	r3, [r4, #8]
				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
 8008d58:	465b      	mov	r3, fp
 8008d5a:	7323      	strb	r3, [r4, #12]
				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
 8008d5c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8008d5e:	6123      	str	r3, [r4, #16]
				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* If the task is in the suspended list then there is a chance
					it is actually just blocked indefinitely - so really it should
					be reported as being in the Blocked state. */
					if( eState == eSuspended )
 8008d60:	465b      	mov	r3, fp
 8008d62:	2b03      	cmp	r3, #3
 8008d64:	d019      	beq.n	8008d9a <prvListTaskWithinSingleList.part.1+0x86>
				}
				#endif /* INCLUDE_vTaskSuspend */

				#if ( configUSE_MUTEXES == 1 )
				{
					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
 8008d66:	6c6b      	ldr	r3, [r5, #68]	; 0x44
				{
					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxEndOfStack );
				}
				#else
				{
					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxStack );
 8008d68:	6b2f      	ldr	r7, [r5, #48]	; 0x30
				}
				#endif /* INCLUDE_vTaskSuspend */

				#if ( configUSE_MUTEXES == 1 )
				{
					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
 8008d6a:	6163      	str	r3, [r4, #20]
				{
					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
				}
				#else
				{
					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
 8008d6c:	4663      	mov	r3, ip
 8008d6e:	61a3      	str	r3, [r4, #24]

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 8008d70:	783b      	ldrb	r3, [r7, #0]
 8008d72:	2ba5      	cmp	r3, #165	; 0xa5
 8008d74:	d11e      	bne.n	8008db4 <prvListTaskWithinSingleList.part.1+0xa0>
 8008d76:	2300      	movs	r3, #0
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
 8008d78:	3301      	adds	r3, #1

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 8008d7a:	5cfa      	ldrb	r2, [r7, r3]
 8008d7c:	2aa5      	cmp	r2, #165	; 0xa5
 8008d7e:	d0fb      	beq.n	8008d78 <prvListTaskWithinSingleList.part.1+0x64>
 8008d80:	089b      	lsrs	r3, r3, #2
 8008d82:	b29b      	uxth	r3, r3
				{
					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxEndOfStack );
				}
				#else
				{
					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxStack );
 8008d84:	83a3      	strh	r3, [r4, #28]
				}
				#endif

				uxTask++;
 8008d86:	3001      	adds	r0, #1
 8008d88:	3420      	adds	r4, #32

			} while( pxNextTCB != pxFirstTCB );
 8008d8a:	45a8      	cmp	r8, r5
 8008d8c:	d1d9      	bne.n	8008d42 <prvListTaskWithinSingleList.part.1+0x2e>
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return uxTask;
	}
 8008d8e:	bc3c      	pop	{r2, r3, r4, r5}
 8008d90:	4690      	mov	r8, r2
 8008d92:	4699      	mov	r9, r3
 8008d94:	46a2      	mov	sl, r4
 8008d96:	46ab      	mov	fp, r5
 8008d98:	bdf0      	pop	{r4, r5, r6, r7, pc}
					/* If the task is in the suspended list then there is a chance
					it is actually just blocked indefinitely - so really it should
					be reported as being in the Blocked state. */
					if( eState == eSuspended )
					{
						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
 8008d9a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8008d9c:	2b00      	cmp	r3, #0
 8008d9e:	d0e2      	beq.n	8008d66 <prvListTaskWithinSingleList.part.1+0x52>
						{
							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
 8008da0:	464b      	mov	r3, r9
 8008da2:	7323      	strb	r3, [r4, #12]
				}
				#endif /* INCLUDE_vTaskSuspend */

				#if ( configUSE_MUTEXES == 1 )
				{
					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
 8008da4:	6c6b      	ldr	r3, [r5, #68]	; 0x44
				{
					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxEndOfStack );
				}
				#else
				{
					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxStack );
 8008da6:	6b2f      	ldr	r7, [r5, #48]	; 0x30
				}
				#endif /* INCLUDE_vTaskSuspend */

				#if ( configUSE_MUTEXES == 1 )
				{
					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
 8008da8:	6163      	str	r3, [r4, #20]
				{
					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
				}
				#else
				{
					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
 8008daa:	4663      	mov	r3, ip
 8008dac:	61a3      	str	r3, [r4, #24]

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 8008dae:	783b      	ldrb	r3, [r7, #0]
 8008db0:	2ba5      	cmp	r3, #165	; 0xa5
 8008db2:	d0e0      	beq.n	8008d76 <prvListTaskWithinSingleList.part.1+0x62>
 8008db4:	2300      	movs	r3, #0
 8008db6:	e7e5      	b.n	8008d84 <prvListTaskWithinSingleList.part.1+0x70>
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 8008db8:	68ce      	ldr	r6, [r1, #12]
 8008dba:	604e      	str	r6, [r1, #4]
 8008dbc:	e7c5      	b.n	8008d4a <prvListTaskWithinSingleList.part.1+0x36>
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 8008dbe:	6876      	ldr	r6, [r6, #4]
 8008dc0:	e7b7      	b.n	8008d32 <prvListTaskWithinSingleList.part.1+0x1e>
 8008dc2:	46c0      	nop			; (mov r8, r8)

08008dc4 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8008dc4:	4b07      	ldr	r3, [pc, #28]	; (8008de4 <prvResetNextTaskUnblockTime+0x20>)
 8008dc6:	681a      	ldr	r2, [r3, #0]
 8008dc8:	6812      	ldr	r2, [r2, #0]
 8008dca:	2a00      	cmp	r2, #0
 8008dcc:	d103      	bne.n	8008dd6 <prvResetNextTaskUnblockTime+0x12>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8008dce:	4b06      	ldr	r3, [pc, #24]	; (8008de8 <prvResetNextTaskUnblockTime+0x24>)
 8008dd0:	3a01      	subs	r2, #1
 8008dd2:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
	}
}
 8008dd4:	4770      	bx	lr
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8008dd6:	681b      	ldr	r3, [r3, #0]
 8008dd8:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 8008dda:	68db      	ldr	r3, [r3, #12]
 8008ddc:	685a      	ldr	r2, [r3, #4]
 8008dde:	4b02      	ldr	r3, [pc, #8]	; (8008de8 <prvResetNextTaskUnblockTime+0x24>)
 8008de0:	601a      	str	r2, [r3, #0]
 8008de2:	e7f7      	b.n	8008dd4 <prvResetNextTaskUnblockTime+0x10>
 8008de4:	20000268 	.word	0x20000268
 8008de8:	2000004c 	.word	0x2000004c

08008dec <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8008dec:	4b0c      	ldr	r3, [pc, #48]	; (8008e20 <prvAddCurrentTaskToDelayedList+0x34>)
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
 8008dee:	b510      	push	{r4, lr}
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8008df0:	685a      	ldr	r2, [r3, #4]
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
 8008df2:	1e04      	subs	r4, r0, #0
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8008df4:	6050      	str	r0, [r2, #4]

	if( xTimeToWake < xTickCount )
 8008df6:	689a      	ldr	r2, [r3, #8]
 8008df8:	4294      	cmp	r4, r2
 8008dfa:	d30a      	bcc.n	8008e12 <prvAddCurrentTaskToDelayedList+0x26>
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8008dfc:	6818      	ldr	r0, [r3, #0]
 8008dfe:	6859      	ldr	r1, [r3, #4]
 8008e00:	3104      	adds	r1, #4
 8008e02:	f001 f85b 	bl	8009ebc <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 8008e06:	4b07      	ldr	r3, [pc, #28]	; (8008e24 <prvAddCurrentTaskToDelayedList+0x38>)
 8008e08:	681a      	ldr	r2, [r3, #0]
 8008e0a:	4294      	cmp	r4, r2
 8008e0c:	d200      	bcs.n	8008e10 <prvAddCurrentTaskToDelayedList+0x24>
		{
			xNextTaskUnblockTime = xTimeToWake;
 8008e0e:	601c      	str	r4, [r3, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 8008e10:	bd10      	pop	{r4, pc}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8008e12:	68d8      	ldr	r0, [r3, #12]
 8008e14:	6859      	ldr	r1, [r3, #4]
 8008e16:	3104      	adds	r1, #4
 8008e18:	f001 f850 	bl	8009ebc <vListInsert>
 8008e1c:	e7f8      	b.n	8008e10 <prvAddCurrentTaskToDelayedList+0x24>
 8008e1e:	46c0      	nop			; (mov r8, r8)
 8008e20:	20000268 	.word	0x20000268
 8008e24:	2000004c 	.word	0x2000004c

08008e28 <vTaskSwitchContext.part.5>:
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
 8008e28:	2300      	movs	r3, #0
	}

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
 8008e2a:	b510      	push	{r4, lr}
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
 8008e2c:	4c20      	ldr	r4, [pc, #128]	; (8008eb0 <vTaskSwitchContext.part.5+0x88>)
 8008e2e:	6123      	str	r3, [r4, #16]
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 8008e30:	6862      	ldr	r2, [r4, #4]
 8008e32:	6863      	ldr	r3, [r4, #4]
 8008e34:	6812      	ldr	r2, [r2, #0]
 8008e36:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008e38:	429a      	cmp	r2, r3
 8008e3a:	d923      	bls.n	8008e84 <vTaskSwitchContext.part.5+0x5c>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
 8008e3c:	6863      	ldr	r3, [r4, #4]
 8008e3e:	491d      	ldr	r1, [pc, #116]	; (8008eb4 <vTaskSwitchContext.part.5+0x8c>)
 8008e40:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8008e42:	2214      	movs	r2, #20
 8008e44:	f001 fb9e 	bl	800a584 <memcmp>
 8008e48:	2800      	cmp	r0, #0
 8008e4a:	d003      	beq.n	8008e54 <vTaskSwitchContext.part.5+0x2c>
 8008e4c:	e027      	b.n	8008e9e <vTaskSwitchContext.part.5+0x76>

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8008e4e:	6963      	ldr	r3, [r4, #20]
 8008e50:	3b01      	subs	r3, #1
 8008e52:	6163      	str	r3, [r4, #20]
 8008e54:	6963      	ldr	r3, [r4, #20]
 8008e56:	009a      	lsls	r2, r3, #2
 8008e58:	18d3      	adds	r3, r2, r3
 8008e5a:	009b      	lsls	r3, r3, #2
 8008e5c:	18e3      	adds	r3, r4, r3
 8008e5e:	699b      	ldr	r3, [r3, #24]
 8008e60:	2b00      	cmp	r3, #0
 8008e62:	d0f4      	beq.n	8008e4e <vTaskSwitchContext.part.5+0x26>
 8008e64:	6963      	ldr	r3, [r4, #20]
 8008e66:	009a      	lsls	r2, r3, #2
 8008e68:	18d3      	adds	r3, r2, r3
 8008e6a:	009b      	lsls	r3, r3, #2
 8008e6c:	18e2      	adds	r2, r4, r3
 8008e6e:	3218      	adds	r2, #24
 8008e70:	6851      	ldr	r1, [r2, #4]
 8008e72:	18e3      	adds	r3, r4, r3
 8008e74:	6849      	ldr	r1, [r1, #4]
 8008e76:	3320      	adds	r3, #32
 8008e78:	6051      	str	r1, [r2, #4]
 8008e7a:	4299      	cmp	r1, r3
 8008e7c:	d015      	beq.n	8008eaa <vTaskSwitchContext.part.5+0x82>
 8008e7e:	68cb      	ldr	r3, [r1, #12]
 8008e80:	6063      	str	r3, [r4, #4]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 8008e82:	bd10      	pop	{r4, pc}
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 8008e84:	6860      	ldr	r0, [r4, #4]
 8008e86:	6861      	ldr	r1, [r4, #4]
 8008e88:	3134      	adds	r1, #52	; 0x34
 8008e8a:	f7f7 fd1d 	bl	80008c8 <vApplicationStackOverflowHook>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
 8008e8e:	6863      	ldr	r3, [r4, #4]
 8008e90:	4908      	ldr	r1, [pc, #32]	; (8008eb4 <vTaskSwitchContext.part.5+0x8c>)
 8008e92:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8008e94:	2214      	movs	r2, #20
 8008e96:	f001 fb75 	bl	800a584 <memcmp>
 8008e9a:	2800      	cmp	r0, #0
 8008e9c:	d0da      	beq.n	8008e54 <vTaskSwitchContext.part.5+0x2c>
 8008e9e:	6860      	ldr	r0, [r4, #4]
 8008ea0:	6861      	ldr	r1, [r4, #4]
 8008ea2:	3134      	adds	r1, #52	; 0x34
 8008ea4:	f7f7 fd10 	bl	80008c8 <vApplicationStackOverflowHook>
 8008ea8:	e7d4      	b.n	8008e54 <vTaskSwitchContext.part.5+0x2c>

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8008eaa:	6849      	ldr	r1, [r1, #4]
 8008eac:	6051      	str	r1, [r2, #4]
 8008eae:	e7e6      	b.n	8008e7e <vTaskSwitchContext.part.5+0x56>
 8008eb0:	20000268 	.word	0x20000268
 8008eb4:	0800aa58 	.word	0x0800aa58

08008eb8 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 8008eb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008eba:	464f      	mov	r7, r9
 8008ebc:	4646      	mov	r6, r8
 8008ebe:	4680      	mov	r8, r0
 8008ec0:	b4c0      	push	{r6, r7}
{
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 8008ec2:	204c      	movs	r0, #76	; 0x4c
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 8008ec4:	1c0d      	adds	r5, r1, #0
 8008ec6:	1c17      	adds	r7, r2, #0
 8008ec8:	4699      	mov	r9, r3
{
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 8008eca:	f000 ff9f 	bl	8009e0c <pvPortMalloc>
 8008ece:	1e04      	subs	r4, r0, #0

	if( pxNewTCB != NULL )
 8008ed0:	d100      	bne.n	8008ed4 <xTaskGenericCreate+0x1c>
 8008ed2:	e097      	b.n	8009004 <xTaskGenericCreate+0x14c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8008ed4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008ed6:	2b00      	cmp	r3, #0
 8008ed8:	d100      	bne.n	8008edc <xTaskGenericCreate+0x24>
 8008eda:	e088      	b.n	8008fee <xTaskGenericCreate+0x136>
 8008edc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008ede:	00be      	lsls	r6, r7, #2
 8008ee0:	6303      	str	r3, [r0, #48]	; 0x30
 8008ee2:	1c18      	adds	r0, r3, #0
		{
			/* Avoid dependency on memset() if it is not required. */
			#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
			{
				/* Just to help debugging. */
				( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
 8008ee4:	21a5      	movs	r1, #165	; 0xa5
 8008ee6:	1c32      	adds	r2, r6, #0
 8008ee8:	f001 fbb2 	bl	800a650 <memset>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 8008eec:	4b59      	ldr	r3, [pc, #356]	; (8009054 <xTaskGenericCreate+0x19c>)
 8008eee:	1c20      	adds	r0, r4, #0
 8008ef0:	469c      	mov	ip, r3
 8008ef2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8008ef4:	4467      	add	r7, ip
 8008ef6:	469c      	mov	ip, r3
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8008ef8:	2307      	movs	r3, #7
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 8008efa:	00bf      	lsls	r7, r7, #2
 8008efc:	4467      	add	r7, ip
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8008efe:	439f      	bics	r7, r3
 8008f00:	1c23      	adds	r3, r4, #0
 8008f02:	1c29      	adds	r1, r5, #0
 8008f04:	3334      	adds	r3, #52	; 0x34
 8008f06:	3039      	adds	r0, #57	; 0x39
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 8008f08:	780a      	ldrb	r2, [r1, #0]
 8008f0a:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 8008f0c:	780a      	ldrb	r2, [r1, #0]
 8008f0e:	2a00      	cmp	r2, #0
 8008f10:	d003      	beq.n	8008f1a <xTaskGenericCreate+0x62>
 8008f12:	3301      	adds	r3, #1
 8008f14:	3101      	adds	r1, #1
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8008f16:	4283      	cmp	r3, r0
 8008f18:	d1f6      	bne.n	8008f08 <xTaskGenericCreate+0x50>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8008f1a:	2200      	movs	r2, #0
 8008f1c:	2338      	movs	r3, #56	; 0x38
 8008f1e:	9e08      	ldr	r6, [sp, #32]
 8008f20:	54e2      	strb	r2, [r4, r3]
 8008f22:	2e04      	cmp	r6, #4
 8008f24:	d850      	bhi.n	8008fc8 <xTaskGenericCreate+0x110>

	pxTCB->uxPriority = uxPriority;
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
 8008f26:	2300      	movs	r3, #0
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8008f28:	1d25      	adds	r5, r4, #4

	pxTCB->uxPriority = uxPriority;
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
 8008f2a:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8008f2c:	1c28      	adds	r0, r5, #0
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
 8008f2e:	62e6      	str	r6, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 8008f30:	6466      	str	r6, [r4, #68]	; 0x44
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8008f32:	f000 ffb3 	bl	8009e9c <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 8008f36:	1c20      	adds	r0, r4, #0
 8008f38:	3018      	adds	r0, #24
 8008f3a:	f000 ffaf 	bl	8009e9c <vListInitialiseItem>
	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8008f3e:	2305      	movs	r3, #5
 8008f40:	1b9b      	subs	r3, r3, r6
 8008f42:	61a3      	str	r3, [r4, #24]
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8008f44:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 8008f46:	6264      	str	r4, [r4, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8008f48:	1c38      	adds	r0, r7, #0
 8008f4a:	4641      	mov	r1, r8
 8008f4c:	464a      	mov	r2, r9
 8008f4e:	f000 fff1 	bl	8009f34 <pxPortInitialiseStack>
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 8008f52:	9b09      	ldr	r3, [sp, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8008f54:	6020      	str	r0, [r4, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 8008f56:	2b00      	cmp	r3, #0
 8008f58:	d000      	beq.n	8008f5c <xTaskGenericCreate+0xa4>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8008f5a:	601c      	str	r4, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 8008f5c:	f001 f834 	bl	8009fc8 <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 8008f60:	4e3d      	ldr	r6, [pc, #244]	; (8009058 <xTaskGenericCreate+0x1a0>)
 8008f62:	6ff3      	ldr	r3, [r6, #124]	; 0x7c
 8008f64:	3301      	adds	r3, #1
 8008f66:	67f3      	str	r3, [r6, #124]	; 0x7c
			if( pxCurrentTCB == NULL )
 8008f68:	6873      	ldr	r3, [r6, #4]
 8008f6a:	2b00      	cmp	r3, #0
 8008f6c:	d031      	beq.n	8008fd2 <xTaskGenericCreate+0x11a>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 8008f6e:	4f3b      	ldr	r7, [pc, #236]	; (800905c <xTaskGenericCreate+0x1a4>)
 8008f70:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8008f72:	2b00      	cmp	r3, #0
 8008f74:	d105      	bne.n	8008f82 <xTaskGenericCreate+0xca>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8008f76:	6873      	ldr	r3, [r6, #4]
 8008f78:	9a08      	ldr	r2, [sp, #32]
 8008f7a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8008f7c:	429a      	cmp	r2, r3
 8008f7e:	d300      	bcc.n	8008f82 <xTaskGenericCreate+0xca>
					{
						pxCurrentTCB = pxNewTCB;
 8008f80:	6074      	str	r4, [r6, #4]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8008f82:	6ebb      	ldr	r3, [r7, #104]	; 0x68
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8008f84:	6972      	ldr	r2, [r6, #20]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8008f86:	3301      	adds	r3, #1
 8008f88:	66bb      	str	r3, [r7, #104]	; 0x68

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
 8008f8a:	63e3      	str	r3, [r4, #60]	; 0x3c
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8008f8c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8008f8e:	4293      	cmp	r3, r2
 8008f90:	d818      	bhi.n	8008fc4 <xTaskGenericCreate+0x10c>
 8008f92:	1c32      	adds	r2, r6, #0
 8008f94:	0098      	lsls	r0, r3, #2
 8008f96:	18c0      	adds	r0, r0, r3
 8008f98:	0083      	lsls	r3, r0, #2
 8008f9a:	3218      	adds	r2, #24
 8008f9c:	18d0      	adds	r0, r2, r3
 8008f9e:	1c29      	adds	r1, r5, #0
 8008fa0:	f000 ff80 	bl	8009ea4 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 8008fa4:	f001 f81c 	bl	8009fe0 <vPortExitCritical>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 8008fa8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8008faa:	2401      	movs	r4, #1
 8008fac:	2b00      	cmp	r3, #0
 8008fae:	d004      	beq.n	8008fba <xTaskGenericCreate+0x102>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 8008fb0:	6873      	ldr	r3, [r6, #4]
 8008fb2:	9a08      	ldr	r2, [sp, #32]
 8008fb4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8008fb6:	429a      	cmp	r2, r3
 8008fb8:	d808      	bhi.n	8008fcc <xTaskGenericCreate+0x114>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
 8008fba:	1c20      	adds	r0, r4, #0
 8008fbc:	bc0c      	pop	{r2, r3}
 8008fbe:	4690      	mov	r8, r2
 8008fc0:	4699      	mov	r9, r3
 8008fc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8008fc4:	6173      	str	r3, [r6, #20]
 8008fc6:	e7e4      	b.n	8008f92 <xTaskGenericCreate+0xda>
 8008fc8:	2604      	movs	r6, #4
 8008fca:	e7ac      	b.n	8008f26 <xTaskGenericCreate+0x6e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
			{
				taskYIELD_IF_USING_PREEMPTION();
 8008fcc:	f000 fff0 	bl	8009fb0 <vPortYield>
 8008fd0:	e7f3      	b.n	8008fba <xTaskGenericCreate+0x102>
			uxCurrentNumberOfTasks++;
			if( pxCurrentTCB == NULL )
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 8008fd2:	6074      	str	r4, [r6, #4]

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8008fd4:	6ff3      	ldr	r3, [r6, #124]	; 0x7c
 8008fd6:	2b01      	cmp	r3, #1
 8008fd8:	d017      	beq.n	800900a <xTaskGenericCreate+0x152>
 8008fda:	4f20      	ldr	r7, [pc, #128]	; (800905c <xTaskGenericCreate+0x1a4>)
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8008fdc:	6972      	ldr	r2, [r6, #20]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8008fde:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8008fe0:	3301      	adds	r3, #1
 8008fe2:	66bb      	str	r3, [r7, #104]	; 0x68

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
 8008fe4:	63e3      	str	r3, [r4, #60]	; 0x3c
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8008fe6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8008fe8:	4293      	cmp	r3, r2
 8008fea:	d9d2      	bls.n	8008f92 <xTaskGenericCreate+0xda>
 8008fec:	e7ea      	b.n	8008fc4 <xTaskGenericCreate+0x10c>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8008fee:	00be      	lsls	r6, r7, #2
 8008ff0:	1c30      	adds	r0, r6, #0
 8008ff2:	f000 ff0b 	bl	8009e0c <pvPortMalloc>
 8008ff6:	6320      	str	r0, [r4, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 8008ff8:	2800      	cmp	r0, #0
 8008ffa:	d000      	beq.n	8008ffe <xTaskGenericCreate+0x146>
 8008ffc:	e772      	b.n	8008ee4 <xTaskGenericCreate+0x2c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 8008ffe:	1c20      	adds	r0, r4, #0
 8009000:	f000 ff2e 	bl	8009e60 <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8009004:	2401      	movs	r4, #1
 8009006:	4264      	negs	r4, r4
 8009008:	e7d7      	b.n	8008fba <xTaskGenericCreate+0x102>
 800900a:	237c      	movs	r3, #124	; 0x7c
 800900c:	1c37      	adds	r7, r6, #0
 800900e:	4698      	mov	r8, r3
 8009010:	3718      	adds	r7, #24
 8009012:	44b0      	add	r8, r6
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8009014:	1c38      	adds	r0, r7, #0
 8009016:	3714      	adds	r7, #20
 8009018:	f000 ff34 	bl	8009e84 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800901c:	4547      	cmp	r7, r8
 800901e:	d1f9      	bne.n	8009014 <xTaskGenericCreate+0x15c>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 8009020:	4f0e      	ldr	r7, [pc, #56]	; (800905c <xTaskGenericCreate+0x1a4>)
 8009022:	1c38      	adds	r0, r7, #0
 8009024:	f000 ff2e 	bl	8009e84 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8009028:	2314      	movs	r3, #20
 800902a:	4698      	mov	r8, r3
 800902c:	44b8      	add	r8, r7
 800902e:	4640      	mov	r0, r8
 8009030:	f000 ff28 	bl	8009e84 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8009034:	1c38      	adds	r0, r7, #0
 8009036:	3028      	adds	r0, #40	; 0x28
 8009038:	f000 ff24 	bl	8009e84 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 800903c:	1c38      	adds	r0, r7, #0
 800903e:	303c      	adds	r0, #60	; 0x3c
 8009040:	f000 ff20 	bl	8009e84 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 8009044:	1c38      	adds	r0, r7, #0
 8009046:	3050      	adds	r0, #80	; 0x50
 8009048:	f000 ff1c 	bl	8009e84 <vListInitialise>
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800904c:	4643      	mov	r3, r8
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 800904e:	6037      	str	r7, [r6, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8009050:	60f3      	str	r3, [r6, #12]
 8009052:	e796      	b.n	8008f82 <xTaskGenericCreate+0xca>
 8009054:	3fffffff 	.word	0x3fffffff
 8009058:	20000268 	.word	0x20000268
 800905c:	200002e8 	.word	0x200002e8

08009060 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
 8009060:	b570      	push	{r4, r5, r6, lr}
 8009062:	1c05      	adds	r5, r0, #0
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 8009064:	f000 ffb0 	bl	8009fc8 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8009068:	2d00      	cmp	r5, #0
 800906a:	d026      	beq.n	80090ba <vTaskDelete+0x5a>

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 800906c:	1d2e      	adds	r6, r5, #4
 800906e:	1c30      	adds	r0, r6, #0
 8009070:	f000 ff3c 	bl	8009eec <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8009074:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8009076:	2b00      	cmp	r3, #0
 8009078:	d003      	beq.n	8009082 <vTaskDelete+0x22>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800907a:	1c28      	adds	r0, r5, #0
 800907c:	3018      	adds	r0, #24
 800907e:	f000 ff35 	bl	8009eec <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 8009082:	4c11      	ldr	r4, [pc, #68]	; (80090c8 <vTaskDelete+0x68>)
 8009084:	1c31      	adds	r1, r6, #0
 8009086:	1c20      	adds	r0, r4, #0
 8009088:	303c      	adds	r0, #60	; 0x3c
 800908a:	f000 ff0b 	bl	8009ea4 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
 800908e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8009090:	3301      	adds	r3, #1
 8009092:	66e3      	str	r3, [r4, #108]	; 0x6c

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
 8009094:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8009096:	3301      	adds	r3, #1
 8009098:	66a3      	str	r3, [r4, #104]	; 0x68

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
 800909a:	f000 ffa1 	bl	8009fe0 <vPortExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
 800909e:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80090a0:	2b00      	cmp	r3, #0
 80090a2:	d009      	beq.n	80090b8 <vTaskDelete+0x58>
		{
			if( pxTCB == pxCurrentTCB )
 80090a4:	4b09      	ldr	r3, [pc, #36]	; (80090cc <vTaskDelete+0x6c>)
 80090a6:	685b      	ldr	r3, [r3, #4]
 80090a8:	429d      	cmp	r5, r3
 80090aa:	d009      	beq.n	80090c0 <vTaskDelete+0x60>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
 80090ac:	f000 ff8c 	bl	8009fc8 <vPortEnterCritical>
				{
					prvResetNextTaskUnblockTime();
 80090b0:	f7ff fe88 	bl	8008dc4 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
 80090b4:	f000 ff94 	bl	8009fe0 <vPortExitCritical>
			}
		}
	}
 80090b8:	bd70      	pop	{r4, r5, r6, pc}

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 80090ba:	4b04      	ldr	r3, [pc, #16]	; (80090cc <vTaskDelete+0x6c>)
 80090bc:	685d      	ldr	r5, [r3, #4]
 80090be:	e7d5      	b.n	800906c <vTaskDelete+0xc>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
 80090c0:	f000 ff76 	bl	8009fb0 <vPortYield>
 80090c4:	e7f8      	b.n	80090b8 <vTaskDelete+0x58>
 80090c6:	46c0      	nop			; (mov r8, r8)
 80090c8:	200002e8 	.word	0x200002e8
 80090cc:	20000268 	.word	0x20000268

080090d0 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
 80090d0:	b510      	push	{r4, lr}
 80090d2:	1c04      	adds	r4, r0, #0
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
 80090d4:	f000 ff78 	bl	8009fc8 <vPortEnterCritical>
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( xTask );
 80090d8:	2c00      	cmp	r4, #0
 80090da:	d004      	beq.n	80090e6 <uxTaskPriorityGet+0x16>
			uxReturn = pxTCB->uxPriority;
 80090dc:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
		}
		taskEXIT_CRITICAL();
 80090de:	f000 ff7f 	bl	8009fe0 <vPortExitCritical>

		return uxReturn;
	}
 80090e2:	1c20      	adds	r0, r4, #0
 80090e4:	bd10      	pop	{r4, pc}

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( xTask );
 80090e6:	4b01      	ldr	r3, [pc, #4]	; (80090ec <uxTaskPriorityGet+0x1c>)
 80090e8:	685c      	ldr	r4, [r3, #4]
 80090ea:	e7f7      	b.n	80090dc <uxTaskPriorityGet+0xc>
 80090ec:	20000268 	.word	0x20000268

080090f0 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
 80090f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80090f2:	4647      	mov	r7, r8
 80090f4:	1c04      	adds	r4, r0, #0
 80090f6:	b480      	push	{r7}
 80090f8:	1e0d      	subs	r5, r1, #0
 80090fa:	2d04      	cmp	r5, #4
 80090fc:	d900      	bls.n	8009100 <vTaskPrioritySet+0x10>
 80090fe:	2504      	movs	r5, #4
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
 8009100:	f000 ff62 	bl	8009fc8 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
 8009104:	2c00      	cmp	r4, #0
 8009106:	d036      	beq.n	8009176 <vTaskPrioritySet+0x86>

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
 8009108:	6c62      	ldr	r2, [r4, #68]	; 0x44
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
 800910a:	42aa      	cmp	r2, r5
 800910c:	d01c      	beq.n	8009148 <vTaskPrioritySet+0x58>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
				{
					if( pxTCB != pxCurrentTCB )
 800910e:	4e26      	ldr	r6, [pc, #152]	; (80091a8 <vTaskPrioritySet+0xb8>)

			if( uxCurrentBasePriority != uxNewPriority )
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
 8009110:	d31f      	bcc.n	8009152 <vTaskPrioritySet+0x62>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
 8009112:	6877      	ldr	r7, [r6, #4]
 8009114:	1be7      	subs	r7, r4, r7
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
						{
							xYieldRequired = pdTRUE;
 8009116:	4279      	negs	r1, r7
 8009118:	4179      	adcs	r1, r7
 800911a:	4688      	mov	r8, r1
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 800911c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 800911e:	429a      	cmp	r2, r3
 8009120:	d024      	beq.n	800916c <vTaskPrioritySet+0x7c>
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8009122:	69a2      	ldr	r2, [r4, #24]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
 8009124:	6465      	str	r5, [r4, #68]	; 0x44
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8009126:	2a00      	cmp	r2, #0
 8009128:	db02      	blt.n	8009130 <vTaskPrioritySet+0x40>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800912a:	2205      	movs	r2, #5
 800912c:	1b55      	subs	r5, r2, r5
 800912e:	61a5      	str	r5, [r4, #24]

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8009130:	1c32      	adds	r2, r6, #0
 8009132:	0099      	lsls	r1, r3, #2
 8009134:	18cb      	adds	r3, r1, r3
 8009136:	3218      	adds	r2, #24
 8009138:	009b      	lsls	r3, r3, #2
 800913a:	18d3      	adds	r3, r2, r3
 800913c:	6962      	ldr	r2, [r4, #20]
 800913e:	429a      	cmp	r2, r3
 8009140:	d01c      	beq.n	800917c <vTaskPrioritySet+0x8c>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired == pdTRUE )
 8009142:	4643      	mov	r3, r8
 8009144:	2b01      	cmp	r3, #1
 8009146:	d013      	beq.n	8009170 <vTaskPrioritySet+0x80>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
 8009148:	f000 ff4a 	bl	8009fe0 <vPortExitCritical>
	}
 800914c:	bc04      	pop	{r2}
 800914e:	4690      	mov	r8, r2
 8009150:	bdf0      	pop	{r4, r5, r6, r7, pc}
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
				{
					if( pxTCB != pxCurrentTCB )
 8009152:	6873      	ldr	r3, [r6, #4]
 8009154:	429c      	cmp	r4, r3
 8009156:	d023      	beq.n	80091a0 <vTaskPrioritySet+0xb0>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 8009158:	2700      	movs	r7, #0
 800915a:	1c39      	adds	r1, r7, #0
 800915c:	6873      	ldr	r3, [r6, #4]
 800915e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009160:	429d      	cmp	r5, r3
 8009162:	4179      	adcs	r1, r7
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 8009164:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
					if( pxTCB != pxCurrentTCB )
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 8009166:	4688      	mov	r8, r1

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 8009168:	429a      	cmp	r2, r3
 800916a:	d1da      	bne.n	8009122 <vTaskPrioritySet+0x32>
					{
						pxTCB->uxPriority = uxNewPriority;
 800916c:	62e5      	str	r5, [r4, #44]	; 0x2c
 800916e:	e7d8      	b.n	8009122 <vTaskPrioritySet+0x32>
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired == pdTRUE )
				{
					taskYIELD_IF_USING_PREEMPTION();
 8009170:	f000 ff1e 	bl	8009fb0 <vPortYield>
 8009174:	e7e8      	b.n	8009148 <vTaskPrioritySet+0x58>

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
 8009176:	4b0c      	ldr	r3, [pc, #48]	; (80091a8 <vTaskPrioritySet+0xb8>)
 8009178:	685c      	ldr	r4, [r3, #4]
 800917a:	e7c5      	b.n	8009108 <vTaskPrioritySet+0x18>
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 800917c:	1d25      	adds	r5, r4, #4
 800917e:	1c28      	adds	r0, r5, #0
 8009180:	f000 feb4 	bl	8009eec <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
 8009184:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8009186:	6972      	ldr	r2, [r6, #20]
 8009188:	4293      	cmp	r3, r2
 800918a:	d900      	bls.n	800918e <vTaskPrioritySet+0x9e>
 800918c:	6173      	str	r3, [r6, #20]
 800918e:	0098      	lsls	r0, r3, #2
 8009190:	18c3      	adds	r3, r0, r3
 8009192:	3618      	adds	r6, #24
 8009194:	009b      	lsls	r3, r3, #2
 8009196:	18f0      	adds	r0, r6, r3
 8009198:	1c29      	adds	r1, r5, #0
 800919a:	f000 fe83 	bl	8009ea4 <vListInsertEnd>
 800919e:	e7d0      	b.n	8009142 <vTaskPrioritySet+0x52>

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
 80091a0:	2300      	movs	r3, #0
 80091a2:	4698      	mov	r8, r3
 80091a4:	e7ba      	b.n	800911c <vTaskPrioritySet+0x2c>
 80091a6:	46c0      	nop			; (mov r8, r8)
 80091a8:	20000268 	.word	0x20000268

080091ac <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
 80091ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80091ae:	1c04      	adds	r4, r0, #0
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 80091b0:	f000 ff0a 	bl	8009fc8 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 80091b4:	4f1c      	ldr	r7, [pc, #112]	; (8009228 <vTaskSuspend+0x7c>)
 80091b6:	2c00      	cmp	r4, #0
 80091b8:	d02c      	beq.n	8009214 <vTaskSuspend+0x68>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 80091ba:	1d26      	adds	r6, r4, #4
 80091bc:	1c30      	adds	r0, r6, #0
 80091be:	f000 fe95 	bl	8009eec <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80091c2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80091c4:	2b00      	cmp	r3, #0
 80091c6:	d003      	beq.n	80091d0 <vTaskSuspend+0x24>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80091c8:	1c20      	adds	r0, r4, #0
 80091ca:	3018      	adds	r0, #24
 80091cc:	f000 fe8e 	bl	8009eec <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 80091d0:	4d16      	ldr	r5, [pc, #88]	; (800922c <vTaskSuspend+0x80>)
 80091d2:	1c31      	adds	r1, r6, #0
 80091d4:	1c28      	adds	r0, r5, #0
 80091d6:	3050      	adds	r0, #80	; 0x50
 80091d8:	f000 fe64 	bl	8009ea4 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
 80091dc:	f000 ff00 	bl	8009fe0 <vPortExitCritical>

		if( pxTCB == pxCurrentTCB )
 80091e0:	687b      	ldr	r3, [r7, #4]
 80091e2:	429c      	cmp	r4, r3
 80091e4:	d009      	beq.n	80091fa <vTaskSuspend+0x4e>
				}
			}
		}
		else
		{
			if( xSchedulerRunning != pdFALSE )
 80091e6:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 80091e8:	2b00      	cmp	r3, #0
 80091ea:	d005      	beq.n	80091f8 <vTaskSuspend+0x4c>
			{
				/* A task other than the currently running task was suspended,
				reset the next expected unblock time in case it referred to the
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
 80091ec:	f000 feec 	bl	8009fc8 <vPortEnterCritical>
				{
					prvResetNextTaskUnblockTime();
 80091f0:	f7ff fde8 	bl	8008dc4 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
 80091f4:	f000 fef4 	bl	8009fe0 <vPortExitCritical>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 80091f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		}
		taskEXIT_CRITICAL();

		if( pxTCB == pxCurrentTCB )
		{
			if( xSchedulerRunning != pdFALSE )
 80091fa:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 80091fc:	2b00      	cmp	r3, #0
 80091fe:	d10b      	bne.n	8009218 <vTaskSuspend+0x6c>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 8009200:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8009202:	6d29      	ldr	r1, [r5, #80]	; 0x50
 8009204:	4291      	cmp	r1, r2
 8009206:	d00d      	beq.n	8009224 <vTaskSuspend+0x78>
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8009208:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800920a:	2b00      	cmp	r3, #0
 800920c:	d007      	beq.n	800921e <vTaskSuspend+0x72>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 800920e:	2301      	movs	r3, #1
 8009210:	613b      	str	r3, [r7, #16]
 8009212:	e7f1      	b.n	80091f8 <vTaskSuspend+0x4c>

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 8009214:	687c      	ldr	r4, [r7, #4]
 8009216:	e7d0      	b.n	80091ba <vTaskSuspend+0xe>
		{
			if( xSchedulerRunning != pdFALSE )
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 8009218:	f000 feca 	bl	8009fb0 <vPortYield>
 800921c:	e7ec      	b.n	80091f8 <vTaskSuspend+0x4c>
 800921e:	f7ff fe03 	bl	8008e28 <vTaskSwitchContext.part.5>
 8009222:	e7e9      	b.n	80091f8 <vTaskSuspend+0x4c>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 8009224:	607b      	str	r3, [r7, #4]
 8009226:	e7e7      	b.n	80091f8 <vTaskSuspend+0x4c>
 8009228:	20000268 	.word	0x20000268
 800922c:	200002e8 	.word	0x200002e8

08009230 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
 8009230:	b570      	push	{r4, r5, r6, lr}
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 8009232:	2800      	cmp	r0, #0
 8009234:	d00e      	beq.n	8009254 <vTaskResume+0x24>
 8009236:	4d18      	ldr	r5, [pc, #96]	; (8009298 <vTaskResume+0x68>)
 8009238:	686b      	ldr	r3, [r5, #4]
 800923a:	4298      	cmp	r0, r3
 800923c:	d00a      	beq.n	8009254 <vTaskResume+0x24>
 800923e:	1c04      	adds	r4, r0, #0
		{
			taskENTER_CRITICAL();
 8009240:	f000 fec2 	bl	8009fc8 <vPortEnterCritical>

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8009244:	4b15      	ldr	r3, [pc, #84]	; (800929c <vTaskResume+0x6c>)
 8009246:	6961      	ldr	r1, [r4, #20]
 8009248:	1c1a      	adds	r2, r3, #0
 800924a:	3250      	adds	r2, #80	; 0x50
 800924c:	4291      	cmp	r1, r2
 800924e:	d002      	beq.n	8009256 <vTaskResume+0x26>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
 8009250:	f000 fec6 	bl	8009fe0 <vPortExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8009254:	bd70      	pop	{r4, r5, r6, pc}

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 8009256:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8009258:	3328      	adds	r3, #40	; 0x28
 800925a:	429a      	cmp	r2, r3
 800925c:	d0f8      	beq.n	8009250 <vTaskResume+0x20>
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
		{
			taskENTER_CRITICAL();
			{
				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 800925e:	2a00      	cmp	r2, #0
 8009260:	d1f6      	bne.n	8009250 <vTaskResume+0x20>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 8009262:	1d26      	adds	r6, r4, #4
 8009264:	1c30      	adds	r0, r6, #0
 8009266:	f000 fe41 	bl	8009eec <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800926a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800926c:	696a      	ldr	r2, [r5, #20]
 800926e:	4293      	cmp	r3, r2
 8009270:	d900      	bls.n	8009274 <vTaskResume+0x44>
 8009272:	616b      	str	r3, [r5, #20]
 8009274:	1c2a      	adds	r2, r5, #0
 8009276:	0098      	lsls	r0, r3, #2
 8009278:	18c0      	adds	r0, r0, r3
 800927a:	3218      	adds	r2, #24
 800927c:	0083      	lsls	r3, r0, #2
 800927e:	18d0      	adds	r0, r2, r3
 8009280:	1c31      	adds	r1, r6, #0
 8009282:	f000 fe0f 	bl	8009ea4 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8009286:	686b      	ldr	r3, [r5, #4]
 8009288:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800928a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800928c:	429a      	cmp	r2, r3
 800928e:	d3df      	bcc.n	8009250 <vTaskResume+0x20>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
 8009290:	f000 fe8e 	bl	8009fb0 <vPortYield>
 8009294:	e7dc      	b.n	8009250 <vTaskResume+0x20>
 8009296:	46c0      	nop			; (mov r8, r8)
 8009298:	20000268 	.word	0x20000268
 800929c:	200002e8 	.word	0x200002e8

080092a0 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
 80092a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80092a2:	4647      	mov	r7, r8
 80092a4:	b480      	push	{r7}
 80092a6:	1c04      	adds	r4, r0, #0
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80092a8:	f000 fea4 	bl	8009ff4 <ulSetInterruptMaskFromISR>

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 80092ac:	4b1d      	ldr	r3, [pc, #116]	; (8009324 <xTaskResumeFromISR+0x84>)
 80092ae:	6961      	ldr	r1, [r4, #20]
 80092b0:	1c1a      	adds	r2, r3, #0
 80092b2:	3250      	adds	r2, #80	; 0x50
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80092b4:	1c06      	adds	r6, r0, #0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 80092b6:	4291      	cmp	r1, r2
 80092b8:	d007      	beq.n	80092ca <xTaskResumeFromISR+0x2a>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
 80092ba:	2500      	movs	r5, #0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80092bc:	1c30      	adds	r0, r6, #0
 80092be:	f000 fe9f 	bl	800a000 <vClearInterruptMaskFromISR>

		return xYieldRequired;
	}
 80092c2:	1c28      	adds	r0, r5, #0
 80092c4:	bc04      	pop	{r2}
 80092c6:	4690      	mov	r8, r2
 80092c8:	bdf0      	pop	{r4, r5, r6, r7, pc}

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 80092ca:	1c18      	adds	r0, r3, #0
 80092cc:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80092ce:	3028      	adds	r0, #40	; 0x28

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
 80092d0:	2500      	movs	r5, #0

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 80092d2:	4282      	cmp	r2, r0
 80092d4:	d0f2      	beq.n	80092bc <xTaskResumeFromISR+0x1c>
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 80092d6:	2a00      	cmp	r2, #0
 80092d8:	d1f0      	bne.n	80092bc <xTaskResumeFromISR+0x1c>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80092da:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80092dc:	2b00      	cmp	r3, #0
 80092de:	d11b      	bne.n	8009318 <xTaskResumeFromISR+0x78>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80092e0:	4b11      	ldr	r3, [pc, #68]	; (8009328 <xTaskResumeFromISR+0x88>)
 80092e2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80092e4:	4698      	mov	r8, r3
 80092e6:	685b      	ldr	r3, [r3, #4]
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 80092e8:	1d27      	adds	r7, r4, #4
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80092ea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 80092ec:	1c38      	adds	r0, r7, #0
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80092ee:	429a      	cmp	r2, r3
 80092f0:	416d      	adcs	r5, r5
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 80092f2:	f000 fdfb 	bl	8009eec <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80092f6:	4642      	mov	r2, r8
 80092f8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80092fa:	6952      	ldr	r2, [r2, #20]
 80092fc:	4293      	cmp	r3, r2
 80092fe:	d901      	bls.n	8009304 <xTaskResumeFromISR+0x64>
 8009300:	4642      	mov	r2, r8
 8009302:	6153      	str	r3, [r2, #20]
 8009304:	4642      	mov	r2, r8
 8009306:	0098      	lsls	r0, r3, #2
 8009308:	18c0      	adds	r0, r0, r3
 800930a:	3218      	adds	r2, #24
 800930c:	0083      	lsls	r3, r0, #2
 800930e:	18d0      	adds	r0, r2, r3
 8009310:	1c39      	adds	r1, r7, #0
 8009312:	f000 fdc7 	bl	8009ea4 <vListInsertEnd>
 8009316:	e7d1      	b.n	80092bc <xTaskResumeFromISR+0x1c>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8009318:	1c21      	adds	r1, r4, #0
 800931a:	3118      	adds	r1, #24
 800931c:	f000 fdc2 	bl	8009ea4 <vListInsertEnd>
 8009320:	e7cc      	b.n	80092bc <xTaskResumeFromISR+0x1c>
 8009322:	46c0      	nop			; (mov r8, r8)
 8009324:	200002e8 	.word	0x200002e8
 8009328:	20000268 	.word	0x20000268

0800932c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 800932c:	b510      	push	{r4, lr}
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 800932e:	2400      	movs	r4, #0

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 8009330:	b084      	sub	sp, #16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 8009332:	9400      	str	r4, [sp, #0]
 8009334:	9401      	str	r4, [sp, #4]
 8009336:	9402      	str	r4, [sp, #8]
 8009338:	9403      	str	r4, [sp, #12]
 800933a:	480b      	ldr	r0, [pc, #44]	; (8009368 <vTaskStartScheduler+0x3c>)
 800933c:	490b      	ldr	r1, [pc, #44]	; (800936c <vTaskStartScheduler+0x40>)
 800933e:	223c      	movs	r2, #60	; 0x3c
 8009340:	2300      	movs	r3, #0
 8009342:	f7ff fdb9 	bl	8008eb8 <xTaskGenericCreate>
	}
	#endif /* INCLUDE_xTaskGetIdleTaskHandle */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 8009346:	2801      	cmp	r0, #1
 8009348:	d001      	beq.n	800934e <vTaskStartScheduler+0x22>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 800934a:	b004      	add	sp, #16
 800934c:	bd10      	pop	{r4, pc}

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
		{
			xReturn = xTimerCreateTimerTask();
 800934e:	f000 fbf1 	bl	8009b34 <xTimerCreateTimerTask>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 8009352:	2801      	cmp	r0, #1
 8009354:	d1f9      	bne.n	800934a <vTaskStartScheduler+0x1e>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 8009356:	b672      	cpsid	i
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
 8009358:	4b05      	ldr	r3, [pc, #20]	; (8009370 <vTaskStartScheduler+0x44>)
 800935a:	6658      	str	r0, [r3, #100]	; 0x64
		xTickCount = ( TickType_t ) 0U;
 800935c:	4b05      	ldr	r3, [pc, #20]	; (8009374 <vTaskStartScheduler+0x48>)
 800935e:	609c      	str	r4, [r3, #8]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 8009360:	f000 fdfa 	bl	8009f58 <xPortStartScheduler>
 8009364:	e7f1      	b.n	800934a <vTaskStartScheduler+0x1e>
 8009366:	46c0      	nop			; (mov r8, r8)
 8009368:	08009635 	.word	0x08009635
 800936c:	0800ac6c 	.word	0x0800ac6c
 8009370:	200002e8 	.word	0x200002e8
 8009374:	20000268 	.word	0x20000268

08009378 <vTaskEndScheduler>:
	}
}
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 8009378:	b508      	push	{r3, lr}
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
 800937a:	b672      	cpsid	i
	xSchedulerRunning = pdFALSE;
 800937c:	2200      	movs	r2, #0
 800937e:	4b02      	ldr	r3, [pc, #8]	; (8009388 <vTaskEndScheduler+0x10>)
 8009380:	665a      	str	r2, [r3, #100]	; 0x64
	vPortEndScheduler();
 8009382:	f000 fe13 	bl	8009fac <vPortEndScheduler>
}
 8009386:	bd08      	pop	{r3, pc}
 8009388:	200002e8 	.word	0x200002e8

0800938c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 800938c:	4a02      	ldr	r2, [pc, #8]	; (8009398 <vTaskSuspendAll+0xc>)
 800938e:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8009390:	3301      	adds	r3, #1
 8009392:	6713      	str	r3, [r2, #112]	; 0x70
}
 8009394:	4770      	bx	lr
 8009396:	46c0      	nop			; (mov r8, r8)
 8009398:	200002e8 	.word	0x200002e8

0800939c <xTaskGetTickCount>:
	return xAlreadyYielded;
}
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 800939c:	b510      	push	{r4, lr}
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
 800939e:	f000 fe13 	bl	8009fc8 <vPortEnterCritical>
	{
		xTicks = xTickCount;
 80093a2:	4b03      	ldr	r3, [pc, #12]	; (80093b0 <xTaskGetTickCount+0x14>)
 80093a4:	689c      	ldr	r4, [r3, #8]
	}
	taskEXIT_CRITICAL();
 80093a6:	f000 fe1b 	bl	8009fe0 <vPortExitCritical>

	return xTicks;
}
 80093aa:	1c20      	adds	r0, r4, #0
 80093ac:	bd10      	pop	{r4, pc}
 80093ae:	46c0      	nop			; (mov r8, r8)
 80093b0:	20000268 	.word	0x20000268

080093b4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
 80093b4:	b510      	push	{r4, lr}
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80093b6:	f000 fe1d 	bl	8009ff4 <ulSetInterruptMaskFromISR>
	{
		xReturn = xTickCount;
 80093ba:	4b03      	ldr	r3, [pc, #12]	; (80093c8 <xTaskGetTickCountFromISR+0x14>)
 80093bc:	689c      	ldr	r4, [r3, #8]
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80093be:	f000 fe1f 	bl	800a000 <vClearInterruptMaskFromISR>

	return xReturn;
}
 80093c2:	1c20      	adds	r0, r4, #0
 80093c4:	bd10      	pop	{r4, pc}
 80093c6:	46c0      	nop			; (mov r8, r8)
 80093c8:	20000268 	.word	0x20000268

080093cc <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
 80093cc:	4b01      	ldr	r3, [pc, #4]	; (80093d4 <uxTaskGetNumberOfTasks+0x8>)
 80093ce:	6fd8      	ldr	r0, [r3, #124]	; 0x7c
}
 80093d0:	4770      	bx	lr
 80093d2:	46c0      	nop			; (mov r8, r8)
 80093d4:	20000268 	.word	0x20000268

080093d8 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 80093d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80093da:	4656      	mov	r6, sl
 80093dc:	465f      	mov	r7, fp
 80093de:	464d      	mov	r5, r9
 80093e0:	4644      	mov	r4, r8

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80093e2:	4b40      	ldr	r3, [pc, #256]	; (80094e4 <xTaskIncrementTick+0x10c>)

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 80093e4:	b4f0      	push	{r4, r5, r6, r7}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80093e6:	469a      	mov	sl, r3
 80093e8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80093ea:	2b00      	cmp	r3, #0
 80093ec:	d15f      	bne.n	80094ae <xTaskIncrementTick+0xd6>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 80093ee:	4d3e      	ldr	r5, [pc, #248]	; (80094e8 <xTaskIncrementTick+0x110>)
 80093f0:	68ab      	ldr	r3, [r5, #8]
 80093f2:	3301      	adds	r3, #1
 80093f4:	60ab      	str	r3, [r5, #8]

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 80093f6:	68af      	ldr	r7, [r5, #8]

			if( xConstTickCount == ( TickType_t ) 0U )
 80093f8:	2f00      	cmp	r7, #0
 80093fa:	d066      	beq.n	80094ca <xTaskIncrementTick+0xf2>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 80093fc:	4b3b      	ldr	r3, [pc, #236]	; (80094ec <xTaskIncrementTick+0x114>)
 80093fe:	469b      	mov	fp, r3
 8009400:	681b      	ldr	r3, [r3, #0]
 8009402:	429f      	cmp	r7, r3
 8009404:	d336      	bcc.n	8009474 <xTaskIncrementTick+0x9c>
 8009406:	2300      	movs	r3, #0
 8009408:	4698      	mov	r8, r3
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 800940a:	3318      	adds	r3, #24
 800940c:	4699      	mov	r9, r3
 800940e:	44a9      	add	r9, r5
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8009410:	682b      	ldr	r3, [r5, #0]
 8009412:	681b      	ldr	r3, [r3, #0]
 8009414:	2b00      	cmp	r3, #0
 8009416:	d028      	beq.n	800946a <xTaskIncrementTick+0x92>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8009418:	682b      	ldr	r3, [r5, #0]
 800941a:	68db      	ldr	r3, [r3, #12]
 800941c:	68dc      	ldr	r4, [r3, #12]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 800941e:	6863      	ldr	r3, [r4, #4]

						if( xConstTickCount < xItemValue )
 8009420:	429f      	cmp	r7, r3
 8009422:	d324      	bcc.n	800946e <xTaskIncrementTick+0x96>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8009424:	1d26      	adds	r6, r4, #4
 8009426:	1c30      	adds	r0, r6, #0
 8009428:	f000 fd60 	bl	8009eec <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800942c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800942e:	2b00      	cmp	r3, #0
 8009430:	d003      	beq.n	800943a <xTaskIncrementTick+0x62>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8009432:	1c20      	adds	r0, r4, #0
 8009434:	3018      	adds	r0, #24
 8009436:	f000 fd59 	bl	8009eec <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 800943a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800943c:	696a      	ldr	r2, [r5, #20]
 800943e:	4293      	cmp	r3, r2
 8009440:	d900      	bls.n	8009444 <xTaskIncrementTick+0x6c>
 8009442:	616b      	str	r3, [r5, #20]
 8009444:	0098      	lsls	r0, r3, #2
 8009446:	18c0      	adds	r0, r0, r3
 8009448:	0083      	lsls	r3, r0, #2
 800944a:	444b      	add	r3, r9
 800944c:	1c18      	adds	r0, r3, #0
 800944e:	1c31      	adds	r1, r6, #0
 8009450:	f000 fd28 	bl	8009ea4 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8009454:	686b      	ldr	r3, [r5, #4]
 8009456:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8009458:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800945a:	429a      	cmp	r2, r3
 800945c:	d3d8      	bcc.n	8009410 <xTaskIncrementTick+0x38>
							{
								xSwitchRequired = pdTRUE;
 800945e:	2301      	movs	r3, #1
 8009460:	4698      	mov	r8, r3
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8009462:	682b      	ldr	r3, [r5, #0]
 8009464:	681b      	ldr	r3, [r3, #0]
 8009466:	2b00      	cmp	r3, #0
 8009468:	d1d6      	bne.n	8009418 <xTaskIncrementTick+0x40>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 800946a:	2301      	movs	r3, #1
 800946c:	425b      	negs	r3, r3
 800946e:	465a      	mov	r2, fp
 8009470:	6013      	str	r3, [r2, #0]
						break;
 8009472:	e001      	b.n	8009478 <xTaskIncrementTick+0xa0>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 8009474:	2300      	movs	r3, #0
 8009476:	4698      	mov	r8, r3
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8009478:	686b      	ldr	r3, [r5, #4]
 800947a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800947c:	009a      	lsls	r2, r3, #2
 800947e:	18d3      	adds	r3, r2, r3
 8009480:	009b      	lsls	r3, r3, #2
 8009482:	18eb      	adds	r3, r5, r3
 8009484:	699b      	ldr	r3, [r3, #24]
 8009486:	2b01      	cmp	r3, #1
 8009488:	d901      	bls.n	800948e <xTaskIncrementTick+0xb6>
			{
				xSwitchRequired = pdTRUE;
 800948a:	2301      	movs	r3, #1
 800948c:	4698      	mov	r8, r3

		#if ( configUSE_TICK_HOOK == 1 )
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if( uxPendedTicks == ( UBaseType_t ) 0U )
 800948e:	4653      	mov	r3, sl
 8009490:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8009492:	2b00      	cmp	r3, #0
 8009494:	d016      	beq.n	80094c4 <xTaskIncrementTick+0xec>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 8009496:	692b      	ldr	r3, [r5, #16]
 8009498:	2b00      	cmp	r3, #0
 800949a:	d001      	beq.n	80094a0 <xTaskIncrementTick+0xc8>
		{
			xSwitchRequired = pdTRUE;
 800949c:	2301      	movs	r3, #1
 800949e:	4698      	mov	r8, r3
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 80094a0:	4640      	mov	r0, r8
 80094a2:	bc3c      	pop	{r2, r3, r4, r5}
 80094a4:	4690      	mov	r8, r2
 80094a6:	4699      	mov	r9, r3
 80094a8:	46a2      	mov	sl, r4
 80094aa:	46ab      	mov	fp, r5
 80094ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 80094ae:	4653      	mov	r3, sl
 80094b0:	4652      	mov	r2, sl
 80094b2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80094b4:	3301      	adds	r3, #1
 80094b6:	6793      	str	r3, [r2, #120]	; 0x78

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
 80094b8:	f7f7 fa08 	bl	80008cc <vApplicationTickHook>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 80094bc:	2300      	movs	r3, #0
 80094be:	4d0a      	ldr	r5, [pc, #40]	; (80094e8 <xTaskIncrementTick+0x110>)
 80094c0:	4698      	mov	r8, r3
 80094c2:	e7e8      	b.n	8009496 <xTaskIncrementTick+0xbe>
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if( uxPendedTicks == ( UBaseType_t ) 0U )
			{
				vApplicationTickHook();
 80094c4:	f7f7 fa02 	bl	80008cc <vApplicationTickHook>
 80094c8:	e7e5      	b.n	8009496 <xTaskIncrementTick+0xbe>
			block. */
			const TickType_t xConstTickCount = xTickCount;

			if( xConstTickCount == ( TickType_t ) 0U )
			{
				taskSWITCH_DELAYED_LISTS();
 80094ca:	682b      	ldr	r3, [r5, #0]
 80094cc:	68ea      	ldr	r2, [r5, #12]
 80094ce:	602a      	str	r2, [r5, #0]
 80094d0:	60eb      	str	r3, [r5, #12]
 80094d2:	4653      	mov	r3, sl
 80094d4:	4652      	mov	r2, sl
 80094d6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80094d8:	3301      	adds	r3, #1
 80094da:	6753      	str	r3, [r2, #116]	; 0x74
 80094dc:	f7ff fc72 	bl	8008dc4 <prvResetNextTaskUnblockTime>
 80094e0:	e78c      	b.n	80093fc <xTaskIncrementTick+0x24>
 80094e2:	46c0      	nop			; (mov r8, r8)
 80094e4:	200002e8 	.word	0x200002e8
 80094e8:	20000268 	.word	0x20000268
 80094ec:	2000004c 	.word	0x2000004c

080094f0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 80094f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80094f2:	464f      	mov	r7, r9
 80094f4:	4646      	mov	r6, r8
 80094f6:	b4c0      	push	{r6, r7}
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 80094f8:	f000 fd66 	bl	8009fc8 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 80094fc:	4d29      	ldr	r5, [pc, #164]	; (80095a4 <xTaskResumeAll+0xb4>)
 80094fe:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8009500:	3b01      	subs	r3, #1
 8009502:	672b      	str	r3, [r5, #112]	; 0x70

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8009504:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8009506:	2b00      	cmp	r3, #0
 8009508:	d13d      	bne.n	8009586 <xTaskResumeAll+0x96>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800950a:	4f27      	ldr	r7, [pc, #156]	; (80095a8 <xTaskResumeAll+0xb8>)
 800950c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800950e:	2b00      	cmp	r3, #0
 8009510:	d039      	beq.n	8009586 <xTaskResumeAll+0x96>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
 8009512:	2318      	movs	r3, #24
 8009514:	4698      	mov	r8, r3

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
 8009516:	3b17      	subs	r3, #23
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
 8009518:	44b8      	add	r8, r7

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
 800951a:	4699      	mov	r9, r3
 800951c:	e01b      	b.n	8009556 <xTaskResumeAll+0x66>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 800951e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8009520:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8009522:	1c20      	adds	r0, r4, #0
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8009524:	1d26      	adds	r6, r4, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8009526:	3018      	adds	r0, #24
 8009528:	f000 fce0 	bl	8009eec <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 800952c:	1c30      	adds	r0, r6, #0
 800952e:	f000 fcdd 	bl	8009eec <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8009532:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8009534:	697a      	ldr	r2, [r7, #20]
 8009536:	4293      	cmp	r3, r2
 8009538:	d900      	bls.n	800953c <xTaskResumeAll+0x4c>
 800953a:	617b      	str	r3, [r7, #20]
 800953c:	0098      	lsls	r0, r3, #2
 800953e:	18c0      	adds	r0, r0, r3
 8009540:	0083      	lsls	r3, r0, #2
 8009542:	4443      	add	r3, r8
 8009544:	1c18      	adds	r0, r3, #0
 8009546:	1c31      	adds	r1, r6, #0
 8009548:	f000 fcac 	bl	8009ea4 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800954c:	687b      	ldr	r3, [r7, #4]
 800954e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8009550:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009552:	429a      	cmp	r2, r3
 8009554:	d21f      	bcs.n	8009596 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8009556:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8009558:	2b00      	cmp	r3, #0
 800955a:	d1e0      	bne.n	800951e <xTaskResumeAll+0x2e>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 800955c:	6fab      	ldr	r3, [r5, #120]	; 0x78
 800955e:	2b00      	cmp	r3, #0
 8009560:	d00e      	beq.n	8009580 <xTaskResumeAll+0x90>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 8009562:	6fab      	ldr	r3, [r5, #120]	; 0x78
 8009564:	2b00      	cmp	r3, #0
 8009566:	d00b      	beq.n	8009580 <xTaskResumeAll+0x90>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
 8009568:	2401      	movs	r4, #1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
 800956a:	f7ff ff35 	bl	80093d8 <xTaskIncrementTick>
 800956e:	2800      	cmp	r0, #0
 8009570:	d000      	beq.n	8009574 <xTaskResumeAll+0x84>
						{
							xYieldPending = pdTRUE;
 8009572:	613c      	str	r4, [r7, #16]
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
 8009574:	6fab      	ldr	r3, [r5, #120]	; 0x78
 8009576:	3b01      	subs	r3, #1
 8009578:	67ab      	str	r3, [r5, #120]	; 0x78
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 800957a:	6fab      	ldr	r3, [r5, #120]	; 0x78
 800957c:	2b00      	cmp	r3, #0
 800957e:	d1f4      	bne.n	800956a <xTaskResumeAll+0x7a>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
 8009580:	693b      	ldr	r3, [r7, #16]
 8009582:	2b01      	cmp	r3, #1
 8009584:	d00a      	beq.n	800959c <xTaskResumeAll+0xac>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
 8009586:	2400      	movs	r4, #0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8009588:	f000 fd2a 	bl	8009fe0 <vPortExitCritical>

	return xAlreadyYielded;
}
 800958c:	1c20      	adds	r0, r4, #0
 800958e:	bc0c      	pop	{r2, r3}
 8009590:	4690      	mov	r8, r2
 8009592:	4699      	mov	r9, r3
 8009594:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
 8009596:	464b      	mov	r3, r9
 8009598:	613b      	str	r3, [r7, #16]
 800959a:	e7dc      	b.n	8009556 <xTaskResumeAll+0x66>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 800959c:	f000 fd08 	bl	8009fb0 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 80095a0:	2401      	movs	r4, #1
 80095a2:	e7f1      	b.n	8009588 <xTaskResumeAll+0x98>
 80095a4:	200002e8 	.word	0x200002e8
 80095a8:	20000268 	.word	0x20000268

080095ac <vTaskDelayUntil>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 80095ac:	4a10      	ldr	r2, [pc, #64]	; (80095f0 <vTaskDelayUntil+0x44>)
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
 80095ae:	b538      	push	{r3, r4, r5, lr}
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 80095b0:	6f13      	ldr	r3, [r2, #112]	; 0x70
 80095b2:	3301      	adds	r3, #1
 80095b4:	6713      	str	r3, [r2, #112]	; 0x70

		vTaskSuspendAll();
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 80095b6:	4a0f      	ldr	r2, [pc, #60]	; (80095f4 <vTaskDelayUntil+0x48>)

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 80095b8:	6803      	ldr	r3, [r0, #0]

		vTaskSuspendAll();
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 80095ba:	6895      	ldr	r5, [r2, #8]

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 80095bc:	185c      	adds	r4, r3, r1

			if( xConstTickCount < *pxPreviousWakeTime )
 80095be:	429d      	cmp	r5, r3
 80095c0:	d209      	bcs.n	80095d6 <vTaskDelayUntil+0x2a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 80095c2:	42a3      	cmp	r3, r4
 80095c4:	d809      	bhi.n	80095da <vTaskDelayUntil+0x2e>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 80095c6:	6004      	str	r4, [r0, #0]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 80095c8:	f7ff ff92 	bl	80094f0 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 80095cc:	2800      	cmp	r0, #0
 80095ce:	d101      	bne.n	80095d4 <vTaskDelayUntil+0x28>
		{
			portYIELD_WITHIN_API();
 80095d0:	f000 fcee 	bl	8009fb0 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 80095d4:	bd38      	pop	{r3, r4, r5, pc}
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 80095d6:	42a3      	cmp	r3, r4
 80095d8:	d801      	bhi.n	80095de <vTaskDelayUntil+0x32>
 80095da:	42a5      	cmp	r5, r4
 80095dc:	d2f3      	bcs.n	80095c6 <vTaskDelayUntil+0x1a>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 80095de:	6004      	str	r4, [r0, #0]
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 80095e0:	6850      	ldr	r0, [r2, #4]
 80095e2:	3004      	adds	r0, #4
 80095e4:	f000 fc82 	bl	8009eec <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
 80095e8:	1c20      	adds	r0, r4, #0
 80095ea:	f7ff fbff 	bl	8008dec <prvAddCurrentTaskToDelayedList>
 80095ee:	e7eb      	b.n	80095c8 <vTaskDelayUntil+0x1c>
 80095f0:	200002e8 	.word	0x200002e8
 80095f4:	20000268 	.word	0x20000268

080095f8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 80095f8:	b510      	push	{r4, lr}
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 80095fa:	2800      	cmp	r0, #0
 80095fc:	d102      	bne.n	8009604 <vTaskDelay+0xc>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 80095fe:	f000 fcd7 	bl	8009fb0 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8009602:	bd10      	pop	{r4, pc}
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 8009604:	4a09      	ldr	r2, [pc, #36]	; (800962c <vTaskDelay+0x34>)
 8009606:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8009608:	3301      	adds	r3, #1
 800960a:	6713      	str	r3, [r2, #112]	; 0x70
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 800960c:	4b08      	ldr	r3, [pc, #32]	; (8009630 <vTaskDelay+0x38>)
 800960e:	689c      	ldr	r4, [r3, #8]
 8009610:	1904      	adds	r4, r0, r4

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8009612:	6858      	ldr	r0, [r3, #4]
 8009614:	3004      	adds	r0, #4
 8009616:	f000 fc69 	bl	8009eec <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 800961a:	1c20      	adds	r0, r4, #0
 800961c:	f7ff fbe6 	bl	8008dec <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 8009620:	f7ff ff66 	bl	80094f0 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8009624:	2800      	cmp	r0, #0
 8009626:	d1ec      	bne.n	8009602 <vTaskDelay+0xa>
 8009628:	e7e9      	b.n	80095fe <vTaskDelay+0x6>
 800962a:	46c0      	nop			; (mov r8, r8)
 800962c:	200002e8 	.word	0x200002e8
 8009630:	20000268 	.word	0x20000268

08009634 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8009634:	b570      	push	{r4, r5, r6, lr}
 8009636:	4e15      	ldr	r6, [pc, #84]	; (800968c <prvIdleTask+0x58>)
 8009638:	4c15      	ldr	r4, [pc, #84]	; (8009690 <prvIdleTask+0x5c>)
 800963a:	e007      	b.n	800964c <prvIdleTask+0x18>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 800963c:	6f23      	ldr	r3, [r4, #112]	; 0x70
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 800963e:	6be5      	ldr	r5, [r4, #60]	; 0x3c
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 8009640:	3301      	adds	r3, #1
 8009642:	6723      	str	r3, [r4, #112]	; 0x70
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
			}
			( void ) xTaskResumeAll();
 8009644:	f7ff ff54 	bl	80094f0 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 8009648:	2d00      	cmp	r5, #0
 800964a:	d108      	bne.n	800965e <prvIdleTask+0x2a>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 800964c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800964e:	2b00      	cmp	r3, #0
 8009650:	d1f4      	bne.n	800963c <prvIdleTask+0x8>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8009652:	69b3      	ldr	r3, [r6, #24]
 8009654:	2b01      	cmp	r3, #1
 8009656:	d9f9      	bls.n	800964c <prvIdleTask+0x18>
			{
				taskYIELD();
 8009658:	f000 fcaa 	bl	8009fb0 <vPortYield>
 800965c:	e7f6      	b.n	800964c <prvIdleTask+0x18>

			if( xListIsEmpty == pdFALSE )
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 800965e:	f000 fcb3 	bl	8009fc8 <vPortEnterCritical>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8009662:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8009664:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8009666:	1d28      	adds	r0, r5, #4
 8009668:	f000 fc40 	bl	8009eec <uxListRemove>
					--uxCurrentNumberOfTasks;
 800966c:	6ff3      	ldr	r3, [r6, #124]	; 0x7c
 800966e:	3b01      	subs	r3, #1
 8009670:	67f3      	str	r3, [r6, #124]	; 0x7c
					--uxTasksDeleted;
 8009672:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8009674:	3b01      	subs	r3, #1
 8009676:	66e3      	str	r3, [r4, #108]	; 0x6c
				}
				taskEXIT_CRITICAL();
 8009678:	f000 fcb2 	bl	8009fe0 <vPortExitCritical>
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
 800967c:	6b28      	ldr	r0, [r5, #48]	; 0x30
 800967e:	f000 fbef 	bl	8009e60 <vPortFree>
		vPortFree( pxTCB );
 8009682:	1c28      	adds	r0, r5, #0
 8009684:	f000 fbec 	bl	8009e60 <vPortFree>
 8009688:	e7e0      	b.n	800964c <prvIdleTask+0x18>
 800968a:	46c0      	nop			; (mov r8, r8)
 800968c:	20000268 	.word	0x20000268
 8009690:	200002e8 	.word	0x200002e8

08009694 <uxTaskGetSystemState>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
 8009694:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009696:	464e      	mov	r6, r9
 8009698:	4645      	mov	r5, r8
 800969a:	4657      	mov	r7, sl
 800969c:	b4e0      	push	{r5, r6, r7}
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 800969e:	4e38      	ldr	r6, [pc, #224]	; (8009780 <uxTaskGetSystemState+0xec>)
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
 80096a0:	1c07      	adds	r7, r0, #0
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 80096a2:	6f33      	ldr	r3, [r6, #112]	; 0x70
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
 80096a4:	4690      	mov	r8, r2
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 80096a6:	3301      	adds	r3, #1
 80096a8:	6733      	str	r3, [r6, #112]	; 0x70
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;

		vTaskSuspendAll();
		{
			/* Is there a space in the array for each task in the system? */
			if( uxArraySize >= uxCurrentNumberOfTasks )
 80096aa:	4b36      	ldr	r3, [pc, #216]	; (8009784 <uxTaskGetSystemState+0xf0>)

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 80096ac:	2500      	movs	r5, #0

		vTaskSuspendAll();
		{
			/* Is there a space in the array for each task in the system? */
			if( uxArraySize >= uxCurrentNumberOfTasks )
 80096ae:	4699      	mov	r9, r3
 80096b0:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80096b2:	428b      	cmp	r3, r1
 80096b4:	d82a      	bhi.n	800970c <uxTaskGetSystemState+0x78>
 80096b6:	2304      	movs	r3, #4
 80096b8:	464c      	mov	r4, r9
 80096ba:	444b      	add	r3, r9
 80096bc:	469a      	mov	sl, r3
 80096be:	3468      	adds	r4, #104	; 0x68
	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 80096c0:	6823      	ldr	r3, [r4, #0]
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
 80096c2:	2000      	movs	r0, #0

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 80096c4:	2b00      	cmp	r3, #0
 80096c6:	d129      	bne.n	800971c <uxTaskGetSystemState+0x88>
 80096c8:	3c14      	subs	r4, #20
				/* Fill in an TaskStatus_t structure with information on each
				task in the Ready state. */
				do
				{
					uxQueue--;
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 80096ca:	182d      	adds	r5, r5, r0

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80096cc:	4554      	cmp	r4, sl
 80096ce:	d1f7      	bne.n	80096c0 <uxTaskGetSystemState+0x2c>

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 80096d0:	464b      	mov	r3, r9
 80096d2:	6819      	ldr	r1, [r3, #0]
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
 80096d4:	2000      	movs	r0, #0

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 80096d6:	680b      	ldr	r3, [r1, #0]
 80096d8:	2b00      	cmp	r3, #0
 80096da:	d12e      	bne.n	800973a <uxTaskGetSystemState+0xa6>
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 80096dc:	464b      	mov	r3, r9
 80096de:	68d9      	ldr	r1, [r3, #12]

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 80096e0:	1945      	adds	r5, r0, r5
	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 80096e2:	680b      	ldr	r3, [r1, #0]
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
 80096e4:	2000      	movs	r0, #0

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 80096e6:	2b00      	cmp	r3, #0
 80096e8:	d133      	bne.n	8009752 <uxTaskGetSystemState+0xbe>
 80096ea:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 80096ec:	1945      	adds	r5, r0, r5
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
 80096ee:	2000      	movs	r0, #0

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 80096f0:	2b00      	cmp	r3, #0
 80096f2:	d138      	bne.n	8009766 <uxTaskGetSystemState+0xd2>
 80096f4:	6d33      	ldr	r3, [r6, #80]	; 0x50

				#if( INCLUDE_vTaskDelete == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task that has been deleted but not yet cleaned up. */
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
 80096f6:	1945      	adds	r5, r0, r5
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
 80096f8:	2000      	movs	r0, #0

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 80096fa:	2b00      	cmp	r3, #0
 80096fc:	d115      	bne.n	800972a <uxTaskGetSystemState+0x96>
						#endif
					}
				}
				#else
				{
					if( pulTotalRunTime != NULL )
 80096fe:	4643      	mov	r3, r8

				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task in the Suspended state. */
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
 8009700:	1945      	adds	r5, r0, r5
						#endif
					}
				}
				#else
				{
					if( pulTotalRunTime != NULL )
 8009702:	2b00      	cmp	r3, #0
 8009704:	d002      	beq.n	800970c <uxTaskGetSystemState+0x78>
					{
						*pulTotalRunTime = 0;
 8009706:	2300      	movs	r3, #0
 8009708:	4642      	mov	r2, r8
 800970a:	6013      	str	r3, [r2, #0]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		( void ) xTaskResumeAll();
 800970c:	f7ff fef0 	bl	80094f0 <xTaskResumeAll>

		return uxTask;
	}
 8009710:	1c28      	adds	r0, r5, #0
 8009712:	bc1c      	pop	{r2, r3, r4}
 8009714:	4690      	mov	r8, r2
 8009716:	4699      	mov	r9, r3
 8009718:	46a2      	mov	sl, r4
 800971a:	bdf0      	pop	{r4, r5, r6, r7, pc}
				/* Fill in an TaskStatus_t structure with information on each
				task in the Ready state. */
				do
				{
					uxQueue--;
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 800971c:	0168      	lsls	r0, r5, #5
 800971e:	1838      	adds	r0, r7, r0
 8009720:	1c21      	adds	r1, r4, #0
 8009722:	2201      	movs	r2, #1
 8009724:	f7ff faf6 	bl	8008d14 <prvListTaskWithinSingleList.part.1>
 8009728:	e7ce      	b.n	80096c8 <uxTaskGetSystemState+0x34>
 800972a:	1c31      	adds	r1, r6, #0

				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task in the Suspended state. */
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
 800972c:	0168      	lsls	r0, r5, #5
 800972e:	1838      	adds	r0, r7, r0
 8009730:	3150      	adds	r1, #80	; 0x50
 8009732:	2203      	movs	r2, #3
 8009734:	f7ff faee 	bl	8008d14 <prvListTaskWithinSingleList.part.1>
 8009738:	e7e1      	b.n	80096fe <uxTaskGetSystemState+0x6a>

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 800973a:	0168      	lsls	r0, r5, #5
 800973c:	1838      	adds	r0, r7, r0
 800973e:	2202      	movs	r2, #2
 8009740:	f7ff fae8 	bl	8008d14 <prvListTaskWithinSingleList.part.1>
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 8009744:	464b      	mov	r3, r9
 8009746:	68d9      	ldr	r1, [r3, #12]

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 8009748:	1945      	adds	r5, r0, r5
	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 800974a:	680b      	ldr	r3, [r1, #0]
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
 800974c:	2000      	movs	r0, #0

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 800974e:	2b00      	cmp	r3, #0
 8009750:	d0cb      	beq.n	80096ea <uxTaskGetSystemState+0x56>
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 8009752:	0168      	lsls	r0, r5, #5
 8009754:	1838      	adds	r0, r7, r0
 8009756:	2202      	movs	r2, #2
 8009758:	f7ff fadc 	bl	8008d14 <prvListTaskWithinSingleList.part.1>
	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 800975c:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 800975e:	1945      	adds	r5, r0, r5
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
 8009760:	2000      	movs	r0, #0

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 8009762:	2b00      	cmp	r3, #0
 8009764:	d0c6      	beq.n	80096f4 <uxTaskGetSystemState+0x60>
 8009766:	1c31      	adds	r1, r6, #0

				#if( INCLUDE_vTaskDelete == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task that has been deleted but not yet cleaned up. */
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
 8009768:	0168      	lsls	r0, r5, #5
 800976a:	1838      	adds	r0, r7, r0
 800976c:	313c      	adds	r1, #60	; 0x3c
 800976e:	2204      	movs	r2, #4
 8009770:	f7ff fad0 	bl	8008d14 <prvListTaskWithinSingleList.part.1>
	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 8009774:	6d33      	ldr	r3, [r6, #80]	; 0x50

				#if( INCLUDE_vTaskDelete == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task that has been deleted but not yet cleaned up. */
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
 8009776:	1945      	adds	r5, r0, r5
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
 8009778:	2000      	movs	r0, #0

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 800977a:	2b00      	cmp	r3, #0
 800977c:	d0bf      	beq.n	80096fe <uxTaskGetSystemState+0x6a>
 800977e:	e7d4      	b.n	800972a <uxTaskGetSystemState+0x96>
 8009780:	200002e8 	.word	0x200002e8
 8009784:	20000268 	.word	0x20000268

08009788 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8009788:	b508      	push	{r3, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800978a:	4b05      	ldr	r3, [pc, #20]	; (80097a0 <vTaskSwitchContext+0x18>)
 800978c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800978e:	2b00      	cmp	r3, #0
 8009790:	d102      	bne.n	8009798 <vTaskSwitchContext+0x10>
 8009792:	f7ff fb49 	bl	8008e28 <vTaskSwitchContext.part.5>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 8009796:	bd08      	pop	{r3, pc}
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 8009798:	2201      	movs	r2, #1
 800979a:	4b02      	ldr	r3, [pc, #8]	; (80097a4 <vTaskSwitchContext+0x1c>)
 800979c:	611a      	str	r2, [r3, #16]
 800979e:	e7fa      	b.n	8009796 <vTaskSwitchContext+0xe>
 80097a0:	200002e8 	.word	0x200002e8
 80097a4:	20000268 	.word	0x20000268

080097a8 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 80097a8:	b538      	push	{r3, r4, r5, lr}
 80097aa:	1c0d      	adds	r5, r1, #0

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80097ac:	4c0b      	ldr	r4, [pc, #44]	; (80097dc <vTaskPlaceOnEventList+0x34>)
 80097ae:	6861      	ldr	r1, [r4, #4]
 80097b0:	3118      	adds	r1, #24
 80097b2:	f000 fb83 	bl	8009ebc <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 80097b6:	6860      	ldr	r0, [r4, #4]
 80097b8:	3004      	adds	r0, #4
 80097ba:	f000 fb97 	bl	8009eec <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
 80097be:	1c6b      	adds	r3, r5, #1
 80097c0:	d004      	beq.n	80097cc <vTaskPlaceOnEventList+0x24>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
 80097c2:	68a0      	ldr	r0, [r4, #8]
 80097c4:	1828      	adds	r0, r5, r0
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 80097c6:	f7ff fb11 	bl	8008dec <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 80097ca:	bd38      	pop	{r3, r4, r5, pc}
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80097cc:	6861      	ldr	r1, [r4, #4]
 80097ce:	4804      	ldr	r0, [pc, #16]	; (80097e0 <vTaskPlaceOnEventList+0x38>)
 80097d0:	3104      	adds	r1, #4
 80097d2:	3050      	adds	r0, #80	; 0x50
 80097d4:	f000 fb66 	bl	8009ea4 <vListInsertEnd>
 80097d8:	e7f7      	b.n	80097ca <vTaskPlaceOnEventList+0x22>
 80097da:	46c0      	nop			; (mov r8, r8)
 80097dc:	20000268 	.word	0x20000268
 80097e0:	200002e8 	.word	0x200002e8

080097e4 <vTaskPlaceOnUnorderedEventList>:
	#endif /* INCLUDE_vTaskSuspend */
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
 80097e4:	b538      	push	{r3, r4, r5, lr}
 80097e6:	1c15      	adds	r5, r2, #0
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 80097e8:	2280      	movs	r2, #128	; 0x80
 80097ea:	4c0d      	ldr	r4, [pc, #52]	; (8009820 <vTaskPlaceOnUnorderedEventList+0x3c>)
 80097ec:	0612      	lsls	r2, r2, #24
 80097ee:	6863      	ldr	r3, [r4, #4]
 80097f0:	4311      	orrs	r1, r2
 80097f2:	6199      	str	r1, [r3, #24]
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80097f4:	6861      	ldr	r1, [r4, #4]
 80097f6:	3118      	adds	r1, #24
 80097f8:	f000 fb54 	bl	8009ea4 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 80097fc:	6860      	ldr	r0, [r4, #4]
 80097fe:	3004      	adds	r0, #4
 8009800:	f000 fb74 	bl	8009eec <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
 8009804:	1c6b      	adds	r3, r5, #1
 8009806:	d004      	beq.n	8009812 <vTaskPlaceOnUnorderedEventList+0x2e>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
 8009808:	68a0      	ldr	r0, [r4, #8]
 800980a:	1828      	adds	r0, r5, r0
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 800980c:	f7ff faee 	bl	8008dec <prvAddCurrentTaskToDelayedList>
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8009810:	bd38      	pop	{r3, r4, r5, pc}
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8009812:	6861      	ldr	r1, [r4, #4]
 8009814:	4803      	ldr	r0, [pc, #12]	; (8009824 <vTaskPlaceOnUnorderedEventList+0x40>)
 8009816:	3104      	adds	r1, #4
 8009818:	3050      	adds	r0, #80	; 0x50
 800981a:	f000 fb43 	bl	8009ea4 <vListInsertEnd>
 800981e:	e7f7      	b.n	8009810 <vTaskPlaceOnUnorderedEventList+0x2c>
 8009820:	20000268 	.word	0x20000268
 8009824:	200002e8 	.word	0x200002e8

08009828 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
	{
 8009828:	b538      	push	{r3, r4, r5, lr}
 800982a:	1c0d      	adds	r5, r1, #0

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800982c:	4c06      	ldr	r4, [pc, #24]	; (8009848 <vTaskPlaceOnEventListRestricted+0x20>)
 800982e:	6861      	ldr	r1, [r4, #4]
 8009830:	3118      	adds	r1, #24
 8009832:	f000 fb37 	bl	8009ea4 <vListInsertEnd>

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8009836:	6860      	ldr	r0, [r4, #4]
 8009838:	3004      	adds	r0, #4
 800983a:	f000 fb57 	bl	8009eec <uxListRemove>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
 800983e:	68a0      	ldr	r0, [r4, #8]
 8009840:	1828      	adds	r0, r5, r0

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
 8009842:	f7ff fad3 	bl	8008dec <prvAddCurrentTaskToDelayedList>
	}
 8009846:	bd38      	pop	{r3, r4, r5, pc}
 8009848:	20000268 	.word	0x20000268

0800984c <xTaskRemoveFromEventList>:
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 800984c:	68c3      	ldr	r3, [r0, #12]

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 800984e:	b570      	push	{r4, r5, r6, lr}
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8009850:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8009852:	1c25      	adds	r5, r4, #0
 8009854:	3518      	adds	r5, #24
 8009856:	1c28      	adds	r0, r5, #0
 8009858:	f000 fb48 	bl	8009eec <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800985c:	4813      	ldr	r0, [pc, #76]	; (80098ac <xTaskRemoveFromEventList+0x60>)
 800985e:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8009860:	2b00      	cmp	r3, #0
 8009862:	d11b      	bne.n	800989c <xTaskRemoveFromEventList+0x50>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 8009864:	1d26      	adds	r6, r4, #4
 8009866:	1c30      	adds	r0, r6, #0
 8009868:	f000 fb40 	bl	8009eec <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 800986c:	4d10      	ldr	r5, [pc, #64]	; (80098b0 <xTaskRemoveFromEventList+0x64>)
 800986e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8009870:	696a      	ldr	r2, [r5, #20]
 8009872:	4293      	cmp	r3, r2
 8009874:	d818      	bhi.n	80098a8 <xTaskRemoveFromEventList+0x5c>
 8009876:	1c2a      	adds	r2, r5, #0
 8009878:	0098      	lsls	r0, r3, #2
 800987a:	18c0      	adds	r0, r0, r3
 800987c:	3218      	adds	r2, #24
 800987e:	0083      	lsls	r3, r0, #2
 8009880:	18d0      	adds	r0, r2, r3
 8009882:	1c31      	adds	r1, r6, #0
 8009884:	f000 fb0e 	bl	8009ea4 <vListInsertEnd>
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8009888:	686b      	ldr	r3, [r5, #4]
 800988a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800988c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xReturn = pdFALSE;
 800988e:	2000      	movs	r0, #0
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8009890:	429a      	cmp	r2, r3
 8009892:	d902      	bls.n	800989a <xTaskRemoveFromEventList+0x4e>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 8009894:	2301      	movs	r3, #1
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
 8009896:	3001      	adds	r0, #1

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 8009898:	612b      	str	r3, [r5, #16]
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
 800989a:	bd70      	pop	{r4, r5, r6, pc}
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800989c:	1c29      	adds	r1, r5, #0
 800989e:	3028      	adds	r0, #40	; 0x28
 80098a0:	f000 fb00 	bl	8009ea4 <vListInsertEnd>
 80098a4:	4d02      	ldr	r5, [pc, #8]	; (80098b0 <xTaskRemoveFromEventList+0x64>)
 80098a6:	e7ef      	b.n	8009888 <xTaskRemoveFromEventList+0x3c>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
		prvAddTaskToReadyList( pxUnblockedTCB );
 80098a8:	616b      	str	r3, [r5, #20]
 80098aa:	e7e4      	b.n	8009876 <xTaskRemoveFromEventList+0x2a>
 80098ac:	200002e8 	.word	0x200002e8
 80098b0:	20000268 	.word	0x20000268

080098b4 <xTaskRemoveFromUnorderedEventList>:
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 80098b4:	2380      	movs	r3, #128	; 0x80
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
 80098b6:	b570      	push	{r4, r5, r6, lr}
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 80098b8:	061b      	lsls	r3, r3, #24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 80098ba:	68c5      	ldr	r5, [r0, #12]
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 80098bc:	4319      	orrs	r1, r3
 80098be:	6001      	str	r1, [r0, #0]
	( void ) uxListRemove( pxEventListItem );

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 80098c0:	1d2e      	adds	r6, r5, #4

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
 80098c2:	f000 fb13 	bl	8009eec <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 80098c6:	1c30      	adds	r0, r6, #0
 80098c8:	f000 fb10 	bl	8009eec <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
 80098cc:	4c0c      	ldr	r4, [pc, #48]	; (8009900 <xTaskRemoveFromUnorderedEventList+0x4c>)
 80098ce:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80098d0:	6962      	ldr	r2, [r4, #20]
 80098d2:	4293      	cmp	r3, r2
 80098d4:	d900      	bls.n	80098d8 <xTaskRemoveFromUnorderedEventList+0x24>
 80098d6:	6163      	str	r3, [r4, #20]
 80098d8:	1c22      	adds	r2, r4, #0
 80098da:	0098      	lsls	r0, r3, #2
 80098dc:	18c0      	adds	r0, r0, r3
 80098de:	3218      	adds	r2, #24
 80098e0:	0083      	lsls	r3, r0, #2
 80098e2:	18d0      	adds	r0, r2, r3
 80098e4:	1c31      	adds	r1, r6, #0
 80098e6:	f000 fadd 	bl	8009ea4 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 80098ea:	6863      	ldr	r3, [r4, #4]
 80098ec:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 80098ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xReturn = pdFALSE;
 80098f0:	2000      	movs	r0, #0
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
	prvAddTaskToReadyList( pxUnblockedTCB );

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 80098f2:	429a      	cmp	r2, r3
 80098f4:	d902      	bls.n	80098fc <xTaskRemoveFromUnorderedEventList+0x48>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 80098f6:	2301      	movs	r3, #1
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
 80098f8:	3001      	adds	r0, #1

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 80098fa:	6123      	str	r3, [r4, #16]
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
 80098fc:	bd70      	pop	{r4, r5, r6, pc}
 80098fe:	46c0      	nop			; (mov r8, r8)
 8009900:	20000268 	.word	0x20000268

08009904 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8009904:	4b03      	ldr	r3, [pc, #12]	; (8009914 <vTaskSetTimeOutState+0x10>)
 8009906:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009908:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800990a:	4b03      	ldr	r3, [pc, #12]	; (8009918 <vTaskSetTimeOutState+0x14>)
 800990c:	689b      	ldr	r3, [r3, #8]
 800990e:	6043      	str	r3, [r0, #4]
}
 8009910:	4770      	bx	lr
 8009912:	46c0      	nop			; (mov r8, r8)
 8009914:	200002e8 	.word	0x200002e8
 8009918:	20000268 	.word	0x20000268

0800991c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 800991c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800991e:	1c0e      	adds	r6, r1, #0
 8009920:	1c04      	adds	r4, r0, #0
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
 8009922:	f000 fb51 	bl	8009fc8 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 8009926:	4814      	ldr	r0, [pc, #80]	; (8009978 <xTaskCheckForTimeOut+0x5c>)

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 8009928:	6833      	ldr	r3, [r6, #0]
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 800992a:	6881      	ldr	r1, [r0, #8]

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 800992c:	1c5a      	adds	r2, r3, #1
 800992e:	d020      	beq.n	8009972 <xTaskCheckForTimeOut+0x56>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8009930:	4a12      	ldr	r2, [pc, #72]	; (800997c <xTaskCheckForTimeOut+0x60>)
 8009932:	6825      	ldr	r5, [r4, #0]
 8009934:	4694      	mov	ip, r2
 8009936:	6f52      	ldr	r2, [r2, #116]	; 0x74
 8009938:	4295      	cmp	r5, r2
 800993a:	d014      	beq.n	8009966 <xTaskCheckForTimeOut+0x4a>
 800993c:	6862      	ldr	r2, [r4, #4]
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
 800993e:	2501      	movs	r5, #1
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8009940:	4291      	cmp	r1, r2
 8009942:	d20c      	bcs.n	800995e <xTaskCheckForTimeOut+0x42>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 8009944:	1a8f      	subs	r7, r1, r2
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
 8009946:	2501      	movs	r5, #1
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 8009948:	42bb      	cmp	r3, r7
 800994a:	d908      	bls.n	800995e <xTaskCheckForTimeOut+0x42>
 800994c:	1a5b      	subs	r3, r3, r1
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 800994e:	189b      	adds	r3, r3, r2
 8009950:	6033      	str	r3, [r6, #0]
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8009952:	4663      	mov	r3, ip
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
 8009954:	2500      	movs	r5, #0
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8009956:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009958:	6023      	str	r3, [r4, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800995a:	6883      	ldr	r3, [r0, #8]
 800995c:	6063      	str	r3, [r4, #4]
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
 800995e:	f000 fb3f 	bl	8009fe0 <vPortExitCritical>

	return xReturn;
}
 8009962:	1c28      	adds	r0, r5, #0
 8009964:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009966:	6862      	ldr	r2, [r4, #4]
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
 8009968:	2501      	movs	r5, #1
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 800996a:	1a8f      	subs	r7, r1, r2
 800996c:	42bb      	cmp	r3, r7
 800996e:	d8ed      	bhi.n	800994c <xTaskCheckForTimeOut+0x30>
 8009970:	e7f5      	b.n	800995e <xTaskCheckForTimeOut+0x42>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
 8009972:	2500      	movs	r5, #0
 8009974:	e7f3      	b.n	800995e <xTaskCheckForTimeOut+0x42>
 8009976:	46c0      	nop			; (mov r8, r8)
 8009978:	20000268 	.word	0x20000268
 800997c:	200002e8 	.word	0x200002e8

08009980 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
 8009980:	2201      	movs	r2, #1
 8009982:	4b01      	ldr	r3, [pc, #4]	; (8009988 <vTaskMissedYield+0x8>)
 8009984:	611a      	str	r2, [r3, #16]
}
 8009986:	4770      	bx	lr
 8009988:	20000268 	.word	0x20000268

0800998c <uxTaskGetTaskNumber>:
	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
	{
	UBaseType_t uxReturn;
	TCB_t *pxTCB;

		if( xTask != NULL )
 800998c:	2800      	cmp	r0, #0
 800998e:	d001      	beq.n	8009994 <uxTaskGetTaskNumber+0x8>
		{
			pxTCB = ( TCB_t * ) xTask;
			uxReturn = pxTCB->uxTaskNumber;
 8009990:	6c00      	ldr	r0, [r0, #64]	; 0x40
		{
			uxReturn = 0U;
		}

		return uxReturn;
	}
 8009992:	4770      	bx	lr
			pxTCB = ( TCB_t * ) xTask;
			uxReturn = pxTCB->uxTaskNumber;
		}
		else
		{
			uxReturn = 0U;
 8009994:	2000      	movs	r0, #0
 8009996:	e7fc      	b.n	8009992 <uxTaskGetTaskNumber+0x6>

08009998 <vTaskSetTaskNumber>:

	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
	{
	TCB_t *pxTCB;

		if( xTask != NULL )
 8009998:	2800      	cmp	r0, #0
 800999a:	d000      	beq.n	800999e <vTaskSetTaskNumber+0x6>
		{
			pxTCB = ( TCB_t * ) xTask;
			pxTCB->uxTaskNumber = uxHandle;
 800999c:	6401      	str	r1, [r0, #64]	; 0x40
		}
	}
 800999e:	4770      	bx	lr

080099a0 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 80099a0:	4b01      	ldr	r3, [pc, #4]	; (80099a8 <xTaskGetCurrentTaskHandle+0x8>)
 80099a2:	6858      	ldr	r0, [r3, #4]

		return xReturn;
	}
 80099a4:	4770      	bx	lr
 80099a6:	46c0      	nop			; (mov r8, r8)
 80099a8:	20000268 	.word	0x20000268

080099ac <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 80099ac:	4b04      	ldr	r3, [pc, #16]	; (80099c0 <xTaskGetSchedulerState+0x14>)
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 80099ae:	2001      	movs	r0, #1

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 80099b0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 80099b2:	2a00      	cmp	r2, #0
 80099b4:	d003      	beq.n	80099be <xTaskGetSchedulerState+0x12>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80099b6:	6f18      	ldr	r0, [r3, #112]	; 0x70
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 80099b8:	4243      	negs	r3, r0
 80099ba:	4158      	adcs	r0, r3
 80099bc:	0040      	lsls	r0, r0, #1
			}
		}

		return xReturn;
	}
 80099be:	4770      	bx	lr
 80099c0:	200002e8 	.word	0x200002e8

080099c4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
 80099c4:	b570      	push	{r4, r5, r6, lr}
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
 80099c6:	2800      	cmp	r0, #0
 80099c8:	d019      	beq.n	80099fe <vTaskPriorityInherit+0x3a>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 80099ca:	4c18      	ldr	r4, [pc, #96]	; (8009a2c <vTaskPriorityInherit+0x68>)
 80099cc:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80099ce:	6862      	ldr	r2, [r4, #4]
 80099d0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80099d2:	4293      	cmp	r3, r2
 80099d4:	d213      	bcs.n	80099fe <vTaskPriorityInherit+0x3a>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80099d6:	6982      	ldr	r2, [r0, #24]
 80099d8:	2a00      	cmp	r2, #0
 80099da:	db04      	blt.n	80099e6 <vTaskPriorityInherit+0x22>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80099dc:	6862      	ldr	r2, [r4, #4]
 80099de:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 80099e0:	2205      	movs	r2, #5
 80099e2:	1a52      	subs	r2, r2, r1
 80099e4:	6182      	str	r2, [r0, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 80099e6:	1c22      	adds	r2, r4, #0
 80099e8:	0099      	lsls	r1, r3, #2
 80099ea:	18cb      	adds	r3, r1, r3
 80099ec:	3218      	adds	r2, #24
 80099ee:	009b      	lsls	r3, r3, #2
 80099f0:	18d3      	adds	r3, r2, r3
 80099f2:	6942      	ldr	r2, [r0, #20]
 80099f4:	429a      	cmp	r2, r3
 80099f6:	d003      	beq.n	8009a00 <vTaskPriorityInherit+0x3c>
					prvAddTaskToReadyList( pxTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80099f8:	6863      	ldr	r3, [r4, #4]
 80099fa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80099fc:	62c3      	str	r3, [r0, #44]	; 0x2c
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 80099fe:	bd70      	pop	{r4, r5, r6, pc}
 8009a00:	1c06      	adds	r6, r0, #0

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8009a02:	1d05      	adds	r5, r0, #4
 8009a04:	1c28      	adds	r0, r5, #0
 8009a06:	f000 fa71 	bl	8009eec <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8009a0a:	6863      	ldr	r3, [r4, #4]
					prvAddTaskToReadyList( pxTCB );
 8009a0c:	6962      	ldr	r2, [r4, #20]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8009a0e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009a10:	62f3      	str	r3, [r6, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 8009a12:	4293      	cmp	r3, r2
 8009a14:	d900      	bls.n	8009a18 <vTaskPriorityInherit+0x54>
 8009a16:	6163      	str	r3, [r4, #20]
 8009a18:	0098      	lsls	r0, r3, #2
 8009a1a:	18c3      	adds	r3, r0, r3
 8009a1c:	3418      	adds	r4, #24
 8009a1e:	009b      	lsls	r3, r3, #2
 8009a20:	18e0      	adds	r0, r4, r3
 8009a22:	1c29      	adds	r1, r5, #0
 8009a24:	f000 fa3e 	bl	8009ea4 <vListInsertEnd>
 8009a28:	e7e9      	b.n	80099fe <vTaskPriorityInherit+0x3a>
 8009a2a:	46c0      	nop			; (mov r8, r8)
 8009a2c:	20000268 	.word	0x20000268

08009a30 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 8009a30:	b538      	push	{r3, r4, r5, lr}
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
 8009a32:	2800      	cmp	r0, #0
 8009a34:	d008      	beq.n	8009a48 <xTaskPriorityDisinherit+0x18>
		{
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
 8009a36:	6c83      	ldr	r3, [r0, #72]	; 0x48

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8009a38:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8009a3a:	6c41      	ldr	r1, [r0, #68]	; 0x44
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
		{
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
 8009a3c:	3b01      	subs	r3, #1
 8009a3e:	6483      	str	r3, [r0, #72]	; 0x48

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8009a40:	428a      	cmp	r2, r1
 8009a42:	d001      	beq.n	8009a48 <xTaskPriorityDisinherit+0x18>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8009a44:	2b00      	cmp	r3, #0
 8009a46:	d001      	beq.n	8009a4c <xTaskPriorityDisinherit+0x1c>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
 8009a48:	2000      	movs	r0, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
 8009a4a:	bd38      	pop	{r3, r4, r5, pc}
 8009a4c:	1c04      	adds	r4, r0, #0
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
				{
					/* The holding task must be the running task to be able to give
					the mutex back.  Remove the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8009a4e:	1d05      	adds	r5, r0, #4
 8009a50:	1c28      	adds	r0, r5, #0
 8009a52:	f000 fa4b 	bl	8009eec <uxListRemove>
					pxTCB->uxPriority = pxTCB->uxBasePriority;

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8009a56:	2205      	movs	r2, #5
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8009a58:	6c63      	ldr	r3, [r4, #68]	; 0x44

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
					prvAddTaskToReadyList( pxTCB );
 8009a5a:	4809      	ldr	r0, [pc, #36]	; (8009a80 <xTaskPriorityDisinherit+0x50>)
					pxTCB->uxPriority = pxTCB->uxBasePriority;

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8009a5c:	1ad2      	subs	r2, r2, r3
 8009a5e:	61a2      	str	r2, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 8009a60:	6942      	ldr	r2, [r0, #20]
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8009a62:	62e3      	str	r3, [r4, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
					prvAddTaskToReadyList( pxTCB );
 8009a64:	4293      	cmp	r3, r2
 8009a66:	d900      	bls.n	8009a6a <xTaskPriorityDisinherit+0x3a>
 8009a68:	6143      	str	r3, [r0, #20]
 8009a6a:	1c02      	adds	r2, r0, #0
 8009a6c:	0098      	lsls	r0, r3, #2
 8009a6e:	18c0      	adds	r0, r0, r3
 8009a70:	3218      	adds	r2, #24
 8009a72:	0083      	lsls	r3, r0, #2
 8009a74:	18d0      	adds	r0, r2, r3
 8009a76:	1c29      	adds	r1, r5, #0
 8009a78:	f000 fa14 	bl	8009ea4 <vListInsertEnd>

					/* Return true to indicate that a context switch is required.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken. */
					xReturn = pdTRUE;
 8009a7c:	2001      	movs	r0, #1
 8009a7e:	e7e4      	b.n	8009a4a <xTaskPriorityDisinherit+0x1a>
 8009a80:	20000268 	.word	0x20000268

08009a84 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 8009a84:	4b04      	ldr	r3, [pc, #16]	; (8009a98 <uxTaskResetEventItemValue+0x14>)
 8009a86:	685a      	ldr	r2, [r3, #4]
 8009a88:	6990      	ldr	r0, [r2, #24]

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8009a8a:	685a      	ldr	r2, [r3, #4]
 8009a8c:	685b      	ldr	r3, [r3, #4]
 8009a8e:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8009a90:	2305      	movs	r3, #5
 8009a92:	1a5b      	subs	r3, r3, r1
 8009a94:	6193      	str	r3, [r2, #24]

	return uxReturn;
}
 8009a96:	4770      	bx	lr
 8009a98:	20000268 	.word	0x20000268

08009a9c <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
 8009a9c:	4b04      	ldr	r3, [pc, #16]	; (8009ab0 <pvTaskIncrementMutexHeldCount+0x14>)
 8009a9e:	685a      	ldr	r2, [r3, #4]
 8009aa0:	2a00      	cmp	r2, #0
 8009aa2:	d003      	beq.n	8009aac <pvTaskIncrementMutexHeldCount+0x10>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
 8009aa4:	6859      	ldr	r1, [r3, #4]
 8009aa6:	6c8a      	ldr	r2, [r1, #72]	; 0x48
 8009aa8:	3201      	adds	r2, #1
 8009aaa:	648a      	str	r2, [r1, #72]	; 0x48
		}

		return pxCurrentTCB;
 8009aac:	6858      	ldr	r0, [r3, #4]
	}
 8009aae:	4770      	bx	lr
 8009ab0:	20000268 	.word	0x20000268

08009ab4 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 8009ab4:	b570      	push	{r4, r5, r6, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 8009ab6:	f000 fa87 	bl	8009fc8 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 8009aba:	4c0c      	ldr	r4, [pc, #48]	; (8009aec <prvCheckForValidListAndQueue+0x38>)
 8009abc:	6823      	ldr	r3, [r4, #0]
 8009abe:	2b00      	cmp	r3, #0
 8009ac0:	d002      	beq.n	8009ac8 <prvCheckForValidListAndQueue+0x14>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8009ac2:	f000 fa8d 	bl	8009fe0 <vPortExitCritical>
}
 8009ac6:	bd70      	pop	{r4, r5, r6, pc}
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
			vListInitialise( &xActiveTimerList2 );
 8009ac8:	1c25      	adds	r5, r4, #0
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
 8009aca:	1d26      	adds	r6, r4, #4
 8009acc:	1c30      	adds	r0, r6, #0
			vListInitialise( &xActiveTimerList2 );
 8009ace:	3518      	adds	r5, #24
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
 8009ad0:	f000 f9d8 	bl	8009e84 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 8009ad4:	1c28      	adds	r0, r5, #0
 8009ad6:	f000 f9d5 	bl	8009e84 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8009ada:	2005      	movs	r0, #5
 8009adc:	210c      	movs	r1, #12
 8009ade:	2200      	movs	r2, #0
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
			vListInitialise( &xActiveTimerList2 );
			pxCurrentTimerList = &xActiveTimerList1;
 8009ae0:	62e6      	str	r6, [r4, #44]	; 0x2c
			pxOverflowTimerList = &xActiveTimerList2;
 8009ae2:	6325      	str	r5, [r4, #48]	; 0x30
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8009ae4:	f7fe fe86 	bl	80087f4 <xQueueGenericCreate>
 8009ae8:	6020      	str	r0, [r4, #0]
 8009aea:	e7ea      	b.n	8009ac2 <prvCheckForValidListAndQueue+0xe>
 8009aec:	20000364 	.word	0x20000364

08009af0 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
 8009af0:	b510      	push	{r4, lr}
 8009af2:	1c04      	adds	r4, r0, #0
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8009af4:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8009af6:	6120      	str	r0, [r4, #16]

	if( xNextExpiryTime <= xTimeNow )
 8009af8:	4291      	cmp	r1, r2
 8009afa:	d805      	bhi.n	8009b08 <prvInsertTimerInActiveList+0x18>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
 8009afc:	1ad2      	subs	r2, r2, r3
 8009afe:	69a3      	ldr	r3, [r4, #24]
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 8009b00:	2001      	movs	r0, #1

	if( xNextExpiryTime <= xTimeNow )
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
 8009b02:	429a      	cmp	r2, r3
 8009b04:	d30c      	bcc.n	8009b20 <prvInsertTimerInActiveList+0x30>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
 8009b06:	bd10      	pop	{r4, pc}
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8009b08:	429a      	cmp	r2, r3
 8009b0a:	d202      	bcs.n	8009b12 <prvInsertTimerInActiveList+0x22>
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 8009b0c:	2001      	movs	r0, #1
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8009b0e:	4299      	cmp	r1, r3
 8009b10:	d2f9      	bcs.n	8009b06 <prvInsertTimerInActiveList+0x16>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8009b12:	4b07      	ldr	r3, [pc, #28]	; (8009b30 <prvInsertTimerInActiveList+0x40>)
 8009b14:	1d21      	adds	r1, r4, #4
 8009b16:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8009b18:	f000 f9d0 	bl	8009ebc <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
 8009b1c:	2000      	movs	r0, #0
 8009b1e:	e7f2      	b.n	8009b06 <prvInsertTimerInActiveList+0x16>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8009b20:	4b03      	ldr	r3, [pc, #12]	; (8009b30 <prvInsertTimerInActiveList+0x40>)
 8009b22:	1d21      	adds	r1, r4, #4
 8009b24:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8009b26:	f000 f9c9 	bl	8009ebc <vListInsert>
 8009b2a:	2000      	movs	r0, #0
 8009b2c:	e7eb      	b.n	8009b06 <prvInsertTimerInActiveList+0x16>
 8009b2e:	46c0      	nop			; (mov r8, r8)
 8009b30:	20000364 	.word	0x20000364

08009b34 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
 8009b34:	b500      	push	{lr}
 8009b36:	b085      	sub	sp, #20

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 8009b38:	f7ff ffbc 	bl	8009ab4 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 8009b3c:	4b09      	ldr	r3, [pc, #36]	; (8009b64 <xTimerCreateTimerTask+0x30>)
 8009b3e:	681b      	ldr	r3, [r3, #0]
 8009b40:	2b00      	cmp	r3, #0
 8009b42:	d00c      	beq.n	8009b5e <xTimerCreateTimerTask+0x2a>
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
 8009b44:	2302      	movs	r3, #2
 8009b46:	9300      	str	r3, [sp, #0]
 8009b48:	2300      	movs	r3, #0
 8009b4a:	4807      	ldr	r0, [pc, #28]	; (8009b68 <xTimerCreateTimerTask+0x34>)
 8009b4c:	9301      	str	r3, [sp, #4]
 8009b4e:	9302      	str	r3, [sp, #8]
 8009b50:	9303      	str	r3, [sp, #12]
 8009b52:	4906      	ldr	r1, [pc, #24]	; (8009b6c <xTimerCreateTimerTask+0x38>)
 8009b54:	2250      	movs	r2, #80	; 0x50
 8009b56:	f7ff f9af 	bl	8008eb8 <xTaskGenericCreate>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
 8009b5a:	b005      	add	sp, #20
 8009b5c:	bd00      	pop	{pc}

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
 8009b5e:	2000      	movs	r0, #0
 8009b60:	e7fb      	b.n	8009b5a <xTimerCreateTimerTask+0x26>
 8009b62:	46c0      	nop			; (mov r8, r8)
 8009b64:	20000364 	.word	0x20000364
 8009b68:	08009c71 	.word	0x08009c71
 8009b6c:	0800ac74 	.word	0x0800ac74

08009b70 <xTimerCreate>:
	return xReturn;
}
/*-----------------------------------------------------------*/

TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 8009b70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009b72:	4647      	mov	r7, r8
 8009b74:	b480      	push	{r7}
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
 8009b76:	2900      	cmp	r1, #0
 8009b78:	d018      	beq.n	8009bac <xTimerCreate+0x3c>
 8009b7a:	4680      	mov	r8, r0
	{
		pxNewTimer = NULL;
	}
	else
	{
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
 8009b7c:	202c      	movs	r0, #44	; 0x2c
 8009b7e:	1c1e      	adds	r6, r3, #0
 8009b80:	1c17      	adds	r7, r2, #0
 8009b82:	1c0d      	adds	r5, r1, #0
 8009b84:	f000 f942 	bl	8009e0c <pvPortMalloc>
 8009b88:	1e04      	subs	r4, r0, #0
		if( pxNewTimer != NULL )
 8009b8a:	d00b      	beq.n	8009ba4 <xTimerCreate+0x34>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
 8009b8c:	f7ff ff92 	bl	8009ab4 <prvCheckForValidListAndQueue>

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
 8009b90:	4643      	mov	r3, r8
 8009b92:	6023      	str	r3, [r4, #0]
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
			pxNewTimer->uxAutoReload = uxAutoReload;
			pxNewTimer->pvTimerID = pvTimerID;
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8009b94:	9b06      	ldr	r3, [sp, #24]
			created/initialised. */
			prvCheckForValidListAndQueue();

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 8009b96:	61a5      	str	r5, [r4, #24]
			pxNewTimer->uxAutoReload = uxAutoReload;
 8009b98:	61e7      	str	r7, [r4, #28]
			pxNewTimer->pvTimerID = pvTimerID;
 8009b9a:	6226      	str	r6, [r4, #32]
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8009b9c:	6263      	str	r3, [r4, #36]	; 0x24
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8009b9e:	1d20      	adds	r0, r4, #4
 8009ba0:	f000 f97c 	bl	8009e9c <vListInitialiseItem>

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( TimerHandle_t ) pxNewTimer;
}
 8009ba4:	1c20      	adds	r0, r4, #0
 8009ba6:	bc04      	pop	{r2}
 8009ba8:	4690      	mov	r8, r2
 8009baa:	bdf0      	pop	{r4, r5, r6, r7, pc}
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
	{
		pxNewTimer = NULL;
 8009bac:	2400      	movs	r4, #0
 8009bae:	e7f9      	b.n	8009ba4 <xTimerCreate+0x34>

08009bb0 <xTimerGenericCommand>:
	return ( TimerHandle_t ) pxNewTimer;
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
 8009bb0:	b530      	push	{r4, r5, lr}
BaseType_t xReturn = pdFAIL;
DaemonTaskMessage_t xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 8009bb2:	4c13      	ldr	r4, [pc, #76]	; (8009c00 <xTimerGenericCommand+0x50>)
	return ( TimerHandle_t ) pxNewTimer;
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
 8009bb4:	b085      	sub	sp, #20
BaseType_t xReturn = pdFAIL;
DaemonTaskMessage_t xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 8009bb6:	6825      	ldr	r5, [r4, #0]
 8009bb8:	2d00      	cmp	r5, #0
 8009bba:	d01e      	beq.n	8009bfa <xTimerGenericCommand+0x4a>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 8009bbc:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 8009bbe:	9202      	str	r2, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
 8009bc0:	9003      	str	r0, [sp, #12]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8009bc2:	2905      	cmp	r1, #5
 8009bc4:	dc0a      	bgt.n	8009bdc <xTimerGenericCommand+0x2c>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8009bc6:	f7ff fef1 	bl	80099ac <xTaskGetSchedulerState>
 8009bca:	2802      	cmp	r0, #2
 8009bcc:	d00e      	beq.n	8009bec <xTimerGenericCommand+0x3c>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8009bce:	6820      	ldr	r0, [r4, #0]
 8009bd0:	a901      	add	r1, sp, #4
 8009bd2:	2200      	movs	r2, #0
 8009bd4:	2300      	movs	r3, #0
 8009bd6:	f7fe fe39 	bl	800884c <xQueueGenericSend>
 8009bda:	e005      	b.n	8009be8 <xTimerGenericCommand+0x38>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8009bdc:	1c1a      	adds	r2, r3, #0
 8009bde:	1c28      	adds	r0, r5, #0
 8009be0:	a901      	add	r1, sp, #4
 8009be2:	2300      	movs	r3, #0
 8009be4:	f7fe fef6 	bl	80089d4 <xQueueGenericSendFromISR>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
 8009be8:	b005      	add	sp, #20
 8009bea:	bd30      	pop	{r4, r5, pc}

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8009bec:	6820      	ldr	r0, [r4, #0]
 8009bee:	a901      	add	r1, sp, #4
 8009bf0:	9a08      	ldr	r2, [sp, #32]
 8009bf2:	2300      	movs	r3, #0
 8009bf4:	f7fe fe2a 	bl	800884c <xQueueGenericSend>
 8009bf8:	e7f6      	b.n	8009be8 <xTimerGenericCommand+0x38>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
 8009bfa:	2000      	movs	r0, #0
 8009bfc:	e7f4      	b.n	8009be8 <xTimerGenericCommand+0x38>
 8009bfe:	46c0      	nop			; (mov r8, r8)
 8009c00:	20000364 	.word	0x20000364

08009c04 <prvSwitchTimerLists>:
	}
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
 8009c04:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009c06:	4647      	mov	r7, r8
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8009c08:	2300      	movs	r3, #0
	}
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
 8009c0a:	b480      	push	{r7}
 8009c0c:	4e17      	ldr	r6, [pc, #92]	; (8009c6c <prvSwitchTimerLists+0x68>)
 8009c0e:	b082      	sub	sp, #8
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8009c10:	4698      	mov	r8, r3

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8009c12:	e00c      	b.n	8009c2e <prvSwitchTimerLists+0x2a>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8009c14:	68db      	ldr	r3, [r3, #12]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8009c16:	68dc      	ldr	r4, [r3, #12]
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8009c18:	681f      	ldr	r7, [r3, #0]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8009c1a:	1d25      	adds	r5, r4, #4
 8009c1c:	1c28      	adds	r0, r5, #0
 8009c1e:	f000 f965 	bl	8009eec <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8009c22:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8009c24:	1c20      	adds	r0, r4, #0
 8009c26:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8009c28:	69e3      	ldr	r3, [r4, #28]
 8009c2a:	2b01      	cmp	r3, #1
 8009c2c:	d00a      	beq.n	8009c44 <prvSwitchTimerLists+0x40>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8009c2e:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8009c30:	681a      	ldr	r2, [r3, #0]
 8009c32:	2a00      	cmp	r2, #0
 8009c34:	d1ee      	bne.n	8009c14 <prvSwitchTimerLists+0x10>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 8009c36:	6b32      	ldr	r2, [r6, #48]	; 0x30
	pxOverflowTimerList = pxTemp;
 8009c38:	6333      	str	r3, [r6, #48]	; 0x30
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 8009c3a:	62f2      	str	r2, [r6, #44]	; 0x2c
	pxOverflowTimerList = pxTemp;
}
 8009c3c:	b002      	add	sp, #8
 8009c3e:	bc04      	pop	{r2}
 8009c40:	4690      	mov	r8, r2
 8009c42:	bdf0      	pop	{r4, r5, r6, r7, pc}
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 8009c44:	69a3      	ldr	r3, [r4, #24]
 8009c46:	18fb      	adds	r3, r7, r3
			if( xReloadTime > xNextExpireTime )
 8009c48:	42bb      	cmp	r3, r7
 8009c4a:	d906      	bls.n	8009c5a <prvSwitchTimerLists+0x56>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 8009c4c:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8009c4e:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8009c50:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 8009c52:	1c29      	adds	r1, r5, #0
 8009c54:	f000 f932 	bl	8009ebc <vListInsert>
 8009c58:	e7e9      	b.n	8009c2e <prvSwitchTimerLists+0x2a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8009c5a:	4643      	mov	r3, r8
 8009c5c:	1c20      	adds	r0, r4, #0
 8009c5e:	9300      	str	r3, [sp, #0]
 8009c60:	2100      	movs	r1, #0
 8009c62:	1c3a      	adds	r2, r7, #0
 8009c64:	2300      	movs	r3, #0
 8009c66:	f7ff ffa3 	bl	8009bb0 <xTimerGenericCommand>
 8009c6a:	e7e0      	b.n	8009c2e <prvSwitchTimerLists+0x2a>
 8009c6c:	20000364 	.word	0x20000364

08009c70 <prvTimerTask>:
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
 8009c70:	2300      	movs	r3, #0
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
 8009c72:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009c74:	4644      	mov	r4, r8
 8009c76:	464d      	mov	r5, r9
 8009c78:	465f      	mov	r7, fp
 8009c7a:	4656      	mov	r6, sl
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
 8009c7c:	4699      	mov	r9, r3
 8009c7e:	3301      	adds	r3, #1
 8009c80:	4698      	mov	r8, r3
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
 8009c82:	b4f0      	push	{r4, r5, r6, r7}
 8009c84:	4c58      	ldr	r4, [pc, #352]	; (8009de8 <prvTimerTask+0x178>)
 8009c86:	b089      	sub	sp, #36	; 0x24
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8009c88:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	if( *pxListWasEmpty == pdFALSE )
 8009c8a:	681a      	ldr	r2, [r3, #0]
 8009c8c:	2a00      	cmp	r2, #0
 8009c8e:	d045      	beq.n	8009d1c <prvTimerTask+0xac>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8009c90:	68db      	ldr	r3, [r3, #12]
 8009c92:	681e      	ldr	r6, [r3, #0]
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
 8009c94:	f7ff fb7a 	bl	800938c <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8009c98:	f7ff fb80 	bl	800939c <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 8009c9c:	6b63      	ldr	r3, [r4, #52]	; 0x34
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8009c9e:	1e05      	subs	r5, r0, #0

	if( xTimeNow < xLastTime )
 8009ca0:	429d      	cmp	r5, r3
 8009ca2:	d346      	bcc.n	8009d32 <prvTimerTask+0xc2>
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
 8009ca4:	6360      	str	r0, [r4, #52]	; 0x34
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8009ca6:	42b0      	cmp	r0, r6
 8009ca8:	d24c      	bcs.n	8009d44 <prvTimerTask+0xd4>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
 8009caa:	1b71      	subs	r1, r6, r5
 8009cac:	6820      	ldr	r0, [r4, #0]
 8009cae:	f7ff f811 	bl	8008cd4 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
 8009cb2:	f7ff fc1d 	bl	80094f0 <xTaskResumeAll>
 8009cb6:	2800      	cmp	r0, #0
 8009cb8:	d02d      	beq.n	8009d16 <prvTimerTask+0xa6>
 8009cba:	26c7      	movs	r6, #199	; 0xc7
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8009cbc:	6820      	ldr	r0, [r4, #0]
 8009cbe:	a905      	add	r1, sp, #20
 8009cc0:	2200      	movs	r2, #0
 8009cc2:	2300      	movs	r3, #0
 8009cc4:	f7fe fec6 	bl	8008a54 <xQueueGenericReceive>
 8009cc8:	2800      	cmp	r0, #0
 8009cca:	d0dd      	beq.n	8009c88 <prvTimerTask+0x18>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8009ccc:	9b05      	ldr	r3, [sp, #20]
 8009cce:	9303      	str	r3, [sp, #12]
 8009cd0:	2b00      	cmp	r3, #0
 8009cd2:	dbf3      	blt.n	8009cbc <prvTimerTask+0x4c>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8009cd4:	9f07      	ldr	r7, [sp, #28]

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 8009cd6:	697b      	ldr	r3, [r7, #20]
 8009cd8:	2b00      	cmp	r3, #0
 8009cda:	d002      	beq.n	8009ce2 <prvTimerTask+0x72>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8009cdc:	1d38      	adds	r0, r7, #4
 8009cde:	f000 f905 	bl	8009eec <uxListRemove>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8009ce2:	f7ff fb5b 	bl	800939c <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 8009ce6:	6b63      	ldr	r3, [r4, #52]	; 0x34
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8009ce8:	1e05      	subs	r5, r0, #0

	if( xTimeNow < xLastTime )
 8009cea:	429d      	cmp	r5, r3
 8009cec:	d327      	bcc.n	8009d3e <prvTimerTask+0xce>
 8009cee:	9b05      	ldr	r3, [sp, #20]
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
 8009cf0:	6365      	str	r5, [r4, #52]	; 0x34
 8009cf2:	2b09      	cmp	r3, #9
 8009cf4:	d8e2      	bhi.n	8009cbc <prvTimerTask+0x4c>
 8009cf6:	4642      	mov	r2, r8
 8009cf8:	409a      	lsls	r2, r3
 8009cfa:	1c13      	adds	r3, r2, #0
 8009cfc:	2284      	movs	r2, #132	; 0x84
 8009cfe:	0092      	lsls	r2, r2, #2
 8009d00:	401a      	ands	r2, r3
 8009d02:	4693      	mov	fp, r2
 8009d04:	d143      	bne.n	8009d8e <prvTimerTask+0x11e>
 8009d06:	421e      	tst	r6, r3
 8009d08:	d14a      	bne.n	8009da0 <prvTimerTask+0x130>
 8009d0a:	069b      	lsls	r3, r3, #26
 8009d0c:	d5d6      	bpl.n	8009cbc <prvTimerTask+0x4c>
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
 8009d0e:	1c38      	adds	r0, r7, #0
 8009d10:	f000 f8a6 	bl	8009e60 <vPortFree>
 8009d14:	e7d2      	b.n	8009cbc <prvTimerTask+0x4c>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
 8009d16:	f000 f94b 	bl	8009fb0 <vPortYield>
 8009d1a:	e7ce      	b.n	8009cba <prvTimerTask+0x4a>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
 8009d1c:	f7ff fb36 	bl	800938c <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8009d20:	f7ff fb3c 	bl	800939c <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 8009d24:	6b63      	ldr	r3, [r4, #52]	; 0x34
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8009d26:	1c05      	adds	r5, r0, #0

	if( xTimeNow < xLastTime )
 8009d28:	4283      	cmp	r3, r0
 8009d2a:	d802      	bhi.n	8009d32 <prvTimerTask+0xc2>
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
 8009d2c:	6365      	str	r5, [r4, #52]	; 0x34
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
 8009d2e:	2600      	movs	r6, #0
 8009d30:	e7bb      	b.n	8009caa <prvTimerTask+0x3a>

	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
 8009d32:	f7ff ff67 	bl	8009c04 <prvSwitchTimerLists>
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
 8009d36:	6365      	str	r5, [r4, #52]	; 0x34
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
 8009d38:	f7ff fbda 	bl	80094f0 <xTaskResumeAll>
 8009d3c:	e7bd      	b.n	8009cba <prvTimerTask+0x4a>

	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
 8009d3e:	f7ff ff61 	bl	8009c04 <prvSwitchTimerLists>
 8009d42:	e7d4      	b.n	8009cee <prvTimerTask+0x7e>
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
			{
				( void ) xTaskResumeAll();
 8009d44:	f7ff fbd4 	bl	80094f0 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8009d48:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8009d4a:	68db      	ldr	r3, [r3, #12]
 8009d4c:	68db      	ldr	r3, [r3, #12]
 8009d4e:	469a      	mov	sl, r3

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8009d50:	1d18      	adds	r0, r3, #4
 8009d52:	f000 f8cb 	bl	8009eec <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8009d56:	4653      	mov	r3, sl
 8009d58:	69db      	ldr	r3, [r3, #28]
 8009d5a:	2b01      	cmp	r3, #1
 8009d5c:	d004      	beq.n	8009d68 <prvTimerTask+0xf8>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8009d5e:	4653      	mov	r3, sl
 8009d60:	4650      	mov	r0, sl
 8009d62:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009d64:	4798      	blx	r3
 8009d66:	e7a8      	b.n	8009cba <prvTimerTask+0x4a>
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
 8009d68:	4653      	mov	r3, sl
 8009d6a:	699b      	ldr	r3, [r3, #24]
 8009d6c:	4650      	mov	r0, sl
 8009d6e:	18f1      	adds	r1, r6, r3
 8009d70:	1c2a      	adds	r2, r5, #0
 8009d72:	1c33      	adds	r3, r6, #0
 8009d74:	f7ff febc 	bl	8009af0 <prvInsertTimerInActiveList>
 8009d78:	2801      	cmp	r0, #1
 8009d7a:	d1f0      	bne.n	8009d5e <prvTimerTask+0xee>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8009d7c:	464b      	mov	r3, r9
 8009d7e:	4650      	mov	r0, sl
 8009d80:	9300      	str	r3, [sp, #0]
 8009d82:	2100      	movs	r1, #0
 8009d84:	1c32      	adds	r2, r6, #0
 8009d86:	2300      	movs	r3, #0
 8009d88:	f7ff ff12 	bl	8009bb0 <xTimerGenericCommand>
 8009d8c:	e7e7      	b.n	8009d5e <prvTimerTask+0xee>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8009d8e:	9906      	ldr	r1, [sp, #24]
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8009d90:	1c38      	adds	r0, r7, #0
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8009d92:	61b9      	str	r1, [r7, #24]
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8009d94:	1c2a      	adds	r2, r5, #0
 8009d96:	1869      	adds	r1, r5, r1
 8009d98:	1c2b      	adds	r3, r5, #0
 8009d9a:	f7ff fea9 	bl	8009af0 <prvInsertTimerInActiveList>
 8009d9e:	e78d      	b.n	8009cbc <prvTimerTask+0x4c>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
 8009da0:	9b06      	ldr	r3, [sp, #24]
 8009da2:	1c38      	adds	r0, r7, #0
 8009da4:	9303      	str	r3, [sp, #12]
 8009da6:	9a03      	ldr	r2, [sp, #12]
 8009da8:	69bb      	ldr	r3, [r7, #24]
 8009daa:	4694      	mov	ip, r2
 8009dac:	4463      	add	r3, ip
 8009dae:	1c19      	adds	r1, r3, #0
 8009db0:	1c2a      	adds	r2, r5, #0
 8009db2:	4663      	mov	r3, ip
 8009db4:	f7ff fe9c 	bl	8009af0 <prvInsertTimerInActiveList>
 8009db8:	2801      	cmp	r0, #1
 8009dba:	d000      	beq.n	8009dbe <prvTimerTask+0x14e>
 8009dbc:	e77e      	b.n	8009cbc <prvTimerTask+0x4c>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8009dbe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009dc0:	1c38      	adds	r0, r7, #0
 8009dc2:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8009dc4:	69fb      	ldr	r3, [r7, #28]
 8009dc6:	2b01      	cmp	r3, #1
 8009dc8:	d000      	beq.n	8009dcc <prvTimerTask+0x15c>
 8009dca:	e777      	b.n	8009cbc <prvTimerTask+0x4c>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 8009dcc:	69b9      	ldr	r1, [r7, #24]
 8009dce:	9b06      	ldr	r3, [sp, #24]
 8009dd0:	468c      	mov	ip, r1
 8009dd2:	9303      	str	r3, [sp, #12]
 8009dd4:	4463      	add	r3, ip
 8009dd6:	1c1a      	adds	r2, r3, #0
 8009dd8:	465b      	mov	r3, fp
 8009dda:	1c38      	adds	r0, r7, #0
 8009ddc:	9300      	str	r3, [sp, #0]
 8009dde:	2100      	movs	r1, #0
 8009de0:	2300      	movs	r3, #0
 8009de2:	f7ff fee5 	bl	8009bb0 <xTimerGenericCommand>
 8009de6:	e769      	b.n	8009cbc <prvTimerTask+0x4c>
 8009de8:	20000364 	.word	0x20000364

08009dec <pcTimerGetTimerName>:

const char * pcTimerGetTimerName( TimerHandle_t xTimer )
{
Timer_t *pxTimer = ( Timer_t * ) xTimer;

	return pxTimer->pcTimerName;
 8009dec:	6800      	ldr	r0, [r0, #0]
}
 8009dee:	4770      	bx	lr

08009df0 <xTimerIsTimerActive>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
{
 8009df0:	b510      	push	{r4, lr}
 8009df2:	1c04      	adds	r4, r0, #0
BaseType_t xTimerIsInActiveList;
Timer_t *pxTimer = ( Timer_t * ) xTimer;

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
 8009df4:	f000 f8e8 	bl	8009fc8 <vPortEnterCritical>
	{
		/* Checking to see if it is in the NULL list in effect checks to see if
		it is referenced from either the current or the overflow timer lists in
		one go, but the logic has to be reversed, hence the '!'. */
		xTimerIsInActiveList = ( BaseType_t ) !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
 8009df8:	6964      	ldr	r4, [r4, #20]
 8009dfa:	1e63      	subs	r3, r4, #1
 8009dfc:	419c      	sbcs	r4, r3
	}
	taskEXIT_CRITICAL();
 8009dfe:	f000 f8ef 	bl	8009fe0 <vPortExitCritical>

	return xTimerIsInActiveList;
} /*lint !e818 Can't be pointer to const due to the typedef. */
 8009e02:	1c20      	adds	r0, r4, #0
 8009e04:	bd10      	pop	{r4, pc}
 8009e06:	46c0      	nop			; (mov r8, r8)

08009e08 <pvTimerGetTimerID>:

void *pvTimerGetTimerID( const TimerHandle_t xTimer )
{
Timer_t * const pxTimer = ( Timer_t * ) xTimer;

	return pxTimer->pvTimerID;
 8009e08:	6a00      	ldr	r0, [r0, #32]
}
 8009e0a:	4770      	bx	lr

08009e0c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8009e0c:	b538      	push	{r3, r4, r5, lr}
void *pvReturn = NULL;
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 8009e0e:	2307      	movs	r3, #7
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8009e10:	1c04      	adds	r4, r0, #0
void *pvReturn = NULL;
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 8009e12:	4203      	tst	r3, r0
 8009e14:	d001      	beq.n	8009e1a <pvPortMalloc+0xe>
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8009e16:	439c      	bics	r4, r3
 8009e18:	3408      	adds	r4, #8
		}
	#endif

	vTaskSuspendAll();
 8009e1a:	f7ff fab7 	bl	800938c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 8009e1e:	4a0d      	ldr	r2, [pc, #52]	; (8009e54 <pvPortMalloc+0x48>)
 8009e20:	6813      	ldr	r3, [r2, #0]
 8009e22:	2b00      	cmp	r3, #0
 8009e24:	d010      	beq.n	8009e48 <pvPortMalloc+0x3c>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 8009e26:	490c      	ldr	r1, [pc, #48]	; (8009e58 <pvPortMalloc+0x4c>)
 8009e28:	480c      	ldr	r0, [pc, #48]	; (8009e5c <pvPortMalloc+0x50>)
 8009e2a:	680b      	ldr	r3, [r1, #0]
 8009e2c:	18e4      	adds	r4, r4, r3
 8009e2e:	4284      	cmp	r4, r0
 8009e30:	d808      	bhi.n	8009e44 <pvPortMalloc+0x38>
 8009e32:	42a3      	cmp	r3, r4
 8009e34:	d206      	bcs.n	8009e44 <pvPortMalloc+0x38>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 8009e36:	6815      	ldr	r5, [r2, #0]
			xNextFreeByte += xWantedSize;
 8009e38:	600c      	str	r4, [r1, #0]
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 8009e3a:	18ed      	adds	r5, r5, r3
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 8009e3c:	f7ff fb58 	bl	80094f0 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 8009e40:	1c28      	adds	r0, r5, #0
 8009e42:	bd38      	pop	{r3, r4, r5, pc}

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 8009e44:	2500      	movs	r5, #0
 8009e46:	e7f9      	b.n	8009e3c <pvPortMalloc+0x30>
	vTaskSuspendAll();
	{
		if( pucAlignedHeap == NULL )
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
 8009e48:	1c13      	adds	r3, r2, #0
 8009e4a:	2107      	movs	r1, #7
 8009e4c:	330c      	adds	r3, #12
 8009e4e:	438b      	bics	r3, r1
 8009e50:	6013      	str	r3, [r2, #0]
 8009e52:	e7e8      	b.n	8009e26 <pvPortMalloc+0x1a>
 8009e54:	2000039c 	.word	0x2000039c
 8009e58:	2000191c 	.word	0x2000191c
 8009e5c:	00001573 	.word	0x00001573

08009e60 <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
 8009e60:	4770      	bx	lr
 8009e62:	46c0      	nop			; (mov r8, r8)

08009e64 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
 8009e64:	2200      	movs	r2, #0
 8009e66:	4b01      	ldr	r3, [pc, #4]	; (8009e6c <vPortInitialiseBlocks+0x8>)
 8009e68:	601a      	str	r2, [r3, #0]
}
 8009e6a:	4770      	bx	lr
 8009e6c:	2000191c 	.word	0x2000191c

08009e70 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 8009e70:	4b02      	ldr	r3, [pc, #8]	; (8009e7c <xPortGetFreeHeapSize+0xc>)
 8009e72:	6818      	ldr	r0, [r3, #0]
 8009e74:	4b02      	ldr	r3, [pc, #8]	; (8009e80 <xPortGetFreeHeapSize+0x10>)
 8009e76:	1a18      	subs	r0, r3, r0
}
 8009e78:	4770      	bx	lr
 8009e7a:	46c0      	nop			; (mov r8, r8)
 8009e7c:	2000191c 	.word	0x2000191c
 8009e80:	00001574 	.word	0x00001574

08009e84 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8009e84:	1c03      	adds	r3, r0, #0

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8009e86:	2201      	movs	r2, #1
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8009e88:	3308      	adds	r3, #8
 8009e8a:	6043      	str	r3, [r0, #4]
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8009e8c:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8009e8e:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8009e90:	2300      	movs	r3, #0
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8009e92:	4252      	negs	r2, r2
 8009e94:	6082      	str	r2, [r0, #8]
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8009e96:	6003      	str	r3, [r0, #0]
}
 8009e98:	4770      	bx	lr
 8009e9a:	46c0      	nop			; (mov r8, r8)

08009e9c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8009e9c:	2300      	movs	r3, #0
 8009e9e:	6103      	str	r3, [r0, #16]
}
 8009ea0:	4770      	bx	lr
 8009ea2:	46c0      	nop			; (mov r8, r8)

08009ea4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8009ea4:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8009ea6:	689a      	ldr	r2, [r3, #8]
ListItem_t * const pxIndex = pxList->pxIndex;

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8009ea8:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8009eaa:	608a      	str	r2, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8009eac:	689a      	ldr	r2, [r3, #8]
 8009eae:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8009eb0:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8009eb2:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
	pxIndex->pxPrevious->pxNext = pxNewListItem;
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8009eb4:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8009eb6:	3301      	adds	r3, #1
 8009eb8:	6003      	str	r3, [r0, #0]
}
 8009eba:	4770      	bx	lr

08009ebc <vListInsert>:
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8009ebc:	1c02      	adds	r2, r0, #0
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8009ebe:	b530      	push	{r4, r5, lr}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8009ec0:	680c      	ldr	r4, [r1, #0]
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8009ec2:	3208      	adds	r2, #8
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8009ec4:	1c63      	adds	r3, r4, #1
 8009ec6:	d101      	bne.n	8009ecc <vListInsert+0x10>
 8009ec8:	e00d      	b.n	8009ee6 <vListInsert+0x2a>
 8009eca:	1c1a      	adds	r2, r3, #0
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8009ecc:	6853      	ldr	r3, [r2, #4]
 8009ece:	681d      	ldr	r5, [r3, #0]
 8009ed0:	42ac      	cmp	r4, r5
 8009ed2:	d2fa      	bcs.n	8009eca <vListInsert+0xe>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8009ed4:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8009ed6:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8009ed8:	6803      	ldr	r3, [r0, #0]
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
 8009eda:	608a      	str	r2, [r1, #8]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8009edc:	3301      	adds	r3, #1
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = pxNewListItem;
 8009ede:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8009ee0:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8009ee2:	6003      	str	r3, [r0, #0]
}
 8009ee4:	bd30      	pop	{r4, r5, pc}
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8009ee6:	6902      	ldr	r2, [r0, #16]
 8009ee8:	6853      	ldr	r3, [r2, #4]
 8009eea:	e7f3      	b.n	8009ed4 <vListInsert+0x18>

08009eec <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8009eec:	6842      	ldr	r2, [r0, #4]
 8009eee:	6881      	ldr	r1, [r0, #8]

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8009ef0:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8009ef2:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8009ef4:	6881      	ldr	r1, [r0, #8]
 8009ef6:	604a      	str	r2, [r1, #4]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8009ef8:	685a      	ldr	r2, [r3, #4]
 8009efa:	4282      	cmp	r2, r0
 8009efc:	d005      	beq.n	8009f0a <uxListRemove+0x1e>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8009efe:	2200      	movs	r2, #0
 8009f00:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8009f02:	681a      	ldr	r2, [r3, #0]
 8009f04:	1e50      	subs	r0, r2, #1
 8009f06:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 8009f08:	4770      	bx	lr
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8009f0a:	6059      	str	r1, [r3, #4]
 8009f0c:	e7f7      	b.n	8009efe <uxListRemove+0x12>
 8009f0e:	46c0      	nop			; (mov r8, r8)

08009f10 <prvTaskExitError>:
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
	portDISABLE_INTERRUPTS();
 8009f10:	b672      	cpsid	i
	for( ;; );
 8009f12:	e7fe      	b.n	8009f12 <prvTaskExitError+0x2>

08009f14 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
 8009f14:	4a06      	ldr	r2, [pc, #24]	; (8009f30 <pxCurrentTCBConst2>)
 8009f16:	6813      	ldr	r3, [r2, #0]
 8009f18:	6818      	ldr	r0, [r3, #0]
 8009f1a:	3020      	adds	r0, #32
 8009f1c:	f380 8809 	msr	PSP, r0
 8009f20:	2002      	movs	r0, #2
 8009f22:	f380 8814 	msr	CONTROL, r0
 8009f26:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
 8009f28:	46ae      	mov	lr, r5
 8009f2a:	b662      	cpsie	i
 8009f2c:	bd00      	pop	{pc}
 8009f2e:	46c0      	nop			; (mov r8, r8)

08009f30 <pxCurrentTCBConst2>:
 8009f30:	2000026c 	.word	0x2000026c

08009f34 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
 8009f34:	b510      	push	{r4, lr}
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8009f36:	2480      	movs	r4, #128	; 0x80
 8009f38:	1f03      	subs	r3, r0, #4
 8009f3a:	0464      	lsls	r4, r4, #17
 8009f3c:	601c      	str	r4, [r3, #0]
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
 8009f3e:	3b04      	subs	r3, #4
 8009f40:	6019      	str	r1, [r3, #0]
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8009f42:	4903      	ldr	r1, [pc, #12]	; (8009f50 <pxPortInitialiseStack+0x1c>)
 8009f44:	3b04      	subs	r3, #4
 8009f46:	6019      	str	r1, [r3, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8009f48:	3b14      	subs	r3, #20
	pxTopOfStack -= 8; /* R11..R4. */
 8009f4a:	3840      	subs	r0, #64	; 0x40
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8009f4c:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8; /* R11..R4. */

	return pxTopOfStack;
}
 8009f4e:	bd10      	pop	{r4, pc}
 8009f50:	08009f11 	.word	0x08009f11

08009f54 <SVC_Handler>:

void vPortSVCHandler( void )
{
	/* This function is no longer used, but retained for backward
	compatibility. */
}
 8009f54:	4770      	bx	lr
 8009f56:	46c0      	nop			; (mov r8, r8)

08009f58 <xPortStartScheduler>:
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8009f58:	21ff      	movs	r1, #255	; 0xff

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 8009f5a:	b508      	push	{r3, lr}
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8009f5c:	4b0e      	ldr	r3, [pc, #56]	; (8009f98 <xPortStartScheduler+0x40>)
 8009f5e:	0409      	lsls	r1, r1, #16
 8009f60:	681a      	ldr	r2, [r3, #0]
 8009f62:	430a      	orrs	r2, r1
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 8009f64:	21ff      	movs	r1, #255	; 0xff
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8009f66:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 8009f68:	681a      	ldr	r2, [r3, #0]
 8009f6a:	0609      	lsls	r1, r1, #24
 8009f6c:	430a      	orrs	r2, r1
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8009f6e:	21fa      	movs	r1, #250	; 0xfa
 */
BaseType_t xPortStartScheduler( void )
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 8009f70:	601a      	str	r2, [r3, #0]
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8009f72:	4b0a      	ldr	r3, [pc, #40]	; (8009f9c <xPortStartScheduler+0x44>)
 8009f74:	0089      	lsls	r1, r1, #2
 8009f76:	6818      	ldr	r0, [r3, #0]
 8009f78:	f7f9 fbfc 	bl	8003774 <__aeabi_uidiv>
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 8009f7c:	2207      	movs	r2, #7
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8009f7e:	4b08      	ldr	r3, [pc, #32]	; (8009fa0 <xPortStartScheduler+0x48>)
 8009f80:	3801      	subs	r0, #1
 8009f82:	6018      	str	r0, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 8009f84:	4b07      	ldr	r3, [pc, #28]	; (8009fa4 <xPortStartScheduler+0x4c>)
 8009f86:	601a      	str	r2, [r3, #0]
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8009f88:	2200      	movs	r2, #0
 8009f8a:	4b07      	ldr	r3, [pc, #28]	; (8009fa8 <xPortStartScheduler+0x50>)
 8009f8c:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
 8009f8e:	f7ff ffc1 	bl	8009f14 <vPortStartFirstTask>
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
	portDISABLE_INTERRUPTS();
 8009f92:	b672      	cpsid	i
 8009f94:	e7fe      	b.n	8009f94 <xPortStartScheduler+0x3c>
 8009f96:	46c0      	nop			; (mov r8, r8)
 8009f98:	e000ed20 	.word	0xe000ed20
 8009f9c:	20000010 	.word	0x20000010
 8009fa0:	e000e014 	.word	0xe000e014
 8009fa4:	e000e010 	.word	0xe000e010
 8009fa8:	20000050 	.word	0x20000050

08009fac <vPortEndScheduler>:
void vPortEndScheduler( void )
{
	/* Not implemented in ports where there is nothing to return to.
	Artificially force an assert. */
	configASSERT( uxCriticalNesting == 1000UL );
}
 8009fac:	4770      	bx	lr
 8009fae:	46c0      	nop			; (mov r8, r8)

08009fb0 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
 8009fb0:	2280      	movs	r2, #128	; 0x80
 8009fb2:	4b04      	ldr	r3, [pc, #16]	; (8009fc4 <vPortYield+0x14>)
 8009fb4:	0552      	lsls	r2, r2, #21
 8009fb6:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
 8009fb8:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 8009fbc:	f3bf 8f6f 	isb	sy
}
 8009fc0:	4770      	bx	lr
 8009fc2:	46c0      	nop			; (mov r8, r8)
 8009fc4:	e000ed04 	.word	0xe000ed04

08009fc8 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
 8009fc8:	b672      	cpsid	i
    uxCriticalNesting++;
 8009fca:	4a04      	ldr	r2, [pc, #16]	; (8009fdc <vPortEnterCritical+0x14>)
 8009fcc:	6813      	ldr	r3, [r2, #0]
 8009fce:	3301      	adds	r3, #1
 8009fd0:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" );
 8009fd2:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 8009fd6:	f3bf 8f6f 	isb	sy
}
 8009fda:	4770      	bx	lr
 8009fdc:	20000050 	.word	0x20000050

08009fe0 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
    uxCriticalNesting--;
 8009fe0:	4a03      	ldr	r2, [pc, #12]	; (8009ff0 <vPortExitCritical+0x10>)
 8009fe2:	6813      	ldr	r3, [r2, #0]
 8009fe4:	3b01      	subs	r3, #1
 8009fe6:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
 8009fe8:	2b00      	cmp	r3, #0
 8009fea:	d100      	bne.n	8009fee <vPortExitCritical+0xe>
    {
        portENABLE_INTERRUPTS();
 8009fec:	b662      	cpsie	i
    }
}
 8009fee:	4770      	bx	lr
 8009ff0:	20000050 	.word	0x20000050

08009ff4 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
	__asm volatile(
 8009ff4:	f3ef 8010 	mrs	r0, PRIMASK
 8009ff8:	b672      	cpsid	i
 8009ffa:	4770      	bx	lr
					" bx lr				  "
				  );

	/* To avoid compiler warnings.  This line will never be reached. */
	return 0;
}
 8009ffc:	2000      	movs	r0, #0
 8009ffe:	46c0      	nop			; (mov r8, r8)

0800a000 <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( uint32_t ulMask )
{
	__asm volatile(
 800a000:	f380 8810 	msr	PRIMASK, r0
 800a004:	4770      	bx	lr
 800a006:	46c0      	nop			; (mov r8, r8)

0800a008 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 800a008:	f3ef 8009 	mrs	r0, PSP
 800a00c:	4b0e      	ldr	r3, [pc, #56]	; (800a048 <pxCurrentTCBConst>)
 800a00e:	681a      	ldr	r2, [r3, #0]
 800a010:	3820      	subs	r0, #32
 800a012:	6010      	str	r0, [r2, #0]
 800a014:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800a016:	4644      	mov	r4, r8
 800a018:	464d      	mov	r5, r9
 800a01a:	4656      	mov	r6, sl
 800a01c:	465f      	mov	r7, fp
 800a01e:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800a020:	b508      	push	{r3, lr}
 800a022:	b672      	cpsid	i
 800a024:	f7ff fbb0 	bl	8009788 <vTaskSwitchContext>
 800a028:	b662      	cpsie	i
 800a02a:	bc0c      	pop	{r2, r3}
 800a02c:	6811      	ldr	r1, [r2, #0]
 800a02e:	6808      	ldr	r0, [r1, #0]
 800a030:	3010      	adds	r0, #16
 800a032:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800a034:	46a0      	mov	r8, r4
 800a036:	46a9      	mov	r9, r5
 800a038:	46b2      	mov	sl, r6
 800a03a:	46bb      	mov	fp, r7
 800a03c:	f380 8809 	msr	PSP, r0
 800a040:	3820      	subs	r0, #32
 800a042:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800a044:	4718      	bx	r3
 800a046:	46c0      	nop			; (mov r8, r8)

0800a048 <pxCurrentTCBConst>:
 800a048:	2000026c 	.word	0x2000026c

0800a04c <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 800a04c:	b510      	push	{r4, lr}
uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 800a04e:	f7ff ffd1 	bl	8009ff4 <ulSetInterruptMaskFromISR>
 800a052:	1c04      	adds	r4, r0, #0
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 800a054:	f7ff f9c0 	bl	80093d8 <xTaskIncrementTick>
 800a058:	2800      	cmp	r0, #0
 800a05a:	d003      	beq.n	800a064 <SysTick_Handler+0x18>
		{
			/* Pend a context switch. */
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 800a05c:	2280      	movs	r2, #128	; 0x80
 800a05e:	4b03      	ldr	r3, [pc, #12]	; (800a06c <SysTick_Handler+0x20>)
 800a060:	0552      	lsls	r2, r2, #21
 800a062:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 800a064:	1c20      	adds	r0, r4, #0
 800a066:	f7ff ffcb 	bl	800a000 <vClearInterruptMaskFromISR>
}
 800a06a:	bd10      	pop	{r4, pc}
 800a06c:	e000ed04 	.word	0xe000ed04

0800a070 <ui2a>:
	}

#endif

static void ui2a(unsigned int num, unsigned int base, int uc,char * bf)
	{
 800a070:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a072:	464e      	mov	r6, r9
 800a074:	4657      	mov	r7, sl
 800a076:	4645      	mov	r5, r8
 800a078:	4691      	mov	r9, r2
 800a07a:	b4e0      	push	{r5, r6, r7}
	int n=0;
	unsigned int d=1;
	while (num/d >= base)
 800a07c:	2401      	movs	r4, #1
	}

#endif

static void ui2a(unsigned int num, unsigned int base, int uc,char * bf)
	{
 800a07e:	1c05      	adds	r5, r0, #0
 800a080:	1c0e      	adds	r6, r1, #0
 800a082:	1c1f      	adds	r7, r3, #0
	int n=0;
	unsigned int d=1;
	while (num/d >= base)
 800a084:	4288      	cmp	r0, r1
 800a086:	d308      	bcc.n	800a09a <ui2a+0x2a>
		d*=base;		
 800a088:	4374      	muls	r4, r6

static void ui2a(unsigned int num, unsigned int base, int uc,char * bf)
	{
	int n=0;
	unsigned int d=1;
	while (num/d >= base)
 800a08a:	1c28      	adds	r0, r5, #0
 800a08c:	1c21      	adds	r1, r4, #0
 800a08e:	f7f9 fb71 	bl	8003774 <__aeabi_uidiv>
 800a092:	42b0      	cmp	r0, r6
 800a094:	d2f8      	bcs.n	800a088 <ui2a+0x18>
		d*=base;		
	while (d!=0) {
 800a096:	2c00      	cmp	r4, #0
 800a098:	d029      	beq.n	800a0ee <ui2a+0x7e>
 800a09a:	2300      	movs	r3, #0
 800a09c:	4698      	mov	r8, r3
		int dgt = num / d;
 800a09e:	1c21      	adds	r1, r4, #0
 800a0a0:	1c28      	adds	r0, r5, #0
 800a0a2:	f7f9 fb67 	bl	8003774 <__aeabi_uidiv>
		num%= d;
 800a0a6:	1c21      	adds	r1, r4, #0
	int n=0;
	unsigned int d=1;
	while (num/d >= base)
		d*=base;		
	while (d!=0) {
		int dgt = num / d;
 800a0a8:	4682      	mov	sl, r0
		num%= d;
 800a0aa:	1c28      	adds	r0, r5, #0
 800a0ac:	f7f9 fbe8 	bl	8003880 <__aeabi_uidivmod>
		d/=base;
 800a0b0:	1c20      	adds	r0, r4, #0
	unsigned int d=1;
	while (num/d >= base)
		d*=base;		
	while (d!=0) {
		int dgt = num / d;
		num%= d;
 800a0b2:	1c0d      	adds	r5, r1, #0
		d/=base;
 800a0b4:	1c31      	adds	r1, r6, #0
 800a0b6:	f7f9 fb5d 	bl	8003774 <__aeabi_uidiv>
		if (n || dgt>0 || d==0) {
 800a0ba:	4643      	mov	r3, r8
	while (num/d >= base)
		d*=base;		
	while (d!=0) {
		int dgt = num / d;
		num%= d;
		d/=base;
 800a0bc:	1c04      	adds	r4, r0, #0
		if (n || dgt>0 || d==0) {
 800a0be:	2b00      	cmp	r3, #0
 800a0c0:	d102      	bne.n	800a0c8 <ui2a+0x58>
 800a0c2:	4653      	mov	r3, sl
 800a0c4:	2b00      	cmp	r3, #0
 800a0c6:	dd1a      	ble.n	800a0fe <ui2a+0x8e>
			*bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
 800a0c8:	4652      	mov	r2, sl
 800a0ca:	1c7b      	adds	r3, r7, #1
 800a0cc:	2030      	movs	r0, #48	; 0x30
 800a0ce:	2a09      	cmp	r2, #9
 800a0d0:	dd04      	ble.n	800a0dc <ui2a+0x6c>
 800a0d2:	464a      	mov	r2, r9
 800a0d4:	3007      	adds	r0, #7
 800a0d6:	2a00      	cmp	r2, #0
 800a0d8:	d100      	bne.n	800a0dc <ui2a+0x6c>
 800a0da:	3020      	adds	r0, #32
			++n;
 800a0dc:	2201      	movs	r2, #1
 800a0de:	4694      	mov	ip, r2
	while (d!=0) {
		int dgt = num / d;
		num%= d;
		d/=base;
		if (n || dgt>0 || d==0) {
			*bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
 800a0e0:	4450      	add	r0, sl
 800a0e2:	7038      	strb	r0, [r7, #0]
			++n;
 800a0e4:	44e0      	add	r8, ip
	{
	int n=0;
	unsigned int d=1;
	while (num/d >= base)
		d*=base;		
	while (d!=0) {
 800a0e6:	2c00      	cmp	r4, #0
 800a0e8:	d002      	beq.n	800a0f0 <ui2a+0x80>
 800a0ea:	1c1f      	adds	r7, r3, #0
 800a0ec:	e7d7      	b.n	800a09e <ui2a+0x2e>
 800a0ee:	1c3b      	adds	r3, r7, #0
		if (n || dgt>0 || d==0) {
			*bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
			++n;
			}
		}
	*bf=0;
 800a0f0:	2200      	movs	r2, #0
 800a0f2:	701a      	strb	r2, [r3, #0]
	}
 800a0f4:	bc1c      	pop	{r2, r3, r4}
 800a0f6:	4690      	mov	r8, r2
 800a0f8:	4699      	mov	r9, r3
 800a0fa:	46a2      	mov	sl, r4
 800a0fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		d*=base;		
	while (d!=0) {
		int dgt = num / d;
		num%= d;
		d/=base;
		if (n || dgt>0 || d==0) {
 800a0fe:	2800      	cmp	r0, #0
 800a100:	d002      	beq.n	800a108 <ui2a+0x98>
 800a102:	1c3b      	adds	r3, r7, #0
 800a104:	1c1f      	adds	r7, r3, #0
 800a106:	e7ca      	b.n	800a09e <ui2a+0x2e>
			*bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
 800a108:	4650      	mov	r0, sl
 800a10a:	3030      	adds	r0, #48	; 0x30
 800a10c:	1c7b      	adds	r3, r7, #1
 800a10e:	7038      	strb	r0, [r7, #0]
 800a110:	e7ee      	b.n	800a0f0 <ui2a+0x80>
 800a112:	46c0      	nop			; (mov r8, r8)

0800a114 <putchw>:
	*nump=num;
	return ch;
	}

static void putchw(void* putp,putcf putf,int n, char z, char* bf)
	{
 800a114:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a116:	4647      	mov	r7, r8
 800a118:	1c06      	adds	r6, r0, #0
 800a11a:	b480      	push	{r7}
	char fc=z? '0' : ' ';
 800a11c:	2430      	movs	r4, #48	; 0x30
	*nump=num;
	return ch;
	}

static void putchw(void* putp,putcf putf,int n, char z, char* bf)
	{
 800a11e:	1c0f      	adds	r7, r1, #0
	char fc=z? '0' : ' ';
 800a120:	2b00      	cmp	r3, #0
 800a122:	d100      	bne.n	800a126 <putchw+0x12>
 800a124:	3c10      	subs	r4, #16
	char ch;
	char* p=bf;
	while (*p++ && n > 0)
 800a126:	9b06      	ldr	r3, [sp, #24]
 800a128:	3301      	adds	r3, #1
 800a12a:	4698      	mov	r8, r3
 800a12c:	9b06      	ldr	r3, [sp, #24]
 800a12e:	7819      	ldrb	r1, [r3, #0]
 800a130:	2900      	cmp	r1, #0
 800a132:	d023      	beq.n	800a17c <putchw+0x68>
 800a134:	2a00      	cmp	r2, #0
 800a136:	dd16      	ble.n	800a166 <putchw+0x52>
 800a138:	4643      	mov	r3, r8
 800a13a:	e002      	b.n	800a142 <putchw+0x2e>
 800a13c:	3301      	adds	r3, #1
 800a13e:	2a00      	cmp	r2, #0
 800a140:	d011      	beq.n	800a166 <putchw+0x52>
 800a142:	7818      	ldrb	r0, [r3, #0]
		n--;
 800a144:	3a01      	subs	r2, #1
static void putchw(void* putp,putcf putf,int n, char z, char* bf)
	{
	char fc=z? '0' : ' ';
	char ch;
	char* p=bf;
	while (*p++ && n > 0)
 800a146:	2800      	cmp	r0, #0
 800a148:	d1f8      	bne.n	800a13c <putchw+0x28>
		n--;
	while (n-- > 0) 
 800a14a:	1e55      	subs	r5, r2, #1
 800a14c:	2a00      	cmp	r2, #0
 800a14e:	d00a      	beq.n	800a166 <putchw+0x52>
		putf(putp,fc);
 800a150:	1c30      	adds	r0, r6, #0
 800a152:	1c21      	adds	r1, r4, #0
	char fc=z? '0' : ' ';
	char ch;
	char* p=bf;
	while (*p++ && n > 0)
		n--;
	while (n-- > 0) 
 800a154:	3d01      	subs	r5, #1
		putf(putp,fc);
 800a156:	47b8      	blx	r7
 800a158:	1c6b      	adds	r3, r5, #1
	char fc=z? '0' : ' ';
	char ch;
	char* p=bf;
	while (*p++ && n > 0)
		n--;
	while (n-- > 0) 
 800a15a:	2b00      	cmp	r3, #0
 800a15c:	dcf8      	bgt.n	800a150 <putchw+0x3c>
 800a15e:	9b06      	ldr	r3, [sp, #24]
 800a160:	7819      	ldrb	r1, [r3, #0]
		putf(putp,fc);
	while ((ch= *bf++))
 800a162:	2900      	cmp	r1, #0
 800a164:	d007      	beq.n	800a176 <putchw+0x62>
 800a166:	4644      	mov	r4, r8
		putf(putp,ch);
 800a168:	1c30      	adds	r0, r6, #0
 800a16a:	3401      	adds	r4, #1
 800a16c:	47b8      	blx	r7
 800a16e:	1e63      	subs	r3, r4, #1
	char* p=bf;
	while (*p++ && n > 0)
		n--;
	while (n-- > 0) 
		putf(putp,fc);
	while ((ch= *bf++))
 800a170:	7819      	ldrb	r1, [r3, #0]
 800a172:	2900      	cmp	r1, #0
 800a174:	d1f8      	bne.n	800a168 <putchw+0x54>
		putf(putp,ch);
	}
 800a176:	bc04      	pop	{r2}
 800a178:	4690      	mov	r8, r2
 800a17a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	char fc=z? '0' : ' ';
	char ch;
	char* p=bf;
	while (*p++ && n > 0)
		n--;
	while (n-- > 0) 
 800a17c:	1e55      	subs	r5, r2, #1
 800a17e:	2a00      	cmp	r2, #0
 800a180:	dce6      	bgt.n	800a150 <putchw+0x3c>
 800a182:	e7f8      	b.n	800a176 <putchw+0x62>

0800a184 <putcp>:
	va_end(va);
	}

static void putcp(void* p,char c)
	{
	*(*((char**)p))++ = c;
 800a184:	6803      	ldr	r3, [r0, #0]
 800a186:	1c5a      	adds	r2, r3, #1
 800a188:	6002      	str	r2, [r0, #0]
 800a18a:	7019      	strb	r1, [r3, #0]
	}
 800a18c:	4770      	bx	lr
 800a18e:	46c0      	nop			; (mov r8, r8)

0800a190 <tfp_format>:
	while ((ch= *bf++))
		putf(putp,ch);
	}

void tfp_format(void* putp,putcf putf,char *fmt, va_list va)
	{
 800a190:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a192:	4656      	mov	r6, sl
 800a194:	4644      	mov	r4, r8
 800a196:	465f      	mov	r7, fp
 800a198:	464d      	mov	r5, r9
 800a19a:	b4f0      	push	{r4, r5, r6, r7}
 800a19c:	1c1c      	adds	r4, r3, #0

static void i2a (int num, char * bf)
	{
	if (num<0) {
		num=-num;
		*bf++ = '-';
 800a19e:	232d      	movs	r3, #45	; 0x2d
	while ((ch= *bf++))
		putf(putp,ch);
	}

void tfp_format(void* putp,putcf putf,char *fmt, va_list va)
	{
 800a1a0:	1c06      	adds	r6, r0, #0
 800a1a2:	468a      	mov	sl, r1
 800a1a4:	1c17      	adds	r7, r2, #0

static void i2a (int num, char * bf)
	{
	if (num<0) {
		num=-num;
		*bf++ = '-';
 800a1a6:	4698      	mov	r8, r3
	while ((ch= *bf++))
		putf(putp,ch);
	}

void tfp_format(void* putp,putcf putf,char *fmt, va_list va)
	{
 800a1a8:	b087      	sub	sp, #28
	char bf[12];
    
	char ch;


	while ((ch=*(fmt++))) {
 800a1aa:	7839      	ldrb	r1, [r7, #0]
 800a1ac:	2900      	cmp	r1, #0
 800a1ae:	d007      	beq.n	800a1c0 <tfp_format+0x30>
		if (ch!='%') 
 800a1b0:	2925      	cmp	r1, #37	; 0x25
 800a1b2:	d00c      	beq.n	800a1ce <tfp_format+0x3e>
	char bf[12];
    
	char ch;


	while ((ch=*(fmt++))) {
 800a1b4:	3701      	adds	r7, #1
		if (ch!='%') 
			putf(putp,ch);
 800a1b6:	1c30      	adds	r0, r6, #0
 800a1b8:	47d0      	blx	sl
	char bf[12];
    
	char ch;


	while ((ch=*(fmt++))) {
 800a1ba:	7839      	ldrb	r1, [r7, #0]
 800a1bc:	2900      	cmp	r1, #0
 800a1be:	d1f7      	bne.n	800a1b0 <tfp_format+0x20>
					break;
				}
			}
		}
	abort:;
	}
 800a1c0:	b007      	add	sp, #28
 800a1c2:	bc3c      	pop	{r2, r3, r4, r5}
 800a1c4:	4690      	mov	r8, r2
 800a1c6:	4699      	mov	r9, r3
 800a1c8:	46a2      	mov	sl, r4
 800a1ca:	46ab      	mov	fp, r5
 800a1cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
			char lz=0;
#ifdef 	PRINTF_LONG_SUPPORT
			char lng=0;
#endif
			int w=0;
			ch=*(fmt++);
 800a1ce:	787a      	ldrb	r2, [r7, #1]
			if (ch=='0') {
 800a1d0:	2a30      	cmp	r2, #48	; 0x30
 800a1d2:	d04b      	beq.n	800a26c <tfp_format+0xdc>

	while ((ch=*(fmt++))) {
		if (ch!='%') 
			putf(putp,ch);
		else {
			char lz=0;
 800a1d4:	2300      	movs	r3, #0
 800a1d6:	4699      	mov	r9, r3
#ifdef 	PRINTF_LONG_SUPPORT
			char lng=0;
#endif
			int w=0;
			ch=*(fmt++);
 800a1d8:	3702      	adds	r7, #2
			if (ch=='0') {
				ch=*(fmt++);
				lz=1;
				}
			if (ch>='0' && ch<='9') {
 800a1da:	1c13      	adds	r3, r2, #0
 800a1dc:	3b30      	subs	r3, #48	; 0x30
 800a1de:	b2d9      	uxtb	r1, r3
		else {
			char lz=0;
#ifdef 	PRINTF_LONG_SUPPORT
			char lng=0;
#endif
			int w=0;
 800a1e0:	2500      	movs	r5, #0
			ch=*(fmt++);
			if (ch=='0') {
				ch=*(fmt++);
				lz=1;
				}
			if (ch>='0' && ch<='9') {
 800a1e2:	2909      	cmp	r1, #9
 800a1e4:	d921      	bls.n	800a22a <tfp_format+0x9a>
			if (ch=='l') {
				ch=*(fmt++);
				lng=1;
			}
#endif
			switch (ch) {
 800a1e6:	2a63      	cmp	r2, #99	; 0x63
 800a1e8:	d03a      	beq.n	800a260 <tfp_format+0xd0>
 800a1ea:	2a63      	cmp	r2, #99	; 0x63
 800a1ec:	d916      	bls.n	800a21c <tfp_format+0x8c>
 800a1ee:	2a73      	cmp	r2, #115	; 0x73
 800a1f0:	d04c      	beq.n	800a28c <tfp_format+0xfc>
 800a1f2:	d940      	bls.n	800a276 <tfp_format+0xe6>
 800a1f4:	2a75      	cmp	r2, #117	; 0x75
 800a1f6:	d155      	bne.n	800a2a4 <tfp_format+0x114>
#ifdef 	PRINTF_LONG_SUPPORT
					if (lng)
						uli2a(va_arg(va, unsigned long int),10,0,bf);
					else
#endif
					ui2a(va_arg(va, unsigned int),10,0,bf);
 800a1f8:	210a      	movs	r1, #10
 800a1fa:	2200      	movs	r2, #0
 800a1fc:	1d23      	adds	r3, r4, #4
 800a1fe:	6820      	ldr	r0, [r4, #0]
 800a200:	469b      	mov	fp, r3
 800a202:	ab03      	add	r3, sp, #12
	{
	if (num<0) {
		num=-num;
		*bf++ = '-';
		}
	ui2a(num,10,0,bf);
 800a204:	f7ff ff34 	bl	800a070 <ui2a>
					if (lng)
						li2a(va_arg(va, unsigned long int),bf);
					else
#endif
					i2a(va_arg(va, int),bf);
					putchw(putp,putf,w,lz,bf);
 800a208:	ab03      	add	r3, sp, #12
 800a20a:	9300      	str	r3, [sp, #0]
 800a20c:	1c30      	adds	r0, r6, #0
 800a20e:	4651      	mov	r1, sl
 800a210:	1c2a      	adds	r2, r5, #0
 800a212:	464b      	mov	r3, r9
 800a214:	f7ff ff7e 	bl	800a114 <putchw>
#ifdef 	PRINTF_LONG_SUPPORT
					if (lng)
						li2a(va_arg(va, unsigned long int),bf);
					else
#endif
					i2a(va_arg(va, int),bf);
 800a218:	465c      	mov	r4, fp
					putchw(putp,putf,w,lz,bf);
					break;
 800a21a:	e7c6      	b.n	800a1aa <tfp_format+0x1a>
			if (ch=='l') {
				ch=*(fmt++);
				lng=1;
			}
#endif
			switch (ch) {
 800a21c:	2a25      	cmp	r2, #37	; 0x25
 800a21e:	d04d      	beq.n	800a2bc <tfp_format+0x12c>
 800a220:	2a58      	cmp	r2, #88	; 0x58
 800a222:	d042      	beq.n	800a2aa <tfp_format+0x11a>
 800a224:	2a00      	cmp	r2, #0
 800a226:	d0cb      	beq.n	800a1c0 <tfp_format+0x30>
 800a228:	e7bf      	b.n	800a1aa <tfp_format+0x1a>
 800a22a:	1c39      	adds	r1, r7, #0
 800a22c:	e00a      	b.n	800a244 <tfp_format+0xb4>
	if (ch>='0' && ch<='9') 
		return ch-'0';
	else if (ch>='a' && ch<='f')
		return ch-'a'+10;
	else if (ch>='A' && ch<='F')
		return ch-'A'+10;
 800a22e:	330a      	adds	r3, #10
	{
	char* p= *src;
	int num=0;
	int digit;
	while ((digit=a2d(ch))>=0) {
		if (digit>base) break;
 800a230:	2b0a      	cmp	r3, #10
 800a232:	dcd8      	bgt.n	800a1e6 <tfp_format+0x56>
		num=num*base+digit;
 800a234:	00aa      	lsls	r2, r5, #2
 800a236:	1952      	adds	r2, r2, r5
 800a238:	0052      	lsls	r2, r2, #1
 800a23a:	189d      	adds	r5, r3, r2
		ch=*p++;
 800a23c:	780a      	ldrb	r2, [r1, #0]
 800a23e:	3101      	adds	r1, #1
 800a240:	1c13      	adds	r3, r2, #0
 800a242:	3b30      	subs	r3, #48	; 0x30
	ui2a(num,10,0,bf);
	}

static int a2d(char ch)
	{
	if (ch>='0' && ch<='9') 
 800a244:	b2d8      	uxtb	r0, r3
 800a246:	1c0f      	adds	r7, r1, #0
 800a248:	2809      	cmp	r0, #9
 800a24a:	d9f3      	bls.n	800a234 <tfp_format+0xa4>
		return ch-'0';
	else if (ch>='a' && ch<='f')
 800a24c:	1c13      	adds	r3, r2, #0
 800a24e:	3b61      	subs	r3, #97	; 0x61
 800a250:	2b05      	cmp	r3, #5
 800a252:	d9ec      	bls.n	800a22e <tfp_format+0x9e>
		return ch-'a'+10;
	else if (ch>='A' && ch<='F')
 800a254:	1c13      	adds	r3, r2, #0
 800a256:	3b41      	subs	r3, #65	; 0x41
 800a258:	2b05      	cmp	r3, #5
 800a25a:	d9e8      	bls.n	800a22e <tfp_format+0x9e>
			if (ch=='l') {
				ch=*(fmt++);
				lng=1;
			}
#endif
			switch (ch) {
 800a25c:	2a63      	cmp	r2, #99	; 0x63
 800a25e:	d1c4      	bne.n	800a1ea <tfp_format+0x5a>
#endif
					ui2a(va_arg(va, unsigned int),16,(ch=='X'),bf);
					putchw(putp,putf,w,lz,bf);
					break;
				case 'c' : 
					putf(putp,(char)(va_arg(va, int)));
 800a260:	7821      	ldrb	r1, [r4, #0]
 800a262:	1d25      	adds	r5, r4, #4
 800a264:	1c30      	adds	r0, r6, #0
 800a266:	47d0      	blx	sl
 800a268:	1c2c      	adds	r4, r5, #0
					break;
 800a26a:	e79e      	b.n	800a1aa <tfp_format+0x1a>
#endif
			int w=0;
			ch=*(fmt++);
			if (ch=='0') {
				ch=*(fmt++);
				lz=1;
 800a26c:	2301      	movs	r3, #1
			char lng=0;
#endif
			int w=0;
			ch=*(fmt++);
			if (ch=='0') {
				ch=*(fmt++);
 800a26e:	78ba      	ldrb	r2, [r7, #2]
				lz=1;
 800a270:	4699      	mov	r9, r3
			char lng=0;
#endif
			int w=0;
			ch=*(fmt++);
			if (ch=='0') {
				ch=*(fmt++);
 800a272:	3703      	adds	r7, #3
 800a274:	e7b1      	b.n	800a1da <tfp_format+0x4a>
			if (ch=='l') {
				ch=*(fmt++);
				lng=1;
			}
#endif
			switch (ch) {
 800a276:	2a64      	cmp	r2, #100	; 0x64
 800a278:	d197      	bne.n	800a1aa <tfp_format+0x1a>
#ifdef 	PRINTF_LONG_SUPPORT
					if (lng)
						li2a(va_arg(va, unsigned long int),bf);
					else
#endif
					i2a(va_arg(va, int),bf);
 800a27a:	6820      	ldr	r0, [r4, #0]
 800a27c:	1d23      	adds	r3, r4, #4
 800a27e:	469b      	mov	fp, r3
	*bf=0;
	}

static void i2a (int num, char * bf)
	{
	if (num<0) {
 800a280:	ab03      	add	r3, sp, #12
 800a282:	2800      	cmp	r0, #0
 800a284:	db1e      	blt.n	800a2c4 <tfp_format+0x134>
		num=-num;
		*bf++ = '-';
		}
	ui2a(num,10,0,bf);
 800a286:	210a      	movs	r1, #10
 800a288:	2200      	movs	r2, #0
 800a28a:	e7bb      	b.n	800a204 <tfp_format+0x74>
					break;
				case 'c' : 
					putf(putp,(char)(va_arg(va, int)));
					break;
				case 's' : 
					putchw(putp,putf,w,0,va_arg(va, char*));
 800a28c:	1d23      	adds	r3, r4, #4
 800a28e:	4699      	mov	r9, r3
 800a290:	6823      	ldr	r3, [r4, #0]
 800a292:	1c30      	adds	r0, r6, #0
 800a294:	9300      	str	r3, [sp, #0]
 800a296:	4651      	mov	r1, sl
 800a298:	1c2a      	adds	r2, r5, #0
 800a29a:	2300      	movs	r3, #0
 800a29c:	f7ff ff3a 	bl	800a114 <putchw>
 800a2a0:	464c      	mov	r4, r9
					break;
 800a2a2:	e782      	b.n	800a1aa <tfp_format+0x1a>
			if (ch=='l') {
				ch=*(fmt++);
				lng=1;
			}
#endif
			switch (ch) {
 800a2a4:	2a78      	cmp	r2, #120	; 0x78
 800a2a6:	d000      	beq.n	800a2aa <tfp_format+0x11a>
 800a2a8:	e77f      	b.n	800a1aa <tfp_format+0x1a>
#ifdef 	PRINTF_LONG_SUPPORT
					if (lng)
						uli2a(va_arg(va, unsigned long int),16,(ch=='X'),bf);
					else
#endif
					ui2a(va_arg(va, unsigned int),16,(ch=='X'),bf);
 800a2aa:	1d23      	adds	r3, r4, #4
 800a2ac:	3a58      	subs	r2, #88	; 0x58
 800a2ae:	469b      	mov	fp, r3
 800a2b0:	6820      	ldr	r0, [r4, #0]
 800a2b2:	4253      	negs	r3, r2
 800a2b4:	415a      	adcs	r2, r3
 800a2b6:	2110      	movs	r1, #16
 800a2b8:	ab03      	add	r3, sp, #12
 800a2ba:	e7a3      	b.n	800a204 <tfp_format+0x74>
					break;
				case 's' : 
					putchw(putp,putf,w,0,va_arg(va, char*));
					break;
				case '%' :
					putf(putp,ch);
 800a2bc:	1c30      	adds	r0, r6, #0
 800a2be:	2125      	movs	r1, #37	; 0x25
 800a2c0:	47d0      	blx	sl
					break;
 800a2c2:	e772      	b.n	800a1aa <tfp_format+0x1a>

static void i2a (int num, char * bf)
	{
	if (num<0) {
		num=-num;
		*bf++ = '-';
 800a2c4:	466b      	mov	r3, sp
 800a2c6:	4642      	mov	r2, r8
 800a2c8:	731a      	strb	r2, [r3, #12]
 800a2ca:	230d      	movs	r3, #13
	}

static void i2a (int num, char * bf)
	{
	if (num<0) {
		num=-num;
 800a2cc:	4240      	negs	r0, r0
		*bf++ = '-';
 800a2ce:	446b      	add	r3, sp
		}
	ui2a(num,10,0,bf);
 800a2d0:	210a      	movs	r1, #10
 800a2d2:	2200      	movs	r2, #0
 800a2d4:	e796      	b.n	800a204 <tfp_format+0x74>
 800a2d6:	46c0      	nop			; (mov r8, r8)

0800a2d8 <init_printf>:
	}


void init_printf(void* putp,void (*putf) (void*,char))
	{
	stdout_putf=putf;
 800a2d8:	4b01      	ldr	r3, [pc, #4]	; (800a2e0 <init_printf+0x8>)
 800a2da:	6019      	str	r1, [r3, #0]
	stdout_putp=putp;
 800a2dc:	6058      	str	r0, [r3, #4]
	}
 800a2de:	4770      	bx	lr
 800a2e0:	20001920 	.word	0x20001920

0800a2e4 <tfp_printf>:

void tfp_printf(char *fmt, ...)
	{
 800a2e4:	b40f      	push	{r0, r1, r2, r3}
 800a2e6:	b500      	push	{lr}
 800a2e8:	b083      	sub	sp, #12
 800a2ea:	ab04      	add	r3, sp, #16
	va_list va;
	va_start(va,fmt);
	tfp_format(stdout_putp,stdout_putf,fmt,va);
 800a2ec:	4905      	ldr	r1, [pc, #20]	; (800a304 <tfp_printf+0x20>)
	stdout_putf=putf;
	stdout_putp=putp;
	}

void tfp_printf(char *fmt, ...)
	{
 800a2ee:	cb04      	ldmia	r3!, {r2}
	va_list va;
	va_start(va,fmt);
	tfp_format(stdout_putp,stdout_putf,fmt,va);
 800a2f0:	6848      	ldr	r0, [r1, #4]
 800a2f2:	6809      	ldr	r1, [r1, #0]
	}

void tfp_printf(char *fmt, ...)
	{
	va_list va;
	va_start(va,fmt);
 800a2f4:	9301      	str	r3, [sp, #4]
	tfp_format(stdout_putp,stdout_putf,fmt,va);
 800a2f6:	f7ff ff4b 	bl	800a190 <tfp_format>
	va_end(va);
	}
 800a2fa:	b003      	add	sp, #12
 800a2fc:	bc08      	pop	{r3}
 800a2fe:	b004      	add	sp, #16
 800a300:	4718      	bx	r3
 800a302:	46c0      	nop			; (mov r8, r8)
 800a304:	20001920 	.word	0x20001920

0800a308 <tfp_sprintf>:
	}



void tfp_sprintf(char* s,char *fmt, ...)
	{
 800a308:	b40e      	push	{r1, r2, r3}
 800a30a:	b500      	push	{lr}
 800a30c:	b084      	sub	sp, #16
 800a30e:	ab05      	add	r3, sp, #20
 800a310:	cb04      	ldmia	r3!, {r2}
 800a312:	9001      	str	r0, [sp, #4]
	va_list va;
	va_start(va,fmt);
	tfp_format(&s,putcp,fmt,va);
 800a314:	4905      	ldr	r1, [pc, #20]	; (800a32c <tfp_sprintf+0x24>)
 800a316:	a801      	add	r0, sp, #4


void tfp_sprintf(char* s,char *fmt, ...)
	{
	va_list va;
	va_start(va,fmt);
 800a318:	9303      	str	r3, [sp, #12]
	tfp_format(&s,putcp,fmt,va);
 800a31a:	f7ff ff39 	bl	800a190 <tfp_format>
	va_end(va);
	}

static void putcp(void* p,char c)
	{
	*(*((char**)p))++ = c;
 800a31e:	2300      	movs	r3, #0
 800a320:	9a01      	ldr	r2, [sp, #4]
 800a322:	7013      	strb	r3, [r2, #0]
	va_list va;
	va_start(va,fmt);
	tfp_format(&s,putcp,fmt,va);
	putcp(&s,0);
	va_end(va);
	}
 800a324:	b004      	add	sp, #16
 800a326:	bc08      	pop	{r3}
 800a328:	b003      	add	sp, #12
 800a32a:	4718      	bx	r3
 800a32c:	0800a185 	.word	0x0800a185

0800a330 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 800a330:	4812      	ldr	r0, [pc, #72]	; (800a37c <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 800a332:	4685      	mov	sp, r0

/*Check if boot space corresponds to test memory*/
 
    LDR R0,=0x00000004
 800a334:	4812      	ldr	r0, [pc, #72]	; (800a380 <LoopForever+0x6>)
    LDR R1, [R0]
 800a336:	6801      	ldr	r1, [r0, #0]
    LSRS R1, R1, #24
 800a338:	0e09      	lsrs	r1, r1, #24
    LDR R2,=0x1F
 800a33a:	4a12      	ldr	r2, [pc, #72]	; (800a384 <LoopForever+0xa>)
    CMP R1, R2
 800a33c:	4291      	cmp	r1, r2
    BNE ApplicationStart
 800a33e:	d105      	bne.n	800a34c <ApplicationStart>

 /*SYSCFG clock enable*/

    LDR R0,=0x40021018
 800a340:	4811      	ldr	r0, [pc, #68]	; (800a388 <LoopForever+0xe>)
    LDR R1,=0x00000001
 800a342:	4912      	ldr	r1, [pc, #72]	; (800a38c <LoopForever+0x12>)
    STR R1, [R0]
 800a344:	6001      	str	r1, [r0, #0]

/*Set CFGR1 register with flash memory remap at address 0*/
    LDR R0,=0x40010000
 800a346:	4812      	ldr	r0, [pc, #72]	; (800a390 <LoopForever+0x16>)
    LDR R1,=0x00000000
 800a348:	4912      	ldr	r1, [pc, #72]	; (800a394 <LoopForever+0x1a>)
    STR R1, [R0]
 800a34a:	6001      	str	r1, [r0, #0]

0800a34c <ApplicationStart>:

ApplicationStart:
/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 800a34c:	2100      	movs	r1, #0
  b LoopCopyDataInit
 800a34e:	e003      	b.n	800a358 <LoopCopyDataInit>

0800a350 <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 800a350:	4b11      	ldr	r3, [pc, #68]	; (800a398 <LoopForever+0x1e>)
  ldr r3, [r3, r1]
 800a352:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 800a354:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 800a356:	3104      	adds	r1, #4

0800a358 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 800a358:	4810      	ldr	r0, [pc, #64]	; (800a39c <LoopForever+0x22>)
  ldr r3, =_edata
 800a35a:	4b11      	ldr	r3, [pc, #68]	; (800a3a0 <LoopForever+0x26>)
  adds r2, r0, r1
 800a35c:	1842      	adds	r2, r0, r1
  cmp r2, r3
 800a35e:	429a      	cmp	r2, r3
  bcc CopyDataInit
 800a360:	d3f6      	bcc.n	800a350 <CopyDataInit>
  ldr r2, =_sbss
 800a362:	4a10      	ldr	r2, [pc, #64]	; (800a3a4 <LoopForever+0x2a>)
  b LoopFillZerobss
 800a364:	e002      	b.n	800a36c <LoopFillZerobss>

0800a366 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 800a366:	2300      	movs	r3, #0
  str  r3, [r2]
 800a368:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800a36a:	3204      	adds	r2, #4

0800a36c <LoopFillZerobss>:


LoopFillZerobss:
  ldr r3, = _ebss
 800a36c:	4b0e      	ldr	r3, [pc, #56]	; (800a3a8 <LoopForever+0x2e>)
  cmp r2, r3
 800a36e:	429a      	cmp	r2, r3
  bcc FillZerobss
 800a370:	d3f9      	bcc.n	800a366 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 800a372:	f7f5 feb1 	bl	80000d8 <SystemInit>
    
/* Call the application's entry point.*/
  bl main
 800a376:	f000 f81b 	bl	800a3b0 <main>

0800a37a <LoopForever>:
  
LoopForever:
    b LoopForever
 800a37a:	e7fe      	b.n	800a37a <LoopForever>

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 800a37c:	20001fff 	.word	0x20001fff
  mov   sp, r0          /* set stack pointer */

/*Check if boot space corresponds to test memory*/
 
    LDR R0,=0x00000004
 800a380:	00000004 	.word	0x00000004
    LDR R1, [R0]
    LSRS R1, R1, #24
    LDR R2,=0x1F
 800a384:	0000001f 	.word	0x0000001f
    CMP R1, R2
    BNE ApplicationStart

 /*SYSCFG clock enable*/

    LDR R0,=0x40021018
 800a388:	40021018 	.word	0x40021018
    LDR R1,=0x00000001
 800a38c:	00000001 	.word	0x00000001
    STR R1, [R0]

/*Set CFGR1 register with flash memory remap at address 0*/
    LDR R0,=0x40010000
 800a390:	40010000 	.word	0x40010000
    LDR R1,=0x00000000
 800a394:	00000000 	.word	0x00000000
/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
  b LoopCopyDataInit

CopyDataInit:
  ldr r3, =_sidata
 800a398:	0800ac7c 	.word	0x0800ac7c
  ldr r3, [r3, r1]
  str r3, [r0, r1]
  adds r1, r1, #4

LoopCopyDataInit:
  ldr r0, =_sdata
 800a39c:	20000000 	.word	0x20000000
  ldr r3, =_edata
 800a3a0:	20000054 	.word	0x20000054
  adds r2, r0, r1
  cmp r2, r3
  bcc CopyDataInit
  ldr r2, =_sbss
 800a3a4:	20000054 	.word	0x20000054
  str  r3, [r2]
  adds r2, r2, #4


LoopFillZerobss:
  ldr r3, = _ebss
 800a3a8:	20001928 	.word	0x20001928

0800a3ac <ADC1_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 800a3ac:	e7fe      	b.n	800a3ac <ADC1_IRQHandler>
	...

0800a3b0 <main>:

//====================================================================================================
// Main Function
//====================================================================================================
int main(void)
{
 800a3b0:	b570      	push	{r4, r5, r6, lr}
	Flowmeter_ForceGetFlow(0); // SOMENTE PARA DEBUG

	//-----------------------------------------------------------------------------
	// Buzzer Task
	//-----------------------------------------------------------------------------
    xTaskCreate(vBuzzerTask,
 800a3b2:	2400      	movs	r4, #0
				xHandle_BuzzerTask);

	//-----------------------------------------------------------------------------
	// User Interface Task (Display - LED - Flowmeter)
	//-----------------------------------------------------------------------------
    xTaskCreate(v10msTask,
 800a3b4:	2601      	movs	r6, #1

//====================================================================================================
// Main Function
//====================================================================================================
int main(void)
{
 800a3b6:	b084      	sub	sp, #16
#ifdef _DEBUG_STR_
	sprintf_lib(str_debug, "Shower Started - version %d.%d.%d\r\n", VERSION_MAJOR, VERSION_MINOR, VERSION_BUILD); // These defines are in makefile
	Debug_Write(str_debug, strlen(str_debug));
#endif

	SystemInit();  			// CMSIS SystemInit clocks and PLLs
 800a3b8:	f7f5 fe8e 	bl	80000d8 <SystemInit>
	User_ResetShowerVariables(); // ShowerConfiguration
 800a3bc:	f7f6 fb96 	bl	8000aec <User_ResetShowerVariables>

	RTCC_Init();
 800a3c0:	f7f7 feda 	bl	8002178 <RTCC_Init>
	Bluetooth_Init();
 800a3c4:	f7f7 fd94 	bl	8001ef0 <Bluetooth_Init>
	NTC_Init();
 800a3c8:	f7f8 fb52 	bl	8002a70 <NTC_Init>
	Voltmeter_Init();
 800a3cc:	f7f8 fb44 	bl	8002a58 <Voltmeter_Init>
	TRIAC_Init();
 800a3d0:	f7f7 fb34 	bl	8001a3c <TRIAC_Init>
	ShowerController_Init();
 800a3d4:	f7f9 f9b0 	bl	8003738 <ShowerController_Init>

	FLASH_Unlock(); // Unlock the Flash Program Erase controller
 800a3d8:	f7fb f9e2 	bl	80057a0 <FLASH_Unlock>
	EE_Init();		// Initializes Emulated EEPROM
 800a3dc:	f7f7 ffae 	bl	800233c <EE_Init>

	Flowmeter_ForceGetFlow(0); // SOMENTE PARA DEBUG
 800a3e0:	2000      	movs	r0, #0
 800a3e2:	f7f7 fb09 	bl	80019f8 <Flowmeter_ForceGetFlow>

	//-----------------------------------------------------------------------------
	// Buzzer Task
	//-----------------------------------------------------------------------------
    xTaskCreate(vBuzzerTask,
 800a3e6:	4b35      	ldr	r3, [pc, #212]	; (800a4bc <main+0x10c>)
 800a3e8:	9400      	str	r4, [sp, #0]
 800a3ea:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800a3ec:	4934      	ldr	r1, [pc, #208]	; (800a4c0 <main+0x110>)
 800a3ee:	9301      	str	r3, [sp, #4]
 800a3f0:	9402      	str	r4, [sp, #8]
 800a3f2:	9403      	str	r4, [sp, #12]
 800a3f4:	223c      	movs	r2, #60	; 0x3c
 800a3f6:	2300      	movs	r3, #0
 800a3f8:	4832      	ldr	r0, [pc, #200]	; (800a4c4 <main+0x114>)
 800a3fa:	f7fe fd5d 	bl	8008eb8 <xTaskGenericCreate>
				xHandle_BuzzerTask);

	//-----------------------------------------------------------------------------
	// User Interface Task (Display - LED - Flowmeter)
	//-----------------------------------------------------------------------------
    xTaskCreate(v10msTask,
 800a3fe:	4d32      	ldr	r5, [pc, #200]	; (800a4c8 <main+0x118>)
 800a400:	9600      	str	r6, [sp, #0]
 800a402:	682b      	ldr	r3, [r5, #0]
 800a404:	4931      	ldr	r1, [pc, #196]	; (800a4cc <main+0x11c>)
 800a406:	9301      	str	r3, [sp, #4]
 800a408:	9402      	str	r4, [sp, #8]
 800a40a:	9403      	str	r4, [sp, #12]
 800a40c:	223c      	movs	r2, #60	; 0x3c
 800a40e:	2300      	movs	r3, #0
 800a410:	482f      	ldr	r0, [pc, #188]	; (800a4d0 <main+0x120>)
 800a412:	f7fe fd51 	bl	8008eb8 <xTaskGenericCreate>
				xHandle_10msTask);

	//-----------------------------------------------------------------------------
	// Screen Task
	//-----------------------------------------------------------------------------
    xTaskCreate(vScreenTask,
 800a416:	9400      	str	r4, [sp, #0]
 800a418:	686b      	ldr	r3, [r5, #4]
 800a41a:	492e      	ldr	r1, [pc, #184]	; (800a4d4 <main+0x124>)
 800a41c:	9301      	str	r3, [sp, #4]
 800a41e:	9402      	str	r4, [sp, #8]
 800a420:	9403      	str	r4, [sp, #12]
 800a422:	2278      	movs	r2, #120	; 0x78
 800a424:	2300      	movs	r3, #0
 800a426:	482c      	ldr	r0, [pc, #176]	; (800a4d8 <main+0x128>)
 800a428:	f7fe fd46 	bl	8008eb8 <xTaskGenericCreate>

	//-----------------------------------------------------------------------------
	// Debug Task
	//-----------------------------------------------------------------------------
#ifdef _DEBUG_
	xTaskCreate(vDebugTask,
 800a42c:	9400      	str	r4, [sp, #0]
 800a42e:	68ab      	ldr	r3, [r5, #8]
 800a430:	492a      	ldr	r1, [pc, #168]	; (800a4dc <main+0x12c>)
 800a432:	9301      	str	r3, [sp, #4]
 800a434:	9402      	str	r4, [sp, #8]
 800a436:	9403      	str	r4, [sp, #12]
 800a438:	22b4      	movs	r2, #180	; 0xb4
 800a43a:	2300      	movs	r3, #0
 800a43c:	4828      	ldr	r0, [pc, #160]	; (800a4e0 <main+0x130>)
 800a43e:	f7fe fd3b 	bl	8008eb8 <xTaskGenericCreate>
#endif // _DEBUG_

	//-----------------------------------------------------------------------------
	// PID Task
	//-----------------------------------------------------------------------------
	xTaskCreate(vPIDTask,
 800a442:	9400      	str	r4, [sp, #0]
 800a444:	68eb      	ldr	r3, [r5, #12]
 800a446:	4927      	ldr	r1, [pc, #156]	; (800a4e4 <main+0x134>)
 800a448:	9301      	str	r3, [sp, #4]
 800a44a:	9402      	str	r4, [sp, #8]
 800a44c:	9403      	str	r4, [sp, #12]
 800a44e:	223c      	movs	r2, #60	; 0x3c
 800a450:	2300      	movs	r3, #0
 800a452:	4825      	ldr	r0, [pc, #148]	; (800a4e8 <main+0x138>)
 800a454:	f7fe fd30 	bl	8008eb8 <xTaskGenericCreate>
				xHandle_PIDTask);

	//-----------------------------------------------------------------------------
	// Triac Controller Task
	//-----------------------------------------------------------------------------
	xTaskCreate(vTriacControllerTask,
 800a458:	2302      	movs	r3, #2
 800a45a:	9300      	str	r3, [sp, #0]
 800a45c:	692b      	ldr	r3, [r5, #16]
 800a45e:	4923      	ldr	r1, [pc, #140]	; (800a4ec <main+0x13c>)
 800a460:	9301      	str	r3, [sp, #4]
 800a462:	9402      	str	r4, [sp, #8]
 800a464:	9403      	str	r4, [sp, #12]
 800a466:	2278      	movs	r2, #120	; 0x78
 800a468:	2300      	movs	r3, #0
 800a46a:	4821      	ldr	r0, [pc, #132]	; (800a4f0 <main+0x140>)
 800a46c:	f7fe fd24 	bl	8008eb8 <xTaskGenericCreate>

	//-----------------------------------------------------------------------------
	// Shower Logs Task
	//-----------------------------------------------------------------------------
#ifdef _LOGS_
	xTaskCreate(vShowerLogsTask,
 800a470:	9400      	str	r4, [sp, #0]
 800a472:	696b      	ldr	r3, [r5, #20]
 800a474:	491f      	ldr	r1, [pc, #124]	; (800a4f4 <main+0x144>)
 800a476:	9301      	str	r3, [sp, #4]
 800a478:	9402      	str	r4, [sp, #8]
 800a47a:	9403      	str	r4, [sp, #12]
 800a47c:	223c      	movs	r2, #60	; 0x3c
 800a47e:	2300      	movs	r3, #0
 800a480:	481d      	ldr	r0, [pc, #116]	; (800a4f8 <main+0x148>)
 800a482:	f7fe fd19 	bl	8008eb8 <xTaskGenericCreate>

	//-----------------------------------------------------------------------------
	// Shower Time Task
	//-----------------------------------------------------------------------------
#ifdef _SHOWERTIME_
	xTaskCreate(vShowerTimeTask,
 800a486:	9400      	str	r4, [sp, #0]
 800a488:	69ab      	ldr	r3, [r5, #24]
 800a48a:	491c      	ldr	r1, [pc, #112]	; (800a4fc <main+0x14c>)
 800a48c:	9301      	str	r3, [sp, #4]
 800a48e:	9402      	str	r4, [sp, #8]
 800a490:	9403      	str	r4, [sp, #12]
 800a492:	223c      	movs	r2, #60	; 0x3c
 800a494:	2300      	movs	r3, #0
 800a496:	481a      	ldr	r0, [pc, #104]	; (800a500 <main+0x150>)
 800a498:	f7fe fd0e 	bl	8008eb8 <xTaskGenericCreate>

	//-----------------------------------------------------------------------------
	// Shower Controller Task
	//-----------------------------------------------------------------------------
#ifdef _SHOWERCONTROL_
	xTaskCreate(vShowerControllerTask,
 800a49c:	9600      	str	r6, [sp, #0]
 800a49e:	69eb      	ldr	r3, [r5, #28]
 800a4a0:	4918      	ldr	r1, [pc, #96]	; (800a504 <main+0x154>)
 800a4a2:	9301      	str	r3, [sp, #4]
 800a4a4:	2278      	movs	r2, #120	; 0x78
 800a4a6:	2300      	movs	r3, #0
 800a4a8:	9402      	str	r4, [sp, #8]
 800a4aa:	9403      	str	r4, [sp, #12]
 800a4ac:	4816      	ldr	r0, [pc, #88]	; (800a508 <main+0x158>)
 800a4ae:	f7fe fd03 	bl	8008eb8 <xTaskGenericCreate>
#endif // _SHOWERCONTROL_

	//-----------------------------------------------------------------------------
	// Scheduler
	//-----------------------------------------------------------------------------
    vTaskStartScheduler();
 800a4b2:	f7fe ff3b 	bl	800932c <vTaskStartScheduler>

    return 0;
}
 800a4b6:	2000      	movs	r0, #0
 800a4b8:	b004      	add	sp, #16
 800a4ba:	bd70      	pop	{r4, r5, r6, pc}
 800a4bc:	20000054 	.word	0x20000054
 800a4c0:	0800aab0 	.word	0x0800aab0
 800a4c4:	08000619 	.word	0x08000619
 800a4c8:	200000d4 	.word	0x200000d4
 800a4cc:	0800aabc 	.word	0x0800aabc
 800a4d0:	080005c9 	.word	0x080005c9
 800a4d4:	0800aac8 	.word	0x0800aac8
 800a4d8:	0800056d 	.word	0x0800056d
 800a4dc:	0800aad4 	.word	0x0800aad4
 800a4e0:	08000501 	.word	0x08000501
 800a4e4:	0800aae0 	.word	0x0800aae0
 800a4e8:	080004f1 	.word	0x080004f1
 800a4ec:	0800aae8 	.word	0x0800aae8
 800a4f0:	080006dd 	.word	0x080006dd
 800a4f4:	0800aafc 	.word	0x0800aafc
 800a4f8:	08000325 	.word	0x08000325
 800a4fc:	0800ab0c 	.word	0x0800ab0c
 800a500:	08000245 	.word	0x08000245
 800a504:	0800ab1c 	.word	0x0800ab1c
 800a508:	0800023d 	.word	0x0800023d

0800a50c <strcpy>:
 800a50c:	1c03      	adds	r3, r0, #0
 800a50e:	780a      	ldrb	r2, [r1, #0]
 800a510:	3101      	adds	r1, #1
 800a512:	701a      	strb	r2, [r3, #0]
 800a514:	3301      	adds	r3, #1
 800a516:	2a00      	cmp	r2, #0
 800a518:	d1f9      	bne.n	800a50e <strcpy+0x2>
 800a51a:	4770      	bx	lr

0800a51c <strlen>:
 800a51c:	b510      	push	{r4, lr}
 800a51e:	0783      	lsls	r3, r0, #30
 800a520:	d027      	beq.n	800a572 <strlen+0x56>
 800a522:	7803      	ldrb	r3, [r0, #0]
 800a524:	2b00      	cmp	r3, #0
 800a526:	d026      	beq.n	800a576 <strlen+0x5a>
 800a528:	1c03      	adds	r3, r0, #0
 800a52a:	2103      	movs	r1, #3
 800a52c:	e002      	b.n	800a534 <strlen+0x18>
 800a52e:	781a      	ldrb	r2, [r3, #0]
 800a530:	2a00      	cmp	r2, #0
 800a532:	d01c      	beq.n	800a56e <strlen+0x52>
 800a534:	3301      	adds	r3, #1
 800a536:	420b      	tst	r3, r1
 800a538:	d1f9      	bne.n	800a52e <strlen+0x12>
 800a53a:	6819      	ldr	r1, [r3, #0]
 800a53c:	4a0f      	ldr	r2, [pc, #60]	; (800a57c <strlen+0x60>)
 800a53e:	4c10      	ldr	r4, [pc, #64]	; (800a580 <strlen+0x64>)
 800a540:	188a      	adds	r2, r1, r2
 800a542:	438a      	bics	r2, r1
 800a544:	4222      	tst	r2, r4
 800a546:	d10f      	bne.n	800a568 <strlen+0x4c>
 800a548:	3304      	adds	r3, #4
 800a54a:	6819      	ldr	r1, [r3, #0]
 800a54c:	4a0b      	ldr	r2, [pc, #44]	; (800a57c <strlen+0x60>)
 800a54e:	188a      	adds	r2, r1, r2
 800a550:	438a      	bics	r2, r1
 800a552:	4222      	tst	r2, r4
 800a554:	d108      	bne.n	800a568 <strlen+0x4c>
 800a556:	3304      	adds	r3, #4
 800a558:	6819      	ldr	r1, [r3, #0]
 800a55a:	4a08      	ldr	r2, [pc, #32]	; (800a57c <strlen+0x60>)
 800a55c:	188a      	adds	r2, r1, r2
 800a55e:	438a      	bics	r2, r1
 800a560:	4222      	tst	r2, r4
 800a562:	d0f1      	beq.n	800a548 <strlen+0x2c>
 800a564:	e000      	b.n	800a568 <strlen+0x4c>
 800a566:	3301      	adds	r3, #1
 800a568:	781a      	ldrb	r2, [r3, #0]
 800a56a:	2a00      	cmp	r2, #0
 800a56c:	d1fb      	bne.n	800a566 <strlen+0x4a>
 800a56e:	1a18      	subs	r0, r3, r0
 800a570:	bd10      	pop	{r4, pc}
 800a572:	1c03      	adds	r3, r0, #0
 800a574:	e7e1      	b.n	800a53a <strlen+0x1e>
 800a576:	2000      	movs	r0, #0
 800a578:	e7fa      	b.n	800a570 <strlen+0x54>
 800a57a:	46c0      	nop			; (mov r8, r8)
 800a57c:	fefefeff 	.word	0xfefefeff
 800a580:	80808080 	.word	0x80808080

0800a584 <memcmp>:
 800a584:	b530      	push	{r4, r5, lr}
 800a586:	2a03      	cmp	r2, #3
 800a588:	d91e      	bls.n	800a5c8 <memcmp+0x44>
 800a58a:	1c03      	adds	r3, r0, #0
 800a58c:	430b      	orrs	r3, r1
 800a58e:	079b      	lsls	r3, r3, #30
 800a590:	d011      	beq.n	800a5b6 <memcmp+0x32>
 800a592:	7804      	ldrb	r4, [r0, #0]
 800a594:	780d      	ldrb	r5, [r1, #0]
 800a596:	1c4b      	adds	r3, r1, #1
 800a598:	188a      	adds	r2, r1, r2
 800a59a:	42ac      	cmp	r4, r5
 800a59c:	d006      	beq.n	800a5ac <memcmp+0x28>
 800a59e:	e016      	b.n	800a5ce <memcmp+0x4a>
 800a5a0:	3301      	adds	r3, #1
 800a5a2:	1e59      	subs	r1, r3, #1
 800a5a4:	7804      	ldrb	r4, [r0, #0]
 800a5a6:	780d      	ldrb	r5, [r1, #0]
 800a5a8:	42ac      	cmp	r4, r5
 800a5aa:	d110      	bne.n	800a5ce <memcmp+0x4a>
 800a5ac:	3001      	adds	r0, #1
 800a5ae:	4293      	cmp	r3, r2
 800a5b0:	d1f6      	bne.n	800a5a0 <memcmp+0x1c>
 800a5b2:	2000      	movs	r0, #0
 800a5b4:	bd30      	pop	{r4, r5, pc}
 800a5b6:	6803      	ldr	r3, [r0, #0]
 800a5b8:	680c      	ldr	r4, [r1, #0]
 800a5ba:	42a3      	cmp	r3, r4
 800a5bc:	d104      	bne.n	800a5c8 <memcmp+0x44>
 800a5be:	3a04      	subs	r2, #4
 800a5c0:	3004      	adds	r0, #4
 800a5c2:	3104      	adds	r1, #4
 800a5c4:	2a03      	cmp	r2, #3
 800a5c6:	d8f6      	bhi.n	800a5b6 <memcmp+0x32>
 800a5c8:	2a00      	cmp	r2, #0
 800a5ca:	d1e2      	bne.n	800a592 <memcmp+0xe>
 800a5cc:	e7f1      	b.n	800a5b2 <memcmp+0x2e>
 800a5ce:	1b60      	subs	r0, r4, r5
 800a5d0:	e7f0      	b.n	800a5b4 <memcmp+0x30>
 800a5d2:	46c0      	nop			; (mov r8, r8)

0800a5d4 <memcpy>:
 800a5d4:	b570      	push	{r4, r5, r6, lr}
 800a5d6:	2a0f      	cmp	r2, #15
 800a5d8:	d932      	bls.n	800a640 <memcpy+0x6c>
 800a5da:	1c04      	adds	r4, r0, #0
 800a5dc:	430c      	orrs	r4, r1
 800a5de:	1c0b      	adds	r3, r1, #0
 800a5e0:	07a4      	lsls	r4, r4, #30
 800a5e2:	d131      	bne.n	800a648 <memcpy+0x74>
 800a5e4:	1c15      	adds	r5, r2, #0
 800a5e6:	1c04      	adds	r4, r0, #0
 800a5e8:	3d10      	subs	r5, #16
 800a5ea:	092d      	lsrs	r5, r5, #4
 800a5ec:	3501      	adds	r5, #1
 800a5ee:	012d      	lsls	r5, r5, #4
 800a5f0:	1949      	adds	r1, r1, r5
 800a5f2:	681e      	ldr	r6, [r3, #0]
 800a5f4:	6026      	str	r6, [r4, #0]
 800a5f6:	685e      	ldr	r6, [r3, #4]
 800a5f8:	6066      	str	r6, [r4, #4]
 800a5fa:	689e      	ldr	r6, [r3, #8]
 800a5fc:	60a6      	str	r6, [r4, #8]
 800a5fe:	68de      	ldr	r6, [r3, #12]
 800a600:	3310      	adds	r3, #16
 800a602:	60e6      	str	r6, [r4, #12]
 800a604:	3410      	adds	r4, #16
 800a606:	4299      	cmp	r1, r3
 800a608:	d1f3      	bne.n	800a5f2 <memcpy+0x1e>
 800a60a:	230f      	movs	r3, #15
 800a60c:	1945      	adds	r5, r0, r5
 800a60e:	4013      	ands	r3, r2
 800a610:	2b03      	cmp	r3, #3
 800a612:	d91b      	bls.n	800a64c <memcpy+0x78>
 800a614:	1f1c      	subs	r4, r3, #4
 800a616:	2300      	movs	r3, #0
 800a618:	08a4      	lsrs	r4, r4, #2
 800a61a:	3401      	adds	r4, #1
 800a61c:	00a4      	lsls	r4, r4, #2
 800a61e:	58ce      	ldr	r6, [r1, r3]
 800a620:	50ee      	str	r6, [r5, r3]
 800a622:	3304      	adds	r3, #4
 800a624:	42a3      	cmp	r3, r4
 800a626:	d1fa      	bne.n	800a61e <memcpy+0x4a>
 800a628:	18ed      	adds	r5, r5, r3
 800a62a:	18c9      	adds	r1, r1, r3
 800a62c:	2303      	movs	r3, #3
 800a62e:	401a      	ands	r2, r3
 800a630:	d005      	beq.n	800a63e <memcpy+0x6a>
 800a632:	2300      	movs	r3, #0
 800a634:	5ccc      	ldrb	r4, [r1, r3]
 800a636:	54ec      	strb	r4, [r5, r3]
 800a638:	3301      	adds	r3, #1
 800a63a:	4293      	cmp	r3, r2
 800a63c:	d1fa      	bne.n	800a634 <memcpy+0x60>
 800a63e:	bd70      	pop	{r4, r5, r6, pc}
 800a640:	1c05      	adds	r5, r0, #0
 800a642:	2a00      	cmp	r2, #0
 800a644:	d1f5      	bne.n	800a632 <memcpy+0x5e>
 800a646:	e7fa      	b.n	800a63e <memcpy+0x6a>
 800a648:	1c05      	adds	r5, r0, #0
 800a64a:	e7f2      	b.n	800a632 <memcpy+0x5e>
 800a64c:	1c1a      	adds	r2, r3, #0
 800a64e:	e7f8      	b.n	800a642 <memcpy+0x6e>

0800a650 <memset>:
 800a650:	b570      	push	{r4, r5, r6, lr}
 800a652:	0783      	lsls	r3, r0, #30
 800a654:	d03f      	beq.n	800a6d6 <memset+0x86>
 800a656:	1e54      	subs	r4, r2, #1
 800a658:	2a00      	cmp	r2, #0
 800a65a:	d03b      	beq.n	800a6d4 <memset+0x84>
 800a65c:	b2ce      	uxtb	r6, r1
 800a65e:	1c03      	adds	r3, r0, #0
 800a660:	2503      	movs	r5, #3
 800a662:	e003      	b.n	800a66c <memset+0x1c>
 800a664:	1e62      	subs	r2, r4, #1
 800a666:	2c00      	cmp	r4, #0
 800a668:	d034      	beq.n	800a6d4 <memset+0x84>
 800a66a:	1c14      	adds	r4, r2, #0
 800a66c:	3301      	adds	r3, #1
 800a66e:	1e5a      	subs	r2, r3, #1
 800a670:	7016      	strb	r6, [r2, #0]
 800a672:	422b      	tst	r3, r5
 800a674:	d1f6      	bne.n	800a664 <memset+0x14>
 800a676:	2c03      	cmp	r4, #3
 800a678:	d924      	bls.n	800a6c4 <memset+0x74>
 800a67a:	25ff      	movs	r5, #255	; 0xff
 800a67c:	400d      	ands	r5, r1
 800a67e:	022a      	lsls	r2, r5, #8
 800a680:	4315      	orrs	r5, r2
 800a682:	042a      	lsls	r2, r5, #16
 800a684:	4315      	orrs	r5, r2
 800a686:	2c0f      	cmp	r4, #15
 800a688:	d911      	bls.n	800a6ae <memset+0x5e>
 800a68a:	1c26      	adds	r6, r4, #0
 800a68c:	3e10      	subs	r6, #16
 800a68e:	0936      	lsrs	r6, r6, #4
 800a690:	3601      	adds	r6, #1
 800a692:	0136      	lsls	r6, r6, #4
 800a694:	1c1a      	adds	r2, r3, #0
 800a696:	199b      	adds	r3, r3, r6
 800a698:	6015      	str	r5, [r2, #0]
 800a69a:	6055      	str	r5, [r2, #4]
 800a69c:	6095      	str	r5, [r2, #8]
 800a69e:	60d5      	str	r5, [r2, #12]
 800a6a0:	3210      	adds	r2, #16
 800a6a2:	4293      	cmp	r3, r2
 800a6a4:	d1f8      	bne.n	800a698 <memset+0x48>
 800a6a6:	220f      	movs	r2, #15
 800a6a8:	4014      	ands	r4, r2
 800a6aa:	2c03      	cmp	r4, #3
 800a6ac:	d90a      	bls.n	800a6c4 <memset+0x74>
 800a6ae:	1f26      	subs	r6, r4, #4
 800a6b0:	08b6      	lsrs	r6, r6, #2
 800a6b2:	3601      	adds	r6, #1
 800a6b4:	00b6      	lsls	r6, r6, #2
 800a6b6:	1c1a      	adds	r2, r3, #0
 800a6b8:	199b      	adds	r3, r3, r6
 800a6ba:	c220      	stmia	r2!, {r5}
 800a6bc:	4293      	cmp	r3, r2
 800a6be:	d1fc      	bne.n	800a6ba <memset+0x6a>
 800a6c0:	2203      	movs	r2, #3
 800a6c2:	4014      	ands	r4, r2
 800a6c4:	2c00      	cmp	r4, #0
 800a6c6:	d005      	beq.n	800a6d4 <memset+0x84>
 800a6c8:	b2c9      	uxtb	r1, r1
 800a6ca:	191c      	adds	r4, r3, r4
 800a6cc:	7019      	strb	r1, [r3, #0]
 800a6ce:	3301      	adds	r3, #1
 800a6d0:	42a3      	cmp	r3, r4
 800a6d2:	d1fb      	bne.n	800a6cc <memset+0x7c>
 800a6d4:	bd70      	pop	{r4, r5, r6, pc}
 800a6d6:	1c14      	adds	r4, r2, #0
 800a6d8:	1c03      	adds	r3, r0, #0
 800a6da:	e7cc      	b.n	800a676 <memset+0x26>
