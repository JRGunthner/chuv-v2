/* Common includes */
#include "main.h"
#include "string.h"

/* FreeRTOS includes */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"

/* drv includes */
#include "Display.h"
#include "LED.h"
#include "Bluetooth.h"
#include "printf_lib.h"
#include "IrDA.h"
#include "NTC.h"
#include "Flowmeter.h"
#include "Triac.h"
#include "Buzzer.h"
#include "Debug.h"
#include "RTCC.h"
#include "Controller.h"
#include "AD.h"

//-------------------------------------------
// Debug Defines
#define _DEBUG_
//#define _DEBUG_STR_

#if defined(_DEBUG_) || defined(_DEBUG_STR_)
	char str_debug[40];
	uint8_t debug_show = 3;
    #define DEBUG_MAX 4
#endif

//-------------------------------------------
// Users shower configuration
uint8_t UserIndex; 		// Index of the current user
USER 	User[6]; 		// User settings. User[0] is U6, User[1] is U1, ... , User[5] is U5

//-------------------------------------------
// Tasks Handlers
xTaskHandle xHandle_LedTask = NULL;
xTaskHandle xHandle_DisplayTask = NULL;
xTaskHandle xHandle_ControllerTask = NULL;
xTaskHandle xHandle_PIDTask = NULL;
xTaskHandle xHandle_ADTask = NULL;
xTaskHandle xHandle_FlowTask = NULL;
#ifdef _DEBUG_
	xTaskHandle xHandle_DebugTask = NULL;
#endif

//-------------------------------------------
// Tasks Code
static void vLedTask (void *pvParameters);
static void vDisplayTask (void *pvParameters);
static void vControllerTask (void *pvParameters);
static void vPIDTask (void *pvParameters);
static void vADTask (void *pvParameters);
static void vFlowTask (void *pvParameters);
#ifdef _DEBUG_
	static void vDebugTask (void *pvParameters);
#endif

//====================================================================================================
//
//====================================================================================================
void Init_Shower_Variables()
{
	uint8_t i;

	UserIndex = 0; //User 6 is the initial user (Default User)

	for(i=0; i<6; i++)
	{
		User[i].DisplayMode 		= DISPLAY_SETPOINT;
		User[i].ShowerMode 		    = SHOWER_MODE_POWER;
		User[i].LedMode 			= LED_MODE_FIXED;
		User[i].LedColor			= LED_COLOR_RED;
		User[i].TemperatureSetPoint = DEFAULT_SETPOINT;
		User[i].PowerSetPoint 	    = 0;
		User[i].Buzzer 			    = BUZZER_MODE_ON;
		User[i].MaxTemperatureLimit = TEMPERATURE_LIMIT_ON;
	}
}

//====================================================================================================
//
//====================================================================================================
int main(void)
{

#if (defined VERSION_MAJOR && VERSION_MAJOR == 0) && (defined VERSION_MINOR && VERSION_MINOR == 0)
	#warning "Verify if firmware version in Makefile is updated (VERSION_MAJOR, VERSION_MINOR, VERSION_BUILD)"
#endif

#ifdef _DEBUG_STR_
	sprintf_lib(str_debug, "Shower Started - version %d.%d.%d\r\n", VERSION_MAJOR, VERSION_MINOR, VERSION_BUILD); // These defines are in makefile
	Debug_Write(str_debug, strlen(str_debug));
#endif

	SystemInit();  					// CMSIS SystemInit clocks and PLLs

	Init_Shower_Variables();        // ShowerConfiguration

	RTCC_Init();

	LED_Init ();

	Display_Init();

	IrDA_Init();

	Debug_Init();

	//Bluetooth_Init();

	AD_Init();

	NTC_Init();

	//Flowmeter_Init();

	Buzzer_Init();
	
	//TRIAC_Init();

	//-----------------------------------------------------------------------------
	// Controller Task
	//-----------------------------------------------------------------------------
//	xTaskCreate( vControllerTask,
//    			 "ControllerTask",
//				 configMINIMAL_STACK_SIZE,
//				 (void *) NULL,
//				 tskIDLE_PRIORITY + 2,
//				 xHandle_ControllerTask);

	//-----------------------------------------------------------------------------
	// Led Task
	//-----------------------------------------------------------------------------
	xTaskCreate( vLedTask,
    			 "LedTask",
				 configMINIMAL_STACK_SIZE,
				 (void *) NULL,
				 tskIDLE_PRIORITY,
				 xHandle_LedTask);

	//-----------------------------------------------------------------------------
	// AD Task
	//-----------------------------------------------------------------------------
	xTaskCreate( vADTask,
    			 "ADTask",
				 configMINIMAL_STACK_SIZE,
				 (void *) NULL,
				 tskIDLE_PRIORITY,
				 xHandle_ADTask);

	//-----------------------------------------------------------------------------
	// Flow Task
	//-----------------------------------------------------------------------------
//	xTaskCreate( vFlowTask,
//    			 "FlowTask",
//				 configMINIMAL_STACK_SIZE,
//				 (void *) NULL,
//				 tskIDLE_PRIORITY+1,
//				 xHandle_FlowTask);

	//-----------------------------------------------------------------------------
	// Display Task
	//-----------------------------------------------------------------------------
    xTaskCreate( vDisplayTask,
    			 "DisplayTask",
				 configMINIMAL_STACK_SIZE,
				 (void *) NULL,
				 tskIDLE_PRIORITY,
				 xHandle_DisplayTask);

	//-----------------------------------------------------------------------------
	// PID Task
	//-----------------------------------------------------------------------------
//	xTaskCreate( vPIDTask,
//    			 "PIDTask",
//    			 configMINIMAL_STACK_SIZE,
//				 (void *) NULL,
//				 tskIDLE_PRIORITY,
//				 xHandle_PIDTask);

	//-----------------------------------------------------------------------------
	// Debug Task
	//-----------------------------------------------------------------------------
	#ifdef _DEBUG_
	xTaskCreate( vDebugTask,
    			 "DebugTask",
    			 configMINIMAL_STACK_SIZE*2,
				 (void *) NULL,
				 tskIDLE_PRIORITY,
				 xHandle_DebugTask);
	#endif

    vTaskStartScheduler();

    return 0;
}

//====================================================================================================
//
//====================================================================================================
void RemoteControlCommand(uint32_t Data)
{
	Buzzer_Beep(50);

	switch(Data)
	{
		//----------------------------------------------------------------------------------------------
		case KEY_MENU:
		{
			switch(User[UserIndex].DisplayMode)
			{
				case DISPLAY_OFF:
				{
					User[UserIndex].DisplayMode = DISPLAY_TEMPERATURE;
					#ifdef _DEBUG_STR_
						sprintf_lib(str_debug, "DISPLAY_FLOW\r\n" );
					#endif
					break;
				}
				case DISPLAY_FLOW:
				{
					User[UserIndex].DisplayMode = DISPLAY_OFF;
					#ifdef _DEBUG_STR_
						sprintf_lib(str_debug, "DISPLAY_TEMPERATURE\r\n" );
					#endif
					break;
				}
				case DISPLAY_TEMPERATURE:
				{
					User[UserIndex].DisplayMode = DISPLAY_SETPOINT;
					#ifdef _DEBUG_STR_
						sprintf_lib(str_debug, "DISPLAY_POWER\r\n" );
					#endif
					break;
				}
				case DISPLAY_POWER:
				{
					User[UserIndex].DisplayMode = DISPLAY_SETPOINT;
					#ifdef _DEBUG_STR_
						sprintf_lib(str_debug, "DISPLAY_SETPOINT\r\n" );
					#endif
					break;
				}
				case DISPLAY_SETPOINT:
				{
					User[UserIndex].DisplayMode = DISPLAY_FLOW;
					#ifdef _DEBUG_STR_
						sprintf_lib(str_debug, "DISPLAY_OFF\r\n" );
					#endif
					break;
				}
				default:
				{
					User[UserIndex].DisplayMode = DISPLAY_TEMPERATURE;
					#ifdef _DEBUG_STR_
						sprintf_lib(str_debug, "DISPLAY_TEMPERATURE (Default) \r\n" );
					#endif
					break;
				}
			}

			#ifdef _DEBUG_STR_
				Debug_Write(str_debug, strlen(str_debug));
			#endif

			break;
		}
		//----------------------------------------------------------------------------------------------
		case KEY_UP:
		{
			switch(User[UserIndex].ShowerMode)
			{
				case SHOWER_MODE_POWER:
				{
					if( User[UserIndex].PowerSetPoint < 100)
					{
						User[UserIndex].PowerSetPoint++;
					}

					#ifdef _DEBUG_STR_
						sprintf_lib(str_debug, "U%d_POWER %03d\r\n", UserIndex, User[UserIndex].PowerSetPoint );
						Debug_Write(str_debug, strlen(str_debug));
					#endif
				}
				case SHOWER_MODE_TEMPERATURE:
				{
					if( User[UserIndex].TemperatureSetPoint < MAX_SETPOINT)
					{
						User[UserIndex].TemperatureSetPoint+=10;
					}

					#ifdef _DEBUG_STR_
						sprintf_lib(str_debug, "U%d_TEMPERATURE %03d\r\n",  UserIndex, User[UserIndex].TemperatureSetPoint );
						Debug_Write(str_debug, strlen(str_debug));
					#endif
				}
				default:
				{
					if( User[UserIndex].TemperatureSetPoint < MAX_SETPOINT)
					{
						User[UserIndex].TemperatureSetPoint+=10;
					}

					#ifdef _DEBUG_STR_
						sprintf_lib(str_debug, "U%d_TEMPERATURE %03d (default) \r\n",  UserIndex, User[UserIndex].TemperatureSetPoint );
						Debug_Write(str_debug, strlen(str_debug));
					#endif
				}
			}

			break;
		}
		//----------------------------------------------------------------------------------------------
		case KEY_DOWN:
		{

			switch (User[UserIndex].ShowerMode)
			{
			    case SHOWER_MODE_POWER:
				{
					if( User[UserIndex].PowerSetPoint > 0)
					{
						User[UserIndex].PowerSetPoint--;
					}

					#ifdef _DEBUG_STR_
						sprintf_lib(str_debug, "U%d_POWER %03d\r\n", UserIndex, User[UserIndex].PowerSetPoint );
						Debug_Write(str_debug, strlen(str_debug));
					#endif

				    break;
				}
				case SHOWER_MODE_TEMPERATURE:
				{
					// Lower temperature must be equal to the inlet temperature
					if( User[UserIndex].TemperatureSetPoint > MIN_SETPOINT )
					{
						User[UserIndex].TemperatureSetPoint-=10;
					}

					#ifdef _DEBUG_STR_
						sprintf_lib(str_debug, "U%d_TEMPERATURE %03d\r\n",  UserIndex, User[UserIndex].TemperatureSetPoint );
						Debug_Write(str_debug, strlen(str_debug));
					#endif

					break;
				}
				default:
				{
					// Lower temperature must be equal to the inlet temperature
					if( User[UserIndex].TemperatureSetPoint > MIN_SETPOINT )
					{
						User[UserIndex].TemperatureSetPoint-=10;
					}

					#ifdef _DEBUG_STR_
						sprintf_lib(str_debug, "U%d_TEMPERATURE %03d (default) \r\n",  UserIndex, User[UserIndex].TemperatureSetPoint );
						Debug_Write(str_debug, strlen(str_debug));
					#endif

					break;
				}
			}

			break;
		}
		//----------------------------------------------------------------------------------------------
		case KEY_USER:
		{
			if( UserIndex >= 5 )
			{
				UserIndex = 0;
			}
			else
			{
				UserIndex++;
			}

			#ifdef _DEBUG_STR_
				sprintf_lib(str_debug, "U%d\r\n", UserIndex );
				Debug_Write(str_debug, strlen(str_debug));
			#endif

			break;
		}
		//----------------------------------------------------------------------------------------------
		case KEY_LED_OFF:
		{
			static uint8_t Last_LedMode;

			uint8_t User_Led_Mode = User[UserIndex].LedMode;

			if( User_Led_Mode != LED_MODE_OFF)
			{
				Last_LedMode = User[UserIndex].LedMode;

				User[UserIndex].LedMode = LED_MODE_OFF;

				#ifdef _DEBUG_STR_
					sprintf_lib(str_debug, "LED_MODE_OFF\r\n" );
				#endif
			}
			else
			{
				if( (Last_LedMode != LED_MODE_AUTO ) && (Last_LedMode != LED_MODE_FIXED) )
				{
					Last_LedMode = LED_MODE_AUTO;
				}

				User[UserIndex].LedMode = Last_LedMode;

				#ifdef _DEBUG_STR_
					if(User[UserIndex].LedMode == LED_MODE_AUTO)
					{
						sprintf_lib(str_debug, "LED_MODE_AUTO\r\n" );
					}
					else
					{
						sprintf_lib(str_debug, "LED_MODE_FIXED\r\n" );
					}
				#endif
			}

			#ifdef _DEBUG_STR_
				Debug_Write(str_debug, strlen(str_debug));
			#endif
			break;
		}
		//----------------------------------------------------------------------------------------------
		case KEY_LED_AUTO:
		{
			uint8_t User_Led_Mode = User[UserIndex].LedMode;

			if( ( User_Led_Mode == LED_MODE_FIXED) || ( User_Led_Mode == LED_MODE_OFF) )
			{
				User[UserIndex].LedMode = LED_MODE_AUTO;

				#ifdef _DEBUG_STR_
					sprintf_lib(str_debug, "LED_MODE_AUTO\r\n" );
				#endif
			}
			else
			{
				User[UserIndex].LedMode = LED_MODE_FIXED;
				User[UserIndex].LedColor = LED_GetColor();

				#ifdef _DEBUG_STR_
					sprintf_lib(str_debug, "LED_MODE_FIXED - Color %02X\r\n", LED_GetColor() );
				#endif

			}
			#ifdef _DEBUG_STR_
				Debug_Write(str_debug, strlen(str_debug));
			#endif

			break;
		}
		//----------------------------------------------------------------------------------------------
		case KEY_BIP:
		{
			if( User[UserIndex].Buzzer == BUZZER_MODE_OFF)
			{
				User[UserIndex].Buzzer = BUZZER_MODE_ON;

				#ifdef _DEBUG_STR_
					sprintf_lib(str_debug, "BUZZER_MODE_ON\r\n" );
				#endif

				Buzzer_Control(BUZZER_ON);
			}
			else
			{
				User[UserIndex].Buzzer = BUZZER_MODE_OFF;

				#ifdef _DEBUG_STR_
					sprintf_lib(str_debug, "BUZZER_MODE_OFF\r\n" );
				#endif

				Buzzer_Control(BUZZER_OFF);
			}

			#ifdef _DEBUG_STR_
				Debug_Write(str_debug, strlen(str_debug));
			#endif

			break;
		}
		//----------------------------------------------------------------------------------------------
		case KEY_TEMPERATURE:
		{
			if( User[UserIndex].ShowerMode == SHOWER_MODE_POWER)
			{
				Controller_ResetPID();
			}

			User[UserIndex].ShowerMode = SHOWER_MODE_TEMPERATURE;

			#ifdef _DEBUG_STR_
				sprintf_lib(str_debug, "SHOWER_MODE_TEMPERATURE\r\n" );
				Debug_Write(str_debug, strlen(str_debug));
			#endif

			break;
		}
		//----------------------------------------------------------------------------------------------
		case KEY_POWER:
		{
			User[UserIndex].ShowerMode = SHOWER_MODE_POWER;

			#ifdef _DEBUG_STR_
				sprintf_lib(str_debug, "SHOWER_MODE_POWER\r\n" );
				Debug_Write(str_debug, strlen(str_debug));
			#endif

			break;
		}
		//----------------------------------------------------------------------------------------------
		case E1:
		{
			#ifdef _DEBUG_
				debug_show++;
				if( debug_show>DEBUG_MAX ) debug_show = 0;
			#endif
			break;
		}
		//----------------------------------------------------------------------------------------------
		default:
		{
			break;
		}

	}
}

//==================================================================================================
//
//==================================================================================================
void EXTI4_15_IRQHandler (void)
{
	uint32_t Data;

	IrDA_DisableIRQ();		// Disable the IRQ
	Data = IrDA_IRQHandler();
	IrDA_EnableIRQ();

	if( Data > 0)
	{
		RemoteControlCommand(Data);
	}
}

//====================================================================================================
//
//====================================================================================================
static void vLedTask (void *pvParameters)
{
	for (;;)
	{
		LED_Task( User[UserIndex].LedMode, User[UserIndex].LedColor );

		vTaskDelay(15);
	}
	  
	vTaskDelete(NULL);
}

//====================================================================================================
//
//====================================================================================================
static void vControllerTask (void *pvParameters)
{
	uint8_t Power;
	uint8_t State;

	enum { CONTROLLER_ON, CONTROLLER_OFF, CONTROLLER_WAIT };

	State = CONTROLLER_OFF;
	Power = 0;

	for (;;)
	{
		//---------------------------------------------
		// State Machine Control (Controlled by Water Flow)
		switch(State)
		{
			//----------------------
			case CONTROLLER_ON:
			{
				if( Flowmeter_GetFlow() < FLOW_OFF )
				{
					State = CONTROLLER_WAIT;
				}
				break;
			}
			//----------------------
			case CONTROLLER_OFF:
			{
				if( Flowmeter_GetFlow() > FLOW_ON )
				{
					Controller_ResetPID();
					State = CONTROLLER_ON;
				}
				break;
			}
			//----------------------
			case CONTROLLER_WAIT:
			{
				// TODO: implemetar logica para aguardar um tempo ate religar o controle
				State = CONTROLLER_OFF;
				break;
			}
			//----------------------
			default:
			{
				State = CONTROLLER_OFF;
				break;
			}
		}

		//---------------------------------------------
		// Apply power according to user configuration SHOWER_MODE_TEMPERATURE or SHOWER_MODE_POWER
		if( State ==  CONTROLLER_ON )
		{
			if( User[UserIndex].ShowerMode == SHOWER_MODE_TEMPERATURE )
			{
				Power = Controller_Task(User[UserIndex].TemperatureSetPoint);
			}
			else // SHOWER_MODE_POWER
			{
				Power = User[UserIndex].PowerSetPoint;
			}
		}
		else
		{
			Power = 0;
		}

		//---------------------------------------------
		// Max Temperature Protection
		if( (NTC_GetWaterTemperature(TEMPERATURE_OUTLET) > MAX_TEMPERATURE) || (NTC_GetWaterTemperature(TEMPERATURE_RESISTANCE) > MAX_TEMPERATURE) )
		{
			Power = 0;
		}

		//---------------------------------------------
		// Set Triac power
		TRIAC_SetPower(Power);

		//---------------------------------------------
		// Time delay for hysteresis
		if( State ==  CONTROLLER_WAIT )
		{
			vTaskDelay( 1000 ); // TODO: este delay vai depender da temperatura na resistencia.
		}
		else
		{
			vTaskDelay( 100 );
		}
	}

	vTaskDelete(NULL);
}

//====================================================================================================
//
//====================================================================================================
static void vPIDTask (void *pvParameters)
{
	for (;;)
	{
		PID_Task();

		vTaskDelay( 150 );

	}
}


//====================================================================================================
//
//====================================================================================================
static void vDisplayTask (void *pvParameters)
{
	uint8_t count = 0;

	uint8_t Dg1 = 0;
	uint8_t Dg2 = 0;

	for (;;)
	{
		if(count > 100)
		{
			uint8_t User_Display_Mode = User[UserIndex].DisplayMode;

			switch(User_Display_Mode)
			{
			//--------------------------------------------
			case DISPLAY_OFF:
			{
				//Dg1 = ;
				//Dg2 = ;
				Display.blPonto1 = 0;
				Display.blPonto2 = 0;
				break;
			}
			//--------------------------------------------
			case DISPLAY_FLOW:
			{
				int16_t Flow = Flowmeter_GetFlow();

				Flow = Flowmeter_GetFlow()/10;

				if( Flow < 10 )
				{
					Dg1 = Flow;
					Dg2 = 0;

					Display.blPonto1 = 1;
					Display.blPonto2 = 0;
				}
				else if (Flow <= 99  )
				{
					Dg1 = Flow%10;
					Dg2 = Flow/10;

					Display.blPonto1 = 1;
					Display.blPonto2 = 0;
				}
				else
				{
					uint32_t val = Flow/10;
					Dg1 = val%10;
					Dg2 = val/10;

					Display.blPonto1 = 0;
					Display.blPonto2 = 0;
				}

				break;
			}
			//--------------------------------------------
			case DISPLAY_TEMPERATURE:
			{
				uint16_t Temp = NTC_GetWaterTemperature(TEMPERATURE_OUTLET);
				uint16_t iSetpoint = User[UserIndex].TemperatureSetPoint;

				if ( (Temp <= (iSetpoint+10)) &&  (Temp >= (iSetpoint-10)) )
				{
					Temp = iSetpoint/10;
				}
				else
				{
					Temp = Temp/10;
				}

				Dg1 = Temp%10;
				Dg2 = Temp/10;

				Display.blPonto1 = 0;
				Display.blPonto2 = 0;

				break;
			}
			//--------------------------------------------
			case DISPLAY_SETPOINT:
			{
				uint8_t Temp = User[UserIndex].TemperatureSetPoint/10;

				Dg1 = Temp%10;
				Dg2 = Temp/10;

				Display.blPonto1 = 0;
				Display.blPonto2 = 1;

				break;
			}
			//--------------------------------------------
			case DISPLAY_POWER:
			{
				if(TRIAC_GetPower() == 100)
				{
					Display.Digi1 = _SEG_G_;
					Display.Digi2 = _SEG_G_;
				}
				else
				{
					Dg1 = TRIAC_GetPower()%10;
					Dg2 = TRIAC_GetPower()/10;
				}

				Display.blPonto1 = 0;
				Display.blPonto2 = 0;

				break;
			}
			//--------------------------------------------
			default:
			{
				break;
			}

			}

			if(Dg1 == 0) Display.Digi1 = _0_;
			if(Dg2 == 0) Display.Digi2 = _0_;
			if(Dg1 == 1) Display.Digi1 = _1_;
			if(Dg2 == 1) Display.Digi2 = _1_;
			if(Dg1 == 2) Display.Digi1 = _2_;
			if(Dg2 == 2) Display.Digi2 = _2_;
			if(Dg1 == 3) Display.Digi1 = _3_;
			if(Dg2 == 3) Display.Digi2 = _3_;
			if(Dg1 == 4) Display.Digi1 = _4_;
			if(Dg2 == 4) Display.Digi2 = _4_;
			if(Dg1 == 5) Display.Digi1 = _5_;
			if(Dg2 == 5) Display.Digi2 = _5_;
			if(Dg1 == 6) Display.Digi1 = _6_;
			if(Dg2 == 6) Display.Digi2 = _6_;
			if(Dg1 == 7) Display.Digi1 = _7_;
			if(Dg2 == 7) Display.Digi2 = _7_;
			if(Dg1 == 8) Display.Digi1 = _8_;
			if(Dg2 == 8) Display.Digi2 = _8_;
			if(Dg1 == 9) Display.Digi1 = _9_;
			if(Dg2 == 9) Display.Digi2 = _9_;

			if(User_Display_Mode == DISPLAY_OFF)
			{
				Display.Digi1 = 0x00;
				Display.Digi2 = 0x00;
			}


		}
		else
		{
			count++;
			if(count == 99 ) Buzzer_Beep(500);
		}

		Display_task();

		vTaskDelay(10);
	}

	vTaskDelete(NULL);
}

//====================================================================================================
//
//====================================================================================================
static void vADTask (void *pvParameters)
{
	for (;;)
	{
		//AD_Task();
		vTaskDelay(100);
	}
}

//====================================================================================================
//
//====================================================================================================
static void vFlowTask (void *pvParameters)
{
	for (;;)
	{
		Flowmeter_Task();
		vTaskDelay(100);
	}
}

//====================================================================================================
//
//====================================================================================================
#ifdef _DEBUG_
static void vDebugTask (void *pvParameters)
{

	extern uint16_t TemperatureSetPoint;

	extern uint16_t ucOffsetPID;
	extern uint16_t ucMaximoPID;

	extern int16_t DerivadaFluxo;
	extern uint16_t TemperaturaEntrada;
	extern uint16_t TemperaturaSaida;
	extern int16_t FluxoAgua;
	extern int8_t Saida_PID;
	extern int8_t uiPower;

	extern uint32_t Frequency;
	extern uint32_t DutyCycle;

	extern int16_t Flow;
	extern int16_t FlowDerivative;

	for (;;)
	{
		#ifdef _DEBUG_
			if(debug_show == 0 )
			{
				sprintf_lib(str_debug, "0 %d ", NTC_GetWaterTemperature(TEMPERATURE_INLET) );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", NTC_GetWaterTemperature(TEMPERATURE_RESISTANCE) );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", NTC_GetWaterTemperature(TEMPERATURE_OUTLET) );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", Flowmeter_GetFlow() );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", Flowmeter_GetFlowDerivative() );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", TRIAC_GetPower() );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d 0\r\n", User[UserIndex].TemperatureSetPoint );
				Debug_Write(str_debug, strlen(str_debug));
			}
			else if(debug_show == 1)
			{
				sprintf_lib(str_debug, "1 %d ", TemperatureSetPoint );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", ucOffsetPID );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", ucMaximoPID );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", DerivadaFluxo );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", TemperaturaEntrada );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", TemperaturaSaida );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", FluxoAgua );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", Saida_PID );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d\r\n", uiPower );
				Debug_Write(str_debug, strlen(str_debug));
			}
			else if(debug_show == 2)
			{
				sprintf_lib(str_debug, "2 %d ", AD_GetValue(AD_VOLTAGE_REFERENCE) );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", AD_GetValue(AD_PROCESSOR_TEMPERATURE_SENSOR) );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", AD_GetValue(AD_TOUCH_UP) );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", AD_GetValue(AD_TOUCH_DOWN) );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", AD_GetValue(AD_NTC1) );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", AD_GetValue(AD_NTC2) );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d 0 0 0 0 0 0\r\n", AD_GetValue(AD_NTC3) );
				Debug_Write(str_debug, strlen(str_debug));
			}
			else if(debug_show == 3)
			{
				sprintf_lib(str_debug, "3 %d ", AD_GetValue(AD_TOUCH_UP) );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d 0 0 0 0 0 0\r\n", AD_GetValue(AD_TOUCH_DOWN) );
				Debug_Write(str_debug, strlen(str_debug));
			}
			else if(debug_show == 4)
			{

				sprintf_lib(str_debug, "4 %d ", Frequency );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", TIM15->CCR1 );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "%d ", TIM15->CCR2 );
				Debug_Write(str_debug, strlen(str_debug));

				sprintf_lib(str_debug, "0 0 0 0 0 0 0\r\n" );
				Debug_Write(str_debug, strlen(str_debug));
			}
		#endif

		vTaskDelay(100);
	}
}
#endif

//====================================================================================================
//
//====================================================================================================
void vApplicationIdleHook( void )
{
	/* vApplicationIdleHook() will only be called if configUSE_IDLE_HOOK is set
	to 1 in FreeRTOSConfig.h.  It will be called on each iteration of the idle
	task.  It is essential that code added to this hook function never attempts
	to block in any way (for example, call xQueueReceive() with a block time
	specified, or call vTaskDelay()).  If the application makes use of the
	vTaskDelete() API function (as this demo application does) then it is also
	important that vApplicationIdleHook() is permitted to return to its calling
	function, because it is the responsibility of the idle task to clean up
	memory allocated by the kernel to any task that has since been deleted. */
}

//====================================================================================================
//
//====================================================================================================
void vApplicationStackOverflowHook( xTaskHandle pxTask, signed char *pcTaskName )
{
	( void ) pcTaskName;
	( void ) pxTask;

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();

	// TODO - Desabilitar as interrupccoes de hardware ou pelo menos a do triac

	for( ;; );
}

//====================================================================================================
//
//====================================================================================================
void vApplicationTickHook( void )
{
	/* This function will be called by each tick interrupt if
	configUSE_TICK_HOOK is set to 1 in FreeRTOSConfig.h.  User code can be
	added here, but the tick hook is called from an interrupt context, so
	code must not attempt to block, and only the interrupt safe FreeRTOS API
	functions can be used (those that end in FromISR()). */
}





